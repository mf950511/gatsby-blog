---
title: "HTTP与TCP/IP了解"
date: "2019-02-26"
name: 'francis'
age: '24'
tags: [HTTP,TCP/IP]
categories: HTTP
---

#TCP协议的3次握手与4次分手

## TCP协议的连接与断开

- 什么是`TCP`协议的`三次握手`？为什么会有`三次握手`？
- 什么是`TCP`协议的四次分手？为什么会有四次分手？

## 问题解释

- TCP的`三次握手`其实是在`客户端`与`服务端`建立一个TCP连接，在`TCP/IP`协议中，采用三次握手可建立可靠的连接服务
- TCP的`四次分手`用来断开客户端与服务端的连接

<!--more-->

## 详解

### TCP报文重要字段解释

- 序号：`seq`序号，标识从TCP源向目的端发送字节流，并由发送端对其标记
- 确认序号：`ack`序号，只有`ACK`标志位为1时确认序号字段才有效，`ack=seq+1`（注意：`ack`序号与`ACK`标志位不是同一个东西）
- 注意：确认放`ack`=发起方`req+1`时两者配对成功
- 标志位：共六个，即`URG`,`ACK`,`PSH`,`RST`,`SYN`,`FIN`
   - `ACK`:确认序号有效
   - `PSH`:接收方尽快将报文提交应用层
   - `RST`:连接重置
   - `URG`:紧急指针有效
   - `SYN`:发起一个新连接
   - `FIN`:释放一个链接

### 三次握手

- 三次握手是为了在客户端与服务端建立可靠安全的连接服务，所以需要三次握手确认
   - 第一次：客户端将标志位`SYN`设置为`1`，产生一个随机值`seq=J`并将其发送给server,等待server确认，自己进入`SYN_SENT`状态（我要跟你连接了，你看看你听得到吗）
   - 第二次：server收到数据包由`SYN=1`知道客户端建立请求，server将标志位`SYN`与`ACK`都设置为1，随机产生一个值`seq=K`，并将该数据发回客户端确认连接请求，server进入`SYN_RCVD`状态（我听到了，你看看你听得到我吗）
   - 第三次：客户端收到确认后检查`ack`是否为`J+1`,`ACK`是否为`1`，如果正确则将标志位`ACK`设置为`1`，`ack=K+1`,并将数据包发给server，server检查`ack`是否为`K+1`,`ACK`是否为`1`，如果正确则连接建立成功，客户端与服务端进入`ESTABLISHED`状态，完成三次握手，此后客户端与服务端即可开始传输数据了（我也能听到了，咱们来交流吧）

### 四次分手

- 当我们用三次握手建立连接后数据传输完成要断开TCP链接啊，所以就有了四次分手
   - 由于TCP连接是双全工的，每个方向都需要单独关闭，当一方发送数据完成后需要发送一个`FIN`来终止这一方向连接，收到FIN只是表示对方不会有数据流动了，但是接收方依然可以发送数据，直到接收方也发送了`FIN`
   - 第一次：客户端发送一个FIN，用来关闭客户端到服务端的数据传输，客户端进入`FIN_WAIT_1`状态（我没有要说的了，我想关闭连接了）
   - 第二次：服务端收到`FIN`后，发送一个`ACK`给客户端，确认序号为收到序号+1，服务端进入`CLOSE_WAIT`状态（我知道你不想说了，我不确定我还有没有要说的）
   - 第三次：服务端向客户端发送一个`FIN`，用来关闭服务端到客户端的数据传输，服务端进入`LAST_ACK`状态（我也没有要说的了，咱关闭连接吧）
   - 第四次：客户端收到`FIN`后，客户端进入`TIME_WAIT`状态，接着发送一个`ACK`给服务端，确认序号为收到序号+1，服务端进入`CLOSED`状态，完成四次分手（好的，我知道了，咱关闭吧，你听不到我的声音就说明关闭了）
- 为什么建立连接是三次而分手要四次呐？
   - 因为服务端在`LISTEN`状态下，收到建立请求的`SYN`报文后，把`ACK`与`SYN`都放在一个报文里发给了客户端。关闭连接时当收到对方的`FIn`报文仅仅表示对方不再发数据了，但还能接数据，自己也未必把所有数据发送给对方了，所以己方可以立即关闭也可以发送数据后再发送`FIn`报文给对方同意现在关闭，因此`ACK`与`FIN`都会分开发送
