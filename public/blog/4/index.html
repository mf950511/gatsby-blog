<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><style id="typography.js">html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}article,aside,details,figcaption,figure,footer,header,main,menu,nav,section,summary{display:block}audio,canvas,progress,video{display:inline-block}audio:not([controls]){display:none;height:0}progress{vertical-align:baseline}[hidden],template{display:none}a{background-color:transparent;-webkit-text-decoration-skip:objects}a:active,a:hover{outline-width:0}abbr[title]{border-bottom:none;text-decoration:underline;text-decoration:underline dotted}b,strong{font-weight:inherit;font-weight:bolder}dfn{font-style:italic}h1{font-size:2em;margin:.67em 0}mark{background-color:#ff0;color:#000}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}img{border-style:none}svg:not(:root){overflow:hidden}code,kbd,pre,samp{font-family:monospace,monospace;font-size:1em}figure{margin:1em 40px}hr{box-sizing:content-box;height:0;overflow:visible}button,input,optgroup,select,textarea{font:inherit;margin:0}optgroup{font-weight:700}button,input{overflow:visible}button,select{text-transform:none}[type=reset],[type=submit],button,html [type=button]{-webkit-appearance:button}[type=button]::-moz-focus-inner,[type=reset]::-moz-focus-inner,[type=submit]::-moz-focus-inner,button::-moz-focus-inner{border-style:none;padding:0}[type=button]:-moz-focusring,[type=reset]:-moz-focusring,[type=submit]:-moz-focusring,button:-moz-focusring{outline:1px dotted ButtonText}fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}legend{box-sizing:border-box;color:inherit;display:table;max-width:100%;padding:0;white-space:normal}textarea{overflow:auto}[type=checkbox],[type=radio]{box-sizing:border-box;padding:0}[type=number]::-webkit-inner-spin-button,[type=number]::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}[type=search]::-webkit-search-cancel-button,[type=search]::-webkit-search-decoration{-webkit-appearance:none}::-webkit-input-placeholder{color:inherit;opacity:.54}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{font:100%/1.45 'Open Sans',sans-serif;box-sizing:border-box;overflow-y:scroll;}*{box-sizing:inherit;}*:before{box-sizing:inherit;}*:after{box-sizing:inherit;}body{color:black;font-family:'Open Sans',sans-serif;font-weight:400;word-wrap:break-word;font-kerning:normal;-moz-font-feature-settings:"kern", "liga", "clig", "calt";-ms-font-feature-settings:"kern", "liga", "clig", "calt";-webkit-font-feature-settings:"kern", "liga", "clig", "calt";font-feature-settings:"kern", "liga", "clig", "calt";}img{max-width:100%;margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.16rem;}h1{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.16rem;color:inherit;font-family:'Domine',sans-serif;font-weight:700;text-rendering:optimizeLegibility;font-size:2rem;line-height:1.1;}h2{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.16rem;color:inherit;font-family:'Domine',sans-serif;font-weight:700;text-rendering:optimizeLegibility;font-size:1.51572rem;line-height:1.1;}h3{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.16rem;color:inherit;font-family:'Domine',sans-serif;font-weight:700;text-rendering:optimizeLegibility;font-size:1.31951rem;line-height:1.1;}h4{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.16rem;color:inherit;font-family:'Domine',sans-serif;font-weight:700;text-rendering:optimizeLegibility;font-size:1rem;line-height:1.1;}h5{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.16rem;color:inherit;font-family:'Domine',sans-serif;font-weight:700;text-rendering:optimizeLegibility;font-size:0.87055rem;line-height:1.1;}h6{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.16rem;color:inherit;font-family:'Domine',sans-serif;font-weight:700;text-rendering:optimizeLegibility;font-size:0.81225rem;line-height:1.1;}hgroup{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.16rem;}ul{margin-left:1.45rem;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.16rem;list-style-position:outside;list-style-image:none;}ol{margin-left:1.45rem;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.16rem;list-style-position:outside;list-style-image:none;}dl{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.16rem;}dd{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.16rem;}p{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.16rem;}figure{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.16rem;}pre{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.16rem;font-size:0.85rem;line-height:1.42;background:hsla(0,0%,0%,0.04);border-radius:3px;overflow:auto;word-wrap:normal;padding:1.16rem;}table{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.16rem;font-size:1rem;line-height:1.45rem;border-collapse:collapse;width:100%;}fieldset{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.16rem;}blockquote{margin-left:0;margin-right:1.45rem;margin-top:0;padding-bottom:0;padding-left:1.17812rem;padding-right:0;padding-top:0;margin-bottom:1.16rem;font-size:1.1487rem;line-height:1.45rem;color:hsla(0,0%,0%,0.59);font-style:italic;border-left:0.27187rem solid hsla(0,0%,0%,0.9);}form{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.16rem;}noscript{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.16rem;}iframe{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.16rem;}hr{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:calc(1.16rem - 1px);background:hsla(0,0%,0%,0.2);border:none;height:1px;}address{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.16rem;}b{font-weight:700;}strong{font-weight:700;}dt{font-weight:700;}th{font-weight:700;}li{margin-bottom:calc(1.16rem / 2);}ol li{padding-left:0;}ul li{padding-left:0;}li > ol{margin-left:1.45rem;margin-bottom:calc(1.16rem / 2);margin-top:calc(1.16rem / 2);}li > ul{margin-left:1.45rem;margin-bottom:calc(1.16rem / 2);margin-top:calc(1.16rem / 2);}blockquote *:last-child{margin-bottom:0;}li *:last-child{margin-bottom:0;}p *:last-child{margin-bottom:0;}li > p{margin-bottom:calc(1.16rem / 2);}code{font-size:0.85rem;line-height:1.45rem;}kbd{font-size:0.85rem;line-height:1.45rem;}samp{font-size:0.85rem;line-height:1.45rem;}abbr{border-bottom:1px dotted hsla(0,0%,0%,0.5);cursor:help;}acronym{border-bottom:1px dotted hsla(0,0%,0%,0.5);cursor:help;}abbr[title]{border-bottom:1px dotted hsla(0,0%,0%,0.5);cursor:help;text-decoration:none;}thead{text-align:left;}td,th{text-align:left;border-bottom:1px solid hsla(0,0%,0%,0.12);font-feature-settings:"tnum";-moz-font-feature-settings:"tnum";-ms-font-feature-settings:"tnum";-webkit-font-feature-settings:"tnum";padding-left:0.96667rem;padding-right:0.96667rem;padding-top:0.725rem;padding-bottom:calc(0.725rem - 1px);}th:first-child,td:first-child{padding-left:0;}th:last-child,td:last-child{padding-right:0;}tt,code{background-color:hsla(0,0%,0%,0.04);border-radius:3px;font-family:"SFMono-Regular", Consolas,"Roboto Mono","Droid Sans Mono","Liberation Mono",Menlo,Courier,monospace;padding:0;padding-top:0.2em;padding-bottom:0.2em;}pre code{background:none;line-height:1.42;}code:before,code:after,tt:before,tt:after{letter-spacing:-0.2em;content:" ";}pre code:before,pre code:after,pre tt:before,pre tt:after{content:none;}h1,h2,h3,h4,h5,h6{line-height:1.1;}a{color:#ff5700;text-decoration:none;}a:hover,a:active{color:black;}blockquote > :last-child{margin-bottom:0;}blockquote cite{font-size:1rem;line-height:1.45rem;color:black;font-weight:400;}blockquote cite:before{content:"— ";}@media only screen and (max-width:480px){html{font-size:100%;}blockquote{margin-left:-1.0875rem;margin-right:0;padding-left:0.81562rem;}}span, h1 , h2, h3, h4, h5, h6, p{color:#999;}ul, ol{margin:0;}</style><link as="script" rel="preload" href="/83d6cd58f512da6a6ea6dd96bfbf09511419d80b-744605ee7713f03b785c.js"/><style data-href="/styles.6c075c92cac89f908ae9.css">body{background:#fff}.me404{width:1000px;height:480px;position:absolute;top:50%;left:50%;margin-left:-400px;margin-top:-240px}.st0{fill-rule:evenodd;clip-rule:evenodd;fill:#e8ebed}.st1{fill:#fff;stroke:#89949b;stroke-width:3;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:10}.st2{fill-rule:evenodd;clip-rule:evenodd;fill:#dbdfe1}.st3{fill:#fff}.st4{fill-rule:evenodd;fill:#e8ebed}.st4,.st5{clip-rule:evenodd;stroke:#89949b;stroke-width:3;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:10}.st5{fill-rule:evenodd;fill:#fff}.st6{stroke:#89949b;stroke-width:3;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:10}.st6,.st7{fill-rule:evenodd;clip-rule:evenodd;fill:none}.st7{stroke:#89949b;stroke-width:4;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:10}.st8{fill-rule:evenodd;clip-rule:evenodd;fill:#fff;stroke:#89949b;stroke-width:2;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:10}.st9{fill:#89949b}.st10{fill-rule:evenodd;fill:#89949b}.st10,.st11{clip-rule:evenodd}.st11{fill-rule:evenodd;fill:none;stroke:#89949b;stroke-width:2;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:10}.st12,.st13{fill-rule:evenodd;clip-rule:evenodd;fill:#fff}.st13{stroke:#8894a0;stroke-width:3;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:10}.st14{fill-rule:evenodd;clip-rule:evenodd}.st14,.st15{fill:none;stroke:#89949b;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:10}#cloud{animation:cloud 9s ease-in-out infinite}@keyframes cloud{0%{opacity:.3;left:160px;transform:skewX(20deg)}65%{opacity:1;left:114px;transform:skewX(0deg)}to{opacity:.3;left:160px;transform:skewX(20deg)}}#moon{transform-origin:640px 81px;animation:moon-float 6s ease-in-out infinite}@keyframes moon-float{0%{transform:translateY(20px) scale(1.1)}65%{transform:translate(0) scale(1)}to{transform:translateY(20px) scale(1.1)}}#monkey-eye-l{transform-origin:191px 257px;animation:blink-l 12s ease-in-out infinite}#monkey-eye-r{transform-origin:205px 256px;animation:blink-r 12s ease-in-out infinite}#monkey-arm{transform-origin:155px 298px;animation:monkey-arm 4s ease-in-out infinite}@keyframes monkey-arm{0%{transform:rotate(-10deg)}50%{transform:rotate(20deg)}to{transform:rotate(-10deg)}}@keyframes blink-l{0%{transform:rotateX(0deg)}2%{transform:rotateX(80deg)}4%,20%{transform:rotateX(0deg)}22%{transform:rotateX(80deg)}24%,30%{transform:rotateX(0deg)}32%{transform:rotateX(80deg)}34%,70%{transform:rotateX(0deg)}72%{transform:rotateX(80deg)}74%,to{transform:rotateX(0deg)}}@keyframes blink-r{0%{transform:rotateX(0deg)}2%{transform:rotateX(80deg)}4%,30%{transform:rotateX(0deg)}32%{transform:rotateX(80deg)}34%,50%{transform:rotateX(0deg)}52%{transform:rotateX(80deg)}54%,to{transform:rotateX(0deg)}}#star1{transform-origin:643px 338px;animation:star1 12s linear infinite,star1-fade 12s ease-in-out infinite}#star2{transform-origin:489px 82px;animation:star2 12s linear infinite,star2-fade 12s ease-in-out infinite}#star3{transform-origin:316px 344px;animation:star3 12s linear infinite,star3-fade 12s ease-in-out infinite}#star4{transform-origin:126px 182px;animation:star4 12s linear infinite,star4-fade 12s ease-in-out infinite}@keyframes star1{0%{transform:scale(.5) skewX(15deg) rotate(0deg)}15%{transform:scale(1) skewX(0deg) rotate(1turn)}30%,to{transform:scale(.5) skewX(15deg) rotate(2turn)}}@keyframes star2{0%,15%{transform:scale(.5) skewX(15deg) rotate(0deg)}30%{transform:scale(1) skewX(0deg) rotate(1turn)}45%,to{transform:scale(.5) skewX(15deg) rotate(2turn)}}@keyframes star3{0%,30%{transform:scale(.5) skewX(15deg) rotate(0deg)}45%{transform:scale(1) skewX(0deg) rotate(1turn)}60%,to{transform:scale(.5) skewX(15deg) rotate(2turn)}}@keyframes star4{0%,45%{transform:scale(.5) skewX(15deg) rotate(0deg)}60%{transform:scale(1) skewX(0deg) rotate(1turn)}75%,to{transform:scale(.5) skewX(15deg) rotate(2turn)}}@keyframes star1-fade{0%{opacity:0}15%{opacity:1}30%,to{opacity:0}}@keyframes star2-fade{0%,15%{opacity:0}30%{opacity:1}45%,to{opacity:0}}@keyframes star3-fade{0%,30%{opacity:0}45%{opacity:1}60%,to{opacity:0}}@keyframes star4-fade{0%,45%{opacity:0}60%{opacity:1}75%,to{opacity:0}}#sword-path{animation:tetris-float 3s ease-in-out infinite}#sword,#sword-path{transform-origin:458px 206px}#sword{animation:sword 4s ease-out infinite}@keyframes sword{0%,15%{transform:rotate(-40deg)}87%{transform:rotate(50deg)}to{transform:rotate(-40deg)}}#tetris-path{animation:tetris-float 5s ease-in-out infinite}#tetris,#tetris-path{transform-origin:538px 374px}#tetris{animation:rotate 10s steps(1) infinite alternate}@keyframes rotate{0%{transform:rotate(0deg)}25%{transform:rotate(90deg)}50%{transform:rotate(180deg)}75%{transform:rotate(270deg)}to{transform:rotate(1turn)}}@keyframes tetris-float{0%{transform:translate(0) scale(.9)}65%{transform:translateY(30px) scale(1)}to{transform:translate(0) scale(.9)}}#triforce{transform-origin:175px 91px;animation:triforce-float 3s ease-in-out infinite}lesshat-selector{-lh-property:0}@keyframes triforce-float{0%{transform:translate(0) scale(.9)}65%{transform:translateY(30px) scale(1)}to{transform:translate(0) scale(.9)}}[not-existing]{zoom:1}.authorInfo-module--authorInfo--gr-99{color:#fff}.authorInfo-module--authorInfo--gr-99 .authorInfo-module--imgWrapper--30Yrt{width:128px;height:128px;overflow:hidden;position:relative;box-shadow:0 0 0 2px hsla(0,0%,100%,.5),0 2px 20px 3px rgba(0,0,0,.25);border-radius:300px}.authorInfo-module--authorInfo--gr-99 .authorInfo-module--imgWrapper--30Yrt img{position:absolute;top:-40px}.authorInfo-module--authorInfo--gr-99 .authorInfo-module--authorName--GPPjR{margin:20px 0}.authorInfo-module--authorInfo--gr-99 a{color:#fff}.authorInfo-module--authorInfo--gr-99 a:hover{color:#4d4d4b}.authorInfo-module--authorInfo--gr-99 p{color:#fff}.navLeft-module--navLeft--1SxhG{width:300px;opacity:1;height:100%;background:url(/static/bg2-70973c308892c6eb8c89415e6cc12dc6.jpg) no-repeat 50%;background-size:cover;position:relative;z-index:0}.navLeft-module--navLeft--1SxhG .navLeft-module--overlay--1jp1U{width:100%;height:100%;background-color:rgba(0,0,0,.75);position:absolute;opacity:.7;z-index:-1}.navTop-module--navTop--1_zLH{opacity:1;background:url(/static/bg2-70973c308892c6eb8c89415e6cc12dc6.jpg) no-repeat 50%;background-size:cover;position:relative;z-index:0}.navTop-module--navTop--1_zLH .navTop-module--overlay--11W-h{width:100%;height:100%;background-color:rgba(0,0,0,.75);position:absolute;opacity:.7;z-index:-1}.layout-module--container--280Lj .layout-module--nav--2_Lzo{position:fixed;height:100%;width:300px}@media screen and (min-width:800px){.layout-module--container--280Lj .layout-module--nav--2_Lzo{display:block}}@media screen and (max-width:800px){.layout-module--container--280Lj .layout-module--nav--2_Lzo{display:none}}.article-title{color:#999;margin-left:0;font-weight:400;line-height:35px;margin-bottom:20px;text-align:center;font-size:26px;transition:color .3s}.article-title.left{text-align:left}.article-title:hover{color:#fff}.article-entry h1{font-size:2rem;margin:2rem 0;padding:0;font-weight:700;text-align:center;color:#ff4081}.article-entry h2{padding:0 0 0 20px;line-height:1.8em;position:relative;font-size:1.3em;margin-top:.8em;font-weight:700}.article-entry li{padding-left:1rem}.article-entry ul li{position:relative;padding-left:1.25rem}.article-entry ul li:hover{background:#2e2e2e}.article-entry ul li p{display:inline-block;text-indent:0;padding-left:0!important}.article-entry ul li:before{position:absolute;width:1.25rem;height:1.25rem;left:0;top:.3125rem;content:"\F05D";font:normal normal normal .875rem/1 FontAwesome}.article-entry li code,.article-entry p code{padding:1px 3px;margin:0 3px;color:#d1d1d2;background:rgba(32,33,43,.9);border:1px dashed #20212b;border-radius:3px;word-wrap:break-word;font-size:.875rem}.article-entry a,.article-entry a:hover{color:#4094c7}.article-entry pre{background:#282a36;overflow:auto}.article-entry pre::-webkit-scrollbar{width:4px;height:4px}.article-entry pre::-webkit-scrollbar-thumb{border-radius:5px;-webkit-box-shadow:inset 0 0 5px rgba(0,0,0,.2);background:rgba(0,0,0,.2)}.article-entry pre::-webkit-scrollbar-track{-webkit-box-shadow:inset 0 0 5px rgba(0,0,0,.2);border-radius:0;background:rgba(0,0,0,.1)}.article-entry-bottom{margin-top:2.5rem}.article-entry-bottom .article-more-link a{background:#258fb8;color:#fff;font-size:12px;padding:2px 8px 4px;line-height:16px;border-radius:2px;transition:background .3s}.article-entry h2:before,.article-entry h4:before,.article-entry h5:before,.article-entry h6:before{position:absolute;content:"";left:0;top:0;bottom:0;width:5px;border-radius:2px;background:#ec407a;box-shadow:inset 0 1px 1px rgba(0,0,0,.5),0 1px 1px hsla(0,0%,100%,.3)}.archives-wrap{position:relative;margin:0 1.875rem;padding-right:3.75rem;border-bottom:2px solid #2f2f2f;color:#999}.archives-wrap:first-child{margin-top:1.875rem}.archives-wrap .archive-year-wrap{line-height:2.1875rem;width:12.5rem;position:absolute;padding-top:.9375rem;font-size:1.8rem}.archives-wrap .archives{position:relative}.archives-wrap .archives .archive-article{margin-left:9.375rem;padding:1.25rem 0;border-bottom:1px solid #2f2f2f;border-top:1px solid #2f2f2f;position:relative}.archives-wrap .archives .archive-article:first-child{border-top:none}.archives-wrap .archives .archive-article:last-child{border-bottom:none}.archives-wrap .archives .archive-article .archive-article-header{position:relative}.archives-wrap .archives .archive-article .archive-article-header .archive-title a{color:#999}.archives-wrap .archives .archive-article .archive-article-header .archive-title a:hover{color:#fff}.archives-wrap .archives .archive-article .archive-article-header time{font-size:.75rem;color:#aaa;margin-top:.1875rem;cursor:default}.archives-wrap .archives .archive-article .archive-article-header time:before{content:"\F073";color:#999;position:relative;margin-right:.625rem;font:.875rem FontAwesome}@media screen and (max-width:800px){.archives-wrap{margin:10px 10px 0;padding:10px 20px 10px 10px}.archives-wrap .archive-year-wrap{position:relative;padding:0}.archives-wrap .archive-year-wrap a{padding:0}.archives-wrap .archives .archive-article{padding:10px 0;margin-left:0}}.main{min-height:100%;position:absolute;background:#3f3f3f;right:0;overflow-x:hidden}.main>div::-webkit-scrollbar{width:4px;height:4px}.main>div::-webkit-scrollbar-thumb{border-radius:5px;-webkit-box-shadow:inset 0 0 5px rgba(0,0,0,.2);background:rgba(0,0,0,.2)}.main>div::-webkit-scrollbar-track{-webkit-box-shadow:inset 0 0 5px rgba(0,0,0,.2);border-radius:0;background:rgba(0,0,0,.1)}@media screen and (min-width:800px){.navTop{display:none}.main{left:300px}}@media screen and (max-width:800px){.navTop{display:block}.main{left:0}}@font-face{font-family:FontAwesome;src:url(/static/fontawesome-webfont-8b27bc96115c2d24350f0d09e6a9433f.eot);src:url(/static/fontawesome-webfont-8b27bc96115c2d24350f0d09e6a9433f.eot?#iefix) format("embedded-opentype"),url(/static/fontawesome-webfont-3293616ec0c605c7c2db25829a0a509e.woff) format("woff"),url(/static/fontawesome-webfont-dcb26c7239d850266941e80370e207c1.ttf) format("truetype"),url(/static/fontawesome-webfont-b526f0637e912fae979bcfe9f0c9bd74.svg#FontAwesomeRegular) format("svg"),url(/static/fontawesome-webfont-b526f0637e912fae979bcfe9f0c9bd74.svg#FontAwesomeRegular) format("svg");font-weight:400;font-style:normal}body{background:#3f3f3f;color:#999}

/*! https://github.com/lzxb/flex.css */[data-flex]{display:flex}[data-flex]>*{display:block}[data-flex]>[data-flex]{display:flex}[data-flex~="dir:left"]{flex-direction:row}[data-flex~="dir:right"]{flex-direction:row-reverse;-webkit-box-pack:end}[data-flex~="dir:top"]{flex-direction:column}[data-flex~="dir:bottom"]{flex-direction:column-reverse;-webkit-box-pack:end}[data-flex~="main:left"]{justify-content:flex-start}[data-flex~="main:right"]{justify-content:flex-end}[data-flex~="main:justify"]{justify-content:space-between}[data-flex~="main:center"]{justify-content:center}[data-flex~="cross:top"]{align-items:flex-start}[data-flex~="cross:bottom"]{align-items:flex-end}[data-flex~="cross:center"]{align-items:center}[data-flex~="cross:baseline"]{align-items:baseline}[data-flex~="cross:stretch"]{align-items:stretch}[data-flex~="box:first"]>*,[data-flex~="box:justify"]>*,[data-flex~="box:last"]>*,[data-flex~="box:mean"]>*{width:0;height:auto;flex-grow:1;flex-shrink:1}[data-flex~="box:first"]>:first-child,[data-flex~="box:justify"]>:first-child,[data-flex~="box:justify"]>:last-child,[data-flex~="box:last"]>:last-child{width:auto;flex-grow:0;flex-shrink:0}[data-flex~="dir:bottom"][data-flex~="box:first"]>*,[data-flex~="dir:bottom"][data-flex~="box:justify"]>*,[data-flex~="dir:bottom"][data-flex~="box:last"]>*,[data-flex~="dir:bottom"][data-flex~="box:mean"]>*,[data-flex~="dir:top"][data-flex~="box:first"]>*,[data-flex~="dir:top"][data-flex~="box:justify"]>*,[data-flex~="dir:top"][data-flex~="box:last"]>*,[data-flex~="dir:top"][data-flex~="box:mean"]>*{width:auto;height:0;flex-grow:1;flex-shrink:1}[data-flex~="dir:bottom"][data-flex~="box:first"]>:first-child,[data-flex~="dir:bottom"][data-flex~="box:justify"]>:first-child [data-flex~="dir:bottom"][data-flex~="box:justify"]>:last-child,[data-flex~="dir:bottom"][data-flex~="box:last"]>:last-child,[data-flex~="dir:top"][data-flex~="box:first"]>:first-child,[data-flex~="dir:top"][data-flex~="box:justify"]>:first-child,[data-flex~="dir:top"][data-flex~="box:justify"]>:last-child,[data-flex~="dir:top"][data-flex~="box:last"]>:last-child{height:auto;flex-grow:0;flex-shrink:0}[data-flex-box="0"]{flex-grow:0;flex-shrink:0}[data-flex-box="1"]{flex-grow:1;flex-shrink:1}[data-flex-box="2"]{flex-grow:2;flex-shrink:2}[data-flex-box="3"]{flex-grow:3;flex-shrink:3}[data-flex-box="4"]{flex-grow:4;flex-shrink:4}[data-flex-box="5"]{flex-grow:5;flex-shrink:5}[data-flex-box="6"]{flex-grow:6;flex-shrink:6}[data-flex-box="7"]{flex-grow:7;flex-shrink:7}[data-flex-box="8"]{flex-grow:8;flex-shrink:8}[data-flex-box="9"]{flex-grow:9;flex-shrink:9}[data-flex-box="10"]{flex-grow:10;flex-shrink:10}.listWrapper-module--hide--2daIu{visibility:hidden}.listWrapper-module--listWrapper--FBSVx{margin:30px;position:relative;transition:all .2s ease-in}.listWrapper-module--listWrapper--FBSVx .listWrapper-module--listContent--6okCO{position:relative;border:1px solid #2f2f2f;margin-bottom:20px;padding:20px;border-radius:6px;box-shadow:4px 4px 18px rgba(0,0,0,.46)}.listWrapper-module--listWrapper--FBSVx .listWrapper-module--listContent--6okCO ol,.listWrapper-module--listWrapper--FBSVx .listWrapper-module--listContent--6okCO p,.listWrapper-module--listWrapper--FBSVx .listWrapper-module--listContent--6okCO ul{list-style:none}.listWrapper-module--listWrapper--FBSVx .listWrapper-module--listContent--6okCO ol,.listWrapper-module--listWrapper--FBSVx .listWrapper-module--listContent--6okCO ul{margin:0}@media screen and (min-width:800px){.listWrapper-module--listContent--6okCO ol,.listWrapper-module--listContent--6okCO p,.listWrapper-module--listContent--6okCO ul{padding-left:1rem}}@media screen and (max-width:800px){.listWrapper-module--listContent--6okCO ol,.listWrapper-module--listContent--6okCO p,.listWrapper-module--listContent--6okCO ul{padding-left:0}}.tagInfo-module--tagInfoWrap--e-EOI{width:100%;display:flex;flex-wrap:wrap;align-items:center;font-size:.75rem}.tagInfo-module--tagInfoWrap--e-EOI a{display:inline-block;text-decoration:none;font-weight:400;font-size:.625rem;color:#fff;height:1.125rem;line-height:1.125rem;padding:0 5px 0 10px;position:relative;border-radius:0 5px 5px 0;margin:5px 9px 5px 8px}.tagInfo-module--tagInfoWrap--e-EOI a:before{content:" ";width:0;height:0;position:absolute;top:0;left:-1.125rem;border:9px solid transparent}.tagInfo-module--tagInfoWrap--e-EOI a:after{content:" ";width:4px;height:4px;background-color:#fff;border-radius:4px;box-shadow:0 0 0 1px rgba(0,0,0,.3);position:absolute;top:7px;left:2px}.tagInfo-module--tagInfoWrap--e-EOI .tagInfo-module--tagClassify--11TLD:before{color:#999;content:"\F02D";font:1rem FontAwesome;float:left;margin-right:.625rem;padding-top:.3125rem}.tagInfo-module--tagInfoWrap--e-EOI .tagInfo-module--tagClassify--11TLD a{background:#e23794}.tagInfo-module--tagInfoWrap--e-EOI .tagInfo-module--tagClassify--11TLD a:before{border-right-color:#e23794}.tagInfo-module--tagInfoWrap--e-EOI .tagInfo-module--tagClassify--11TLD a:hover{color:#ddd}.tagInfo-module--tagInfoWrap--e-EOI .tagInfo-module--tagList--2JajG{flex-wrap:wrap}.tagInfo-module--tagInfoWrap--e-EOI .tagInfo-module--tagList--2JajG:before{color:#999;content:"\F02E";font:1rem FontAwesome;float:left;margin-right:.625rem;margin-top:.3125rem}.tagInfo-module--tagInfoWrap--e-EOI .tagInfo-module--tagList--2JajG .tagInfo-module--tag--1NeBn a{background:#4cae4c}.tagInfo-module--tagInfoWrap--e-EOI .tagInfo-module--tagList--2JajG .tagInfo-module--tag--1NeBn a:before{border-right-color:#4cae4c}.tagInfo-module--tagInfoWrap--e-EOI .tagInfo-module--tagList--2JajG .tagInfo-module--tag--1NeBn a:hover{color:#ddd}.paganation-module--paganation--2bE_X{text-align:center;padding:30px 0}.paganation-module--paganation--2bE_X:hover .paganation-module--extend--2q4Qk{opacity:1}.paganation-module--paganation--2bE_X .paganation-module--extend--2q4Qk{color:#999;margin:0 27px;opacity:0}.paganation-module--paganation--2bE_X .paganation-module--hide--wBlxP{opacity:0}.paganation-module--paganation--2bE_X .paganation-module--pageNumber--RUHS6{width:20px;height:20px;background:#4d4d4d;border-radius:50%;display:inline-block;color:#fff;line-height:20px;font-size:12px;margin:0 3px 30px}.paganation-module--paganation--2bE_X .paganation-module--pageNumber--RUHS6:hover{background:#5e5e5e}.paganation-module--paganation--2bE_X .paganation-module--pageNumber--RUHS6.paganation-module--current--39YZ4{background:#4094c7;cursor:default}.paganation-module--paganation--2bE_X .paganation-module--pageNumber--RUHS6.paganation-module--current--39YZ4:hover{background:#4094c7}.hljs{display:block;overflow-x:auto;padding:.5em;color:#abb2bf;background:#282c34}.hljs-comment,.hljs-quote{color:#5c6370;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#c678dd}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e06c75}.hljs-literal{color:#56b6c2}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#98c379}.hljs-built_in,.hljs-class .hljs-title{color:#e6c07b}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#d19a66}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#61aeee}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}</style><link href="//fonts.googleapis.com/css?family=Domine:700|Open+Sans:400,400i,700,700i" rel="stylesheet" type="text/css"/><link as="script" rel="preload" href="/styles-89fd2ae28bdf06750a71.js"/><link as="script" rel="preload" href="/component---src-templates-index-jsx-1afb50278c9b0fcb6759.js"/><meta name="generator" content="Gatsby 2.24.63"/><link as="script" rel="preload" href="/framework-31fa3cffff5950ebff26.js"/><link as="script" rel="preload" href="/app-03a564126170dae91f0b.js"/><link as="script" rel="preload" href="/webpack-runtime-c691ad7dc71c44256655.js"/><link as="fetch" rel="preload" href="/page-data\blog\4\page-data.json" crossorigin="anonymous"/><link as="fetch" rel="preload" href="/page-data/sq/d/2566592090.json" crossorigin="anonymous"/><link as="fetch" rel="preload" href="/page-data\app-data.json" crossorigin="anonymous"/></head><body><div id="___gatsby"><div style="outline:none" tabindex="-1" id="gatsby-focus-wrapper"><div class="layout-module--container--280Lj"><div class="layout-module--nav--2_Lzo"><div class="navLeft-module--navLeft--1SxhG" data-flex="main:center cross:center"><div class="navLeft-module--overlay--1jp1U"></div><header class="authorInfo-module--authorInfo--gr-99" data-flex="dir:top cross:center"><a href="/"><div class="authorInfo-module--imgWrapper--30Yrt"><img src="/static/cat-4c59261f56e727d38ef6862edcb9a7d4.jpg" alt=""/></div></a><hgroup data-flex="dir:top cross:center"><h2 class="authorInfo-module--authorName--GPPjR"><a href="/">Francis</a></h2><p>前端小白，光吃不做</p></hgroup></header></div></div><div class="main"><div class="navTop"><div id="navTop"><div class="navTop-module--navTop--1_zLH"><div class="navTop-module--overlay--11W-h"></div><header class="authorInfo-module--authorInfo--gr-99" data-flex="dir:top cross:center"><a href="/"><div class="authorInfo-module--imgWrapper--30Yrt"><img src="/static/cat-4c59261f56e727d38ef6862edcb9a7d4.jpg" alt=""/></div></a><hgroup data-flex="dir:top cross:center"><h2 class="authorInfo-module--authorName--GPPjR"><a href="/">Francis</a></h2><p>前端小白，光吃不做</p></hgroup></header></div></div></div><div><div><div class="blogList"><span><article class="listWrapper-module--listWrapper--FBSVx"><div class="listWrapper-module--listContent--6okCO"><div></div><a href="/blog/loop-statement/"><h1 class="article-title left">常用循环语句的基本属性</h1></a><div class="article-entry"><h1>循环语句</h1>
<h2>for-in 循环语句</h2>
<ul>
<li>for-in是严格迭代语句，会迭代一个对象中非Symbol的其他属性值，语法如下</li>
</ul>
<pre><code class="language-js">for(const prop in obj) {
  console.log(prop)  
}
</code></pre>
<ul>
<li>for-in迭代对象是无序的，各浏览器下返回的顺序可能不一致</li>
<li>const并不是必须的，但建议使用，避免影响外界变量</li>
<li>迭代null或undefined则迭代内的表达式不会被执行</li>
</ul>
<h2>for-of 循环语句</h2>
<ul>
<li>for-of也是迭代语句，只能迭代一个可迭代对象，语法如下</li>
</ul>
<pre><code class="language-js">for(const value in obj) {
  console.log(value)  
}
</code></pre>
<ul>
<li>迭代是有序的，由对象内部的next()方法决定</li>
<li>迭代一个非迭代器对象会抛出错误</li>
</ul>
<h2>标记语法</h2>
<ul>
<li>用来标记一个表达式，用于在后续使用，一般用于配合break、continue打破循环使用</li>
<li>标记语法如下</li>
</ul>
<pre><code class="language-js">label: statement
</code></pre>
<ul>
<li>break用于结束这个循环体，执行循环体后的语句</li>
<li>continue用于结束单次循环，进行该循环体的下一次循环</li>
<li>配合标记语法如下</li>
</ul>
<pre><code class="language-js">let num = 0
outermost: for(let i = 0; i &#x3C; 10; i++) {
  for(let j = 0; j &#x3C; 10; j++) {
    if(i === 5 &#x26;&#x26; j === 5) {
      break outermost
    }
    num++
  }
}

console.log(num) // 55
</code></pre>
<ul>
<li>这里当执行到i跟j都是5的时候，我们的break将外层循环结束了，导致后续的4次大循环与当次剩余的5次小循环无法继续，所以导致最终的输出为55</li>
</ul>
<pre><code class="language-js">let num = 0
outermost: for(let i = 0; i &#x3C; 10; i++) {
  for(let j = 0; j &#x3C; 10; j++) {
    if(i === 5 &#x26;&#x26; j === 5) {
      continue outermost
    }
    num++
  }
}

console.log(num) // 95
</code></pre>
<ul>
<li>这里的continue跳过了外层循环，导致子循环后续的5次没法执行直接到了下一个循环，所以最终次数会少5，变成了95</li>
</ul>
<h2>with语法</h2>
<ul>
<li>with语法用于将一个代码执行块与一个变量绑定，语法如下</li>
</ul>
<pre><code class="language-js">with (expression) statement;
</code></pre>
<ul>
<li>当一个对象被一次又一次的引用执行的时候就可以使用with语法来简化，比如下场景</li>
</ul>
<pre><code class="language-js">let qs = location.search.substring(1)
let hostname = location.hostname
let url = location.href
</code></pre>
<ul>
<li>这里我们的location对象被多次重复引用，我们可以使用with进行简化</li>
</ul>
<pre><code class="language-js">with(location){
  let qs = search.substring(1)
  let hostname = hostname
  let url = href
}
</code></pre>
<ul>
<li>with工作原理会在当前的作用域内查找是否有对应的变量，如果没有就会从对应location对象上面查找对应的同名属性</li>
<li>在严格模式下with语法会报错</li>
<li>with语法会降低代码性能与导致一些奇怪的bug，所以不推荐使用</li>
</ul></div><div class="article-entry-bottom" data-flex="box:last"><div class="tagInfo-module--tagInfoWrap--e-EOI"><div class="tagInfo-module--tagClassify--11TLD"><a href="/category/JavaScript">JavaScript</a></div><div class="tagInfo-module--tagList--2JajG" data-flex="main:left"><div class="tagInfo-module--tag--1NeBn"><a href="/tag/JavaScript回顾">JavaScript回顾</a></div></div></div><div class="article-more-link"><a href="/blog/loop-statement/">阅读全文 &gt;&gt;</a></div></div></div></article></span></div><div class="blogList"><span><article class="listWrapper-module--listWrapper--FBSVx"><div class="listWrapper-module--listContent--6okCO"><div></div><a href="/blog/script-element/"><h1 class="article-title left">script不为人知的标签属性</h1></a><div class="article-entry"><h1>script不为人知的标签属性</h1>
<h2>普通引用</h2>
<ul>
<li>js加载与执行都会阻塞页面渲染与执行，等到js加载并执行完成后才会继续页面的渲染</li>
</ul>
<h2>async</h2>
<ul>
<li>js加载不会阻塞页面渲染，js加载后就会立即执行，执行时会阻塞页面渲染，有多个async的文件时，跟引入的顺序无关，谁先加载完就执行谁</li>
</ul>
<h2>defer</h2>
<ul>
<li>js加载不会阻塞页面渲染，js加载后不会立即执行，等页面渲染完成后才执行，在 DOMContentLoaded 事件之前执行，有多个 defer 文件时，规范应该是按引入的顺序执行，但实际情况下并不一定按原有顺序执行，所以多个 defer 引入需注意</li>
</ul>
<h2>charset</h2>
<ul>
<li>定义js脚本使用的编码值，大多数浏览器都没有遵守它，无意义</li>
</ul>
<h2>crossorigin</h2>
<ul>
<li>当正常引入跨域资源脚本时，因为浏览器限制，如果该脚本报错我们是拿不到报错信息的，监听onerror只能拿到script error，但是最新的html5规范又规定允许本地获取到跨域脚本错误的，这个时候，满足两个条件就可以实现</li>
<li>跨域资源服务器通过 Access-Control-Allow-Origin 头信息允许当前域名可以获取错误信息。</li>
<li>script标签指定脚本地址是跨域资源，也就是我们的 crossorigin，当值为 anonymous 时不携带cookie等认证信息，当值为 use-credentials 会携带cookie等认证信息</li>
</ul>
<h2>integrity</h2>
<ul>
<li>又称SRI，子资源完整性完整性。该值由两部分组成签名算法跟摘要签名内容组成，用 - 连接。</li>
<li>指定了该值之后，浏览器在拿到资源后会用 integrity 指定的签名算法对资源进行计算并与 摘要签名内容 进行比较，如果值不统一，说明是经过篡改的，就不会执行该资源</li>
</ul>
<h2>type</h2>
<ul>
<li>传统意义上该值为"text/javscript"或者"text/ecmascript"，但是这两个值已经不赞成使用了</li>
<li>通常我们应该设置该值为"application/x-javascript"，虽然设置该值可能会导致脚本被忽略</li>
<li>其他在非IE浏览器下，我们可以设置为"application/javascript"或者"application/ecmascript"</li>
<li>如果设置该值为"module"，则该文件下的code会被视为ES6模块，只有这样才能使用import跟export关键字</li>
</ul></div><div class="article-entry-bottom" data-flex="box:last"><div class="tagInfo-module--tagInfoWrap--e-EOI"><div class="tagInfo-module--tagClassify--11TLD"><a href="/category/JavaScript">JavaScript</a></div><div class="tagInfo-module--tagList--2JajG" data-flex="main:left"><div class="tagInfo-module--tag--1NeBn"><a href="/tag/JavaScript回顾">JavaScript回顾</a></div></div></div><div class="article-more-link"><a href="/blog/script-element/">阅读全文 &gt;&gt;</a></div></div></div></article></span></div><div class="blogList"><span><article class="listWrapper-module--listWrapper--FBSVx"><div class="listWrapper-module--listContent--6okCO"><div></div><a href="/blog/symbol/"><h1 class="article-title left">符号类型(symbol)</h1></a><div class="article-entry"><h1>符号类型(symbol)</h1>
<ul>
<li>Symbol是ES6新增的一种数据类型，用以标识独一无二的类型，所有的Symbol实例都是独一无二的</li>
</ul>
<h2>Symbol的使用方式</h2>
<ul>
<li>Symbol跟其他类不同，生成实例不需要使用 new 关键字，使用 new 关键字会报错，可以接受一个字符串作为Symbol的入参，也可以不传参直接生成，如下</li>
</ul>
<pre><code class="language-js">let sm = new Symbol() // TypeError: Symbol is not a constructor

let sm1 = Symbol()
console.log(sm1) // Symbol()
console.log(typeof sm1) // symbol
let sm2 = Symbol('test')
console.log(sm2) // Symbol('test')
</code></pre>
<ul>
<li>每一个Symbol实例都不相同，如下实验</li>
</ul>
<pre><code class="language-js">let sm = Symbol()
let sm1 = Symbol()
console.log(sm === sm1) // false

let sm2 = Symbol('test')
let sm3 = Symbol('test')
console.log(sm2 === sm3) // false
</code></pre>
<ul>
<li>这也是Symbol最显著的特殊，可以让我们无后顾之忧的拓展对象属性，而不用担心会跟其现有的属性或方法冲突</li>
</ul>
<h2>Symbol.for()</h2>
<ul>
<li>如果都是使用上面的Symbol()来给对象赋值的的话我们就没法读取到该属性值了，如下</li>
</ul>
<pre><code class="language-js">let a = {}
a[Symbol('test')] = 123
console.log(a[Symbol('test')]) // undefined
</code></pre>
<ul>
<li>因为在这里我们赋值跟取值的Symbol是完全不同的，为了避免这种情况，且能获取到对应的值我们需要使用Symbol.for()</li>
<li>Symbol.for()方法的使用跟Symbol()的使用是一致的，可以接收一个字符串来做Symbol的唯一表示，调用该方式时，会从全局运行注册对象中查找有没有该Symbol，如果没有找到，就会生成一个Symbol对象并注册到全局运行注册对象中，然后返回该对象，如果查到了该Symbol，则直接返回该对象，所以看下示例：</li>
</ul>
<pre><code class="language-js">let a = Symbol.for('test') // 没找到，创建实例
let b = Symbol.for('test') // 找到，直接返回实例
console.log(a === b) // true

let c = {}
c[Symbol.for('foo')] = 123
console.log(c[Symbol.for('foo')]) // 123
</code></pre>
<ul>
<li>使用Symbol()给对象赋值的方式，如下</li>
</ul>
<pre><code class="language-js">let s1 = Symbol('foo'),
  s2 = Symbol('bar'),
  s3 = Symbol('baz'),
  s4 = Symbol('qux')
let o = {
  [s1]: 'foo val'
}
console.log(o) // {Symbol(foo): "foo val"}
Object.defineProperty(o, s2, { value: 'bar val' })
console.log(o) // {Symbol(foo): "foo val", Symbol(bar): "bar val"}
Object.defineProperties(o, {
  [s3]: { value: 'baz val' },
  [s4]: { value: 'qux val' }
})
console.log(o) // {Symbol(foo): "foo val", Symbol(bar): "bar val", Symbol(baz): "baz val", Symbol(qux): "qux val"}
</code></pre>
<h2>Symbol.keyFor()</h2>
<ul>
<li>我们可以使用 Symbol.keyFor() 来检查一个Symbol实例是否存在与全局运行注册表中，该方法接收一个Symbol实例，如果全局注册表中存在该实例，则返回对应的key值，如果不存在，就会返回一个undefined，如下</li>
</ul>
<pre><code class="language-js">Symbol.keyFor(Symbol.for('test')) // 'test'，通过Symbol.for()创建的Symbol实例会自动在注册表中注册
Symbol.keyFor(Symbol('test')) // undefined 通过Symbol()方式创建的不会在注册表中注册，所以会返回undefined
</code></pre>
<h2>Object.getOwnPropertyNames() 跟 Object.getOwnPropertySymbols()</h2>
<ul>
<li>然后我们尝试使用 Object.getOwnPropertyNames 跟 Object.getOwnPropertySymbols 来获取一下对象o的值来看一下</li>
</ul>
<pre><code class="language-js">Object.getOwnPropertyNames(o) // []
Object.getOwnPropertySymbols(o) // [Symbol(foo), Symbol(bar), Symbol(baz), Symbol(qux)]
</code></pre>
<ul>
<li>这里我们能看到使用 Object.getOwnPropertyNames 好像并不能获取到我们Symbol实例键，我们再给o拓展几个普通属性试试</li>
</ul>
<pre><code class="language-js">o['baz'] = '123'
o['foo'] = '234'

Object.getOwnPropertyNames(o) // ["baz", "foo"]
Object.getOwnPropertySymbols(o) // [Symbol(foo), Symbol(bar), Symbol(baz), Symbol(qux)]
</code></pre>
<ul>
<li>看到上结果我们也能知道，Object.getOwnPropertyNames 用于获取我们的常规除Symbol外的常规键值，Object.getOwnPropertySymbols 用于获取我们的Symbol键值</li>
</ul>
<h2>Object.getOwnPropertyDescriptors() 跟 Reflect.ownKeys()</h2>
<ul>
<li>然后我们再使用 Object.getOwnPropertyDescriptors() 跟 Reflect.ownKeys()来获取一下o的属性</li>
</ul>
<pre><code class="language-js">Object.getOwnPropertyDescriptors(o) // {baz: {…}, foo: {…}, Symbol(foo): {…}, Symbol(bar): {…}, Symbol(baz): {…},Symbol(qux): {...}}
Reflect.keys(o) // ["baz", "foo", Symbol(foo), Symbol(bar), Symbol(baz), Symbol(qux)]
</code></pre>
<ul>
<li>从中我们能看到 Object.getOwnPropertyDescriptors() 可以获取对象的常规值跟Symbol对应的值，Reflec.ownKeys() 可以获取对象的常规键跟Symbol键</li>
</ul></div><div class="article-entry-bottom" data-flex="box:last"><div class="tagInfo-module--tagInfoWrap--e-EOI"><div class="tagInfo-module--tagClassify--11TLD"><a href="/category/JavaScript">JavaScript</a></div><div class="tagInfo-module--tagList--2JajG" data-flex="main:left"><div class="tagInfo-module--tag--1NeBn"><a href="/tag/JavaScript回顾">JavaScript回顾</a></div></div></div><div class="article-more-link"><a href="/blog/symbol/">阅读全文 &gt;&gt;</a></div></div></div></article></span></div><div class="blogList"><span><article class="listWrapper-module--listWrapper--FBSVx"><div class="listWrapper-module--listContent--6okCO"><div></div><a href="/blog/multiplicative-operators/"><h1 class="article-title left">常用计算符独特的计算属性</h1></a><div class="article-entry"><h1>乘、除、取余、指数、加法、减法、比较、相等操作符</h1>
<h2>乘</h2>
<ul>
<li>乘法的计算遵循下面的原则</li>
<li>如果结果超出ECMAScript所表示的范围，那么最终会得到 Infinity 或者 -Infinity</li>
<li>NaN参与运算，得到NaN</li>
<li>Infinity 与 0 相乘得 NaN </li>
<li>Infinity 与 非 0 数相乘得 Infinity 或者 -Infinity ，由非 0 数决定符号</li>
<li>如果其中一个是非数值，将会被Number()强制转为数值参与计算</li>
</ul>
<h2>除</h2>
<ul>
<li>除法的计算遵循下原则</li>
<li>如果结果超出ECMAScript所表示的范围，那么最终会得到 Infinity 或者 -Infinity</li>
<li>NaN参与运算，得到NaN</li>
<li>Infinity 除以 Infinity 得到 NaN</li>
<li>0 除以 0 得 NaN</li>
<li>Infinity 除以 任何数都得 Infinity 或者 -Infinity ，符号由除数决定</li>
<li>如果其中一个操作符为非数值，则被Number()转为数值参与计算</li>
</ul>
<h2>取余</h2>
<ul>
<li>取余的计算规则如下</li>
<li>如果被除数是 Infinity ，除数是有限值，那么结果为 NaN</li>
<li>如果被除数是 有限值，除数为 0，那么结果为 NaN</li>
<li>除数跟被除数都是Infinity,则结果为NaN</li>
<li>被除数是有限值，除数是Infinity,结果是被除数</li>
<li>被除数是0，除数是非0，结果是0</li>
<li>如果其中一个操作符为非数值，则被Number()转为数值参与计算</li>
</ul>
<h2>指数操作符</h2>
<ul>
<li>指数被用来表示某个数的多少次方，用<code>Math.pow()</code>来计算，在ECMAScript 7中可以使用 <code>**</code> 来表示</li>
</ul>
<pre><code class="language-js">console.log(Math.pow(3, 2)) // 9
console.log(3 ** 2) // 9
</code></pre>
<ul>
<li>有了 <code>**</code>操作符自然也就有了对应的速写计算符<code>**=</code>，如下</li>
</ul>
<pre><code class="language-js">let square = 3
square **= 2
console.log(square) // 9
</code></pre>
<h2>加法操作符</h2>
<ul>
<li>加法操作符比较特殊，对应不同的数据状态会发生不同的数据类型转换，规则如下</li>
</ul>
<h3>两个数都是数值的计算规则</h3>
<ul>
<li>如果两个数都是数值类型，那么对应规则如下</li>
<li>有NaN参与计算，则值为NaN</li>
<li>Infinity 加 -Infinity，结果为NaN</li>
<li>-0 加 +0，结果为+0</li>
<li>-0 加 -0，为-0， +0 加 +0，为+0</li>
<li>Infinity 加 Infinity为Infinity，-Infinity 加 -Infinity 为 -Infinity</li>
</ul>
<h3>字符串参与计算的规则如下</h3>
<ul>
<li>其中一个值为字符串，则另一个值会被转为字符串然后进行拼接</li>
</ul>
<h2>减法操作符</h2>
<ul>
<li>减法操作符的计算规则</li>
<li>NaN参与运算结果为NaN</li>
<li>Infinity 减 Infinity ,结果为NaN</li>
<li>-Infinity 减 -Infinity，结果为NaN</li>
<li>Infinity 减 -Infinity，结果为Infinity</li>
<li>-Infiniy 减 Infinity，结果为 -Infinity</li>
<li>+0 减 +0 结果为 +0</li>
<li>-0 减 +0 结果为 -0</li>
<li>-0 减 -0 结果为 +0</li>
<li>如果其中一个是 字符串、布尔值、null或者undefined，会使用Number()转为数值参与计算</li>
<li>如果其中一个是对象，则会调用该对象的 valueOf() 方法来获取数值进行计算，如果对象没有valueOf方法，那么会调用toString()方法来获取值并转为对象参与计算</li>
</ul>
<h2>比较运算符</h2>
<ul>
<li>比较运算法有 >, &#x3C;, &#x3C;=, >=</li>
<li>用来比较两个变量的大小关系，会返回一个布尔值</li>
<li>针对不同数据类型，比较规则如下</li>
<li>数值则直接比较大小</li>
<li>都是字符串则依次比较每个字符对应的字符编码</li>
<li>其中一个是数值则把另一个转为数值进行比较</li>
<li>如果是对象，则调用 valueOf() 获取值参与比较，没有该属性就获取 toString()方法获取值参与比较</li>
<li>如果其中一个是布尔值，则把它转为数值参与计算</li>
<li>字符串比较时，所有的小写字母都要大于大写字母，所以要是想按字母顺序比较的话需要同时转为大写或者小写，如下</li>
</ul>
<pre><code class="language-js">let result = "Brick" &#x3C; "alphabet"
console.log(result) // true，并不是我们的预期

let result = "Brick".toLowerCase() &#x3C; "alphabet".toLowerCase()
console.log(result) // false
</code></pre>
<ul>
<li>NaN参与比较运算符永远都得false，哪怕是比较两个 NaN</li>
</ul>
<pre><code class="language-js">let result = NaN > 3 // false
let result = NaN &#x3C;= 3 // false

let result = NaN > NaN // false
let result = NaN &#x3C;= NaN // false
</code></pre>
<h2>相等运算符</h2>
<ul>
<li>相等运算符分为全等与不全等运算符，不全等运算符不会比较类型，而是在比较时进行类型转换</li>
</ul>
<h3>不全等运算符规则</h3>
<ul>
<li>null 跟 undefined 相等</li>
<li>null 跟 undefined 不会被转为其他类型进行比较</li>
<li>NaN 参与比较永远返回false</li>
<li>两个对象比较则对比是否两个是同一个对象，是就返回true，不是就返回false</li>
<li></li>
</ul></div><div class="article-entry-bottom" data-flex="box:last"><div class="tagInfo-module--tagInfoWrap--e-EOI"><div class="tagInfo-module--tagClassify--11TLD"><a href="/category/JavaScript">JavaScript</a></div><div class="tagInfo-module--tagList--2JajG" data-flex="main:left"><div class="tagInfo-module--tag--1NeBn"><a href="/tag/JavaScript回顾">JavaScript回顾</a></div></div></div><div class="article-more-link"><a href="/blog/multiplicative-operators/">阅读全文 &gt;&gt;</a></div></div></div></article></span></div><div class="blogList"><span><article class="listWrapper-module--listWrapper--FBSVx"><div class="listWrapper-module--listContent--6okCO"><div></div><a href="/blog/template-tag-function/"><h1 class="article-title left">字符串模板标记函数</h1></a><div class="article-entry"><h1>字符串模板标记函数</h1>
<h2>字符串模板</h2>
<ul>
<li>ES6新增的字符串定义方式，可以通过 <code></code> 配合${} 来进行变量的嵌入，如下示例</li>
</ul>
<pre><code class="language-js">let name = '张三'
let age = 24
// 常规定义字符串的方式
let str = '我的名字叫' + name + ', 我今年' + age + '岁了'

// 字符串模板定义
let str1 = `我的名字叫${ name },我今年${ age }岁了`

console.log(str === str1) // true
</code></pre>
<h2>模板标记函数</h2>
<ul>
<li>模板标记函数的定义跟普通函数一致，但是在使用它之前要准备一个字符串模板，调用方式也跟常规的函数调用方法不同，不需要使用 functionName() 的形式调用，直接在函数名后面跟模板字符串即可，如下:</li>
</ul>
<pre><code class="language-js">let a = 6
let b = 9
let sum = 15
function tagTemplate(strings, aVariable, bVariable, sumVariable) {
  console.log(strings)        // ['', ' + ', ' = ', '']
  console.log(aVariable)      // 6
  console.log(bVariable)      // 9
  console.log(sumVariable)    // 15
}

tagTemplate`${a} + ${b} = ${sum}`

let c = '张三'
let d = 24
function tagTemplate(strings, cVariable, dVariable, notVariable) {
  console.log(strings)        // ['我叫', '，今年', '岁了']
  console.log(cVariable)      // '张三'
  console.log(dVariable)      // 24
  console.log(notVariable)    // undefined
}

tagTemplate`我叫${c}，今年${d}岁了`
</code></pre>
<ul>
<li>使用标记函数可以看到，参数里面的第一个参数是数组，是由字符串模板被插入变量分割之后剩余字符串组成的数组，之后的参数依次就是按顺序插入变量的值了</li>
<li>知道参数的形式后我们就可以用ES6的结构对插入变量进行一个遍历了</li>
</ul>
<pre><code class="language-js">let c = '张三'
let d = 24
function tagTemplate(strings, ...variable) {
  console.log(strings)        // ['我叫', '，今年', '岁了']
  for(let i = 0; i &#x3C; variable.length; i++) {
    console.log(variable[i])
  }
  // '张三'  24
}

tagTemplate`我叫${c}，今年${d}岁了`
</code></pre>
<h3>模板标记函数下的raw数组</h3>
<ul>
<li>采用模板标记函数后，第一个数组返回的是我们的非变量插入的字符串片段，这里的字符串片段是会转换成我们的实际展示形式的，比如 \u00A9 会转为 ©，\n 会转为一个空格</li>
<li>如果我们想要拿到没有经过转换的原版字符串，这里我们就可以使用这个数组上的raw属性来获取原版字符串的数组，我们可以看下代码</li>
</ul>
<pre><code class="language-js">function tagTest(strings, ...rest){
  for(let value of strings) {
    console.log(value)
  }
  for(let value of strings.raw) {
    console.log(value)
  }
}
let a = '张三'
let b = 24
tagTest`你${ a }\u00A9,哈哈\n${ b }我`
// strings遍历
// 你
// ©,哈哈 
// 我

// strings.raw遍历
// 你
// \u00A9,哈哈\n
// 我
</code></pre>
<ul>
<li>这就是模板标记函数给我们提供的一些特性，其实归结起来就是插入变量的提取跟原始字符串的收集，方便我们的使用</li>
</ul>
<h2>String.raw</h2>
<ul>
<li>String.raw是ES6标准的一个字符串方法，使用方式类似于模板标记函数，后面直接跟一个模板字符串即可，会原样返回该模板字符串的值，不受可编译字符的影响，普通的字符串会返回经过转义的字符串结果，如下</li>
</ul>
<pre><code class="language-js">console.log(`\u00A9`)
// ©
console.log(String.raw`\u00A9`)
// \u00A9

console.log(`Hi\n`)
// Hi
console.log(String.raw`Hi\n`)
// Hi\n

console.log(`Hi
张三`)
// Hi
// 张三
console.log(String.raw`Hi
张三`)
// Hi
// 张三
</code></pre>
<ul>
<li>它只对会被重新编译的字符串生效，实际的回车或者空格是不会被转义回去的</li>
<li>其实我也没想好这玩意哪里能用到，既然看到了就记录一下</li>
</ul></div><div class="article-entry-bottom" data-flex="box:last"><div class="tagInfo-module--tagInfoWrap--e-EOI"><div class="tagInfo-module--tagClassify--11TLD"><a href="/category/JavaScript">JavaScript</a></div><div class="tagInfo-module--tagList--2JajG" data-flex="main:left"><div class="tagInfo-module--tag--1NeBn"><a href="/tag/JavaScript回顾">JavaScript回顾</a></div></div></div><div class="article-more-link"><a href="/blog/template-tag-function/">阅读全文 &gt;&gt;</a></div></div></div></article></span></div><div class="blogList"><span><article class="listWrapper-module--listWrapper--FBSVx"><div class="listWrapper-module--listContent--6okCO"><div></div><a href="/blog/well-known-symbol/"><h1 class="article-title left">Well-Known Symbols</h1></a><div class="article-entry"><h1>Well-Known Symbols</h1>
<ul>
<li>well-known symbols 是es6引入的在整个javascript中使用的一系列方法，用于直接访问、重写、模拟语言内部的一系列行为。这些方法或者说符号以字符串属性存在于Symbol的工厂函数上。</li>
<li>这些符号存在的主要意义就是重新定义它们用于修改原生语言中的构造函数表现形式。例如，for of 循环其实是依靠于对象原型提供的 Symbol.iterator 属性，所以我们可以通过重新定义对象的 Symbol.iterator 属性来控制它的for of 表现。</li>
<li>well-known symbols 这些符号就是Symbol对象上的一些字符串属性，定义良好的符号都具有不可写入、不可重复、不可配置的特性。</li>
</ul>
<h2>Symbol.asyncIterator</h2>
<ul>
<li>ECMAScript规范中，此符号用于描述一个对象返回默认异步迭代对象的方法属性。当对象具有该属性则该对象是异步可迭代的，可以被 for await of 表达式调用。</li>
<li>语言构造器例如 for await of 利用该符号对应的方法来实现异步迭代。</li>
<li>所以我们可以对一个自定义对象添加该符号方法实现其可被for await of 调用</li>
<li>for await of 的调用必须在async 函数下才可以</li>
</ul>
<pre><code class="language-js">var a = { a :1, b: 2 }
async function b(){
  for await(var value of a) {
    console.log(a)
  }
}
b() // TypeError: a is not async iterable

var a = {
  a :1,
  b: 2,
  *[Symbol.asyncIterator](){
  }
}
async function b(){
  for await(var value of a) {
    console.log(a)
  }
}
b() // Promise {&#x3C;resolved>: undefined}
</code></pre>
<ul>
<li>可以看出只要我们实现了符号对应的异步方法，就可以正常调用，下面我们可以自定义我们想要的表现形式</li>
</ul>
<pre><code class="language-js">class Emitter {
  constructor(max) {
    this.max = max
    this.asyncIdx = 0
  }
  async*[Symbol.asyncIterator] () {
    while(this.asyncIdx &#x3C; this.max) {
      if(this.asyncIdx % 2 === 0) {
        yield new Promise(resolve => resolve(this.asyncIdx++))
      } else {
        yield new Promise(resolve => {
          setTimeout(() => {
            resolve(this.asyncIdx++)
          }, 1000)
        })
      }
    }
  }
}
var a = new Emitter(6)
async function b(){
  for await(let value of a) {
    console.log(value)
  }
}
b() // 0 1 2 3 4 5 
</code></pre>
<h2>Symbol.hasInstance</h2>
<ul>
<li>在ECMAScript标准中，该符号用做决定对象是否为构造器的实例。也就是“一个方法用来决定构造函数是否识别一个对象为它的实例。在语法上由instanceof方法调用”。instanceof操作符提供了一个方法判断一个对象实例在其原型链中是否有该原型。</li>
<li>instanceof使用如下</li>
</ul>
<pre><code class="language-js">function Foo(){}
let f = new Foo()

console.log(f instanceof Foo) // true
</code></pre>
<ul>
<li>在ES6中，instanceof 操作使用 SYmbol.hasInstance 来衡量这个关系。该键对应一个函数具有跟instanceof相同的表现，但是操作方式相反，如下</li>
</ul>
<pre><code class="language-js">function Foo(){}
let f = new Foo()
console.log(Foo[Symbol.hasInstance](f)) // true
</code></pre>
<ul>
<li>该属性被定义到了函数原型上面，所以所有的函数跟类都自动具有了该方法，因为instanceof操作符会在原型链上查找这个属性值，所以我们可以在一个继承类上来重新定义该属性。</li>
</ul>
<pre><code class="language-js">class Bar{}
class Baz extends Bar{
  static [Symbol.hasInstance] (){
    return false
  }
}

let b = new Baz()
console.log(Bar[Symbol.hasInstance](b)) // true
console.log(b instanceof Bar) // true
console.log(Baz[Symbol.hasInstance](b)) // false
console.log(b instanceof Baz) // false
</code></pre>
<ul>
<li>我们能看到，当我们查找是否是Bar的实例时，因为我们的构造函数就是继承自Bar，并且没有修改Bar的相关属性，所以能正常返回true。但是当我们修改了Baz的构造函数之后，再次调用Baz返回的就是我们修改后的函数值了</li>
</ul>
<h2>Symbol.isConcatSpreadable</h2>
<ul>
<li>在ECMAScript标准中，此符号用来决定一个对象在被Array.prototype.concat()方法调用的时候是否要被扁平化。Array.prototype.concat()方法在ES6中将会基于传入的类数组对象来决定如何将其与数组实例拼接。符号Symbol.isConcatSpreadable将允许你重写这个方法。</li>
<li>数组对象在默认情况下将会被扁平化处理到当前数组中，当对应实例的Symbol.isConcatSpreadable属性为false或者falsy数据时，则数组对象会被整个塞到当前数组中。如下</li>
</ul>
<pre><code class="language-js">let initial = ['foo']
let array = ['baz']
console.log(initial.concat(array)) // ["foo", "baz"]

let initial = ['foo']
let array = ['baz']
array[Symbol.isConcatSpreadable] = false
console.log(initial.concat(array)) // ["foo", Array(1)]
</code></pre>
<ul>
<li>类数组对象在默认情况下会被整个塞到当前数组中，类似于append表现，当我们修改其Symbol.isConcatSpreadable属性为true或者truthy时，这个对象将会被扁平化处理，然后拼接到数组中。</li>
<li>类数组对象有两个特征，一个是length属性值为数值，一个是有数字键值，看以下表现</li>
</ul>
<pre><code class="language-js">// 默认值
let arrayLikeObject = { length: 1, 0: 'baz'}
let initial = ['foo']
console.log(initial.concat(arrayLikeObject)) // ["foo", {…}]

// 修改后
let arrayLikeObject = { length: 1, 0: 'baz'}
let initial = ['foo']
arrayLikeObject[Symbol.isConcatSpreadable] = true
console.log(initial.concat(arrayLikeObject)) // ["foo", "baz"]
</code></pre>
<ul>
<li>其他的非数组或者类数组对象在设置了Symbol.isConcatSpreadable为true时都会被忽略，并不会被添加进去</li>
</ul>
<pre><code class="language-js">let otherObject = new Set().add('qux')
let initial = ['foo']
console.log(initial.concat(otherObject)) // ["foo", Set(1)]

let otherObject = new Set().add('qux')
let initial = ['foo']
otherObject[Symbol.isConcatSpreadable] = true
console.log(initial.concat(otherObject)) // ["foo"]
</code></pre>
<h2>Symbol.iterator</h2>
<ul>
<li>在ECMAScript标准中，该符号用于描述一个对象返回默认迭代器对象的方法属性。当对象具有该属性则该对象是可迭代的，可以被for of 循环调用。</li>
<li>for of 语句就是利用此符号来执行迭代，该语句将会调用Symbol.iterator对应的函数，并期望它返回一个实现了迭代器的对象，在很多场景下会返回一个生成器(一个实现了Iterator api的对象。)</li>
</ul>
<pre><code class="language-js">class Foo{
  *[Symbol.iterator](){}
}
let f = new Foo()
console.log(f[Symbol.iterator]()) // Generator {&#x3C;suspended>}
</code></pre>
<ul>
<li>需要注意的是，通过Symbol.iterator生产的对象需要能够连续生产对象凭借 next() 方法。这可以通过显示声明next方法或者通过生成器函数生成。</li>
</ul>
<pre><code class="language-js">// 显式定义next
class Emitter{
  constructor(max){
    this.max = max
    this.idx = 0
  }
  [Symbol.iterator](){
    return {
      next:() => {
        if(this.idx &#x3C; this.max) {
          return { value: this.idx++, done: false}
        } else {
          return { done: true }
        }
      }
    }
  }
}
function count(){
  let emitter = new Emitter(6)
  for(let x of emitter) {
    console.log(x)
  }
}
count() // 0 1 2 3 4 5

// 生成器函数生成
class Emitter{
  constructor(max){
    this.max = max
    this.idx = 0
  }
  *[Symbol.iterator](){
    while(this.idx &#x3C; this.max) {
      yield this.idx++
    }
  }
}

function count(){
  let emitter = new Emitter(5)
  for(const x of emitter) {
    console.log(x)
  }
}

count()  // 0 1 2 3 4
</code></pre>
<h2>Symbol.match</h2>
<ul>
<li>ECMAScript标准中，此符号是用于描述一个字符串与正则表达式的匹配关系的方法属性。被String.prototype.match()方法调用，String.prototype.match()方法会调用Symbol.match对应的函数去计算表达式，因为正则表达式的原型上有该方法属性，所以所有的正则表达式都可以被String.prototype.mactch()方法调用。</li>
<li>如果提供其他的非正则表达式参数给String.prototype.match()将会把参数转为正则表达式。</li>
<li>如果要避免此行为并且想要将参数直接使用，我们可以通过为参数指定 Symbol.match 属性为函数来绕过这个限制，该函数只接受一个参数，参数为调用match方法的字符串实例，返回值为任意类型。</li>
</ul>
<pre><code class="language-js">// 正常情况
var a = {}
'123123'.match(a) // null

// 添加值
var a = {}
Object.prototype[Symbol.match] = string => string.includes('123')
'123123'.match(a) // true
</code></pre>
<ul>
<li>上面我们就是为对象指定了Symbol.match属性，所以但我们传递进去对象值时都会返回true</li>
</ul>
<h2>Symbol.replace</h2>
<ul>
<li>ECMAScript标准中，此符号是用于描述“替换字符串中匹配到的子字符串的一个正则表达式方法，被String.prototype.replace()方法调用”</li>
<li>String.prototype.replace将会调用参数上的Symbol.replace对应的方法来进行表达式计算</li>
<li>正则表达式原型有Symbol.replace方法，所以所有的正则表达式都可以被replace方法调用。</li>
<li>同样的，如果传入的是非正则类型，则会被强制转为正则类型。我们可以通过为入参定义Symbol.replace方法来绕过并重新定义行为</li>
<li>定义的方法有两个参数，一个是原始字符串，一个是要替换的字符串</li>
</ul>
<pre><code class="language-js">// 原表现形式
class Test{
  constructor(str){
    this.str = str
  }
}
"aaasdasddd".replace(new Test('asd'), '123') // 'aaasdasddd'

// 重新定义属性
class Test{
  constructor(str){
    this.str = str
  }
  [Symbol.replace] = (str, replaceStr) => str.split(this.str).join(replaceStr)
}
"aaasdasddd".replace(new Test('asd'), '123') // 'aa123123dd'
</code></pre>
<ul>
<li>上面我们就实现了传递一个非正则对象给replace方法并成功完成我们想要的展示形式</li>
</ul>
<h2>Symbol.search</h2>
<ul>
<li>在ECMAScript规范中，该符号用来描述“一个用来返回字符串中符合对应正则表达式的字符串的位置，被String.prototype.search()方法调用”</li>
<li>String.prototype.search将会调用参数上的Symbol.search对应的方法来进行表达式计算</li>
<li>正则表达式原型有Symbol.search方法属性，所以所有的正则表达式都可以被search方法调用。</li>
<li>同样的，如果传入的是非正则类型，则会被强制转为正则类型。我们可以通过为入参定义Symbol.search方法来绕过并重新定义行为</li>
<li>定义的方法只有一个参数，就是对应的字符串实例，返回值为任意类型</li>
</ul>
<pre><code class="language-js">// 原表现形式
class Search{
  constructor(str){
    this.str = str
  }
}
"hahaha".search(new Search('ha')) // -1

// 重新定义属性
class Search{
  constructor(str){
    this.str = str
  }
  [Symbol.replace] = (str) => str.indexOf(this.str)
}
"hahaha".replace(new Search('ha')) // 0
</code></pre>
<h2>Symbol.species</h2>
<ul>
<li>该符号被构建函数调用创造派生实例</li>
<li>在构造类中声明静态getter方法Symbol.species将会覆盖新创建实例原型的构建函数</li>
<li>当我们调用map方法或者concat方法时会默认返回对应实例的默认构造函数，如果我们这里通过声明getter方法Symbol.species来将其修改为其他构建对象，那在map或concat方法后返回的对象类型就会发生变化</li>
</ul>
<pre><code class="language-js">class Bar extends Array {}
var b = new Bar(1, 2, 3)
console.log(b instanceof Array) // true
console.log(b instanceof Bar) // true

// 添加getter方法
class Baz extends Array {
  static get [Symbol.species] () {
    return Number
  }
}
var c = new Baz(1, 2, 3)
console.log(c instanceof Array)   // true
console.log(c instanceof Baz)     // true
console.log(c instanceof Number)  // false

console.log(c.concat(c) instanceof Array)   // false
console.log(c.concat(c) instanceof Baz)     // false
console.log(c.concat(c) instanceof Number)  // true
</code></pre>
<ul>
<li>从上面我们可以看出，声明getter方法Symbol.species后，对单独的实例不会有影响，但是当返回默认的构造函数时，就会使用我们Symbol.species中返回的构造函数了</li>
</ul>
<h2>Symbol.split</h2>
<ul>
<li>该符号用于描述“一个用于在匹配正则表达式的位置进行字符串分割的正则表达式方法，被String.prototype.split()方法调用”</li>
<li>String.prototype.split将会调用入参对象的Symbol.split属性方法来进行表达式计算。</li>
<li>正则表达式原型有Symbol.split方法属性，所以所有的正则表达式都可以被split方法调用。</li>
<li>同样的，如果传入的是非正则类型，则会被强制转为正则类型。我们可以通过为入参定义Symbol.split方法来绕过并重新定义行为</li>
<li>定义的方法只有一个参数，就是对应的字符串实例，返回值为任意类型</li>
</ul>
<pre><code class="language-js">// 原表现形式
class Split{
  constructor(str){
    this.str = str
  }
}
"123hahaha123".split(new Split('ha')) // ["123hahaha123"]

// 重新定义属性
class Split{
  constructor(str){
    this.str = str
  }
  [Symbol.split](target){
    console.log(123, target, this.str)
    return target.split(this.str)
  }
}
"123hahaha123".split(new Split('ha')) // ["123", "", "", "123"]
</code></pre>
<h2>Symbol.toPrimitive</h2>
<ul>
<li>该符号用于描述“一个将对象转换为常规数据类型的方法，被强制类型操作符所调用”。很多内置操作符都会尝试将对象转为基本数据类型，例如：string类型、number类型、number类型，或者其他的基本类型。</li>
<li>对一个自定义的对象，我们可以通过定义它的Symbol.toPrimitive属性来决定它的强制类型转换方式。该方法接收一个它原本会被转换为的数据类型的类型字符串名称，所以我们根据这个情况构造我们想要的形式</li>
</ul>
<pre><code class="language-js">// 原始类型
class Foo{}
let foo = new Foo()
console.log(3 + foo) // "3[object Object]"
console.log(3 - foo)  // NaN
console.log(String(foo))  // "[object Object]"

// 自定义表现形式
class Bar {
  constructor(){
    this[Symbol.toPrimitive] = function (hint){
      switch(hint) {
        case 'string':
          return 'string bar'
        case 'number':
          return 3
        case 'default':
        default:
          return 'default bar'
      }
    }
  }
}
let bar = new Bar()
console.log(3 + bar) // 3default bar
console.log(3 - bar)  // 0
console.log(String(bar))  // string bar
</code></pre>
<ul>
<li>上面我们可以看到，当对象遇到 + 操作符时它无法确定要执行字符串拼接的 + 操作还是数值的相加 + 操作，所以就返回了默认的 default bar;当对象遇到 - 操作时明确的知道自己要被转为数值类型，所以走了 case 'number' ，返回了3，然后被执行操作；当预定String()方法时也明确的知道自己要返回字符串类型，所以返回了 string bar</li>
</ul>
<h2>Symbol.toStringTag</h2>
<ul>
<li>该符号用于描述“一个对象的创建对象类型的默认字符串描述，被Object.prototype.toString所调用”，该创建对象的字符串描述会依靠Symbol.toStringTag方法来获取，默认为"Object"</li>
<li>内置类型都有声明这个属性方法，但是自定义对象就需要我们显式声明了</li>
</ul>
<pre><code class="language-js">// 内置对象
var s = new Set()
console.log(s)                      // Set(0) {}
console.log(s.toString())           // [object Set]
console.log(s[Symbol.toStringTag])  // Set
// 自定义对象
class Foo{}
var f = new Foo()
console.log(f)                      // Foo {}
console.log(f.toString())           // [object Object]
console.log(f[Symbol.toStringTag])  // undefined

// 修改后的自定义对象
class Bar{
  constructor(){
    this[Symbol.toStringTag] = 'Bar'
  }
}
var b = new Bar()
console.log(b)                      // Bar {Symbol(Symbol.toStringTag): "Bar"}
console.log(b.toString())           // [object Bar]
console.log(b[Symbol.toStringTag])  // Bar
</code></pre>
<h2>Symbol.unscopables</h2>
<ul>
<li>该符号用于描述“防止被width操作绑定到该对象的自有属性或者继承属性”，设置这个属性将指定键值改为true则with方法将无法在该对象上查找指定属性</li>
</ul>
<pre><code class="language-js">// 正常形式
var o = { foo: 'asd' }
with(o) {
  console.log(foo) // 'asd'
}

// 自定义后
var o = { foo: 'asd' }
o[Symbol.unscopables] = {
  foo: true
}
with(o) {
  console.log(foo)  // Uncaught ReferenceError: foo is not defined
}
</code></pre>
<ul>
<li>新的ECMAScript规范中已经不推荐使用with方法了，所以，我们的Symbol.unscopables也不再推荐使用</li>
</ul></div><div class="article-entry-bottom" data-flex="box:last"><div class="tagInfo-module--tagInfoWrap--e-EOI"><div class="tagInfo-module--tagClassify--11TLD"><a href="/category/JavaScript">JavaScript</a></div><div class="tagInfo-module--tagList--2JajG" data-flex="main:left"><div class="tagInfo-module--tag--1NeBn"><a href="/tag/JavaScript回顾">JavaScript回顾</a></div></div></div><div class="article-more-link"><a href="/blog/well-known-symbol/">阅读全文 &gt;&gt;</a></div></div></div></article></span></div><div class="blogList"><span><article class="listWrapper-module--listWrapper--FBSVx"><div class="listWrapper-module--listContent--6okCO"><div></div><a href="/blog/Date/"><h1 class="article-title left">Date类型</h1></a><div class="article-entry"><h1>Date 类型</h1>
<ul>
<li>Date构造函数可以接收毫秒数来创建时间对象，对此提供了辅助函数来进行毫秒数的获取</li>
</ul>
<h2>Date.parse()</h2>
<ul>
<li>
<p>该方法接收一个表示日期的字符串，并转为对应的毫秒数，接受的格式如下</p>
<ul>
<li>"月/日/年"，如"5/23/2019"</li>
<li>"月名日,年"，如"May 23, 2019"</li>
<li>"周几月名日年时:分:秒:时区"，如"Tue May 23 2020 00:00:00 GMT-0700"</li>
<li>拓展格式"YYYY-MM-DDTHH:mm:ss.sssZ"，如："2020-05-23T00:00:00"</li>
</ul>
</li>
<li>使用方式如下</li>
</ul>
<pre><code class="language-js">let time1 = new Date(Date.parse("May 23, 2020"))
// Sat May 23 2020 00:00:00 GMT+0800 (中国标准时间)
</code></pre>
<ul>
<li>如果传给Date.parse()的字符串不能表示时间该方法返回NaN</li>
<li>如果在给new Date()传参时直接传了表示时间的字符串，那Date会在后台隐式调用Date.parse()，下代码与上面同样</li>
</ul>
<pre><code class="language-js">let time1 = new Date("May 23, 2020")
// Sat May 23 2020 00:00:00 GMT+0800 (中国标准时间)
</code></pre>
<ul>
<li>关于越界时间，当我们传了一个不存在的时间比如3月32号时部分浏览器会返回4月1号的时间，有些浏览器则会直接返回当前时间，比如你在5月1日运行代码就会返回5月1号的时间</li>
</ul>
<h2>Date.UTC()</h2>
<ul>
<li>这个方法也是用于返回日期的毫秒数，但是参数不一样，参数是年，零起点的月数（也就是1月用0表示，2月用1表示，依次类推），日，时（0-24），分，秒，毫秒</li>
<li>只有年跟月是必须，其他的不填都默认为0，使用方式如下</li>
</ul>
<pre><code class="language-js">let time2 = new Date(Date.UTC(2020, 09, 12, 15, 44, 03))
// Mon Oct 12 2020 23:44:03 GMT+0800 (中国标准时间)
</code></pre>
<ul>
<li>可以看到其实会被我们的参数当做UTC时间来做解析，最后得到的是本地的 23：44</li>
<li>当我们在new Date()的时候使用Date.UTC形式的参数，那Date也会隐式调用Date.UTC()，但是不同的是不会被当做UTC时间处理而是当做本地时间处理，如下</li>
</ul>
<pre><code class="language-js">let time2 = new Date(2020, 09, 12, 15, 44, 03)
// Mon Oct 12 2020 15:44:03 GMT+0800 (中国标准时间)
</code></pre>
<h2>Date原型方法</h2>
<ul>
<li>Date对象重写了toString、valueOf、toLocalString方法</li>
<li>toLocalString与toString，两个方法分别返回对应的GMT时间与本地时间，如下</li>
</ul>
<pre><code class="language-js">new Date().toLocaleString()
// "2020/10/12 下午3:53:58"
new Date().toString()
// "Mon Oct 12 2020 15:54:04 GMT+0800 (中国标准时间)"
</code></pre>
<ul>
<li>valueOf方法会返回对应时间的毫秒数，数字类型</li>
</ul>
<pre><code class="language-js">new Date().valueOf()
// 1602489459169
</code></pre>
<ul>
<li>
<p>Date格式时间的方法</p>
<ul>
<li>toDateString()，显示时间中的周几、月、日、年</li>
<li>toTimeString()，显示时间中的时、分、秒、时区</li>
<li>toLocalDateString()，获取本地时间的周几、月、日、年</li>
<li>toLocalTimeString()，获取本地时间的时、分、秒、时区</li>
<li>toUTCString()，显示完整的UTC时间</li>
</ul>
</li>
</ul></div><div class="article-entry-bottom" data-flex="box:last"><div class="tagInfo-module--tagInfoWrap--e-EOI"><div class="tagInfo-module--tagClassify--11TLD"><a href="/category/JavaScript">JavaScript</a></div><div class="tagInfo-module--tagList--2JajG" data-flex="main:left"><div class="tagInfo-module--tag--1NeBn"><a href="/tag/JavaScript回顾">JavaScript回顾</a></div></div></div><div class="article-more-link"><a href="/blog/Date/">阅读全文 &gt;&gt;</a></div></div></div></article></span></div><div class="blogList"><span><article class="listWrapper-module--listWrapper--FBSVx"><div class="listWrapper-module--listContent--6okCO"><div></div><a href="/blog/Number/"><h1 class="article-title left">Number类型</h1></a><div class="article-entry"><h1>Number 类型</h1>
<ul>
<li>Number对象也重写了toString、toLocalString、valueOf方法</li>
<li>valueOf返回原数值</li>
<li>toString()接收一个参数用于表示该数字的几进制数，如下</li>
</ul>
<pre><code class="language-js">let num = 10
console.log(num.toString()) // '10'
console.log(num.toString(2)) // '1010'
console.log(num.toString(8)) // '12'
console.log(num.toString(10)) // '10'
console.log(num.toString(16)) // 'a'
</code></pre>
<ul>
<li>toExponential()用于表示数值的科学技术法的表示字符串</li>
</ul>
<pre><code class="language-js">console.log(num.toExponential()) // 1e+1
</code></pre>
<ul>
<li>toPrecision()会根据你传入的参数决定输出结果，该参数表示结果中的数字的位数，如下</li>
</ul>
<pre><code class="language-js">let num1 = 99
console.log(num1.toPrecision(1)) // 1e+2
console.log(num1.toPrecision(2)) // 99
console.log(num1.toPrecision(3)) // 99.0
</code></pre>
<ul>
<li>ES6新增isInteger()用于判断是否是整数</li>
</ul>
<pre><code class="language-js">console.log(Number.isInteger(1)) // true
console.log(Number.isInteger(1.00)) // true
console.log(Number.isInteger(1.01)) // false
</code></pre>
<ul>
<li>该方法不会受到小数点后都是0的影响</li>
<li>IEEE 754数值格式有一个特殊的数值范围，此范围内的二进制值可表示一个整数，该范围为Number.MIN<em>SAFE</em>INTEGER((-2) ** 53 + 1) 到 Number.MAX<em>SAFE</em>INTEGER(2 ** 53 - 1)</li>
<li>超出这个范围的值在保存为整数时数值可能会变化，所以我们可以通过 Number.isSafeInteger()来判断一个整数是否在该范围内</li>
</ul>
<pre><code class="language-js">console.log(Number.isSafeInteger(-1 * (2 ** 53))) // false
console.log(Number.isSafeInteger(-1 * (2 ** 53) + 1)) // true
</code></pre></div><div class="article-entry-bottom" data-flex="box:last"><div class="tagInfo-module--tagInfoWrap--e-EOI"><div class="tagInfo-module--tagClassify--11TLD"><a href="/category/JavaScript">JavaScript</a></div><div class="tagInfo-module--tagList--2JajG" data-flex="main:left"><div class="tagInfo-module--tag--1NeBn"><a href="/tag/JavaScript回顾">JavaScript回顾</a></div></div></div><div class="article-more-link"><a href="/blog/Number/">阅读全文 &gt;&gt;</a></div></div></div></article></span></div><div class="blogList"><span><article class="listWrapper-module--listWrapper--FBSVx"><div class="listWrapper-module--listContent--6okCO"><div></div><a href="/blog/String/"><h1 class="article-title left">String类型</h1></a><div class="article-entry"><h1>String类型</h1>
<ul>
<li>字符串由16位码元组成，多数字符都是16位码元对应一个字符，length属性就是表示有多少个16位码元</li>
<li>charAt()方法返回给定索引位置的字符，参数为索引位置</li>
<li>javascript采用UCS-2和UTF-16两种Unicode编码混合策略，对于(U+0000~U+FFFF)，这两种编码是一样的</li>
<li>charCodeAt()可以查看对应索引位置的字符编码，参数为索引位置</li>
<li>fromCharCode()可以根据给定的UTF-16码元创建字符串，然后将其拼接返回</li>
</ul>
<pre><code class="language-js">let message = 'abcde'
console.log(message.charAt(2)) // 'c'
console.log(message.charCodeAt(2)) // 99
// 可以16进制入参
console.log(String.fromCharCode(0x61, 0x62, 0x63, 0x64, 0x65)) // "abcde"
console.log(String.fromCharCode(97, 98, 99, 100, 101)) // "abcde"
</code></pre>
<ul>
<li>对于在U+0000~U+FFFF范围内的字符，length、charAt()、charCodeAt()、fromCharCode()都可以正常运行</li>
<li>当拓展到Unicode增补字符平面就不行了，上面的16位只能标识65536个字符，这些表示基本多语言平面，为了表示更多的字符，采用了每个字符使用另外16位去选择一个增补平面。这种每个字符使用两个16位码元的策略称为代理对</li>
<li>当我们对含有代理对编码的字符串就会有问题，如下</li>
</ul>
<pre><code class="language-js">let message = 'ab😊de'
console.log(message.length)     // 6
console.log(message.charAt(1))  // b
console.log(message.charAt(2))  // �
console.log(message.charAt(3))  // �
console.log(message.charAt(4))  // d 
console.log(message.charCodeAt(1))  // 98
console.log(message.charCodeAt(2))  // 55357
console.log(message.charCodeAt(3))  // 56842
console.log(message.charCodeAt(4))  // 100


console.log(String.fromCharCode(97, 98, 55357, 56842, 100, 101)) // ab😊de
</code></pre>
<ul>
<li>这里我们能看到笑脸符明显占了两个字符，然后我们尝试使用fromCharCode()来将代理对进行解析为字符串是没有问题的，这是因为浏览器可以正常解析代理对</li>
<li>针对这种情况，我们可以使用codePointAt()来替代charCodeAt()</li>
<li>codePointAt()使用方法跟charCodeAt()基本一致，也是接受一个表示索引的参数并返回该索引的码点。码点是Unicode中一个字符的完整标识，可能是16位，也有可能32位，codePointAt()可以查看完整的码点</li>
</ul>
<pre><code class="language-js">let message = 'ab😊de'
console.log(message.codePointAt(1))  // 98
console.log(message.codePointAt(2))  // 128522
console.log(message.codePointAt(3))  // 56842
console.log(message.codePointAt(4))  // 100
</code></pre>
<ul>
<li>我们可以通过字符串解析来识别代理对，如下</li>
</ul>
<pre><code class="language-js">let message = 'ab😊de'
console.log([...message]) // ["a", "b", "😊", "d", "e"]
</code></pre>
<ul>
<li>这样就将我们的代理对给完整解析了</li>
<li>对应的，我们也有fromCodePoint()来讲对应的码点转为字符串，并拼接返回</li>
</ul>
<pre><code class="language-js">// 使用 fromCharCode要有6位数字才可以
console.log(String.fromCharCode(97, 98, 55357, 56842, 100, 101)) // ab😊de
// 使用 fromCodePoint
console.log(String.fromCodePoint(97, 98, 128522, 100, 101)) // ab😊de
</code></pre>
<h2>normalize 方法</h2>
<ul>
<li>该方法针对一些可以使用多种编码方式表达的unicode字符，比如下面字符</li>
</ul>
<pre><code class="language-js">// 上面带圆圈的 A
console.log(String.fromCharCode(0x00C5))          // Å
// 长度单位 “埃”
console.log(String.fromCharCode(0x212B))          // Å
// U+004大写字符 A, U+030A 上面的圆圈
console.log(String.fromCharCode(0x0041, 0x030A))  // Å
</code></pre>
<ul>
<li>上面三种编码返回的字符串看上去是一样的，其实编码不一样，所以比较起来也不会一样</li>
</ul>
<pre><code class="language-js">let a1 = String.fromCharCode(0x00C5),
a2 = String.fromCharCode(0x212B),
a3 = String.fromCharCode(0x0041, 0x030A)
console.log(a1 === a2)  // false
console.log(a1 === a3)  // false
console.log(a2 === a3)  // false
</code></pre>
<ul>
<li>针对上情况，Unicode提供了4种格式化方法，将类似上面的字符串转为一致格式，分别是NFD、NFC、NFKD、NFKC</li>
<li>然后我们就可以使用normalize方法跟对应的优化方法名称来进行格式化</li>
</ul>
<pre><code class="language-js">let a1 = String.fromCharCode(0x00C5),
a2 = String.fromCharCode(0x212B),
a3 = String.fromCharCode(0x0041, 0x030A)

// U+005C是对U+212B进行NFC/NFKC规范之后的结果
console.log(a1 === a1.normalize('NFD')) // false
console.log(a1 === a1.normalize('NFC')) // true
console.log(a1 === a1.normalize('NFKD')) // false
console.log(a1 === a1.normalize('NFKC')) // true

// U+212B是未规范化的
console.log(a2 === a2.normalize('NFD')) // false
console.log(a2 === a2.normalize('NFC')) // false
console.log(a2 === a2.normalize('NFKD')) // false
console.log(a2 === a2.normalize('NFKC')) // false

// U+0041/U+030A是对U+212B进行NFD/NFKD规范之后的结果
console.log(a3 === a3.normalize('NFD')) // true
console.log(a3 === a3.normalize('NFC')) // false
console.log(a3 === a3.normalize('NFKD')) // true
console.log(a3 === a3.normalize('NFKC')) // false
</code></pre>
<ul>
<li>当对上述编码采用同样的规范方式可以让比较操作符返回正确结果</li>
</ul>
<pre><code class="language-js">let a1 = String.fromCharCode(0x00C5),
a2 = String.fromCharCode(0x212B),
a3 = String.fromCharCode(0x0041, 0x030A)

console.log(a1.normalize("NFD") === a2.normalize("NFD")) // true
console.log(a1.normalize("NFKC") === a3.normalize("NFKC")) // true
console.log(a2.normalize("NFC") === a3.normalize("NFC")) // true
</code></pre>
<h2>slice、substr、substring对比</h2>
<ul>
<li>这三种方法都是从字符串中提取子字符串</li>
<li>都接收一个或两个参数，第一个参数为开始位置</li>
<li>slice跟substring第二个参数为提取结束的位置，该位置之前的字符串都会被提取</li>
<li>substr第二个参数表示要提取的字符串的长度</li>
<li>忽略第二个参数这三个方法的返回值一致，都会提取到字符串尾</li>
</ul>
<pre><code class="language-js">let stringValue = 'hello world'
console.log(stringValue.slice(3))      //  'lo world'
console.log(stringValue.substring(3))  //  'lo world'
console.log(stringValue.substr(3))     //  'lo world'
console.log(stringValue.slice(3, 7))      //  'lo w'
console.log(stringValue.substring(3, 7))  //  'lo w'
console.log(stringValue.substr(3, 7))     //  'lo worl'
</code></pre>
<ul>
<li>当参数为负数时，slice会将所有负数跟字符串长度相加作为新的参数</li>
<li>substr会将第一个负数参数与字符串长度相加，第二个负数参数转为0</li>
<li>substring会将所有的负数参数转为0，会将小的参数作为起点，大的参数作为终点</li>
</ul>
<pre><code class="language-js">let stringValue = 'hello world'
console.log(stringValue.slice(-3))      //  'rld'
console.log(stringValue.substring(-3))  //  'hello world'
console.log(stringValue.substr(-3))     //  'rld'
console.log(stringValue.slice(3, -4))      //  'lo w'
console.log(stringValue.substring(3, -4))  //  'hel'
console.log(stringValue.substr(3, -4))     //  ''
</code></pre>
<h2>indexOf与lastIndexOf</h2>
<ul>
<li>都是查找指定字符串，接受两个参数，第一个是查找字符串，第二个是起始位置</li>
<li>indexOf默认从0开始向后找，指定第二个参数后会从第二个参数指定的下标开始找，忽略该下标之前的字符</li>
<li>lastIndexOf默认从字符串最后一位开始向前找，指定第二个参数则会从参数指定的下标向前找，忽略该下标之前的字符</li>
</ul>
<h2>startsWith、endsWith、includes</h2>
<ul>
<li>ES6新增用于判断字符串中是否包含另外字符串的方法，都返回布尔值</li>
<li>startsWith检查开始于索引0的匹配项</li>
<li>endsWith检查开始于索引(string.length - subString.length)的匹配项</li>
<li>includes检查整个字符串</li>
</ul>
<pre><code class="language-js">let message = 'foobarbaz'

console.log(message.startsWith('foo')) // true
console.log(message.startsWith('bar')) // false

console.log(message.endsWith('baz')) // true
console.log(message.endsWith('bar')) // false

console.log(message.includes('bar')) // true
console.log(message.includes('foo')) // true
</code></pre>
<ul>
<li>startsWith与includes可接收第二个参数，用于表示开始查找的位置，传入该参数会忽略该参数之前的字符</li>
<li>endsWith也可以接收第二个参数，用于表示字符串末尾的位置，传入该参数就好像将被查找字符串截断了一样</li>
</ul>
<pre><code class="language-js">let message = 'foobarbaz'

console.log(message.startsWith('foo')) // true
console.log(message.startsWith('foo', 1)) // false

console.log(message.includes('bar')) // true
console.log(message.includes('bar', 4)) // false

console.log(message.endsWith('bar')) // false
console.log(message.endsWith('bar', 6)) // true
</code></pre>
<h2>trim、trimRight、trimLeft</h2>
<ul>
<li>分别用于去除两端的空格、右面的空格、左面的空格</li>
</ul>
<h2>repeat方法</h2>
<ul>
<li>接收一个整数参数，表示将该字符串复制多少次然后拼接返回</li>
</ul>
<pre><code class="language-js">let stringValue = 'na '
console.log(stringValue.repeat(8)) // 'na na na na na na na na '
</code></pre>
<h2>padStart、padEnd方法</h2>
<ul>
<li>这两个方法会复制字符串，如果小于指定字符串，则在相应的一边填充字符，直到满足条件，第一个参数是长度，第二个参数是可选的填充字符串，默认为空格</li>
</ul>
<pre><code class="language-js">let stringValue = 'foo'
console.log(stringValue.padStart(6))      // '   foo'
console.log(stringValue.padStart(6, '.')) // '...foo'
console.log(stringValue.padEnd(6))        // 'foo   '
console.log(stringValue.padEnd(6, '.'))   // 'foo...'
</code></pre>
<ul>
<li>要是第二个参数指定的是多个字符的字符串，那么在复制后如果长度超出会把参数指定的字符串裁剪</li>
<li>如果第一个参数指定的长度小于等于原始字符串长度，则返回原始字符串</li>
</ul>
<pre><code class="language-js">let stringValue = 'foo'
console.log(stringValue.padStart(8, 'bar')) // 'barbafoo'
console.log(stringValue.padStart(2))        // 'foo'
console.log(stringValue.padEnd(8, 'bar'))   // 'foobarba'
console.log(stringValue.padEnd(2))          // 'foo'
</code></pre>
<h2>字符串解析与迭代</h2>
<ul>
<li>字符串原型暴露了 @@iterator方法，所以字符串可以被解析与迭代，如下</li>
</ul>
<pre><code class="language-js">let a = 'abcde'
for(const c of a) {
  console.log(c)
}
// a
// b
// c
// d
// e
console.log([...a])
// ["a", "b", "c", "d", "e"]
</code></pre>
<h2>toLowerCase、toUpperCase、toLocalLowerCase、toLocalUpperCase</h2>
<ul>
<li>都是用于进行大小写转换的，toLowerCase与toLocalLowerCase都是将字符串转为小写字母表示，toLocalLowerCase是为了防止出现地方字符无法转换的情况</li>
<li>toUpperCase与toLocalUpperCase都是将字符串转为大写字母表示，toLocalUpperCase是为了防止出现地方字符无法转换的情况</li>
</ul>
<h2>match、search、replace方法</h2>
<ul>
<li>match方法接收一个正则表达式或正则表达式字符串，返回一个数组，第一个元素是与正则匹配的字符串，其余的元素是表达式中的捕获组匹配到的字符串('()'中的内容)</li>
<li>search方法是查找方法，也是接收一个正则表达式或者正则表达式字符串，返回匹配到的第一个的索引，没有找到返回-1</li>
<li>replace是替换方法，接受两个参数，第一个参数是正则表达式或者字符串（该字符串时不会转为正则表达式），第二个参数是字符串或者函数。当地一个参数为字符串时只会替换查找到的第一个字符串，要想全部替换必须用正则表达式</li>
</ul>
<pre><code class="language-js">let text = 'cat, bat, sat, fat'
console.log(text.replace('at', 'ond'))    // cond, bat, sat, fat
console.log(text.replace(/at/g, 'ond'))   // cond, bond, sond, fond
console.log(text.replace(/(.at)/g, 'word ($1)')) // word (cat), word (bat), word (sat), word (fat)
</code></pre>
<ul>
<li>第二个参数为函数时，当匹配项只有一个时，有三个参数，整个模式匹配的字符串、匹配字符串的开始位置、整个字符串。</li>
<li>当有多个捕获组的情况下，每个匹配的捕获组的字符串也会被当做参数，最后两个参数仍然是匹配字符串的开始位置、整个字符串</li>
<li>这个函数应该返回一个字符串，表示把匹配项换成什么</li>
</ul>
<h2>split方法</h2>
<ul>
<li>split会根据传入的参数将字符串转为数组，参数可以是字符串，也可以是RegExp对象。还可以接收第二个参数来表示数组大小，确保数组不会超过指定大小</li>
</ul>
<pre><code class="language-js">let color = 'red,blue,green,yellow'
console.log(color.split(','))     // ["red", "blue", "green", "yellow"]
console.log(color.split(',', 2))  // ["red", "blue"]
console.log(color.split(/[^,]+/)) // ["", ",", ",", ",", ""]
</code></pre>
<h2>localeCompare方法</h2>
<ul>
<li>用于比较字符串</li>
<li>按照字母排序，如果字符串应该排在字符串参数之前，返回负数</li>
<li>字符串与参数字符串相同，返回0</li>
<li>字符串应该在字符串参数之后，返回正数</li>
</ul>
<pre><code class="language-js">let stringValue = 'yellow'
console.log(stringValue.localeCompare('brick'))   // 1
console.log(stringValue.localeCompare('yellow'))  // 0
console.log(stringValue.localeCompare('zoo'))     // -1
</code></pre></div><div class="article-entry-bottom" data-flex="box:last"><div class="tagInfo-module--tagInfoWrap--e-EOI"><div class="tagInfo-module--tagClassify--11TLD"><a href="/category/JavaScript">JavaScript</a></div><div class="tagInfo-module--tagList--2JajG" data-flex="main:left"><div class="tagInfo-module--tag--1NeBn"><a href="/tag/JavaScript回顾">JavaScript回顾</a></div></div></div><div class="article-more-link"><a href="/blog/String/">阅读全文 &gt;&gt;</a></div></div></div></article></span></div><div class="blogList"><span><article class="listWrapper-module--listWrapper--FBSVx"><div class="listWrapper-module--listContent--6okCO"><div></div><a href="/blog/Global/"><h1 class="article-title left">Global对象</h1></a><div class="article-entry"><h1>Global对象及方法</h1>
<h2>encodeURI、encodeURIComponent</h2>
<ul>
<li>这两个方法都是用于编码统一资源标识符（URI），以传给浏览器</li>
<li>区别是encodeURI不会编码属于URL组件的特殊字符，如冒号、斜杠、问号、井号，而encodeURIComponent会编码所有的非标准字符</li>
<li>所以一般我们会使用encodeURIComponent</li>
<li>它们分别对应的解码方法时decodeURI与decodeURIComponent</li>
</ul>
<h2>eval</h2>
<ul>
<li>eval接收一个完整的要执行的ECMAScript字符串，当解释器发现eval()方法时会将其解释为真实的ECMAScript语句</li>
<li>然后将其插入当前位置，插入的语句属于该调用的执行上下文，被执行语句与该上下文有同样的作用域链</li>
</ul>
<pre><code class="language-js">let msg = 'hello'
eval("console.log(msg)") // 'hello'
</code></pre>
<ul>
<li>可以在eval中定义函数或变量，然后在外面引用</li>
</ul>
<pre><code class="language-js">eval("function sayHi(){ console.log('hi')}")
sayHi() // hi

eval("let msg = 'world'")
console.log(msg) // msg is not defined
</code></pre>
<ul>
<li>这是因为eval中的变量跟函数都无法被提升，只有到执行之后才会被创建，所以函数可以正常执行，但是变量在编译阶段就会报错</li>
<li>在严格模式下使用eval会报错</li>
</ul>
<h2>Math对象</h2>
<ul>
<li>Math.E,自然对数的基数e的值</li>
<li>Math.LN10，10为底的自然对数</li>
<li>Math.LN2，2为底的自然对数</li>
<li>Math.LOG2E，以2为底e的对数</li>
<li>Math.LOG10E，以10为底e的对数</li>
<li>Math.PI，数字π</li>
<li>Math.SQRT1_2，1/2的平方根</li>
<li>Math.SQRT2，2的平方根</li>
</ul>
<h3>min和max方法</h3>
<ul>
<li>min，确定一组数值的最小值</li>
<li>max，确定一组数值的最大值</li>
</ul>
<pre><code class="language-js">console.log(Math.min(3, 8, 4, 12, 66,44, 66, 77)) // 3
console.log(Math.max(3, 8, 4, 12, 66,44, 66, 77)) // 77
</code></pre>
<ul>
<li>由接受参数形式可以对数组解构来获取最大最小值</li>
</ul>
<pre><code class="language-js">let arr = [3, 8, 4, 12, 66,44, 66, 77]
console.log(Math.min(...arr)) // 3
console.log(Math.max(...arr)) // 77
</code></pre>
<ul>
<li>其他方法</li>
<li>Math.abs()，返回绝对值</li>
<li>Math.exp(x)，返回MATH.E的x次幂</li>
<li>Math.expm1(x)，Math.exp(x) - 1</li>
<li>Math.log(x)，返回x的自然对数</li>
<li>Math.log1p(x)，等于1 + Math.log(x)</li>
<li>Math.pow(x, power)，返回x的power次幂</li>
<li>Math.hypot(...nums)，返回nums中每个数平方和的平方根</li>
<li>Math.clz32(x)，返回32位整数x的前置0的数量</li>
<li>Math.sign(x)，返回表示x符号的1，0，-0，-1</li>
<li>Math.trunc(x)，返回x的整数部分，删除所有小数部分</li>
<li>Math.sqrt(x)，返回x的平方根</li>
<li>Math.cbrt(x)，返回x的立方根</li>
<li>Math.acos(x)，返回x的反余弦</li>
<li>Math.acosh(x)，返回x的反双曲余弦</li>
<li>Math.asin(x)，返回x的反正弦</li>
<li>Math.asinh(x)，返回x的双反曲正弦</li>
<li>Math.atan(x)，返回x的反正切</li>
<li>Math.atanh(x)，返回x的双反曲正切</li>
<li>Math.atan2(y, x)，返回y/x的反正切</li>
<li>Math.cos(x)，返回x的余弦</li>
<li>Math.sin(x)，返回x的正弦</li>
<li>Math.tan(x)，返回x的正切</li>
</ul></div><div class="article-entry-bottom" data-flex="box:last"><div class="tagInfo-module--tagInfoWrap--e-EOI"><div class="tagInfo-module--tagClassify--11TLD"><a href="/category/JavaScript">JavaScript</a></div><div class="tagInfo-module--tagList--2JajG" data-flex="main:left"><div class="tagInfo-module--tag--1NeBn"><a href="/tag/JavaScript回顾">JavaScript回顾</a></div></div></div><div class="article-more-link"><a href="/blog/Global/">阅读全文 &gt;&gt;</a></div></div></div></article></span></div></div><div class="paganation-module--paganation--2bE_X"><a class="paganation-module--extend--2q4Qk" href="/blog/2">« Prev</a><a class="paganation-module--pageNumber--RUHS6 " href="/blog/">1</a><a class="paganation-module--pageNumber--RUHS6 " href="/blog/2">2</a><a class="paganation-module--pageNumber--RUHS6 " href="/blog/3">3</a><a aria-current="page" class="paganation-module--pageNumber--RUHS6 paganation-module--current--39YZ4" href="/blog/4">4</a><a aria-current="page" class="paganation-module--hide--wBlxP" href="/blog/4">Next »</a></div></div></div></div></div><div id="gatsby-announcer" style="position:absolute;top:0;width:1px;height:1px;padding:0;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border:0" aria-live="assertive" aria-atomic="true"></div></div><script id="gatsby-script-loader">/*<![CDATA[*/window.pagePath="/blog/4";/*]]>*/</script><script id="gatsby-chunk-mapping">/*<![CDATA[*/window.___chunkMapping={"polyfill":["/polyfill-86eae43148bf2d393162.js"],"app":["/app-03a564126170dae91f0b.js"],"component---src-pages-404-js":["/component---src-pages-404-js-52d225bf1fd405f33e03.js"],"component---src-pages-all-file-js":["/component---src-pages-all-file-js-8a4e9b634903be2f7e84.js"],"component---src-pages-index-js":["/component---src-pages-index-js-2ae84adc87fbf451f4b1.js"],"component---src-templates-blog-small-jsx":["/component---src-templates-blog-small-jsx-7847ba26c250224f083e.js"],"component---src-templates-category-jsx":["/component---src-templates-category-jsx-59463967dee71859a4f9.js"],"component---src-templates-index-jsx":["/component---src-templates-index-jsx-1afb50278c9b0fcb6759.js"],"component---src-templates-tag-jsx":["/component---src-templates-tag-jsx-428646eb6a5d437de98d.js"]};/*]]>*/</script><script src="/polyfill-86eae43148bf2d393162.js" nomodule=""></script><script src="/webpack-runtime-c691ad7dc71c44256655.js" async=""></script><script src="/app-03a564126170dae91f0b.js" async=""></script><script src="/framework-31fa3cffff5950ebff26.js" async=""></script><script src="/83d6cd58f512da6a6ea6dd96bfbf09511419d80b-744605ee7713f03b785c.js" async=""></script><script src="/component---src-templates-index-jsx-1afb50278c9b0fcb6759.js" async=""></script><script src="/styles-89fd2ae28bdf06750a71.js" async=""></script></body></html>