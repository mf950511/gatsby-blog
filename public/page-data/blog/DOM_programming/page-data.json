{"componentChunkName":"component---src-templates-blog-small-jsx","path":"/blog/DOM_programming/","result":{"data":{"markdownRemark":{"html":"<h1>DOM编程</h1>\n<ul>\n<li>下面是我们常见的DOM编程方法</li>\n<li>动态插入script标签</li>\n</ul>\n<pre><code class=\"language-js\">function loadScript(code){\n  var script = document.createElement('script')\n  try {\n    // 旧版本IE中有问题，IE对script做了特殊处理，不允许常规DOM访问子节点，所以可以在\n    script.appendChild(document.createTextNode(code))\n  } catch () {\n    script.text = code\n  }\n  document.body.appendChild(script)\n}\nloadScript('function sayHi(){alert(\"hi\")}')\n</code></pre>\n<ul>\n<li>这种方法会在返回后立即生效，通过innerHTML创建的 script 元素不会执行，会创建但不会执行</li>\n<li>\n<p>动态插入CSS样式</p>\n<!--more-->\n<pre><code class=\"language-js\">// 所有主流浏览器都支持\nfunction loadStyles(url) {\nlet link = document.createElement('link')\nlink.rel = 'stylesheet'\nlink.type = 'text/css'\nlink.href = url\nlet head = document.getElementsByTagName('head')[0]\nhead.appendChild(link)\n}\n</code></pre>\n</li>\n</ul>\n<p>// 插入动态语句\nfunction loadStyleString(css) {\nlet style = document.createElement('style')\nstyle.type = 'text/css'\ntry{\nstyle.appendChild(document.createTextNode(css))\n} catch() {\nstyle.styleSheet.cssText = css\n}\nlet head = document.getElementsByTagName('head')[0]\nhead.appendChild(style)\n}</p>\n<p>loadStyleString(\"body{background:#fff}\")</p>\n<pre><code>- 这样添加也会立即生效，在IE中要注意使用styleSheet.cssText，如果重用同一个 style 元素并设置该属性超一次，会导致浏览器奔溃，设置cssText为空也会导致奔溃\n\n## 操作表格\n\n- 下面是按常规DOM形式创建的表格\n\n```js\n// 创建表格\nlet table = document.createElement('table')\ntable.border = 1\ntable.width = '100%'\n// 创建表体\nlet tbody = document.createElement('tbody')\ntable.appendChild(tbody)\n\n// 创建行\nlet row1 = document.createElement('tr')\ntbody.appendChild(row1)\nlet cell_1 = document.createElement('td')\ncell_1.appendChild(document.createTextNode('Cell_1'))\nrow1.appendChild(cell_1)\n\nlet cell_2 = document.createElement('td')\ncell_2.appendChild(document.createTextNode('Cell_2'))\nrow1.appendChild(cell_2)\n\ndocument.body.appendChild(table)\n</code></pre>\n<ul>\n<li>上面创建的形式太过繁琐，所以新增了以下属性</li>\n<li>\n<p>table新增的属性</p>\n<ul>\n<li>caption，指向<caption>元素的指针</li>\n<li>tBodies，包含<tbody>的HTMLCollection</li>\n<li>tFoot，指向<tfoot>元素</li>\n<li>tHead，指向<thead>元素</li>\n<li>rows：包含所有行的HTMLCollection</li>\n<li>createTHead()：创建<thead>标签，插入表格，返回引用</li>\n<li>createTFoot()：创建<tfoot>元素，插入表格，返回引用</li>\n<li>createCaption()：创建<caption>元素，插入表格，返回引用</li>\n<li>deleteTHead()：删除<thead>元素</li>\n<li>deleteTFoot()：删除<tfoot>元素</li>\n<li>deleteCaption()：删除<caption>元素</li>\n<li>deleteRow(pos): 删除给定的行</li>\n<li>insertRow(pos)，在给定位置插入一行</li>\n</ul>\n</li>\n<li>\n<p>tbody元素添加以下方法</p>\n<ul>\n<li>rows，包含<tbody>中所有行的HTMLCollection</li>\n<li>deleteRow(pos)，删除指定位置行</li>\n<li>insertRow(pos)，指定位置插入一行，返回改行的引用</li>\n</ul>\n</li>\n<li>\n<p>tr元素新增以下属性和方法</p>\n<ul>\n<li>cells，包含<tr>元素所有表元的HTMLCollection</li>\n<li>deleteCell(pos)，删除指定位置表元</li>\n<li>insertCell(pos)，指定位置插入表元返回引用</li>\n</ul>\n</li>\n<li>重写上面代码</li>\n</ul>\n<pre><code class=\"language-js\">let table = document.createElement('table')\ntable.border = 1\ntable.width = '100%'\n// 创建表体\nlet tbody = document.createElement('tbody')\ntable.appendChild(tbody)\n\ntbody.insertRow(0)\ntbody.rows[0].insertCell(0)\ntbody.rows[0].cells[0].appendChild(document.createTextNode('Cell_1'))\ntbody.rows[0].insertCell(1)\ntbody.rows[0].cells[1].appendChild(document.createTextNode('Cell_2'))\n</code></pre>\n<ul>\n<li>NodeList、NamedNodeMap、HTMLCollection三个集合类型都是实时的，文档结构变化会实时反应，所以下面代码会死循环</li>\n</ul>\n<pre><code class=\"language-js\">let divs = document.getElementsByTagName('div')\nfor(let i = 0 ; i &#x3C; divs.length; i++) {\n  let div = document.createElement('div')\n  document.body.appendChild(div)\n}\n</code></pre>\n<h2>MutationObserver接口</h2>\n<ul>\n<li>DOM规范中的MutationObserver接口可以在DOM被修改时异步执行回调，使用它能够观察整个文档、DOM树的一部分，或某个元素。还能观察元素属性、子节点、文本或者它们的任意组合</li>\n<li>MutationObserver是为了替代废弃的MutationEvent</li>\n<li>基本用法如下</li>\n</ul>\n<pre><code class=\"language-js\">let observer = new MutationObserver(() => {\n  console.log('&#x3C;body> attributes changed')\n})\n\nobserver.observe(document.body, { attributes: true })\ndocument.body.className = 'foo'\nconsole.log('Changed body')\n\n// Changed body\n// &#x3C;body> attributes changed\n</code></pre>\n<ul>\n<li>创建后使用observer()方法关联DOM对象，接收两个参数为：要观察变化的DOM节点，以及一个MutationObserverInit对象</li>\n<li>MutationObserverInit对象用于控制观察哪些方面的变化，是一个键/值形式配置选项的字典。上述代码就是观察body上attributes的变化</li>\n<li>从上面能看出来，观察的回调执行在后面，所以是一个异步函数</li>\n<li>每个回调都会收到一个MutationRecord实例的数组，实例包含的信息包括发生了什么变化，以及DOM的哪一部分受影响了。回调执行之前可能同时发生多个满足条件的事件，所以每次执行回调都会传入一个包含按顺序入队的MutationRecord实例的数组</li>\n</ul>\n<pre><code class=\"language-js\">let observer = new MutationObserver((mutationRecord) => { console.log(mutationRecord) })\nobserver.observe(document.body, { attributes:true })\ndocument.body.setAttribute('foo', 'bar')\n// [\n//   {\n//     addedNodes: NodeList []\n//     attributeName: \"foo\"\n//     attributeNamespace: null\n//     nextSibling: null\n//     oldValue: null\n//     previousSibling: null\n//     removedNodes: NodeList []\n//     target: body.page-v3.eye-protector-processed\n//     type: \"attributes\"\n//   }\n// ]\ndocument.body.setAttributeNS('baz', 'foo', 'bar')\n// [\n//   {\n//     addedNodes: NodeList []\n//     attributeName: \"foo\"\n//     attributeNamespace: \"baz\"\n//     nextSibling: null\n//     oldValue: null\n//     previousSibling: null\n//     removedNodes: NodeList []\n//     target: body.page-v3.eye-protector-processed\n//     type: \"attributes\"\n//   }\n// ]\n</code></pre>\n<ul>\n<li>连续修改会生成多个MutationRecord实例，下次回调就会收到所有包含这些实例的数组，顺序为变化事件发生的顺序</li>\n</ul>\n<pre><code class=\"language-js\">let observer = new MutationObserver((mutationRecords) => { console.log(mutationRecords) })\nobserver.observe(document.body, { attributes:true })\ndocument.body.className = 'foo'\ndocument.body.className = 'bar'\ndocument.body.className = 'baz'\n// [MutationRecord, MutationRecord, MutationRecord]\n</code></pre>\n<ul>\n<li>\n<p>下面是MutationRecord实例的属性</p>\n<ul>\n<li>target: 被修改影响的目标节点</li>\n<li>type: 字符串，表示变化的类型：\"attributes\"、\"characterData\"、\"childList\"</li>\n<li>oldValue: 如果在MutationObserverInit中启用（attributeOldValue或characterData oldValue为true）\"attributes\"或\"characterData\"的事件变化会设置这个属性为被替代的值，\"childList\"类型的变化始终将这个属性设置为null</li>\n<li>attributeName: 对于\"attributes\"类型的变化，这里保存被修改属性的名字，其他变化事件为null</li>\n<li>attributeNameSpace: 对于使用命名空间的\"attributes\"类型变化，这里保存被修改属性的名字，其他事件为null</li>\n<li>addedNodes: 对于\"childList\"类型的变化，返回包含变化中添加节点的NodeList，默认为空NodeList</li>\n<li>removeNodes: 对于\"childList\"类型的变化，返回包含变化中删除节点的NodeList，默认为空NodeList</li>\n<li>previousSibling: 对于\"childList\"类型的变化，返回变化节点的前一个同胞Node，默认为null</li>\n<li>nextSibling: 对于\"childList\"类型的变化，返回变化后节点的后一个同胞Node，默认为null</li>\n</ul>\n</li>\n<li>传给回调的第二个参数是观察变化的MutationObserver的实例</li>\n</ul>\n<pre><code class=\"language-js\">let observer = new MutationObserver((mutationRecords, mutationObserver) => { console.log(mutationRecords, mutationObserver) })\nobserver.observe(document.body, { attributes:true })\ndocument.body.className = 'foo'\n//[MutationRecord] MutationObserver {}\n</code></pre>\n<ul>\n<li>disconnect()方法：默认情况下，只要被观察的元素不被垃圾回收，MutationObserver回调就会响应DOM变化，从而被执行。要提前终止执行回调，调用disconnect()方法。</li>\n</ul>\n<pre><code class=\"language-js\">let observer = new MutationObserver((mutationRecords, mutationObserver) => { console.log(mutationRecords, mutationObserver) })\nobserver.observe(document.body, { attributes:true })\ndocument.body.className = 'foo'\nobserver.disconnect()\ndocument.body.className = 'bar'\n// 没有输出日志\n</code></pre>\n<ul>\n<li>上面可以看出，当调用了disconnect之后，不仅之后变化事件的回调不会执行，已经加入到任务队列的事件也不会执行</li>\n<li>所以想要被加入的事件可以被执行，在调用disconnect方法的时候加一个setTimeout(() => {}, 0)</li>\n<li>多次调用observer()方法，可以复用一个MutationObserver对象观察多个不同的目标节点。</li>\n</ul>\n<pre><code class=\"language-js\">let observer = new MutationObserver((mutationRecords) => console.log(mutationRecords.map(x => x.target)))\n\nlet childA = document.createElement('div'), childB = document.createElement('span')\ndocument.body.appendChild(childA)\ndocument.body.appendChild(childB)\n\n// 观察两个元素\nobserver.observe(childA, { attributes: true })\nobserver.observe(childB, { attributes: true })\n\n// 修改子节点属性\nchildA.setAttribute('foo', 'bar')\nchildB.setAttribute('foo', 'bar')\n\n// [div, span]\n\nobserver.disconnect()\nchildA.setAttribute('a', 'b')\nchildB.setAttribute('a', 'b')\n// 没有日志\n</code></pre>\n<ul>\n<li>disconnect()方法是一刀切的方案，会停止观察所有目标</li>\n<li>调用disconnect只是断开连接，没有结束MutationObserver的声明，可以重新用这个观察者关联新的目标节点</li>\n</ul>\n<pre><code class=\"language-js\">let observer = new MutationObserver((mutationRecords) => console.log('&#x3C;body> attributes changed'))\nobserver.observe(document.body, { attributes: true })\ndocument.body.setAttribute('foo', 'bar')\nsetTimeout(() => {\n  observer.disconnect()\n  document.body.setAttribute('baz', 'baz')\n}, 0)\nsetTimeout(() => {\n  observer.observe(document.body, { attributes: true })\n  document.body.setAttribute('qux', 'qux')\n}, 0)\n// &#x3C;body> attributes changed\n// &#x3C;body> attributes changed\n</code></pre>\n<ul>\n<li>\n<p>MutationObserverInit用于控制目标节点的观察范围。可观察的值如下</p>\n<ul>\n<li>subtree: 布尔值，表示除了目标对象，是否观察目标节点的子节点，为true表示观察节点及子节点</li>\n<li>attributes: 布尔值，表示是否观察目标节点的属性变化</li>\n<li>attributeFilter: 字符串数组，表示要观察哪些属性的变化，这个值设为true会将attributes也转换为true，默认观察所有属性</li>\n<li>attributeOldValue: 布尔值，表示MutaionRecord是否记录变化之前的属性值，将这个值设为true也会导致attributes转换为true，默认为false</li>\n<li>characterData: 布尔值，表示修改字符数据是否触发变化事件，默认false</li>\n<li>characterDataOldValue: 布尔值，表示MutationRecord是否记录变化之前的字符数据，这个值设为true会将characterData值也转为true，默认false</li>\n<li>childList: 布尔值，表示修改目标节点的子节点是否触发变化事件，默认false</li>\n</ul>\n</li>\n<li>调用observe()时，MutationObserverInit对象中的attribute、characterData、childList必须至少有一项为true（直接设置或者通过设置attributeOldValue等设置）。否则会报错</li>\n<li>MutationObserver可以观察节点属性的添加、移除、修改。为属性注册回调，需要在MutationObserverInit对象中将attributes设为true</li>\n</ul>\n<pre><code class=\"language-js\">let observer = new MutationObserver((mutationRecords) => console.log(mutationRecords))\nobserver.observe(document.body, { attributeFilter: ['foo'] })\ndocument.body.setAttribute('foo', 'bar')\ndocument.body.setAttribute('bar', 'baz')\ndocument.body.setAttribute('baz', 'qux')\n\n// 只记录了foo的属性变化\n// [MutationRecord]\n</code></pre>\n<ul>\n<li>要想在记录中保存属性原来的值，将attributeOldValue属性设为true</li>\n</ul>\n<pre><code class=\"language-js\">let observer = new MutationObserver((mutationRecords) => console.log(mutationRecords.map(x => x.oldValue)))\nobserver.observe(document.body, { attributeOldValue: true })\ndocument.body.setAttribute('foo', 'bar')\ndocument.body.setAttribute('foo', 'baz')\ndocument.body.setAttribute('foo', 'qux')\n\n// [null, \"bar\", \"baz\"]\n</code></pre>\n<ul>\n<li>MutationObserver可以观察文本节点（Text、Comment、ProcessingInstruction）中字符串的添加、删除、修改。需要为字符数据注册回调，然后将MutatioObserverInit对象中的characterData属性设置为true</li>\n</ul>\n<pre><code class=\"language-js\">let observer = new MutationObserver((mutationRecord) => console.log(mutationRecord))\ndocument.body.innerText = 'foo'\nobserver.observe(document.body.firstChild, { characterData: true })\n\ndocument.body.innerText = 'foo'\ndocument.body.innerText = 'bar'\ndocument.body.innerText = 'baz'\n\n// [MutationRecord, MutationRecord, MutationRecord]\n</code></pre>\n<ul>\n<li>想要在MutationRecord中保村原始数据可以设置characterDataOldValue为true</li>\n<li>MutationObserver观察子节点</li>\n</ul>\n<pre><code class=\"language-js\">let observer = new MutationObserver((mutationRecord) => console.log(mutationRecord))\ndocument.body.innerText = ''\nobserver.observe(document.body, { childList: true })\ndocument.body.appendChild(document.createElement('div'))\n// [\n//   {\n//     addedNodes: NodeList [div]\n//     attributeName: null\n//     attributeNamespace: null\n//     nextSibling: null\n//     oldValue: null\n//     previousSibling: null\n//     removedNodes: NodeList []\n//     target: body.page-v3.eye-protector-processed\n//     type: \"childList\"\n//   }\n// ]\n\nlet observer = new MutationObserver((mutationRecord) => console.log(mutationRecord))\ndocument.body.innerText = ''\ndocument.body.appendChild(document.createElement('span'))\ndocument.body.appendChild(document.createElement('div'))\nobserver.observe(document.body, { childList: true })\ndocument.body.insertBefore(document.body.lastChild, document.body.firstChild)\n\n//[MutationRecord, MutationRecord]\n</code></pre>\n<ul>\n<li>上面进行子节点的交换会发生两次变化，一次是节点被删除，一次是节点被添加</li>\n<li>将MutationObserverInit对象中的subtree设置为true就能观察节点及其所有子节点</li>\n</ul>\n<pre><code class=\"language-js\">let observer = new MutationObserver((mutationRecord) => console.log(mutationRecord))\ndocument.body.innerText = ''\ndocument.body.appendChild(document.createElement('div'))\nobserver.observe(document.body, { attributes: true, subtree: true })\ndocument.body.firstChild.setAttribute('foo', 'bar')\n// [MutationRecord]\n</code></pre>\n<ul>\n<li>这里要注意，被观察子树中的节点在被移出子树后仍然能够触发变化事件。</li>\n<li>MutationObserver接口出于性能考虑，核心是异步回调与记录队列模型。为了在大量变化事件发生时不影响性能，每次变化的信息会保存在MutationRecord实例中，然后添加到记录队列，这个队列对每个MutationObserver实例都是唯一的，是所有DOM变化事件的有序列表</li>\n<li>每次MutationRecord被添加到MutationObserver记录队列时，只有之前没有已排期的微任务回调时，才会将观察者注册的回调作为作为微任务加到任务队列上，这样能保证记录队列的内容不会被回调处理两次</li>\n<li>在回调的微任务异步执行时，可能发生更多变化事件。因此被调用的回调会接收到一个MutationRecord实例的数组，顺序为它们进入记录队列的顺序。回调负责处理这个数组的没一个实例，函数退出之后这些实现就不存在了，回调执行后，这些MutationRecord就用不到了，记录队列会被清空，内容会被丢弃</li>\n<li>调用MutationObserver的takeRecords()方法可以清空记录队列，取出并返回所有的MutationRecord实例</li>\n</ul>\n<pre><code class=\"language-js\">let observer = new MutationObserver((mutationRecord) => console.log(mutationRecord))\nobserver.observe(document.body, { attributes: true })\ndocument.body.className = 'foo'\ndocument.body.className = 'bar'\ndocument.body.className = 'baz'\nconsole.log(observer.takeRecords()) // [MutationRecord, MutationRecord, MutationRecord]\nconsole.log(observer.takeRecords()) // []\n</code></pre>\n<ul>\n<li>在希望断开与观察目标的联系，但是希望处理由于disconnect而被抛弃的记录队列中的MutationRecord时比较有用</li>\n</ul>\n<h2>性能、垃圾回收</h2>\n<ul>\n<li>DOM Level 2中的MutationEvent定义了会在各种DOM变化时触发的事件。由于浏览器的实现机制，接口有严重的性能问题，因此DOM3废弃了这些事件</li>\n<li>使用MutationObserver将变化回调委托给微任务避免事件同步触发，记录队列可以保证变化事件爆发式的触发时，也不会显著拖慢浏览器，但无论如何，使用MutationObserver都是有代价的</li>\n<li>MutationObserver实例与目标节点是非对称引用，MutationObserver对目标节点是弱引用，所以不会妨碍垃圾回收程序回收节点</li>\n<li>目标节点对MutationObserver是强引用，如果目标节点从DOM被移除，随后垃圾回收，那关联的MutationObserver实例也被回收</li>\n<li>MutationRecord实例至少包含对已有DOM节点的一个引用。如果变化是childList类型，会包含多个节点的引用。记录队列和回调处理的默认行为是耗尽这个队列，处理每个MutationRecord，然后让它们超出作用域，之后被垃圾回收</li>\n<li>记录某个观察者的完整变化记录（MutationRecord）时就会保存它们引用的节点，从而妨碍这些节点的回收。如果需要尽快释放内存，建议从每个MutationRecord中抽取有用的信心保存到新对象，然后抛弃MutationRecord</li>\n</ul>","frontmatter":{"title":"DOM编程--高程4","date":"2020-12-28","tags":["JavaScript回顾"],"categories":"JavaScript"},"fields":{"slug":"/DOM_programming/"}}},"pageContext":{"slug":"/DOM_programming/"}},"staticQueryHashes":["2566592090"]}