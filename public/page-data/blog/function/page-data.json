{"componentChunkName":"component---src-templates-blog-small-jsx","path":"/blog/function/","result":{"data":{"markdownRemark":{"html":"<h1>函数</h1>\n<ul>\n<li>函数实际上是对象，每个函数都是Function类型的实例</li>\n<li>函数通常以函数声明的方式定义</li>\n</ul>\n<pre><code class=\"language-js\">function sum(num1, num2) {\n  return num1 + num2\n}\n</code></pre>\n<ul>\n<li>\n<p>还能以函数表达式来定义</p>\n<!--more-->\n<pre><code class=\"language-js\">let sum = function (num1, num2) {\nreturn num1 + num2\n}\n</code></pre>\n</li>\n<li>箭头函数定义</li>\n</ul>\n<pre><code class=\"language-js\">let sum = (num1, num2) => {\n  return num1 + num2\n}\n</code></pre>\n<ul>\n<li>最后一种以Function构造函数定义函数。此构造函数接收任意个字符串参数，最后一个参数会被当做函数体，前面的参数都是新函数的参数</li>\n<li>此方法不推荐，因为这样会解释两次，第一次是将它当做常规的ECMAScript代码，第二次会解释传给构造函数的字符串</li>\n</ul>\n<pre><code class=\"language-js\">let sum = new Function('num1', 'num2', 'return num1 + num2')\n</code></pre>\n<ul>\n<li>ECMAScript 6的所有函数对象会暴露一个只读的<code>name</code>属性，包含函数的信息。一般情况下保存的就是一个字符串化的变量名</li>\n<li>及时函数没有名称也会变成空字符串，如果是用<code>Function</code>创建的，就会标识成<code>\"anonymous\"</code></li>\n<li>如果函数是一个获取函数、设置函数或者使用bind实例化，name会加上一个前缀</li>\n</ul>\n<pre><code class=\"language-js\">function foo(){}\nlet bar = function(){}\nlet baz = () => {}\n\nconsole.log(foo.name) // foo\nconsole.log(bar.name) // bar\nconsole.log(baz.name) // baz\nconsole.log((() => {}).name) // ''\nconsole.log((new Function()).name) // anonymous\n\n\nlet dog = {\n  years: 1,\n  get age(){\n    return this.year\n  },\n  set age(newVal){\n    this.years = newVal\n  }\n}\nlet propertyDescriptor = Object.getOwnPropertyDescriptor(dog, 'age')\nconsole.log(foo.bind(null).name) // bound foo\nconsole.log(propertyDescriptor.get.name) // get age\nconsole.log(propertyDescriptor.set.name) // set age\n</code></pre>\n<ul>\n<li>函数默认值定义时，参数是按照顺序初始化的，所以后定义的默认值参数可以引用前面定义的参数</li>\n</ul>\n<pre><code class=\"language-js\">function makeKing(name = 'Henry', numerals = name) {\n  return `King ${name} ${numerals}`\n}\nconsole.log(makeKing()) // King Henry Henry\n</code></pre>\n<ul>\n<li>参数初始化顺序遵循“暂时性死区”规则，前面定义的参数，不能引用后面定义的参数，如下就会报错</li>\n</ul>\n<pre><code class=\"language-js\">function makeKing(name = numerals, numerals = 'Henry') {\n  return `King ${name} ${numerals}`\n}\nconsole.log(makeKing()) // Uncaught ReferenceError: Cannot access 'numerals' before initialization\n</code></pre>\n<h2>箭头函数</h2>\n<ul>\n<li>可以使用函数表达式的地方都可以使用箭头函数</li>\n<li>箭头函数不能使用arguments、super和new.target，也不能用作构造函数，并且没有prototype</li>\n</ul>\n<h2>arguments</h2>\n<ul>\n<li>arguments是一个类数组对象，包含函数调用传入的全部参数，这个函数只有一function关键字定义函数时才有 （箭头函数就没有）</li>\n<li>arguments有一个callee属性，始终指向arguments对象所在的函数的指针</li>\n</ul>\n<pre><code class=\"language-js\">function factorial(num){\n  if(num &#x3C;=1) {\n    return 1\n  } else {\n    return num * factorial(num - 1)\n  }\n}\n\nlet trueFactorial = factorial\nfactorial = function(){\n  return 0\n}\ntrueFactorial(5) // 0\nfactorial(5) // 0\n</code></pre>\n<ul>\n<li>这是一个经典的阶乘函数，上面函数要保证正确执行就得保证函数名一定是factorial，一旦我们将函数赋给别的值，就能发现出现问题了，这就导致了紧密耦合，可以使用arguments.callee解耦</li>\n</ul>\n<pre><code class=\"language-js\">function factorial(num){\n  if(num &#x3C;=1) {\n    return 1\n  } else {\n    return num * arguments.callee(num - 1)\n  }\n}\n\n\nlet trueFactorial = factorial\ntrueFactorial(5) // 120\nfactorial = function(){\n  return 0\n}\nfactorial(5) // 0\n</code></pre>\n<ul>\n<li>这样就实现了解耦，修改factorial的引用不会影响递归函数</li>\n<li>arguments对象始终会与对应的命名参数同步</li>\n</ul>\n<pre><code class=\"language-js\">function doAdd(num1, num2) {\n  arguments[1] = 10\n  console.log(arguments[0] + num2)\n}\ndoAdd(10, 30) // 20\n</code></pre>\n<ul>\n<li>这里doAdd函数会把第二个参数的值重写为10。因为arguments对象的值会自动同步到对应的命名参数，所以修改arguments[1]也就是修改了num2</li>\n<li>并不意味着arguments[1]跟num2是同一个内存地址，内存是分开的，但是会同步</li>\n<li>如果只传了一个参数，然后把arguments[1]改为某个值，那这个值并不会反映到第二个命名参数，因为arguments对象的长度是根据传入的参数个数确定，而非定义函数时给出的命名参数确定的</li>\n<li>严格模式下，arguments[1]修改后不再影响num2的值，其次，在函数内重写arguments对象会导致语法错误</li>\n</ul>\n<h2>this</h2>\n<ul>\n<li>this在标准函数与箭头函数中行为不一致</li>\n<li>标准函数中，this引用的是把函数当成方法调用的上下文对象，这时候称其为this值（网页全局调用时，this指向window）</li>\n</ul>\n<pre><code class=\"language-js\">window.color = 'red'\nlet o = {\n  color: 'blue'\n}\nfunction sayColor(){\n  console.log(this.color)\n}\nsayColor() // 'red'\no.sayColor = sayColor\no.sayColor() // 'blue'\n</code></pre>\n<ul>\n<li>定义在全局上下文的sayColor引用了this对象。这个this是那个对象要到函数调用时才能知道。</li>\n<li>全局调sayColor输出red因为this指向window，this.color相当于window.color。</li>\n<li>把sayColor赋值给o再调用，this指向了o，this.color相当于o.color，所以显示\"blue\"</li>\n<li>箭头函数中的this引用的是定义箭头函数的上下文</li>\n</ul>\n<pre><code class=\"language-js\">window.color = 'red'\nlet o = {\n  color: 'blue'\n}\nlet sayColor = () => console.log(this.color)\nsayColor() // 'red'\no.sayColor = sayColor\no.sayColor() // 'red'\n</code></pre>\n<ul>\n<li>所以当我们在事件回调或者定时回调中调用某个函数时，this指向并非我们想要的对象时，我们就可以把函数改为箭头函数即可，因为箭头函数中的this会保留定义该函数的上下文</li>\n</ul>\n<pre><code class=\"language-js\">function King(){\n  this.royaltyName = 'Henry'\n  setTimeout(() => {\n    console.log(this.royaltyName)\n  }, 1000)\n}\n\nfunction Queen(){\n  this.royaltyName = 'Elizabeth'\n  setTimeout(function (){\n    console.log(this.royaltyName)\n  }, 1000)\n}\nnew King() // Henry\nnew Queen() // undefined\n</code></pre>\n<h2>caller</h2>\n<ul>\n<li>ECMAScript 5会给函数对象加一个属性： caller，这个属性引用调用当前函数的函数，如果在全局作用域中调用则为null</li>\n</ul>\n<pre><code class=\"language-js\">function outer(){\n  inner()\n}\nfunction inner(){\n  console.log(inner.caller)\n}\nouter()  // ƒ outer(){\n  inner()\n}\n\n// 降低耦合度的写法\nfunction inner(){\n  console.log(arguments.callee.caller)\n}\n</code></pre>\n<ul>\n<li>严格模式下访问arguments.callee会报错，访问arguments.caller也会报错，非严格模式下访问arguments.caller是undefined，这样是为了分清arguments.caller和函数的caller而做的</li>\n<li>严格模式下不可给caller赋值，否则会报错</li>\n</ul>\n<h2>new.target</h2>\n<ul>\n<li>函数始终可以作为构造函数实例化一个对象，ECMAScript新增了 new.target 检测函数是否使用new关键字调用。函数是正常调用，那new.target就是undefined，如果是new调用，那new.target将引用被调用的构造函数</li>\n</ul>\n<pre><code class=\"language-js\">function King(){\n  if(!new.target) {\n    throw 'King must be instantiated using \"new\"'\n  }\n  console.log('King instantiated using \"new\"')\n}\nnew King() // King instantiated using \"new\"\nKing() // Uncaught King must be instantiated using \"new\"\n</code></pre>","frontmatter":{"title":"函数--高程4","date":"2020-12-10","tags":["JavaScript回顾"],"categories":"JavaScript"},"fields":{"slug":"/function/"}}},"pageContext":{"slug":"/function/"}},"staticQueryHashes":["2566592090"]}