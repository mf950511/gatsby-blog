{"componentChunkName":"component---src-templates-blog-small-jsx","path":"/blog/jQuery/","result":{"data":{"markdownRemark":{"html":"<h1>jQuery选择器的简单实现</h1>\n<ul>\n<li>jQuery是前几年前端开发中的老大哥了，而我们最喜欢的也是他提供的选择器跟链式调用的方法了，最近在看了原型与原型链之后也是有点简单的想法，想尝试着实现以下jquery的选择器</li>\n<li>首先需要构建一个函数A可以接受一个id名，返回一个新的对象，而且对象具有jquery提供的一系列方法，所以我们可以构造一个拥有这些方法的B对象并返回</li>\n</ul>\n<pre><code class=\"language-js\">  function A(selector){\n    return B\n  }\n  let B = {\n    length: 3,\n    size: function(){\n      return this.length\n    }\n  }\n</code></pre>\n<!--more-->\n<ul>\n<li>但是单纯的B对象的没办法接收选择器名称，所以我们可以给B添加一个初始化函数init，接收一个选择器名称，并返回最后的对象，因为返回的对象需要拥有B上面的方法，所以我们还是选择将B对象返回，但是我们也需要获取到的dom元素，所以，参照jquery的方法，我们可以将B对象的0属性设置为获取到的dom元素,并且更新B对象的length属性。那如何在函数内返回B对象那？因为init方法是挂载在对象身上的，所以，我们需要返回B对象的时候只需要返回this就可以了</li>\n</ul>\n<pre><code class=\"language-js\">  function A(selector){\n    return B.init(selector)\n  }\n  let B = {\n    init: function(selector){\n      let dom = document.getElementById(selector)\n      this[0] = dom\n      this.length = 1\n      return this\n    },\n    length: 3,\n    size: function(){\n      return this.length\n    }\n  }\n</code></pre>\n<ul>\n<li>这里的话我们需要手动实现一个B对象，过于繁琐，其实我们可以将A函数的fn属性设置为这个对象，这样就省去了显式的创建B对象</li>\n</ul>\n<pre><code class=\"language-js\">  function A(selector){\n    return A.fn.init(selector)\n  }\n  A.fn = {\n    init: function(selector){\n      let dom = document.getElementById(selector)\n      this[0] = dom\n      this.length = 1\n      return this\n    },\n    length: 3,\n    size: function(){\n      return this.length\n    }\n  }\n\n  var a = A('demo') // Object {0: #demo, init: f, length: 1, size: f}\n  var t = A('test') // Object {0: #test, init: f, length: 1, size: f}\n  console.log(a)    // Object {0: #test, init: f, length: 1, size: f}\n</code></pre>\n<ul>\n<li>上面我们能发现，如果直接返回A.fn这个对象的话则所有通过A函数获取到的对象会公用一个对象，包括属性，这样的话就会相互影响，取不到我们想要的dom，所以我们可以在返回前使用new进行修饰，但是new的特性导致返回的对象中的this将不再指向我们的A.fn，也就意味这我们不能使用size()方法，所以我们可以指定A.fn.init的prototype到A.fn从而获取size方法</li>\n</ul>\n<pre><code class=\"language-js\">  function A(selector){\n    return new A.fn.init(selector)\n  }\n  A.fn = {\n    init: function(selector){\n      let dom = document.getElementById(selector)\n      this[0] = dom\n      this.length = 1\n      return this\n    },\n    length: 3,\n    size: function(){\n      return this.length\n    }\n  }\n\n  A.fn.init.prototype = A.fn\n\n  var a = A('demo')         // Object {0: #demo, init: f, length: 1, size: f}\n  var t = A('test')         // Object {0: #test, init: f, length: 1, size: f}\n  console.log(a.size())     // 1\n</code></pre>\n<h2>extend方法实现</h2>\n<ul>\n<li>上面我们就简单的实现了一个id选择器，下面的话我们需要实现一下jQuery拓展插件的方式extend，extend方法其实就是对对象的整合并返回新的对象，所以要根据参数进行拓展，单对象则在当前对象拓展，多对象则融合并返回</li>\n</ul>\n<pre><code class=\"language-js\">  A.extend = A.fn.extend = function(...args){\n    let len = args.length, target\n    if(len === 0) {\n      return\n    }\n    if(len === 1) {\n      target = this\n      for(let key in args[0]) {\n        target[key] = args[0][key]\n      }\n    } else {\n      target = args[0]\n      for(let i = 1; i &#x3C; len; i++) {\n        for(let key in args[i]) {\n          target[key] = args[i][key]\n        }\n      }\n    }\n    return target\n  }\n\n  var a = A('demo')\n  a.extend({b: 3, d: 4})\n  console.log(a) // Object {0: #demo, length: 1, b:3, d: 4}\n\n  A.extend(a, {e: 4})\n\n  console.log(a) // Object {0: #demo, length: 1, b:3, d: 4, e:4}\n</code></pre>\n<ul>\n<li>上面就是拓展插件extend方法的实现，利用这个方法，可以在A函数或者选择之后的对象进行拓展</li>\n</ul>\n<h2>链式调用的实现</h2>\n<ul>\n<li>链式调用就是在每个方法执行完成之后都将当前this放回，这样接下来的方法便都可以拿到这个对象并接着调用，所以我们可以先拓展几个常用的jquery的方法</li>\n<li>on方法的实现，由于各浏览器的兼容性问题，所以我们对事件绑定方式on进行一个简单的实现，还是要用到我们的extend方法，因为选择器返回的对象都可以调用这个方法，所以我们将其拓展到A.fn对象上面</li>\n</ul>\n<pre><code class=\"language-js\">A.fn.extend({\n  // 立即执行函数获取各浏览器下的绑定方式并绑定到on方法上，避免每次调用都要判断浏览器环境\n  on: (function(){\n    if(document.addEventListener) {\n      return function(type, fn){\n        for(let i = 0; i &#x3C; this.length; i++) {\n          this[i].addEventListener(type, fn, false)\n        }\n      }\n    } else if(document.addEvent) {\n      return function(type, fn){\n        for(let i = 0; i &#x3C; this.length; i++) {\n          this[i].addEvent('on'+type, fn)\n        }\n      }\n    } else {\n      return function(type, fn){\n        for(let i = 0; i &#x3C; this.length; i++) {\n          this[i]['on' + type] = fn\n        }\n      }\n    }\n  })()\n})\n\na.on('click', function(){\n  console.log(this.innerHTML) // 1\n})\n</code></pre>\n<ul>\n<li>上面我们对A.fn进行了拓展，使所有选择器返回的对象都可以进行数据绑定，并且可以成功打印1</li>\n<li>接下来我们依次对其进行attr,css,html方法的拓展，在对css方法进行拓展的时候我们先对A进行了拓展，使其拥有可以将-连接的css属性转为驼峰命名的css属性，从而实现我们的赋值</li>\n</ul>\n<pre><code class=\"language-js\">A.extend({\n  // 常用css转驼峰\n  cameName: function(str){\n    return str.replace(/\\-(\\w)/g, function(all, letter){\n      return letter.toUpperCase()\n    })\n  }\n})\n\nA.fn.extend({\n  attr: function(...args){\n    if(args.length &#x3C; 1) {\n      return\n    }\n    if(args.length === 1) {\n      if(typeof args[0] === 'string') {\n        return this[0].getAttribute(args[0])\n      } else {\n        for(let i = 0; i &#x3C; this.length; i++) {\n          for(let key in args[0]) {\n            this[i].setAttribute(key, args[0][key])\n          }\n        }\n      }\n    } else {\n      for(let i = 0; i &#x3C; this.length; i++) {\n        this[i].setAttribute(args[0], args[1])\n      }\n    }\n    return this\n  },\n  html: function(...args){\n    console.log(args)\n    if(args.length) {\n      for(let i = 0; i &#x3C; this.length; i++) {\n        this[i].innerHTML = args[0]\n      }\n      return this\n    } else {\n      return this[0].innerHTML\n    }\n  },\n  css: function(...args){\n    if(args.length &#x3C; 1) {\n      return\n    }\n    if(args.length === 1) {\n      const name = args[0]\n      if(typeof args[0] === 'string') {\n        if(this[0].currentStyle){\n          return this[0].currentStyle[name]\n        } else {\n          return getComputedStyle(this[0], false)[name]\n        }\n      }else if(typeof args[0] === 'object') {\n        for(let i = 0; i &#x3C; this.length; i++) {\n          for(let key in args[0]) {\n            this[i].style[A.cameName(key)] = args[0][key]\n          }\n        }\n      }\n    } else {\n      const name = args[0]\n      for(let i = 0; i &#x3C; this.length; i++) {\n        this[i].style[A.cameName(name)] = args[1]\n      }\n    }\n    return this\n  }\n})\n</code></pre>\n<ul>\n<li>上面我们就实现了jquery常用的几个方法与链式调用，下面我们就可以使用上面的方法进行调用</li>\n</ul>\n<pre><code class=\"language-js\">a.css('background-color', '#0f0').html('我是链式调用').attr('data-tag', 'div').on('click', function(){\n    alert(this.innerHTML)\n})\n</code></pre>","frontmatter":{"title":"jquery选择器的实现","date":"2019-10-31","tags":["JavaScript回顾","设计模式","进修"],"categories":"JavaScript"},"fields":{"slug":"/jQuery/"}}},"pageContext":{"slug":"/jQuery/"}},"staticQueryHashes":["2566592090"]}