{"componentChunkName":"component---src-templates-index-jsx","path":"/blog/6","result":{"data":{"allMarkdownRemark":{"totalCount":62,"edges":[{"node":{"html":"<h1>类</h1>\n<ul>\n<li>ECMAScript 6 引入了class关键字来实现正式定义类的能力</li>\n<li>类定义也是两种方法：声明类与类表达式</li>\n</ul>\n<pre><code class=\"language-js\">// 类声明\nclass Person {}\n\n// 类表达式\nconst Person = class {}\n</code></pre>\n<ul>\n<li>类定义不可变量提升，声明前不可使用</li>\n<li>函数受函数作用域限制，类受块作用域限制</li>\n<li>\n<p>类可以包含构造函数方法、实例方法、获取函数、设置函数与静态类方法</p>\n<!--more-->\n<h2>构造函数</h2>\n</li>\n<li>构造函数非必须，不定义则默认为空</li>\n<li>默认情况下，构造函数会在执行后返回this对象。构造函数返回的对象会被用作实例化对象，如果没有引用新创建的this对象，则对象会被销毁</li>\n<li>如果返回的不是this对象，而是其他对象，那么这个对象不回通过instanceof操作符检测出与类有关联，因为对象的原型指针没有被修改</li>\n</ul>\n<pre><code class=\"language-js\">class Person{\n  constructor(override){\n    this.foo = 'foo'\n    if(override) {\n      return { bar: 'bar' }\n    }\n  }\n}\n\nlet p1 = new Person()\nlet p2 = new Person(true)\nconsole.log(p1) // Person {foo: \"foo\"}\nconsole.log(p1 instanceof Person) // true\n\nconsole.log(p2) // {bar: \"bar\"}\nconsole.log(p2 instanceof Person) // false\n</code></pre>\n<ul>\n<li>类中定义的constructor不会被当做构造函数，对它使用instanceof会返回false</li>\n</ul>\n<pre><code class=\"language-js\">class Person{\n  constructor(){\n    this.foo = 'foo'\n  }\n}\n\nlet p1 = new Person()\nconsole.log(p1 instanceof Person) // true\nconsole.log(p1 instanceof Person.constructor) // false\n</code></pre>\n<ul>\n<li>类也可以立即被实例化</li>\n</ul>\n<pre><code class=\"language-js\">let p = new class Foo{\n  constructor(x){\n    console.log(x)\n  }\n}('foo') // 'foo'\n</code></pre>\n<h2>实例、原型和类成员</h2>\n<ul>\n<li>定义在构造函数内的属性为实例属性，实例独享</li>\n<li>定义在类块中的方法为原型方法，所有实例共享，可以在类块中定义方法，但不能定义属性</li>\n</ul>\n<pre><code class=\"language-js\">class Person {\n  name: 'Jack' // Uncaught SyntaxError: Unexpected token\n}\n</code></pre>\n<ul>\n<li>类上定义静态方法，一般用于执行不特定于市里的操作，不要求存在类的实例，使用static修饰</li>\n</ul>\n<h2>super</h2>\n<ul>\n<li>派生类可以通过super关键字引用他们的原型。只能在派生类中使用，而且仅限于类构造函数、实例方法、静态方法内部。</li>\n<li>构造函数中使用super可以调用父类构造函数（这种情况下super之前不允许出现this）</li>\n<li>ES6给类构造函数与静态方法添加了内部特征[[HomeObject]]，是一个指针，指向定义该方法的对象。只能在javascript引擎内部访问。</li>\n<li>super始终会定义为[[HomeObject]]的原型</li>\n<li>super不可单独使用，要么用它调用构造函数，要么引用静态方法</li>\n</ul>\n<pre><code class=\"language-js\">class Vehicle {\n\n}\nclass Bus extends Vehicle{\n  constructor(){\n    console.log(super)  // SyntaxError: 'super' keyword unexpected here\n  }\n}\n</code></pre>\n<ul>\n<li>调用super会调用父类构造函数，并将返回的实例赋值给this</li>\n<li>如果没有定义类构造函数，实例化派生类时会调用super，并传入所有给派生类的参数</li>\n<li>如果派生类定义了构造函数，那么要么在其中调用super，要么必须在其中返回一个对象</li>\n</ul>\n<h2>抽象基类</h2>\n<ul>\n<li>基类就是可供继承但不可被实例化的类，ECMAScript没有单独实现，但是可以使用new.target来实现，new.target保存了通过new调用的类或者函数。所以可以如下实现</li>\n</ul>\n<pre><code class=\"language-js\">class Vehicle {\n  constructor(){\n    if(new.target === Vehicle) {\n      throw new Error('Vehicle cannot be directly instantiated')\n    }\n  }\n}\nnew Vehicle() // Error: Vehicle cannot be directly instantiated\n</code></pre>\n<h2>类混入</h2>\n<ul>\n<li>将不同类集中到一个类中</li>\n</ul>\n<pre><code class=\"language-js\">class Vehicle {}\nlet FooMixin = (Superclass) => class extends Superclass {\n    foo() {\n      console.log('foo')\n    }\n  }\n\n  let BarMixin = (Superclass) => class extends Superclass {\n    bar() {\n      console.log('bar')\n    }\n  }\n\n  let BazMixin = (Superclass) => class extends Superclass {\n    baz() {\n      console.log('baz')\n    }\n  }\n\n  class Bus extends FooMixin(BarMixin(BazMixin(Vehicle))) {}\n  let b = new Bus()\n  b.foo()  // 'foo'\n  b.bar()  // 'bar'\n  b.baz()  // 'baz'\n</code></pre>\n<ul>\n<li>很多javascript已经放弃混入模式，转为组合模式，也就是著名的“组合胜过继承”</li>\n</ul>","fields":{"slug":"/class2/"},"frontmatter":{"title":"类--高程4","tags":["JavaScript回顾"],"categories":"JavaScript"}}},{"node":{"html":"<h1>JS中的继承-（高程4）</h1>\n<h2>原型链继承</h2>\n<ul>\n<li>基本思想为：每个构造函数都有一个原型对象，原型有一个属性指回构造函数，实例有一个内部指针指向原型。</li>\n<li>如果一个原型是另一个原型的实例，就是说这个原型内部有一个内部指针指向另一个原型，相应的另一个原型也有一个指针指向另一个构造函数。</li>\n<li>\n<p>这样就在原型和实例间构造了原型链</p>\n<!--more-->\n<pre><code class=\"language-js\">function SuperType(){\nthis.property = true\n}\n</code></pre>\n</li>\n</ul>\n<p>SuperType.prototype.getSuperValue = function(){\nconsole.log(333)\nreturn this.property\n}</p>\n<p>function SubType (){\nthis.subproperty = false\n}</p>\n<p>SubType.prototype = new SuperType()</p>\n<p>SubType.prototype.getSubValue = function(){\nreturn this.subproperty\n}</p>\n<p>var instance = new SubType()\nconsole.log(instance.getSuperValue()) // true</p>\n<pre><code>- 这里SubType没有用默认的原型对象，用了SuperType的实例。这样SubType与SuperType就挂上了构，所以instance内部的[[Prototype]]指向了SubType.prototype，而SubType.prototype内部的[[Prototype]]指向了SuperType.prototype。这样就通过原型链查找实现了继承\n- 因为SubType.prototype的constructor属性被重写为指向了SuperType，所以instance.constructor也指向了SuperType\n- isPrototypeOf方法，用于判断一个原型是否在手里的原型链上，每个原型都可以调用，只要在原型链就返回true\n\n```js\nconsole.log(Object.prototype.isPrototypeOf(instance)) // true\n</code></pre>\n<h3>原型继承现存问题</h3>\n<ul>\n<li>原型包含引用值时，会在所有实例共享</li>\n<li>子类型在实例化时无法给父类型的构造函数传参</li>\n</ul>\n<h2>经典继承或对象伪装</h2>\n<ul>\n<li>基本思路：在子类的构造函数中调用父类的构造函数。然后使用call或者apply方法以新创建的对象作为上下文执行构造函数</li>\n</ul>\n<pre><code class=\"language-js\">function SuperType (){\n  this.colors = ['red', 'blue']\n}\nfunction SubType(){\n  // 继承实现\n  SuperType.call(this)\n}\n\nlet instance1 = new SubType()\ninstance1.colors.push('black')\nconsole.log(instance1.colors) // ['red', 'blue', 'black']\nlet instance2 = new SubType()\nconsole.log(instance2.colors) // ['red', 'blue']\n</code></pre>\n<ul>\n<li>盗用构造函数还可以向父类构造函数传递参数</li>\n</ul>\n<pre><code class=\"language-js\">function SuperType (name){\n  this.name = name\n  this.age = 28\n}\nfunction SubType(name){\n  // 继承实现\n  SuperType.call(this, name)\n}\n\nlet instance1 = new SubType('张三')\nconsole.log(instance1.name) // '张三'\nlet instance2 = new SubType('李四')\nconsole.log(instance2.name) // '李四'\n</code></pre>\n<h3>经典继承现存问题</h3>\n<ul>\n<li>必须在构造函数中定义方法，函数无法重用</li>\n<li>子类型无法访问父类原型上的方法，所有类型都只能用构造函数模式</li>\n</ul>\n<h2>组合继承（伪经典继承）</h2>\n<ul>\n<li>将原型链与盗用构造函数结合起来，使用原型链继承原型上的属性和方法，通过盗用构造函数继承实例属性。</li>\n</ul>\n<pre><code class=\"language-js\">function SuperType (name){\n  this.name = name\n  this.colors = ['red', 'blue']\n}\nSuperType.prototype.sayName = function(){\n  return this.name\n}\n\nfunction SubType(name, age){\n  SuperType.call(this, name)\n  this.age = age\n}\nSubType.prototype = new SuperType()\nSubType.prototype.constructor = SubType\nSubType.prototype.sayAge = function(){\n  return this.age\n}\n\nlet instance1 = new SubType('张三', 27)\ninstance1.colors.push('black')\ninstance1.sayName() // '张三'\nconsole.log(instance1.colors) // ['red', 'blue', 'black']\ninstance1.sayAge() // 27\n\n\n\nlet instance2 = new SubType('李四', 28)\ninstance2.sayName() // '李四'\nconsole.log(instance2.colors) // ['red', 'blue']\ninstance2.sayAge() // 28\n</code></pre>\n<ul>\n<li>组合继承弥补了原型继承与盗用构造函数的不足，是javascript中使用最多的继承，而且也保留了instanceof与isPrototypeOf的识别能力</li>\n</ul>\n<h3>组合式继承问题</h3>\n<ul>\n<li>组合继承存在效率问题，主要问题便是父元素构造函数会被调用两次，一次是创建子类型时调用，另一次是子类构造函数中使用。</li>\n</ul>\n<h2>原型式继承</h2>\n<ul>\n<li>原型式继承是不自定义类型也能通过原型实现对象之间的信息共享，原理就一个函数</li>\n</ul>\n<pre><code class=\"language-js\">function object(o) {\n  function F(){}\n  F.prototype = o\n  return new F()\n}\n</code></pre>\n<ul>\n<li>创建一个临时的构造函数，原型指向传入的对象，然后再返回这个临时类型的实例</li>\n</ul>\n<pre><code class=\"language-js\">function object(o) {\n  function F(){}\n  F.prototype = o\n  return new F()\n}\nlet person = {\n  name: 'Nick',\n  friends: ['Shel', 'Court']\n}\n\nlet anotherPerson = object(person)\nanotherPerson.name = 'Greg'\nanotherPerson.friends.push('Rob')\n\nlet yetAnotherPerson = object(person)\nyetAnotherPerson.name = 'Linda'\nyetAnotherPerson.friends.push('Barieb')\n\nconsole.log(person.friends) // [\"Shel\", \"Court\", \"Rob\", \"Barieb\"]\n</code></pre>\n<ul>\n<li>这里的原型式继承适用于：你有一个对象，在现有基础上创建一个新对象。</li>\n<li>ECMAScript 5 增加了Object.create()来将原型式继承规范化了。接收两个参数：作为新对象原型的对象，给新对象定义额外属性的对象。</li>\n</ul>\n<pre><code class=\"language-js\">let person = {\n  name: 'Nick',\n  friends: ['Shel', 'Court']\n}\n\nlet anotherPerson = Object.create(person)\nanotherPerson.name = 'Greg'\nanotherPerson.friends.push('Rob')\n\nlet yetAnotherPerson = Object.create(person)\nyetAnotherPerson.name = 'Linda'\nyetAnotherPerson.friends.push('Barieb')\n\nconsole.log(person.friends) // [\"Shel\", \"Court\", \"Rob\", \"Barieb\"]\n\nlet morePerson = Object.create(person, { name: { value: 'Francis' } })\nmorePerson.name // Francis\n</code></pre>\n<ul>\n<li>这里Object.create方法第二个参数跟Object.defineProperties方法第二个参数一样，都需要通过各自的描述符来描述。</li>\n</ul>\n<h2>寄生式继承</h2>\n<ul>\n<li>寄生式继承的原理：创建一个实现继承的函数，以某种方式增强对象，然后返回对象</li>\n</ul>\n<pre><code class=\"language-js\">function object(o){\n  function F(){}\n  F.prototype = o\n  return new F()\n}\n\nfunction createAnother(original) {\n  let clone = object(original)\n  clone.sayHi = function(){\n    console.log('Hi')\n  }\n  return clone\n}\n\n\nlet person = {\n  name: 'Nick',\n  friends: ['Shel', 'Court']\n}\nlet another = createAnother(person)\nanother.sayHi() // 'Hi'\n</code></pre>\n<h3>问题</h3>\n<ul>\n<li>通过寄生式继承给对象添加函数难以复用，与构造函数模式类似</li>\n</ul>\n<h2>寄生式组合继承</h2>\n<ul>\n<li>前面说到组合继承存在效率问题，本质上子类原型只需要包含超类对象的所有实例属性，子函数在执行时重写自己的原型就可以了</li>\n</ul>\n<pre><code class=\"language-js\">function SuperType (name){\n  this.name = name\n  this.colors = ['red', 'blue']\n}\nSuperType.prototype.sayName = function(){\n  return this.name\n}\n\nfunction SubType(name, age){\n  // 第二次调用\n  SuperType.call(this, name)\n  this.age = age\n}\nSubType.prototype = new SuperType() // 第一次调用\nSubType.prototype.constructor = SubType\nSubType.prototype.sayAge = function(){\n  return this.age\n}\n\nlet instance1 = new SubType('张三', 27)\n</code></pre>\n<ul>\n<li>寄生式组合继承通过盗用构造函数继承属性，但是使用混合式原型链集成方法。</li>\n<li>基本思路就是不通过调用父类构造函数给子类原型赋值，而是取得父元素原型的一个副本。</li>\n<li>就是使用寄生式继承继承父类原型，然后将获取到的新对象赋值给子类原型。</li>\n</ul>\n<pre><code class=\"language-js\">function object(o) {\n  function F(){}\n  F.prototype = o\n  return new F()\n}\nfunction inheritPrototype(subType, superType) {\n  let prototype = object(superType)\n  // 解决由于原型重写导致的默认constructor丢失问题\n  prototype.constructor = subType\n  subType.prototype = prototype\n}\n\nfunction SuperType (name){\n  this.name = name\n  this.colors = ['red', 'blue']\n}\nSuperType.prototype.sayName = function(){\n  return this.name\n}\n\nfunction SubType(name, age){\n  SuperType.call(this, name)\n  this.age = age\n}\ninheritPrototype(SubType, SuperType)\nSubType.prototype.sayAge = function(){\n  return this.age\n}\n</code></pre>\n<ul>\n<li>这里只调用了一次SuperType的构造函数，避免了SubType上用不到的属性，所以效率更高。</li>\n<li>而且原型链也保持不变，可以说是引用类型继承的最佳模式</li>\n</ul>","fields":{"slug":"/extend2/"},"frontmatter":{"title":"继承--高程4","tags":["JavaScript回顾"],"categories":"JavaScript"}}},{"node":{"html":"<h1>代理</h1>\n<ul>\n<li>ECMAScript 6新增了代理与反射为开发者提供了拦截并向基本操作嵌入额外行为的能力</li>\n<li>就是可以给目标对象定义一个关联的代理对象，代理对象可以作为抽象的目标对象来使用，在对目标对象实行的各种操作影响目标对象之前，都可以在代理对象中对这些操作加以控制</li>\n<li>代理是新的基础性语言能力，所以转移程序无法将其转为之前的ECMAScript代码，因为代理是无可替代的，所以在使用前要检测平台是否支持</li>\n</ul>\n<h2>代理基础</h2>\n<ul>\n<li>\n<p>代理使用Proxy构造函数来创建，接收两个参数： 目标对象和处理程序对象，缺少任何一个参数都会报错，创建一个空代理只需要将对象字面量作为处理程序传递即可，如下</p>\n<!--more-->\n<pre><code class=\"language-js\">const target = {\nid: 'target'\n}\nconst handler = {}\nconst proxy = new Proxy(target, handler)\nconsole.log(target.id) // target\nconsole.log(proxy.id)   // target \n</code></pre>\n</li>\n</ul>\n<p>target.id = 'foo'\nconsole.log(target.id) // foo\nconsole.log(proxy.id)  // foo</p>\n<p>proxy.id = 'bar'\nconsole.log(target.id) // bar\nconsole.log(proxy.id)  // bar</p>\n<p>console.log(target.hasOwnProperty('id')) // true\nconsole.log(proxy.hasOwnProperty('id'))  // true</p>\n<p>console.log(target instanceof Proxy) // Uncaught TypeError: Function has non-object prototype 'undefined' in instanceof check\nconsole.log(proxy instanceof Proxy)  // Uncaught TypeError: Function has non-object prototype 'undefined' in instanceof check</p>\n<p>console.log(target === proxy) // false</p>\n<pre><code>- 这里属性会访问同一个值，对目标属性赋值会反映在两个对象，因为它们访问的是一个值\n- 对代理赋值会反应在两个对象，因为赋值会转移到目标对象\n- hasOwnProperty()在两个地方都会应用到目标对象\n- Proxy.prototype是undefined，所以不能使用instanceof\n- 目标跟代理对象不是严格相等\n\n## 定义捕获器\n\n- 捕获器就是处理程序对象中定义的“基本操作的拦截器”。每个处理程序对象可以包含任意个捕获器，每个捕获器都对应一个基本操作，可以直接或间接在代理对象上调用。\n- 每次在代理上调用这些基本操作，代理都可以在这些操作到达目标对象前调用捕捉器函数，从而拦截并修改相应的行为\n- 如下就是定义了一个get()捕捉器\n\n```js\nconst target = {\n  foo: 'bar'\n}\nconst handler = {\n  get () {\n    return 'handler override'\n  }\n}\n\nconst proxy = new Proxy(target, handler)\nconsole.log(target.foo) // bar\nconsole.log(proxy.foo)  // handler override\n</code></pre>\n<ul>\n<li>当通过代理对象触发get操作时就会触发定义的get()捕获器，get()方法不是ECMAScript对象可以调用的方法，而是通过其他形式触发被捕获的</li>\n<li>proxy[property]、proxy.property 或者 Object.create(proxy)[property]等操作都会触发get()方法</li>\n<li>在目标对象上执行这些操作仍然是正常的行为</li>\n</ul>\n<h2>捕获器参数与反射API</h2>\n<ul>\n<li>捕获器都可以访问相应的参数，基于这些参数可以重建被捕获方法的原始行为。例如get()捕获器可以收到目标对象、要查询的属性和代理对象三个参数</li>\n</ul>\n<pre><code class=\"language-js\">const target = {\n  foo: 'bar'\n}\nconst handler = {\n  get (tarpTarget, property, receiver) {\n    console.log(tarpTarget === target)  // true\n    console.log(property)  // 'foo'\n    console.log(receiver === proxy) // true\n  }\n}\n\nconst proxy = new Proxy(target, handler)\nproxy.foo\n</code></pre>\n<ul>\n<li>有了这些参数我们就可以重建被捕获方法的原始行为</li>\n</ul>\n<pre><code class=\"language-js\">const target = {\n  foo: 'bar'\n}\nconst handler = {\n  get (tarpTarget, property, receiver) {\n    return tarpTarget[property]\n  }\n}\n\nconst proxy = new Proxy(target, handler)\nconsole.log(target.foo) // bar\nconsole.log(proxy.foo)  // bar\n</code></pre>\n<ul>\n<li>所有的捕获器都可以基于自己的参数重建原始操作，但是有些原始操作很复杂，手写太麻烦，所以我们可以调用全局Reflect（封装了原始行为）对象上的同名方法来重建</li>\n<li>处理程序对象中的所有可以捕获的方法都由对应的反射（Reflect）API方法。这些方法与捕获器拦截的方法有相同的名称和函数签名，与被拦截方法有相同的行为，所以可以使用如下方式定义</li>\n</ul>\n<pre><code class=\"language-js\">const target = {\n  foo: 'bar'\n}\nconst handler = {\n  get () {\n    return Reflect.get(...arguments)\n  }\n}\n\nconst proxy = new Proxy(target, handler)\nconsole.log(target.foo) // bar\nconsole.log(proxy.foo)  // bar\n\n// 或者\nconst target = {\n  foo: 'bar'\n}\nconst handler = {\n  get: Reflect.get\n}\n\nconst proxy = new Proxy(target, handler)\nconsole.log(target.foo) // bar\nconsole.log(proxy.foo)  // bar\n</code></pre>\n<ul>\n<li>如果只是想捕获所有方法，然后转发给对应的反射API的空代理，都不需要定义处理程序对象</li>\n</ul>\n<pre><code class=\"language-js\">const target = {\n  foo: 'bar'\n}\n\nconst proxy = new Proxy(target, Reflect)\nconsole.log(target.foo) // bar\nconsole.log(proxy.foo)  // bar\n\nconst target = {\n  foo: 'bar',\n  bar: 'baz'\n}\nconst handler = {\n  get(tarpTarget, property, receiver) {\n    let decoration = ''\n    if(property === 'foo') {\n      decoration = '!!!'\n    }\n    return Reflect.get(...arguments) + decoration\n  }\n}\n\nconst proxy = new Proxy(target, handler)\nconsole.log(proxy.foo) // bar!!!\nconsole.log(proxy.bar)  // baz\n</code></pre>\n<ul>\n<li>捕获器可以改变几乎所有的基本方法，但是有限制，每个捕获的方法都知道目标对象上下文、捕获函数签名，捕获函数处理程序的行为必须遵循“捕获器不变式”</li>\n<li>比如目标对象有一个不可配置不可写的数据属性，那么捕获器返回一个与该属性不同的值会报错</li>\n</ul>\n<pre><code class=\"language-js\">const target = {}\nObject.defineProperty(target, 'foo', {\n  configurable: false,\n  wirtable: false,\n  value: 'bar'\n})\nconst handler = {\n  get(){\n    return 'qux'\n  }\n}\nconst proxy = new Proxy(target, handler)\nconsole.log(proxy.foo) // Uncaught TypeError: 'get' on proxy: property 'foo' is a read-only and non-configurable data property on the proxy target but the proxy did not return its actual value (expected 'bar' but got 'qux')\n</code></pre>\n<h3>可撤销代理</h3>\n<ul>\n<li>对使用new Proxy创建的代理会在代理对象的生命周期中一直存在，有时候我们需要终端代理对象与目标对象的联系，这个时候就要用到Proxy暴露的revocable()方法</li>\n<li>这个方法支持撤销目标对象跟对象的关联，是不可逆的，调用多次结果都是一样，撤销之后在调用代理会抛错</li>\n</ul>\n<pre><code class=\"language-js\">const target = {\n  foo: 'bar'\n}\nconst handler = {\n  get () {\n    return \"interceped\"\n  }\n}\n\nconst { proxy, revoke } = Proxy.revocable(target, handler)\nconsole.log(proxy.foo)  // interceped\n\nrevoke()\nconsole.log(proxy.foo) // Uncaught TypeError: Cannot perform 'get' on a proxy that has been revoked\n</code></pre>\n<ul>\n<li>特定情况下应该优先使用反射API，理由如下</li>\n<li>反射API不限于捕捉处理程序</li>\n<li>大多数反射API方法在Object类型上有对应的方法</li>\n<li>通常Object上的方法是用于通用程序，而反射方法适用于细粒度的对象控制</li>\n<li>很多反射方法会返回“状态标记”的布尔值，表示该操作是否成功，很多时候，状态标记比返回修改后的对象或错误更有用，看以下对比</li>\n</ul>\n<pre><code class=\"language-js\">const o = {}\ntry {\n  Object.defineProperty(o, 'foo', 'bar')\n  console.log('success')\n} catch(e){\n  console.log('failuer')\n}\n\n// 重构后\nconst o = {}\nif(Reflect.defineProperty(o, 'foo', { value: 'bar' })) {\n  console.log('success')\n} else {\n  console.log('failure')\n}\n</code></pre>\n<ul>\n<li>\n<p>以下方法会提供状态标记</p>\n<ul>\n<li>Reflect.defineProperty()</li>\n<li>Reflect.preventExtensions()</li>\n<li>Reflect.setPrototypeOf()</li>\n<li>Relfect.set()</li>\n<li>Relfect.deleteProperty()</li>\n</ul>\n</li>\n<li>\n<p>用一等函数替代操作符，以下反射方法只有通过操作符才可以完成</p>\n<ul>\n<li>Reflect.get(): 可以替代对象属性访问操作符</li>\n<li>Reflect.set(): 可以替代=赋值操作符</li>\n<li>Reflect.has(): 可以替代in操作符</li>\n<li>Reflect.deleteProperty(): 可以替代delete操作符</li>\n<li>Reflect.construct(): 可以替代new操作符</li>\n</ul>\n</li>\n<li>\n<p>安全的使用函数</p>\n<ul>\n<li>通过apply方法调用函数时，被调用函数可能定义了自己的apply属性。为了绕过这个问题，可以使用定义在Function原型上的apply方法</li>\n<li>但是调用Function原型上的方法会很难读，所以可以使用Reflect.apply来替代</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"language-js\">Function.prototype.apply.call(muFunc, thisVal, argumentList)\n\n// 用Reflect.apply替代\nReflect.apply(myFunc, thisVal, argumentList)\n</code></pre>\n<ul>\n<li>代理另一个代理，代理可以拦截反射API的操作，所以我们可以创建一个代理，利用它去代理另一个代理，就构建了多层拦截网</li>\n</ul>\n<pre><code class=\"language-js\">const target = {\n  foo: 'bar'\n}\nconst firstProxy = new Proxy(target, {\n  get() {\n    console.log('first proxy')\n    return Reflect.get(...arguments)\n  }\n})\n\nconst secondProxy = new Proxy(firstProxy, {\n  get() {\n    console.log('seond proxy')\n    return Reflect.get(...arguments)\n  }\n})\nconsole.log(secondProxy.foo)\n\n// seond proxy\n// first proxy\n// bar\n</code></pre>\n<h2>代理的问题与不足</h2>\n<ul>\n<li>代理中的this，方法中的this通常指向调用这个方法的对象，如果目标依赖于对象表示，可能会出问题，如下用WeakMap报错私有变量的例子，简化版</li>\n</ul>\n<pre><code class=\"language-js\">const wm = new WeakMap()\n\nclass User{\n  constructor(userid){\n    wm.set(this, userid)\n  }\n  set id(userid){\n    wm.set(this, userid)\n  }\n  get id(userid) {\n    return wm.get(this)\n  }\n}\n\nconst user = new User(123)\nconsole.log(user.id)  // 123\n\nconst userInstanceProxy = new Proxy(user, {})\nconsole.log(userInstanceProxy.id) // undefined\n</code></pre>\n<ul>\n<li>这里User实例使用目标对象作为WeakMap的键，但是代理对象却从自身取这个实例，所以就出问题了</li>\n<li>解决问题就是将代理User实例改为代理User类本身，之后在创建代理实例就会以代理实例作为WeakMap的值了</li>\n</ul>\n<pre><code class=\"language-js\">const UserClassProxy = new Proxy(User, {})\nconst proxyUser = new UserClassProxy(456)\nconsole.log(proxyUser.id)\n</code></pre>\n<ul>\n<li>代理与内置类型（如Array）的实例可以很好地协作，但有些ECMAScript内置类型可能会导致代理某些方法出错，比如Date类型</li>\n<li>Date类型依赖this值上的[[NumberDate]]槽位，这个槽位无法通过get()跟set()方法访问到，所以代理拦截后转发给目标对象的方法会报错</li>\n</ul>\n<pre><code class=\"language-js\">const target = new Date()\nconst proxy = new Proxy(target, {})\nconsole.log(proxy instanceof Date) // true\nproxy.getDate() // Uncaught TypeError: this is not a Date object.\n</code></pre>\n<h2>代理捕获器与反射方法</h2>\n<ul>\n<li>代理可以捕获13中不同的基本操作。这些操作有各自不同的反射API方法、参数、关联的ECMAScript方法与不变式</li>\n<li>不同的JavsScript操作可以出发同一个捕获器处理。但是对于在代理对象上的任何操作，都只会有一个捕获处理程序被调用，不存在重复捕获的情况</li>\n</ul>\n<h3>get()</h3>\n<ul>\n<li>get()捕获器会在获取属性值的操作被调用，对应的反射API为Reflect.get()</li>\n<li>返回值无限制</li>\n<li>\n<p>拦截的操作： </p>\n<ul>\n<li>proxy.property</li>\n<li>proxy[property]</li>\n<li>Object.create(proxy)[Property]</li>\n<li>Reflect.get(proxy, property, receiver)</li>\n</ul>\n</li>\n<li>\n<p>捕获器处理程序参数</p>\n<ul>\n<li>target: 目标对象</li>\n<li>property: 引用目标对象上的字符串属性（也有可能是符号键）</li>\n<li>receiver: 代理对象或继承代理对象的对象</li>\n</ul>\n</li>\n<li>\n<p>捕获器不定式</p>\n<ul>\n<li>如果target.property不可写切不可配置，则返回的值必须跟target.property一致</li>\n<li>如果target.property不可写且[[Get]]特性为undefined，处理程序的返回值也必须是undefined</li>\n</ul>\n</li>\n</ul>\n<h3>set()</h3>\n<ul>\n<li>set()会在设置属性值的操作中被调用，对应的反射API为Reflect.set()</li>\n<li>返回值为true表示成功；为false表示失败，严格模式下抛错</li>\n<li>\n<p>拦截的操作</p>\n<ul>\n<li>proxy.property = value</li>\n<li>proxy[property] = value</li>\n<li>Object.create(proxy)[property] = value</li>\n<li>Reflect.set(proxy, property, value, receiver)</li>\n</ul>\n</li>\n<li>\n<p>捕获器处理程序参数</p>\n<ul>\n<li>target: 目标对象</li>\n<li>property: 引用目标对象的字符串健属性</li>\n<li>value: 要赋给属性的值</li>\n<li>receiver: 接收最初赋值的对象</li>\n</ul>\n</li>\n<li>\n<p>捕获器不定式</p>\n<ul>\n<li>如果target.property不可写且不可配置，则不能修改目标属性的值</li>\n<li>如果target.property不可配置且[[Set]]特性为undefined，则不可修改目标属性的值</li>\n<li>严格模式下，处理程序返回false会报错</li>\n</ul>\n</li>\n</ul>\n<h3>has()</h3>\n<ul>\n<li>has()捕获器在in操作符中被调用，对应的反射API为Reflect.has()</li>\n<li>返回值必须式布尔值，表示属性是否存在。非布尔值会被转为布尔值</li>\n<li>\n<p>拦截的操作</p>\n<ul>\n<li>property in proxy</li>\n<li>property in Object.create(proxy)</li>\n<li>with(proxy){(property)}</li>\n<li>Reflect.has(proxy, property)</li>\n</ul>\n</li>\n<li>\n<p>捕获器处理程序参数</p>\n<ul>\n<li>target: 目标对象</li>\n<li>property: 引用的目标对象上的字符串键属性</li>\n</ul>\n</li>\n<li>\n<p>捕获器不定式</p>\n<ul>\n<li>如果target.property存在且不可配置，则处理程序必须返回true</li>\n<li>如果target.property存在目标且目标对象不可拓展，则处理程序必须返回true</li>\n</ul>\n</li>\n</ul>\n<h3>defineProperty</h3>\n<ul>\n<li>defineProperty()捕获器会在Object.defineProperty()中被调用，对应的反射API为Reflect.defineProperty()</li>\n<li>返回值必须为布尔值，表示属性是否定义成功。返回非布尔值会被转为布尔值</li>\n<li>\n<p>拦截的操作</p>\n<ul>\n<li>Object.defineProperty(proxy, property, descriptor)</li>\n<li>Reflect.defineProperty(proxy, property, descriptor)</li>\n</ul>\n</li>\n<li>\n<p>捕获器处理程序参数</p>\n<ul>\n<li>target: 目标对象</li>\n<li>property: 引用目标对象上的字符串键属性</li>\n<li>descriptor: 包含可选的enumerable、configuable、writable、value、get、set定义的对象</li>\n</ul>\n</li>\n<li>\n<p>捕获器不定式</p>\n<ul>\n<li>如果目标对象不可拓展，则无法定义属性</li>\n<li>如果目标对象有一个可配置的属性，则不能添加同名的不可配置的属性</li>\n<li>如果目标对象有一个不可配置的属性，则不能添加同名的可配置属性</li>\n</ul>\n</li>\n</ul>\n<h3>getOwnPropertyDescriptor()</h3>\n<ul>\n<li>getOwnPropertyDescriptor()捕获器会在Object.getOwnPropertyDescriptor中被调用，对应的反射API为Reflect.getOwnPropertyDescriptor</li>\n<li>返回值必须返回对象，如果在属性不存在时返回undefined</li>\n<li>\n<p>拦截的操作</p>\n<ul>\n<li>Object.getOwnPropertyDescriptor(proxy, property)</li>\n<li>Reflect.getOwnPropertyDescriptor(proxy, property)</li>\n</ul>\n</li>\n<li>\n<p>捕获器处理程序参数</p>\n<ul>\n<li>target: 目标对象</li>\n<li>property: 引用的目标对象上的字符串键值</li>\n</ul>\n</li>\n<li>\n<p>捕获器不变式</p>\n<ul>\n<li>如果自有的target.property存在且不可配置，则处理程序必须返回一个表示该属性存在的对象</li>\n<li>如果自有的target.property存在且target可拓展，则处理程序必须返回一个表示该属性可配置的对象</li>\n<li>如果自有的target.property存在且target不可拓展，则处理程序必须返回一个表示该属性存在的对象</li>\n<li>如果自有的target.property不存在且target不可拓展，则处理程序必须返回undefined表示该属性不存在</li>\n<li>如果target.property不存在，则处理程序不能返回表示该属性可配置的对象</li>\n</ul>\n</li>\n</ul>\n<h3>deleteProperty</h3>\n<ul>\n<li>deleteProperty会在delete操作符中被调用，对应的反射API为Reflect.deleteProperty()</li>\n<li>返回值必须为布尔值，表示删除属性是否成功。返回非布尔值会被转为布尔值</li>\n<li>\n<p>拦截的操作</p>\n<ul>\n<li>delete proxy.property</li>\n<li>delete proxy[property]</li>\n<li>Reflect.deleteProperty(proxy, property)</li>\n</ul>\n</li>\n<li>\n<p>捕获器处理程序参数</p>\n<ul>\n<li>target: 目标对象</li>\n<li>property: 引用的目标对象上的字符串键值</li>\n</ul>\n</li>\n<li>\n<p>捕获器不变式</p>\n<ul>\n<li>如果自有的target.property存在且不可配置，则处理程序不能删除这个属性</li>\n</ul>\n</li>\n</ul>\n<h3>ownKeys</h3>\n<ul>\n<li>ownKeys会在Object.keys()及类似方法中被调用，对应的反射API为Reflect.ownKeys()</li>\n<li>返回值必须返回包含字符串或符号的可枚举对象</li>\n<li>\n<p>拦截的操作</p>\n<ul>\n<li>Object.getOwnPropertyNames(proxy)</li>\n<li>Object.getOwnPropertySymbols(proxy)</li>\n<li>Object.keys()</li>\n<li>Reflect.ownKeys(proxy)</li>\n</ul>\n</li>\n<li>\n<p>捕获器处理程序参数</p>\n<ul>\n<li>target: 目标对象</li>\n</ul>\n</li>\n<li>\n<p>捕获器不定式</p>\n<ul>\n<li>返回的可枚举对象必须包含target的所有不可配置的自有属性</li>\n<li>如果target不可拓展，则返回可枚举对象必须军却包含自有属性键</li>\n</ul>\n</li>\n</ul>\n<h3>getPrototypeOf()</h3>\n<ul>\n<li>getPrototypeOf()会在Object.getPrototypeOf()中被调用，对应的反射API为Reflect.getPrototypeOf()</li>\n<li>返回值必须返回对象或者null</li>\n<li>\n<p>拦截的操作</p>\n<ul>\n<li>Object.getPrototypeOf(proxy)</li>\n<li>Reflect.getPrototypeOf(proxy)</li>\n<li>proxy.<strong>proto</strong></li>\n<li>Object.prototype.isPrototypeOf(proxy)</li>\n<li>proxy instanceof Object</li>\n</ul>\n</li>\n<li>\n<p>捕获器处理程序参数</p>\n<ul>\n<li>target: 目标对象</li>\n</ul>\n</li>\n<li>\n<p>捕获器不定式</p>\n<ul>\n<li>如果target不可拓展，则Object.getPrototypeOf(proxy)唯一有效的返回值就是Object.getPrototypeOf(target)的返回值</li>\n</ul>\n</li>\n</ul>\n<h3>setPrototypeOf()</h3>\n<ul>\n<li>setPrototypeOf()会在Object.setPrototypeOf()中被调用，对应的反射API为Reflect.setPrototypeOf()</li>\n<li>返回值必须返回布尔值，表示原型赋值是否成功，非布尔值会被转为布尔值</li>\n<li>\n<p>拦截的操作</p>\n<ul>\n<li>Object.setPrototypeOf(proxy)</li>\n<li>Reflect.setPrototypeOf(proxy)</li>\n</ul>\n</li>\n<li>\n<p>捕获器处理程序参数</p>\n<ul>\n<li>target: 目标对象</li>\n<li>prototype: target的替代原型，如果是顶级原型则为null</li>\n</ul>\n</li>\n<li>\n<p>捕获器不定式</p>\n<ul>\n<li>如果target不可拓展，则唯一有效的prototype参数就是Object.getPrototypeOf(target)的返回值</li>\n</ul>\n</li>\n</ul>\n<h3>isExtensible()</h3>\n<ul>\n<li>isExtensible()会在Object.isExtensible()中被调用，对应的反射API为Reflect.isExtensible()</li>\n<li>返回值必须为布尔值，表示target是否可拓展，非布尔值会转为布尔值</li>\n<li>\n<p>拦截的操作</p>\n<ul>\n<li>Object.isExtensible(proxy)</li>\n<li>Reflect.isExtensible(proxy)</li>\n</ul>\n</li>\n<li>\n<p>捕获器处理程序参数</p>\n<ul>\n<li>target: 目标对象</li>\n</ul>\n</li>\n<li>\n<p>捕获器不定式</p>\n<ul>\n<li>如果target可拓展，处理程序必须返回true</li>\n<li>如果target不可拓展，处理程序必须返回false</li>\n</ul>\n</li>\n</ul>\n<h3>preventExtensions()</h3>\n<ul>\n<li>preventExtensions()捕获器会在Object.preventExtensions()中被调用，对应的反射API为Reflect.preventExtensions()</li>\n<li>返回值必须为布尔值，表示target是否已经不可拓展，返回非布尔值会被转为布尔值</li>\n<li>\n<p>拦截的操作</p>\n<ul>\n<li>Object.preventExtensions(proxy)</li>\n<li>Relfect.preventExtensions(proxy)</li>\n</ul>\n</li>\n<li>\n<p>捕获器处理程序参数</p>\n<ul>\n<li>target: 目标对象</li>\n</ul>\n</li>\n<li>\n<p>捕获器不定式</p>\n<ul>\n<li>如果Object.isExtensible(proxy)返回false，则处理程序必须返回true</li>\n</ul>\n</li>\n</ul>\n<h3>apply()</h3>\n<ul>\n<li>apply()会在调用函数时被调用，对应的反射API为Reflect.apply()</li>\n<li>返回值无限制</li>\n<li>\n<p>拦截的操作</p>\n<ul>\n<li>proxy(...argumentsList)</li>\n<li>Function.prototype.apply(thisArg, argumentsList)</li>\n<li>Function.prototype.call(thisArg, ...argumentsList)</li>\n<li>Reflect.apply(target, thisArgument, argumentsList)</li>\n</ul>\n</li>\n<li>\n<p>捕获器处理程序参数</p>\n<ul>\n<li>target: 目标对象</li>\n<li>thisArg: 调用此函数时的this参数</li>\n<li>argumentsList: 调用函数时的参数列表</li>\n</ul>\n</li>\n<li>\n<p>捕获器不定式</p>\n<ul>\n<li>target必须是函数对象</li>\n</ul>\n</li>\n</ul>\n<h3>construct()</h3>\n<ul>\n<li>construct()捕获器会在new操作符中被调用，对应的反射API为Reflect.construct()</li>\n<li>返回值必须返回一个对象</li>\n<li>\n<p>拦截的操作</p>\n<ul>\n<li>new Proxy(...argumentsList)</li>\n<li>Reflect.construct(target, argumentsList, newTarget)</li>\n</ul>\n</li>\n<li>\n<p>捕获器处理程序参数</p>\n<ul>\n<li>target: 目标构造函数</li>\n<li>argumentsList: 传给构造函数的参数列表</li>\n<li>最初被调用的构造函数</li>\n</ul>\n</li>\n<li>\n<p>捕获器不定式</p>\n<ul>\n<li>target必须可以用作构造函数</li>\n</ul>\n</li>\n</ul>\n<h2>代理模式</h2>\n<ul>\n<li>利用代理可以做一些有用的编程模式</li>\n<li>可以捕获get、set、has等操作，知道对象属性什么时候被访问</li>\n</ul>\n<pre><code class=\"language-js\">const user = {\n  name: 'jack'\n}\n\nconst proxy = new Proxy(user, {\n  get (target, property, receiver){\n    console.log(`Getting ${property}`)\n    Reflect.get(...arguments)\n  },\n  set (target, property, value, receiver){\n    console.log(`Setting ${property}=${value}`)\n    Reflect.set(...arguments)\n  }\n})\n\nproxy.name  // Getting name\nproxy.age = 27 // Setting age=27\n</code></pre>\n<ul>\n<li>可以用于隐藏属性</li>\n</ul>\n<pre><code class=\"language-js\">const hiddenProperties = ['foo', 'bar']\nconst targetObject = {\n  foo: 1,\n  bar: 2,\n  baz: 3\n}\nconst proxy = new Proxy(targetObject, {\n  get(target, property) {\n    if(hiddenProperties.includes(property)) {\n      return undefined\n    } else {\n      return Reflect.get(...arguments)\n    }\n  },\n  has(target, property){\n    if(hiddenProperties.includes(property)) {\n      return false\n    } else {\n      return Reflect.has(...arguments)\n    }\n  }\n})\n\nconsole.log(proxy.foo) // undefined\nconsole.log(proxy.bar) // undefined\nconsole.log(proxy.baz) // 3\nconsole.log('foo' in proxy) // false\nconsole.log('bar' in proxy) // false\nconsole.log('baz' in proxy) // true\n</code></pre>\n<ul>\n<li>可以根据所赋的值决定是否允许赋值</li>\n</ul>\n<pre><code class=\"language-js\">const target = {\n  onlyNumbersGoHere: 0\n}\n\nconst proxy = new Proxy(target, {\n  set (target, property, value, receiver){\n    if(typeof value !== 'number') {\n      return false\n    } else {\n      return Reflect.set(...arguments)\n    }\n  }\n})\n\nproxy.onlyNumbersGoHere = 1\nconsole.log(proxy.onlyNumbersGoHere) // 1\n\nproxy.onlyNumbersGoHere = '2'\nconsole.log(proxy.onlyNumbersGoHere) // 1\n</code></pre>\n<ul>\n<li>函数跟构造函数参数验证，指定函数只接受某种类型的值</li>\n</ul>\n<pre><code class=\"language-js\">function median(...nums){\n  return nums.sort()[Math.floor(nums.length / 2)]\n}\nconst proxy = new Proxy(median, {\n  apply(target, thisArg, argumentsList) {\n    for(const arg of argumentsList) {\n      if(typeof arg !== 'number') {\n        throw 'Non-number argument provided'\n      }\n    }\n    return Reflect.apply(...arguments)\n  }\n})\n\nconsole.log(proxy(4, 7, 1)) // 4\nconsole.log(proxy(4, '7', 1)) // Uncaught Non-number argument provided\n</code></pre>\n<ul>\n<li>通过代理可以把原来不关联的部分联系到一起。这样就能实现各种模式，让不同的代码互操作</li>\n<li>例如，可以将被代理的类放到一个全局实例集合</li>\n</ul>\n<pre><code class=\"language-js\">const userList = []\nclass User{\n  constructor(name){\n    this._name = name\n  }\n}\n\nconst proxy = new Proxy(User, {\n  construct(){\n    const newUser = Reflect.construct(...arguments)\n    userList.push(newUser)\n    return newUser\n  }\n})\n\nnew proxy('John')\nnew proxy('Jacob')\nnew proxy('Jing')\nconsole.log(userList) // [User, User, User]\n</code></pre>\n<ul>\n<li>可以把集合绑定到一个事件分配程序，每次插入新实例都会发送消息</li>\n</ul>\n<pre><code class=\"language-js\">const userList = []\nfunction emit(newValue) {\n  console.log(newValue)\n}\n\nconst proxy = new Proxy(userList, {\n  set(target, property, value, receiver) {\n    const result = Reflect.set(...arguments)\n    if(result) {\n      emit(Reflect.get(target, property, receiver))\n    }\n    return result\n  }\n})\nproxy.push('John') // John\nproxy.push('Jacob') // Jacob\nproxy.push('Jing') // Jing\n</code></pre>","fields":{"slug":"/proxy/"},"frontmatter":{"title":"代理","tags":["JavaScript回顾"],"categories":"JavaScript"}}},{"node":{"html":"<h1>函数</h1>\n<ul>\n<li>函数实际上是对象，每个函数都是Function类型的实例</li>\n<li>函数通常以函数声明的方式定义</li>\n</ul>\n<pre><code class=\"language-js\">function sum(num1, num2) {\n  return num1 + num2\n}\n</code></pre>\n<ul>\n<li>\n<p>还能以函数表达式来定义</p>\n<!--more-->\n<pre><code class=\"language-js\">let sum = function (num1, num2) {\nreturn num1 + num2\n}\n</code></pre>\n</li>\n<li>箭头函数定义</li>\n</ul>\n<pre><code class=\"language-js\">let sum = (num1, num2) => {\n  return num1 + num2\n}\n</code></pre>\n<ul>\n<li>最后一种以Function构造函数定义函数。此构造函数接收任意个字符串参数，最后一个参数会被当做函数体，前面的参数都是新函数的参数</li>\n<li>此方法不推荐，因为这样会解释两次，第一次是将它当做常规的ECMAScript代码，第二次会解释传给构造函数的字符串</li>\n</ul>\n<pre><code class=\"language-js\">let sum = new Function('num1', 'num2', 'return num1 + num2')\n</code></pre>\n<ul>\n<li>ECMAScript 6的所有函数对象会暴露一个只读的<code>name</code>属性，包含函数的信息。一般情况下保存的就是一个字符串化的变量名</li>\n<li>及时函数没有名称也会变成空字符串，如果是用<code>Function</code>创建的，就会标识成<code>\"anonymous\"</code></li>\n<li>如果函数是一个获取函数、设置函数或者使用bind实例化，name会加上一个前缀</li>\n</ul>\n<pre><code class=\"language-js\">function foo(){}\nlet bar = function(){}\nlet baz = () => {}\n\nconsole.log(foo.name) // foo\nconsole.log(bar.name) // bar\nconsole.log(baz.name) // baz\nconsole.log((() => {}).name) // ''\nconsole.log((new Function()).name) // anonymous\n\n\nlet dog = {\n  years: 1,\n  get age(){\n    return this.year\n  },\n  set age(newVal){\n    this.years = newVal\n  }\n}\nlet propertyDescriptor = Object.getOwnPropertyDescriptor(dog, 'age')\nconsole.log(foo.bind(null).name) // bound foo\nconsole.log(propertyDescriptor.get.name) // get age\nconsole.log(propertyDescriptor.set.name) // set age\n</code></pre>\n<ul>\n<li>函数默认值定义时，参数是按照顺序初始化的，所以后定义的默认值参数可以引用前面定义的参数</li>\n</ul>\n<pre><code class=\"language-js\">function makeKing(name = 'Henry', numerals = name) {\n  return `King ${name} ${numerals}`\n}\nconsole.log(makeKing()) // King Henry Henry\n</code></pre>\n<ul>\n<li>参数初始化顺序遵循“暂时性死区”规则，前面定义的参数，不能引用后面定义的参数，如下就会报错</li>\n</ul>\n<pre><code class=\"language-js\">function makeKing(name = numerals, numerals = 'Henry') {\n  return `King ${name} ${numerals}`\n}\nconsole.log(makeKing()) // Uncaught ReferenceError: Cannot access 'numerals' before initialization\n</code></pre>\n<h2>箭头函数</h2>\n<ul>\n<li>可以使用函数表达式的地方都可以使用箭头函数</li>\n<li>箭头函数不能使用arguments、super和new.target，也不能用作构造函数，并且没有prototype</li>\n</ul>\n<h2>arguments</h2>\n<ul>\n<li>arguments是一个类数组对象，包含函数调用传入的全部参数，这个函数只有一function关键字定义函数时才有 （箭头函数就没有）</li>\n<li>arguments有一个callee属性，始终指向arguments对象所在的函数的指针</li>\n</ul>\n<pre><code class=\"language-js\">function factorial(num){\n  if(num &#x3C;=1) {\n    return 1\n  } else {\n    return num * factorial(num - 1)\n  }\n}\n\nlet trueFactorial = factorial\nfactorial = function(){\n  return 0\n}\ntrueFactorial(5) // 0\nfactorial(5) // 0\n</code></pre>\n<ul>\n<li>这是一个经典的阶乘函数，上面函数要保证正确执行就得保证函数名一定是factorial，一旦我们将函数赋给别的值，就能发现出现问题了，这就导致了紧密耦合，可以使用arguments.callee解耦</li>\n</ul>\n<pre><code class=\"language-js\">function factorial(num){\n  if(num &#x3C;=1) {\n    return 1\n  } else {\n    return num * arguments.callee(num - 1)\n  }\n}\n\n\nlet trueFactorial = factorial\ntrueFactorial(5) // 120\nfactorial = function(){\n  return 0\n}\nfactorial(5) // 0\n</code></pre>\n<ul>\n<li>这样就实现了解耦，修改factorial的引用不会影响递归函数</li>\n<li>arguments对象始终会与对应的命名参数同步</li>\n</ul>\n<pre><code class=\"language-js\">function doAdd(num1, num2) {\n  arguments[1] = 10\n  console.log(arguments[0] + num2)\n}\ndoAdd(10, 30) // 20\n</code></pre>\n<ul>\n<li>这里doAdd函数会把第二个参数的值重写为10。因为arguments对象的值会自动同步到对应的命名参数，所以修改arguments[1]也就是修改了num2</li>\n<li>并不意味着arguments[1]跟num2是同一个内存地址，内存是分开的，但是会同步</li>\n<li>如果只传了一个参数，然后把arguments[1]改为某个值，那这个值并不会反映到第二个命名参数，因为arguments对象的长度是根据传入的参数个数确定，而非定义函数时给出的命名参数确定的</li>\n<li>严格模式下，arguments[1]修改后不再影响num2的值，其次，在函数内重写arguments对象会导致语法错误</li>\n</ul>\n<h2>this</h2>\n<ul>\n<li>this在标准函数与箭头函数中行为不一致</li>\n<li>标准函数中，this引用的是把函数当成方法调用的上下文对象，这时候称其为this值（网页全局调用时，this指向window）</li>\n</ul>\n<pre><code class=\"language-js\">window.color = 'red'\nlet o = {\n  color: 'blue'\n}\nfunction sayColor(){\n  console.log(this.color)\n}\nsayColor() // 'red'\no.sayColor = sayColor\no.sayColor() // 'blue'\n</code></pre>\n<ul>\n<li>定义在全局上下文的sayColor引用了this对象。这个this是那个对象要到函数调用时才能知道。</li>\n<li>全局调sayColor输出red因为this指向window，this.color相当于window.color。</li>\n<li>把sayColor赋值给o再调用，this指向了o，this.color相当于o.color，所以显示\"blue\"</li>\n<li>箭头函数中的this引用的是定义箭头函数的上下文</li>\n</ul>\n<pre><code class=\"language-js\">window.color = 'red'\nlet o = {\n  color: 'blue'\n}\nlet sayColor = () => console.log(this.color)\nsayColor() // 'red'\no.sayColor = sayColor\no.sayColor() // 'red'\n</code></pre>\n<ul>\n<li>所以当我们在事件回调或者定时回调中调用某个函数时，this指向并非我们想要的对象时，我们就可以把函数改为箭头函数即可，因为箭头函数中的this会保留定义该函数的上下文</li>\n</ul>\n<pre><code class=\"language-js\">function King(){\n  this.royaltyName = 'Henry'\n  setTimeout(() => {\n    console.log(this.royaltyName)\n  }, 1000)\n}\n\nfunction Queen(){\n  this.royaltyName = 'Elizabeth'\n  setTimeout(function (){\n    console.log(this.royaltyName)\n  }, 1000)\n}\nnew King() // Henry\nnew Queen() // undefined\n</code></pre>\n<h2>caller</h2>\n<ul>\n<li>ECMAScript 5会给函数对象加一个属性： caller，这个属性引用调用当前函数的函数，如果在全局作用域中调用则为null</li>\n</ul>\n<pre><code class=\"language-js\">function outer(){\n  inner()\n}\nfunction inner(){\n  console.log(inner.caller)\n}\nouter()  // ƒ outer(){\n  inner()\n}\n\n// 降低耦合度的写法\nfunction inner(){\n  console.log(arguments.callee.caller)\n}\n</code></pre>\n<ul>\n<li>严格模式下访问arguments.callee会报错，访问arguments.caller也会报错，非严格模式下访问arguments.caller是undefined，这样是为了分清arguments.caller和函数的caller而做的</li>\n<li>严格模式下不可给caller赋值，否则会报错</li>\n</ul>\n<h2>new.target</h2>\n<ul>\n<li>函数始终可以作为构造函数实例化一个对象，ECMAScript新增了 new.target 检测函数是否使用new关键字调用。函数是正常调用，那new.target就是undefined，如果是new调用，那new.target将引用被调用的构造函数</li>\n</ul>\n<pre><code class=\"language-js\">function King(){\n  if(!new.target) {\n    throw 'King must be instantiated using \"new\"'\n  }\n  console.log('King instantiated using \"new\"')\n}\nnew King() // King instantiated using \"new\"\nKing() // Uncaught King must be instantiated using \"new\"\n</code></pre>","fields":{"slug":"/function/"},"frontmatter":{"title":"函数--高程4","tags":["JavaScript回顾"],"categories":"JavaScript"}}},{"node":{"html":"<h1>函数</h1>\n<h2>递归</h2>\n<ul>\n<li>递归函数通常是一个函数通过名称自己调用自己</li>\n</ul>\n<pre><code class=\"language-js\">// 耦合性太强\nfunction factorial(num){\n  if(num &#x3C;= 1) {\n    return 1\n  } else {\n    return num * factorial(num - 1)\n  }\n}\n\n// 严格模式下报错\nfunction factorial(num){\n  if(num &#x3C;= 1) {\n    return 1\n  } else {\n    return num * arguments.callee(num - 1)\n  }\n}\n</code></pre>\n<ul>\n<li>\n<p>这样是我们的第一感觉，但是上一章说过，这样的话如果把它赋值给其他变量就会出问题，所以上一章我们用的是arguments.callee来进行调用，但是这样在严格模式下报错，所以我们可以使用命名函数表达式来完成，如下</p>\n<!--more-->\n<pre><code class=\"language-js\">const factorial = (function f(num){\nif(num &#x3C;= 1) {\nreturn 1\n} else {\nreturn num * f(num - 1)\n}\n})\n</code></pre>\n</li>\n<li>这样就实现了我们的一个通用递归方式</li>\n</ul>\n<h2>尾调用优化</h2>\n<ul>\n<li>ECMAScript 6新增了一项内存管理优化机制，让JavaScript引擎在满足条件时可以重用栈帧。这个优化很适合“尾调用”，即外部函数的返回值是内部函数的返回值</li>\n</ul>\n<pre><code class=\"language-js\">function outerFunction(){\n  return innerFuntion() // 尾调用\n}\n</code></pre>\n<ul>\n<li>\n<p>ES6优化之前，会有下操作</p>\n<ul>\n<li>执行到outerFunction函数体，第一个栈帧被推倒栈上</li>\n<li>执行outerFunction函数体，到return语句，需要计算innerFunction</li>\n<li>执行到innerFunction函数体，第二个栈帧被推到栈上</li>\n<li>执行innerFunction函数体，计算返回值</li>\n<li>将返回值传回outerFunction，然后再返回</li>\n<li>将栈帧弹出栈</li>\n</ul>\n</li>\n<li>\n<p>优化后</p>\n<ul>\n<li>执行到outerFunction函数体，第一个栈帧被推倒栈上</li>\n<li>执行outerFunction函数体，到return语句，需要计算innerFunction</li>\n<li>引擎发现将第一个栈帧弹出去也不影响，因为outerFunction的返回值跟innerFunction的返回值一直</li>\n<li>弹出outerFunction的栈帧</li>\n<li>执行到innerFunction函数体，栈帧被推到栈上</li>\n<li>执行innerFunction函数体，计算返回值</li>\n<li>将innerFunction的栈帧弹出栈外</li>\n</ul>\n</li>\n<li>能看出，第一种情况下每多一层嵌套就会多一个栈帧。而第二种情况无论多少次嵌套函数，都只有一个栈帧。</li>\n<li>这就是ES6尾调用优化的关键：如果函数的逻辑允许尾调用将其销毁，那引擎就会这么干</li>\n</ul>\n<h3>尾调用优化的条件</h3>\n<ul>\n<li>\n<p>尾调用优化的条件就是确定外部栈帧没必要存在了，条件如下</p>\n<ul>\n<li>代码在严格模式下执行</li>\n<li>外部函数的返回值是对尾调用函数的调用</li>\n<li>尾调用函数返回后不需执行额外操作</li>\n<li>尾调用函数不是引用外部函数作用域中自由变量的闭包</li>\n</ul>\n</li>\n<li>下面是几个违反上述条件的函数</li>\n</ul>\n<pre><code class=\"language-js\">'use strict'\n// 无优化： 尾调用无返回\nfunction outerFunction(){\n  innerFunction()\n}\n\n// 无优化： 尾调用没有直接返回\nfunction outerFunction(){\n  let result = innerFunction()\n  return result\n}\n\n// 无优化： 尾调用后必须转为字符串\nfunction outerFunction(){\n  return innerFunction().toString()\n}\n\n// 无优化： 尾调用是个闭包\nfunction outerFunction(){\n  let foo = 'bar'\n  function innerFunction(){\n    return foo\n  }\n  return innerFunction()\n}\n</code></pre>\n<ul>\n<li>下面是符合条件的例子</li>\n</ul>\n<pre><code class=\"language-js\">'use strict'\n// 有优化：栈帧销毁前执行计算\nfunction outerFunction(a, b){\n  return innerFunction(a + b)\n}\n\n// 有优化：初识返回值不涉及栈帧\nfunction outerFunction(a, b){\n  if(a &#x3C; b) {\n    return a\n  }\n  return innerFunction(a + b)\n}\n\n// 有优化：两个内部函数都在尾部\nfunction outerFunction(condition){\n  return condition ? innerFunctionA() : innerFunctionB()\n}\n</code></pre>\n<ul>\n<li>差异化尾调用跟递归尾调用容易让人混淆，无论递归尾调用还是非递归尾调用，都可以应用优化。这个优化在递归下最明显，因为递归代码最容易在栈内存中产生大量栈帧</li>\n<li>之所以要求严格模式是因为非严格模式下函数调用中允许使用f.arguments跟f.caller，而它们都引用外部函数的栈帧。所以无法使用优化了</li>\n<li>尾调用优化的代码</li>\n</ul>\n<pre><code class=\"language-js\">function fib(n) {\n  if(n &#x3C; 2) {\n    return n\n  }\n  return fib(n - 1) + fib(n - 2)\n}\n</code></pre>\n<ul>\n<li>这里的函数尾部执行了相加操作，所以不符合尾调用优化的原则，所以fib(n)的栈帧数的内存复杂度为o(2^n)，所以简单地调用fib(1000)也会给浏览器带来麻烦</li>\n<li>所以我们可以对其进行优化让其满足条件，为此使用两个函数，外层函数作为基础框架，内部函数执行递归</li>\n</ul>\n<pre><code class=\"language-js\">'use strict'\nfunction fib(n){\n  return fibImpl(0, 1, n)\n}\n\nfunction fibImpl(a, b, n){\n  if(n === 0) {\n    return a\n  }\n  return fibImpl(b, a + b, n - 1)\n}\nfib(1000)\n</code></pre>\n<ul>\n<li>重构之后在执行就不会有这个问题了，可以正常得出结果</li>\n</ul>\n<h2>闭包</h2>\n<ul>\n<li>闭包是指那些引用了另一个函数作用域中变量的函数，通常是在嵌套函数中使用。</li>\n<li>闭包形成的原因，在调用一个函数时，会为函数调用创建一个执行上下文，并创建作用域链。</li>\n<li>然后用arguments和其他参数来初始化这个函数的活动对象。外部函数的活动对象是内部函数作用域链的第二个对象。</li>\n<li>这个作用域链一直向外串起所有包含函数的活动对象，一直到全局执行上下文才终止</li>\n<li>函数执行时，每个执行上下文都会有一个包含其中变量的对象，全局上下文中叫变量对象，会在代码执行期间一直存在。函数局部上下文中的叫活动对象，只在函数执行期间存在。</li>\n</ul>\n<pre><code class=\"language-js\">function compare(value1, value2){\n  if(value1 &#x3C; value2) {\n    return -1\n  } else if (value1 > value2) {\n    return 1\n  } else {\n    return 0\n  }\n}\nlet result = compare(5, 10)\n</code></pre>\n<ul>\n<li>compare函数是在全局上下文中调用的。第一次调用会为它创建一个包含arguments、value1、value2的活动对象，这个对象就是它作用域链的第一个对象</li>\n<li>全局上下文的变量对象则是compare()作用域链上面的第二个对象，包含了this、result、compare</li>\n<li>定义这个函数时，会先为它创建作用域链，然后预先将全局变量对象，并保存在内部的[[Scope]]中。调用这个函数时，会创建相应的上下文，然后通过复制函数的[[Scope]]来创建器作用域链。</li>\n<li>接着会创建函数的活动对象（用作变量对象）并把它放到作用域链的前端。上面这个例子意味着compare()函数执行上下文的作用域链中有两个变量对象：局部变量对象和全局变量对象。作用域链其实是一个包含指针的列表，每个指针分别指向一个变量对象。</li>\n<li>函数内部访问变量时，就会按照给定的名称从作用域中查找变量。函数执行完成后，局部活动对象被销毁，内存中就只剩全局作用域。</li>\n<li>函数内部定义的函数会把它的包含函数的活动对象添加到自己的作用域链中。然后它就可以访问到包含对象的全部变量，因为它有着包含对象的活动对象的引用，所以包含函数执行完成后不能销毁，只有等函数内部定义的函数被销毁它才能销毁</li>\n<li>闭包保留了它的包含函数的作用域，所以比其他函数更占内存，所以除非必要，不然不使用闭包</li>\n</ul>\n<h2>内存泄漏</h2>\n<ul>\n<li>由于IE9之前对JScript对象跟COM对象的垃圾回收机制不一致，所以闭包在旧版本可能会出问你。在部分版本下，将html闭包就会导致它不能被销毁</li>\n</ul>\n<pre><code class=\"language-js\">function assignHandler(){\n  let element = document.getElementById('someElement')\n  element.onclick = () => console.log(element.id)\n}\n</code></pre>\n<ul>\n<li>这里创建了一个闭包，即element元素的事件处理程序。事件处理程序又创建了循环引用。匿名函数引用着assignHandler的活动对象，阻止了对element的引用计数归零。所以只要匿名函数存在，element的引用次数就至少为1，所以内存无法回收</li>\n</ul>\n<pre><code class=\"language-js\">function assignHandler(){\n  let element = document.getElementById('someElement')\n  let id = element.id\n  element.onclick = () => console.log(id)\n  element = null\n}\n</code></pre>\n<ul>\n<li>这样我们把element.id替换为一个新的id字段去除了循环引用，但是还不够，因为匿名函数引用着包含对象的活动对象，活动对象包含了element。</li>\n<li>所以闭包没有直接引用element，但是包含活动对象还存在着它的引用，所以需要把它设为null解除引用</li>\n</ul>\n<h2>私有变量与特权方法</h2>\n<ul>\n<li>JavaScript没有私有成员概念，但是有私有变量的概念，在函数内部的变量都是函数私有的，函数外部无法访问。私有变量包含函数参数、局部变量、函数内部定义的其他函数</li>\n<li>特权方法是能够访问函数私有变量的公有方法。在对象上创建特权方法的方式有两种，一种是构造函数中实现</li>\n</ul>\n<pre><code class=\"language-js\">function MyObject(){\n  let privateVariable = 10\n  function privateFunction(){\n    return false\n  }\n  this.publicMethod = function(){\n    privateVariable++\n    return privateFunction()\n  }\n}\n</code></pre>\n<ul>\n<li>这是将私有变量跟方法都定义在构造函数中，然后创建一个能访问这些私有成员的特权方法，因为特权方法是一个闭包，可以访问构造函数的所有成员，所以可以使用它来访问</li>\n<li>每个特权方法都由自己的privateVariable，因为每次调用构造函数都会重新创建一套变量跟方法，也就导致这种模式有一个缺点：每个实例都会重新创建一遍新方法</li>\n<li>另一种是通过私有作用域定义私有变量跟函数来实现</li>\n</ul>\n<pre><code class=\"language-js\">(function(){\n  let privateVariable = 10\n  function privateFunction(){\n    return false\n  }\n  MyObject = function(){}\n  MyObject.prototype.publicMethod = function(){\n    privateVariable++\n    return privateFunction()\n  }\n})()\n</code></pre>\n<ul>\n<li>这里，匿名函数定义了私有变量和私有方法，然后又定义了构造函数和公有方法。公有方法定义在构造函数原型上。</li>\n<li>这里生命MyObject没有使用关键字，所以会被创建到全局作用域中，所以MyObject可以在外部被访问（严格模式下不使用关键字声明会报错）</li>\n<li>这样的话私有变量跟私有方法是全部实例共享了，因为特权方法是在原型上，所以由全部实例共享</li>\n<li>这样创建的好处就是可以更好地重用代码，但是也导致了每个实例都没有了私有变量</li>\n<li>闭包跟私有变量会让作用域链变长，作用域链越长，查找变量所需时间越长</li>\n</ul>","fields":{"slug":"/function2/"},"frontmatter":{"title":"函数-闭包--高程4","tags":["JavaScript回顾"],"categories":"JavaScript"}}},{"node":{"html":"<h1>深入Promise</h1>\n<ul>\n<li>Promise中执行resolve会有一个内部值，执行reject会有一个内部理由，默认情况下，这个值跟理由都是undefined</li>\n<li>Promise中使用reject进入拒绝态时没有进行捕获会抛出错误</li>\n</ul>\n<pre><code class=\"language-js\">let p1 = Promise.resolve()\nlet p = Promise.reject()\nsetTimeout(console.log, 0, p1) // Promise {&#x3C;resolved>: undefined}\nsetTimeout(console.log, 0, p)\n// Uncaught (in promise) undefined\n// Promise {&#x3C;rejected>: undefined}\n</code></pre>\n<ul>\n<li>Promise.resolve()可以将任何值转为Promise</li>\n</ul>\n<pre><code class=\"language-js\">setTimeout(console.log, 0, Promise.resolve(3))\n// Promise {&#x3C;resolved>: 3}\n</code></pre>\n<!--more-->\n<ul>\n<li>Promise.resolve()是一个幂等方法，这个方法中，传入的参数本身是一个Promise，那么它的行为就是一个空包装</li>\n</ul>\n<pre><code class=\"language-js\">let p2 = Promise.resolve(7)\nsetTimeout(console.log, 0, p2 === Promise.resolve(p2)) // true\nsetTimeout(console.log, 0, p2 === Promise.resolve(Promise.resolve(p2))) // true\n</code></pre>\n<ul>\n<li>Promise.resolve可以包裹一个Promise，这样的话会保留原始Promise的状态</li>\n</ul>\n<pre><code class=\"language-js\">setTimeout(console.log, 0, Promise.resolve(new Promise((resolve, reject) => { }) ))   // Promise {&#x3C;pending>}\nsetTimeout(console.log, 0, Promise.resolve(Promise.resolve(3))) // Promise {&#x3C;resolved>: 3}\nsetTimeout(console.log, 0, Promise.resolve(Promise.reject(4)))  // Promise {&#x3C;rejected>: 4}\n</code></pre>\n<ul>\n<li>通过Promise.resolve可以包装任何非Promise值，包括错误对象，并将其转为解决的期约，这样做可能出现不符合预期的行为</li>\n</ul>\n<pre><code class=\"language-js\">let p3 = Promise.resolve(new Error('foo'))\nsetTimeout(console.log, 0, p3) \nsetTimeout(console.log, 0, Promise.resolve(Promise.reject(3))) \n//Promise {&#x3C;resolved>: Error: foo\n//    at &#x3C;anonymous>:1:26}\n</code></pre>\n<ul>\n<li>Promise.reject实例化一个拒绝Promise并抛出异步错误（此错误不能通过try/catch捕获，只能通过拒绝处理程序捕获）</li>\n<li>Promise.reject没有幂等的概念，给它一个Promise对象，它会自动将该对象变为拒绝的理由</li>\n</ul>\n<pre><code class=\"language-js\">setTimeout(console.log, 0, Promise.reject(new Promise((resolve, reject) => { }) ))   // Promise {&#x3C;rejected>: Promise}\nsetTimeout(console.log, 0, Promise.reject(Promise.resolve(3))) // Promise {&#x3C;rejected>: Promise}\nsetTimeout(console.log, 0, Promise.reject(Promise.reject(4)))  // Promise {&#x3C;rejected>: Promise}\n</code></pre>\n<h2>Promise.prototype.then</h2>\n<ul>\n<li>接收两个程序处理参数，均为可选，非函数类型的参数会被静默忽略</li>\n</ul>\n<pre><code class=\"language-js\">let p4 = new Promise((res, rej) => {\n  rej(4)\n})\n// 第一个参数被静默，可以捕获到异步报错\np4.then('123', (rej) => {\n  console.log(rej)\n})\n</code></pre>\n<ul>\n<li>这里的返回值会通过Promise.resolve()进行包装返回值来生成新的Promise，如果没有显示的返回语句，就包装默认返回值undefined</li>\n<li>调用then不传处理程序，则原样向后传</li>\n</ul>\n<pre><code class=\"language-js\">let p7 = Promise.resolve('foo')\nlet p8 = p7.then(() => 6) \nlet p9 = p7.then(() => {})\nlet p10 = p7.then(() => Promise.resolve())\nsetTimeout(console.log, 0, p8)   // Promise {&#x3C;resolved>: 6}\nsetTimeout(console.log, 0, p9) // Promise {&#x3C;resolved>: undefined}\nsetTimeout(console.log, 0, p10)  // Promise {&#x3C;resolved>: undefined}\n\np7.then().then(res => {\n  console.log(res) // 'foo'\n})\n</code></pre>\n<ul>\n<li>Promise.prototype.then中的onReject捕获的错误也会通过Promise.resolve包装，这样就可以捕获错误，但是不抛出异常</li>\n</ul>\n<pre><code class=\"language-js\">let p11 = Promise.reject('foo')\nlet p12 = p11.then(null, () => undefined)\nlet p13 = p11.then(null, () => {})\nlet p14 = p11.then(null, () => Promise.resolve())\nlet p15 = p11.then(null, () => Promise.reject())\nsetTimeout(console.log, 0, p12)   // Promise {&#x3C;resolved>: undefined}\nsetTimeout(console.log, 0, p13) // Promise {&#x3C;resolved>: undefined}\nsetTimeout(console.log, 0, p14)  // Promise {&#x3C;resolved>: undefined}\nsetTimeout(console.log, 0, p15)  // Promise {&#x3C;resolved>: undefined}\n// Uncaught (in promise) undefined\n</code></pre>\n<h2>Promise.prototype.catch</h2>\n<ul>\n<li>该方法用于给Promise添加拒绝处理程序，只接受一个参数，onRejct处理程序</li>\n<li>此方法是一个语法糖，相当于调用Promise.prototype.then(null, onReject)</li>\n</ul>\n<h2>Promise.prototype.finally</h2>\n<ul>\n<li>此方法在Promise取得终态时触发，无论是onResolve或者onReject，但是无法知道Promise的结果</li>\n<li>所以此代码主要用于清理无用程序，此方法返回一个新的Promise</li>\n<li>因为它与状态无关，所以它会表现为上一个Promise的状态，无论是拒绝或者解决状态</li>\n</ul>\n<pre><code class=\"language-js\">let p1 = new Promise(() => {})\nlet p2 = p1.finally()\nsetTimeout(console.log, 0, p1)  // Promise {&#x3C;pending>}\nsetTimeout(console.log, 0, p2)  // Promise {&#x3C;pending>}\nsetTimeout(console.log, 0, p1 === p2)  // false\n\nlet p3 = Promise.resolve(1)\nlet p4 = Promise.reject(2)\nlet p5 = new Promise(() => {})\n\n// 原样后传\nlet p6 = p3.finally()\nlet p7 = p3.finally(() => {})\nlet p8 = p3.finally(() => undefined)\nlet p9 = p3.finally(() => Promise.resolve(3))\nlet p10 = p3.finally(() => Error('bar'))\nlet p11 = p4.finally()\nlet p12 = p5.finally()\n\nsetTimeout(console.log, 0, p6)  // Promise {&#x3C;resolved>: 1}\nsetTimeout(console.log, 0, p7)  // Promise {&#x3C;resolved>: 1}\nsetTimeout(console.log, 0, p8)  // Promise {&#x3C;resolved>: 1}\nsetTimeout(console.log, 0, p9)  // Promise {&#x3C;resolved>: 1}\nsetTimeout(console.log, 0, p10)  // Promise {&#x3C;resolved>: 1}\nsetTimeout(console.log, 0, p11)  // Promise {&#x3C;rejected>: 2}\nsetTimeout(console.log, 0, p12)  // Promise {&#x3C;pending>}\n</code></pre>\n<ul>\n<li>如果返回了一个待定的Promise或者在onFinally中抛出了错误（显式抛出或者返回拒绝Promise），则会返回拒绝态的Promise</li>\n</ul>\n<pre><code class=\"language-js\">let p1 = new Promise((resolve) => { resolve('foo') })\nlet p2 = p1.finally(() => Promise.reject())\nlet p3 = p1.finally(() => { throw 'bar' })\nsetTimeout(console.log, 0, p2)  // Promise {&#x3C;rejected>: undefined}\nsetTimeout(console.log, 0, p3)  // Promise {&#x3C;rejected>: \"bar\"}\n</code></pre>\n<ul>\n<li>Promise获得状态后，与该状态相关的处理程序只是被排期，并非立即执行，跟在添加这个处理程序的代码之后的同步代码一定会在处理程序之前执行</li>\n</ul>\n<pre><code class=\"language-js\">let synchronousResolve\nlet p = new Promise((resolve) => {\n  synchronousResolve = function(){\n    console.log('1: invoking resove')\n    resolve()\n    console.log('2: resolve return')\n  }\n})\np.then(() => console.log('4 then handler execute'))\nsynchronousResolve()\nconsole.log('3 synchronousResolve')\n\n// 1: invoking resove\n// 2: resolve return\n// 3 synchronousResolve\n// 4 then handler execute\n</code></pre>\n<h2>串行Promise合成</h2>\n<ul>\n<li>Promise主要特征还有：异步产生值并传给处理程序，后续处理程序可以使用这个值，很像函数合成</li>\n</ul>\n<pre><code class=\"language-js\">function addTwo(x){\n  return x + 2\n}\nfunction addThree(x){\n  return x + 3\n}\nfunction addFive(x){\n  return x + 5\n}\n\nfunction addTen(x) {\n  return addFive(addThree(addTwo(x)))\n}\n\naddTen(5) // 15\n\n// 使用Promise实现\nfunction addTwo(x){\n  return x + 2\n}\nfunction addThree(x){\n  return x + 3\n}\nfunction addFive(x){\n  return x + 5\n}\n\nfunction addTen(x) {\n  return [addTwo, addThree, addFive].reduce((promise, fn) => promise.then(fn), Promise.resolve(x))\n}\naddTen(8).then(console.log) // 18\n\n\n// 拓展实现\n\nfunction addTwo(x){\n  return x + 2\n}\nfunction addThree(x){\n  return x + 3\n}\nfunction addFive(x){\n  return x + 5\n}\nfunction compose(...fns) {\n  return (x) => fns.reduce((promise, fn) => promise.then(fn), Promise.resolve(x))\n}\nlet addTen = compose(addTwo, addThree, addFive)\naddTen(10).then(console.log) // 20\n</code></pre>\n<h2>async/await</h2>\n<ul>\n<li>async关键字用于声明异步函数。使用async可以让函数具有异步特征，但总体上代码仍然是同步求值</li>\n<li>参数与闭包方面，异步函数跟普通函数有一样的行为</li>\n</ul>\n<pre><code class=\"language-js\">async function foo(){\n  console.log(1)\n}\nconsole.log(2)\n\n// 1\n// 2\n</code></pre>\n<ul>\n<li>如果异步函数使用return关键字返回了值（没有return会返回undefined），这个值会被Promise.resolve()包装成Promise对象。</li>\n<li>异步函数始终返回Promise对象，函数外部调用该函数可以得到它返回的Promise</li>\n</ul>\n<pre><code class=\"language-js\">async function foo(){\n  console.log(1)\n  return 3\n}\nfoo().then(console.log)\nconsole.log(2)\n\n// 1\n// 2\n// 3\n\n// 跟直接返回一个Promise对象效果一致\nasync function foo(){\n  console.log(1)\n  return Promise.resolve(3)\n}\nfoo().then(console.log)\nconsole.log(2)\n\n// 1\n// 2\n// 3\n</code></pre>\n<ul>\n<li>异步函数返回值期待（但不要求）一个实现thenable接口的对象，但是常规的值也可以。如果返回的是实现thenable接口的对象，则这个对象可以由提供给then()的处理程序进行解包。如果不是，返回值就被当做已经解决的Promise</li>\n</ul>\n<pre><code class=\"language-js\">async function foo(){\n  return 'foo'\n}\nfoo().then(console.log) // foo\n\nasync function baz(){\n  const thenable = {\n    then(callback) {\n      callback('baz')\n    }\n  }\n  return thenable\n}\nbaz().then(console.log) // baz\n</code></pre>\n<ul>\n<li>在与Promise中一样，在异步函数中抛出错误会返回拒绝的Promise</li>\n</ul>\n<pre><code class=\"language-js\">async function foo(){\n  console.log(1)\n  throw 3\n}\nfoo().catch(console.log)\nconsole.log(2)\n\n// 1\n// 2\n// 3\n</code></pre>\n<ul>\n<li>拒绝Promise的错误不会被异步函数捕获（catch跟then中都无法取值）</li>\n</ul>\n<pre><code class=\"language-js\">async function foo(){\n  console.log(1)\n  Promise.reject(3)\n}\nfoo().catch(console.log).then(console.log)\nconsole.log(2)\n\n// 1\n// 2\n// VM1328:3 Uncaught (in promise) 3\n</code></pre>\n<ul>\n<li>await可以暂停异步函数代码的执行，等待Promise解决</li>\n<li>await会暂停执行异步函数后面的代码，让出JavaScript运行中的执行线程。这个行为跟生成器函数中的yield关键字是一样的</li>\n<li>await同样会尝试解包对象的值，然后将这个值传给表达式，再异步恢复异步函数的执行</li>\n</ul>\n<pre><code class=\"language-js\">async function foo(){\n  console.log(await Promise.resolve('foo'))\n}\nfoo() // foo\n\nasync function bar(){\n  return await Promise.resolve('bar')\n}\nbar().then(console.log) // bar\n</code></pre>\n<ul>\n<li>await关键字期待（但不要求）一个实现thenable接口的对象，但常规值也可以</li>\n<li>如果是实现了thenable接口的对象，await会由await来解包，如果不是，就当做已经解决的Promise</li>\n</ul>\n<pre><code class=\"language-js\">async function bar(){\n  console.log(await ['bar'])\n}\nbar() // [\"bar\"]\n\nasync function baz(){\n  const thenable = {\n    then(callback){\n      callback('baz')\n    }\n  }\n  console.log(await thenable)\n}\nbaz() // baz\n</code></pre>\n<ul>\n<li>等待会抛出错误的同步操作，返回拒绝的期约</li>\n</ul>\n<pre><code class=\"language-js\">async function foo(){\n  console.log(1)\n  await (() => { throw 3 })()\n}\nfoo().catch(console.log)\nconsole.log(2)\n\n// 1\n// 2\n// 3\n</code></pre>\n<ul>\n<li>async中我们说到，单独的Promise.reject()不会被异步函数捕获，而是抛出未捕获错误。不过，对拒绝Promise使用await会释放错误值（将拒绝Promise返回）</li>\n</ul>\n<pre><code class=\"language-js\">async function foo(){\n  console.log(1)\n  await Promise.reject(3)\n  console.log(4) // 这行代码不执行\n}\nfoo().catch(console.log)\nconsole.log(2)\n\n// 1\n// 2\n// 3\n</code></pre>\n<ul>\n<li>await必须在异步函数中使用，不能在顶级上下文如<code>&#x3C;script></code>标签或者模块中使用，同步函数中使用await会抛出SyntaxError</li>\n<li>使用await还有一些细微之处，看下面的例子</li>\n</ul>\n<pre><code class=\"language-js\">async function foo(){\n  console.log(await Promise.resolve('foo'))\n}\nasync function bar(){\n  console.log(await 'bar')\n}\nasync function baz(){\n  console.log('baz')\n}\nfoo()\nbar()\nbaz()\n\n// baz\n// bar\n// foo\n</code></pre>\n<ul>\n<li>async/await组合中，起作用的都是await，async只是一个标识符</li>\n<li>JavaScript运行时遇到await关键字会记录在哪暂停执行。等待await右边的值可以用了，JavaScript会向消息队列中推送一个任务，任务会恢复异步函数的执行</li>\n<li>所以await后面哪怕跟了可用的值，函数的其他部分也会被异步求值</li>\n</ul>\n<pre><code class=\"language-js\">async function foo(){\n  console.log(2)\n  await null\n  console.log(4)\n}\nconsole.log(1)\nfoo()\nconsole.log(3)\n\n// 1\n// 2\n// 3\n// 4\n</code></pre>\n<ul>\n<li>\n<p>上面的执行过程可以这么解读</p>\n<ul>\n<li>打印1</li>\n<li>调用异步函数foo</li>\n<li>打印2</li>\n<li>await暂停执行，为立即可用的值null向消息队列添加一个任务</li>\n<li>foo退出</li>\n<li>打印3</li>\n<li>同步线程代码执行完成</li>\n<li>JavaScript运行时从消息队列取出任务，恢复异步执行函数</li>\n<li>foo中恢复执行，await取得null值</li>\n<li>打印4</li>\n<li>foo返回</li>\n</ul>\n</li>\n<li>当await后面是一个Promise的时候会复杂一些。这个时候，为了执行异步函数，实际有两个任务被添加到消息队列并异步求值(11TC39对await后面是Promise的情况做过处理，导致只会生成一个异步任务，因此新版浏览器中会打印 123458967)</li>\n</ul>\n<pre><code class=\"language-js\">async function foo(){\n  console.log(2)\n  console.log(await Promise.resolve(8))\n  console.log(9)\n}\n\nasync function bar(){\n  console.log(4)\n  console.log(await 6)\n  console.log(7)\n}\n\nconsole.log(1)\nfoo()\nconsole.log(3)\nbar()\nconsole.log(5)\n\n// 1\n// 2\n// 3\n// 4\n// 5\n// 6\n// 7\n// 8\n// 9\n</code></pre>\n<ul>\n<li>\n<p>运行时步骤如下</p>\n<ul>\n<li>打印1</li>\n<li>调用foo</li>\n<li>打印2</li>\n<li>await暂停执行，向消息队列添加一个Promise在落定后执行的任务</li>\n<li>Promise立即落定，把给await提供值的任务添加到消息队列</li>\n<li>foo退出</li>\n<li>打印3</li>\n<li>调用bar</li>\n<li>打印4</li>\n<li>await关键字暂停执行，为立即可用的值6向消息队列中添加任务</li>\n<li>bar退出</li>\n<li>打印5</li>\n<li>顶级线程执行完成</li>\n<li>JavaScript从消息队列中取出解决awaitPromise的处理程序，将解决值8提供给它</li>\n<li>JavaScript运行时向消息队列中添加一个恢复foo执行的任务</li>\n<li>JavaScript运行时从消息队列中取出恢复执行bar的任务及6</li>\n<li>bar恢复执行，await取得6</li>\n<li>打印7</li>\n<li>bar返回</li>\n<li>异步任务完成，JavaScript从消息队列中取出恢复foo的任务及8</li>\n<li>打印8</li>\n<li>打印9</li>\n<li>foo返回</li>\n</ul>\n</li>\n<li>使用async跟await将上面的串行Promise进行优化</li>\n</ul>\n<pre><code class=\"language-js\">async function addTwo(x){\n  return x + 2\n}\nasync function addThree(x){\n  return x + 3\n}\nasync function addFive(x){\n  return x + 5\n}\n\nasync function addTen(x) {\n  for(const fn of [addTwo, addThree, addFive]) {\n    x = await fn(x)\n  }\n  return x\n}\naddTen(9).then(console.log) // 19\n</code></pre>\n<ul>\n<li>在栈管理与内存管理中，Promise会尽可能的保留完整的调用栈，这样在抛出错误时就会更好地找到错误信息位置，但是这也意味着栈追踪信息会占用内存，带来计算与存储成本。</li>\n<li>而异步函数中JavaScript运行时会简单地在嵌套函数中存储指向包含函数的指针。这个指针存在于内存中，用于出错时追踪信息。这样就不会带来而外的消耗</li>\n<li>所以在重视性能的应用中优先考虑异步函数</li>\n</ul>","fields":{"slug":"/Promise/"},"frontmatter":{"title":"深入Promise--高程4","tags":["JavaScript回顾"],"categories":"JavaScript"}}},{"node":{"html":"<h1>window对象</h1>\n<ul>\n<li>BOM的核心是window对象，表示浏览器的实例。window在浏览器中有两重身份，一个是ECMAScript中的Global对象，一个是浏览器窗口中的JavaScript接口。</li>\n<li>意味着网页中定义的所有对象、变量、函数都以window作为其Global对象</li>\n<li>所有通过var声明的全局变量或函数都会成为window对象的属性和方法</li>\n</ul>\n<h2>窗口关系</h2>\n<ul>\n<li>top对象指向最外层窗口，即浏览器本身。</li>\n<li>parent对象指向当前窗口的父窗口。如果当前窗口是最上层窗口，则parent等于top（都等于window）</li>\n<li>还有self属性，它是终极的window属性，始终指向window。这些都是window的属性，可以通过window.top的方式来访问</li>\n<li>window对象的位置可以通过不同的属性跟方法确定，现代浏览器提供了screenLet跟screentTop属性，用于确定窗口相对于屏幕左侧跟顶部的位置，返回值的单位是css像素</li>\n<li>可以使用moveTo跟moveBy来移动窗口，都接收两个参数</li>\n<li>moveTo接收要移动到的位置的绝对坐标x很y</li>\n<li>moveBy接收相对于当前位置在两个方向上的像素数</li>\n<li>这两个方法在不同的浏览器中可能会被部分或全部禁用</li>\n</ul>\n<pre><code class=\"language-js\">window.moveTo(0, 0) // 移动到左上角\nwindow.moveTo(200, 300) // 移动到坐标 200， 300\nwindow.moveBy(0, 100) // 向下移动100\nwindow.moveBy(-50, 0) // 向左移动50\n</code></pre>\n<!--more-->\n<ul>\n<li>css像素是web开发中的统一像素单位。如果屏幕距离人眼是一臂长，那计算的css像素大小大概是1/96英寸。定义像素大小是为了不同设备统一标准。</li>\n<li>低分辨力平板设备上12像素（css像素）应该跟高清4k屏幕上12像素（css像素）的文字有同样的大小，这就让不同像素密度屏幕下有不同的缩放系数，以便将物理像素转为css像素</li>\n<li>例如：手机屏幕的物理分辨率为1920 * 1080，因为其像素非常小，所以浏览器要将其分辨率将为较低的逻辑分辨率，比如640 * 320。这个物理像素与css像素之间转换比率由window.devicePixelRatio提供。对于分辨率1920 * 1080 转换为640 * 320的设备，window.devicePixelRatio值为3。这样12像素（css像素的文字）就会实际以36像素的物理像素展示</li>\n</ul>\n<h2>窗口大小</h2>\n<ul>\n<li>所有现代浏览器支持的4个属性：innerHeight、innerWidth、outerHeight、outerWidth</li>\n<li>outerWidth跟outerHeight返回浏览器窗口自身的大小（不管在外层window还是窗口frame中）。innerHeight跟innerWidth返回浏览器窗口中页面视图的大小</li>\n<li>document.documentElement.clientHeight和document.documentElement.clientWidth返回页面视口宽度和高度</li>\n<li>浏览器窗口的精确尺寸不好确定，但可以确定页面视口的大小</li>\n</ul>\n<pre><code class=\"language-js\">let pageWidth = window.innerWidth, pageHeight = window.innerHeight\nif(typeof pageWidth !== number) {\n  if(document.compatMode == 'CSS1Compat') {\n    pageWidth = document.documentElement.clientWidth\n    pageHeight = document.documentElement.clientHeight\n  } else {\n    pageWidth = document.body.clientWidth\n    pageHeight = document.body.clientHeight\n  }\n}\n</code></pre>\n<ul>\n<li>上面我们先设置为innerWidth跟innerHeight，然后再检查是否是数值决定有没有拿到，之后再通过document.compatMode来检查是否是标准模式，如果是就使用document.documentElement的方式来获取，不是就采用document.body的形式</li>\n<li>移动设备上，window.innerWidth和window.innerHeight也是返回视口的大小，也就是屏幕上可视区域的大小。Mobile Internet Explorer支持这些属性，但在document.documentElement.clientHeight和document.documentElement.clientWidth中提供了相同的信息。放大缩小页面时，这些值也会变化</li>\n<li>其他移动浏览器中，document.documentElement.clientWidth和document.documentElement.clientHeight返回的布局视口的大小，即渲染页面的实际大小。布局视口是相对于可见视口的一个概念，可见视口只能显示整个页面的一小部分。Mobile Internet Explorer把布局视口的信息保存在document.body.clientWidth和document.body.clientHeight中。放大缩小页面时，这些值也会变。</li>\n<li>可以使用resizeTo()和resizeBy()方法调整窗口大小。接收两个参数，resizeTo接收新的宽度和高度，resizeBy接收宽度和高度各缩放多少</li>\n</ul>\n<pre><code class=\"language-js\">window.resizeTo(100, 100)\nwindow.resizeBy(100, 50)\n</code></pre>\n<ul>\n<li>与移动窗口的方法一致，缩放的方法也可能被浏览器禁用，并且部分浏览器默认禁用。缩放方法只能应用到最上层window</li>\n<li>浏览器窗口尺寸通常无法满足完整显示页面，因此用户需要滚动查看。度量文档相对于视口滚动距离的属性有两对，返回相等的值：window.pageXoffset/window.scrollX和window.pageYoffset/scrollY</li>\n<li>可以使用scoroll()、scrollTo()、scrollBy()滚动页面。三个方法都接收相对视口距离的x和y坐标，前两个方法表示要滚动到的坐标，最后一个方法表示滚动的距离</li>\n</ul>\n<pre><code class=\"language-js\">// 相对当前视口向下滚动100像素跟向右40像素\nwindow.scrollBy(0, 100)\nwindow.scrollBy(40, 0)\n//滚动到页面左上角\nwindow.scrollTo(0, 0) \nwindow.scroll(0, 0)\n</code></pre>\n<ul>\n<li>这几个方法都接收一个ScrollToOptions字典，除了提供偏移值，还可以通过beghavior属性告诉浏览器是否平滑滚动。</li>\n</ul>\n<pre><code class=\"language-js\">// 正常滚动\nwindow.scrollTo({\n  left: 100,\n  top: 100,\n  behavior: 'auto'\n})\n\n// 平滑滚动\nwindow.scrollTo({\n  left: 100,\n  top: 100,\n  behavior: 'smooth'\n})\n</code></pre>\n<h2>导航与打开新窗口</h2>\n<ul>\n<li>window.open()可以用于导航到指定url，也可以用于打开新的浏览器窗口。接收4个参数：要加载的url、目标窗口、特性字符串和表示新窗口在浏览器历史记录中是否代替当前加载页面的布尔值。通常只传前3个参数，最后一个参数只有不打开新窗口才会使用。</li>\n<li>如果第二个参数已经是一个存在的窗口或窗格（frame）的名字，则会在对应的窗口或窗格中打开URL。</li>\n</ul>\n<pre><code class=\"language-js\">window.open('http://www.wrox.com/', 'topFrame')\n</code></pre>\n<ul>\n<li>上面代码跟点击链接的形式一致，如果已经有一个窗口名叫'topFrame'，则这个窗口会打开这个URL，否则就新打开一个窗口并命名为'topFrame'，第二个参数也可以是特殊的窗口名，比如<em>self、</em>parent、<em>top、</em>blank</li>\n<li>如果第二个参数不是已有窗口就会打开新的窗口或标签页。</li>\n<li>第三个窗口为特性字符串，用于指定新窗口的配置。要是不传第三个参数，则带有所有默认的浏览器特性。打开的不是新窗口就忽略第三个参数。</li>\n<li>\n<p>特性选项表</p>\n<ul>\n<li>fullscreen: \"yes\" 或 \"no\"，表示窗口是否最大化</li>\n<li>height: 数值，新窗口高度，不小于100</li>\n<li>left: 数值，窗口x坐标，不能是负值</li>\n<li>location: \"yes\"或\"no\"，是否显示地址栏</li>\n<li>Menubar: \"yes\"或\"no\"，是否显示菜单栏</li>\n<li>resizable: \"yes\"或\"no\"，是否可以拖动改变新窗口大小</li>\n<li>scrollbars: \"yes\"或\"no\"，内容过长时是否可以滚动</li>\n<li>status: \"yes\"或\"no\"，是否显示状态栏</li>\n<li>toolbar: \"yes\"或\"no\"，是否显示工具栏</li>\n<li>top: 数值，新窗口的y值，不能为负值</li>\n<li>width: 数值，新窗口宽度，不能小于100</li>\n</ul>\n</li>\n<li>这些设置需要以逗号分割的键值对出现，特性字符串不能有空格</li>\n</ul>\n<pre><code class=\"language-js\">window.open('http://www.wrop.com/', 'wroxWindow', 'height=400,width=300,top=10,left=10,resizable=yes')\n</code></pre>\n<ul>\n<li>上面会打开一个可缩放的窗口，大小为400 * 300，位于屏幕左边即上面各10像素</li>\n<li>window.open返回一个对新窗口的引用。这个对象跟普通window对象一样，只是为控制新窗口提供了便利。某些浏览器不允许缩放跟移动主窗口，但是允许缩放和移动通过open打开的新窗口。</li>\n</ul>\n<pre><code class=\"language-js\">let worxWin1 = window.open('http://www.wrop.com/', 'wroxWindow1', 'height=400,width=300,top=10,left=10,resizable=yes')\nworxWin1.resizeTo(500, 500)\nworxWin1.moveTo(100, 100)\nworxWin1.close()\nconsole.log(worxWin1.closed) // true\n</code></pre>\n<ul>\n<li>还可以使用close关闭open创建的窗口，关闭窗口后，窗口引用还在，但只能检查closed属性了</li>\n<li>新创建窗口的window对象有一个opener指向打开它的窗口。这个属性只在弹出窗口的最上层window对象有定义，指向调用window.open打开它的窗口的指针</li>\n<li>某些浏览器标签页在独立进程中运行，如果一个标签页打开了另一个，而window对象需要跟另一个标签页通信，那标签便不能运行在独立的进程中。这些浏览器中可以将打开标签页的opener设为null，表示新打开的标签页可以运行在独立的进程中。</li>\n<li>把opener设置为null表示新打开的标签页不需要与打开它的标签页通信，因此可以独立进程运行。这个链接一旦切断无法恢复</li>\n</ul>\n<h2>安全限制</h2>\n<ul>\n<li>弹出窗口刚开始被在线广告给滥用，将广告伪装成系统对话框，诱导用户点击。为了让用户区分，浏览器对弹窗做了限制</li>\n<li>IE7开始，地址栏不能隐藏了，弹窗默认不可缩放不可移动。Firefox禁用了隐藏状态栏的功能，Firefox强制弹窗始终显示地址栏。Opera只能在主窗口打开新窗口，不允许它们出现在系统对话框内。</li>\n<li>浏览器需要在用户允许时才能创建弹窗。网页加载中创建弹窗无效还可能报错。要点击或者按下键才可以打开弹窗</li>\n<li>现在浏览器内置了屏蔽程序，如果屏蔽程序屏蔽了弹窗，那window.open会返回null，可以通过这个来判断弹窗是否被屏蔽</li>\n</ul>\n<pre><code class=\"language-js\">let wroxWin = window.open('http://www.wrox.com', \"_blank\")\nif(wroxWin === null) {\n  console.log('the popup was blocked')\n}\n</code></pre>\n<ul>\n<li>浏览器拓展或者其他程序屏蔽弹窗时，window.open通常会抛出错误，因此要准确检测弹窗是否被屏蔽，除了检测window.open的返回值，还要将它用try/catch包裹</li>\n</ul>\n<pre><code class=\"language-js\">let blocked = false\ntry {\n  let wroxWin = window.open('http://www.wrox.com', \"_blank\")\n  if(wroxWin === null) {\n    console.log('the popup was blocked')\n    blocked = true\n  }\n} catch(e) {\n  blocked = true\n}\n\nblocked &#x26;&#x26; console.log(blocked)\n</code></pre>\n<h2>定时器</h2>\n<ul>\n<li>setTimeout的第二个参数是告诉JavaScript引擎在指定的毫秒数后将任务添加到任务队列，任务队列如何是空的，会立即执行，如果不是空的，需要等前面的任务执行完才能执行</li>\n<li>所有setTimeout执行的代码都会在全局作用域的一个匿名函数中执行，因此函数中的this在非严格模式下都是window，在严格模式下是undefined。要是提供的是箭头函数，this会保留它定义时所在的作用域</li>\n<li>setInterval的第二个参数是向队列添加新任务前的等待时间。它不关心任务什么时候执行或者执行花多长时间，是否有阻塞，只会往队列内添加任务</li>\n<li>setInterval在实践中很少会在生产环境下使用，因为一个任务跟下一个任务之间的时间间隔是无法确定的，有些循环定时任务就可能会被跳过。setTimeout就能确保不出现这种情况</li>\n<li>所以一般来说最好不要用setInterval。我们可以使用setTimeout来替换</li>\n</ul>\n<h2>系统对话框</h2>\n<ul>\n<li>alert接收一个字符串并弹出一个只有确认按钮的弹窗，只接受字符串，非字符串会使用toString转为字符串</li>\n<li>confirm确认框，有两个按钮，取消和确认。返回值为按钮的点击情况，true表示点击了确认，false表示点击了取消</li>\n</ul>\n<pre><code class=\"language-js\">if(confirm('Are you sure')) {\n  console.log('I am sure')\n} else {\n  console.log('I am sorry')\n}\n</code></pre>\n<ul>\n<li>prompt提供一个供用户输入的提示框，也有取消和确认的按钮，还有一个输入文本框。prompt()接收两个参数：要显示给用户的文本，以及文本框的默认值。</li>\n<li>点击确认按钮，该方法返回文本框中的值，点击取消按钮，或者被关闭，该方法返回null</li>\n</ul>\n<pre><code class=\"language-js\">let result = prompt(\"What is your name ?\", \"\")\nif(result !== null) {\n  console.log(`welcome ${ result }`)\n}\n</code></pre>\n<ul>\n<li>很多浏览器对系统对话框加了特殊功能。如果网页中的脚本生成了两个或更多的对话框，则除第一个外的对话框都展示一个复选框，用户选中就会禁用后续的弹窗，直到页面刷新。</li>\n<li>用户选中复选框，那在页面刷新之前，所有系统对话框都被拼比，开发者无法获取弹窗是否显示了。要是用户两次独立的操作产生的警告框，不会显示复选框，要是一次操作产生的就会产生复选框</li>\n<li>find()是异步显示，跟用户在浏览器菜单选择查找时一致</li>\n<li>print()也是异步显示，跟用户在浏览器选择打印时显示的一致，不受用户禁用弹窗的限制</li>\n</ul>","fields":{"slug":"/BOM-window/"},"frontmatter":{"title":"BOM —— window对象","tags":["JavaScript回顾"],"categories":"JavaScript"}}},{"node":{"html":"<h1>location对象与navigator对象</h1>\n<h2>location对象</h2>\n<ul>\n<li>location是常用的BOM对象，提供了当前窗口中加载文档的信息，以及常用的导航功能</li>\n<li>它既是window属性，也是document属性，window.location跟document.location两个指向同一个对象</li>\n<li>location对象保存着当前加载文档的信息，还有URL解析为离散片段后能够属性访问的信息。</li>\n<li>\n<p>以下URL来做实例 \"<a href=\"http://ouser:barpassword@www.wrox.com:80/WileyCDA/?q=javascript#contents\">http://ouser:barpassword@www.wrox.com:80/WileyCDA/?q=javascript#contents</a>\"</p>\n<ul>\n<li>location.hash: '#contents',散列值，#后跟零或者多个字符串，没有就是空字符串</li>\n<li>location.host: 'www.wrox.com:80'，服务器名及端口号</li>\n<li>locaion.hostname: 'www.wrox.com'，服务器名</li>\n<li>location.href: '<a href=\"http://www.wrox.com:80/WileyCDA/?q=javascript#contents&#x27;\">http://www.wrox.com:80/WileyCDA/?q=javascript#contents'</a>, 当前加载页面的完整URL。location.toString就返回这个值</li>\n<li>location.pathname: '/WileyCDA/'，URL中的路径和（或）文件名</li>\n<li>location.port: \"80\"，请求的端口，如果URL中没有端口返回空字符串</li>\n<li>location.portocol: 'http:'，页面使用协议，一般是\"http:\"或\"https:\"</li>\n<li>location.search: \"?q=javascript\"，URL的查询字符串，以问号开头</li>\n<li>location.username: 'ouser'，域名前指定的用户名</li>\n<li>location.password: 'barpassword'，域名前指定的密码</li>\n<li>location.origin: '<a href=\"http://www.wrox.com&#x27;%EF%BC%8CURL%E7%9A%84%E6%BA%90%E5%9C%B0%E5%9D%80%EF%BC%8C%E5%8F%AA%E8%AF%BB\">http://www.wrox.com'，URL的源地址，只读</a></li>\n</ul>\n</li>\n<li>\n<p>URL中的多数信息都能通过以上方法获取，search中的查询字符串就需要我们单独处理了</p>\n<!--more-->\n<pre><code class=\"language-js\">function getQueryStringArgs (search){\nlet qs = (search.length > 0 ? search.substring(1) : '')\nlet args = {}\nfor(let item of qs.split('&#x26;').map(kv => kv.split('='))) {\nlet name = decodeURIComponent(item[0]), value = decodeURIComponent(item[1])\nif(name.length) {\n  args[name] = value\n}\n}\nreturn args\n}\nlet qs = '?q=javascript&#x26;num=10'\nconsole.log(getQueryStringArgs(qs)) // {q: \"javascript\", num: \"10\"}\n</code></pre>\n</li>\n<li>URLSearchParams提供了标准API来检查和修改字符串。给URLSearchParams构造函数传入一个查询字符串，就可以创造一个实例，实例暴露了get()、set()、delete()等方法。</li>\n<li>大多数支持URLSearchParams的浏览器也都支持URLSearchParams作为迭代对象</li>\n</ul>\n<pre><code class=\"language-js\">let qs = '?q=javascript&#x26;num=10'\nlet searchParams = new URLSearchParams(qs)\n\nfor(let params of searchParams) {\n  console.log(params)\n}\n// [\"q\", \"javascript\"]\n// [\"num\", \"10\"]\n\nconsole.log(searchParams.toString()) // q=javascript&#x26;num=10\nconsole.log(searchParams.has(\"num\")) // true\nconsole.log(searchParams.get(\"num\")) // 10\nsearchParams.set(\"page\", \"3\")\nconsole.log(searchParams.toString()) // q=javascript&#x26;num=10&#x26;page=3\nsearchParams.delete(\"q\")\nconsole.log(searchParams.toString()) // num=10&#x26;page=3\n</code></pre>\n<ul>\n<li>可以通过修改location对象修改浏览器地址。常用的是使用assign并传入URL</li>\n</ul>\n<pre><code class=\"language-js\">location.assign('http://www.wrox.com')\n</code></pre>\n<ul>\n<li>这行代码会启动导航到新URL，同时在浏览器历史记录中加一条。给location.href或window.location设置一个url也会以同一个URL来调用assign方法，下面的方法跟显示调用assign一样</li>\n</ul>\n<pre><code class=\"language-js\">window.location = 'http://www.wrox.com'\nlocation.href = 'http://www.wrox.com'\n</code></pre>\n<ul>\n<li>修改location对象的属性也会修改当前加载页面。hash、search、hostname、pathname、port设置后都会修改当前URL，如下例所示</li>\n</ul>\n<pre><code class=\"language-js\">// 假设当前URL为 http://www.wrox.com/WileyCDA/\n// 修改为 http://www.wrox.com/WileyCDA/#section1\nlocation.hash = '#section1'\n// 修改为 http://www.wrox.com/WileyCDA/?q=javascript\nlocation.search = '?q=javascript'\n// 修改为 http://www.somewhere.com/WileCDA/\nlocation.hostname = 'www.somewhere.com'\n// 修改为 http://www.wrox.com/myDir/\nlocation.pathname = 'myDir'\n// 修改为 http://www.wrox.com:8080/WileyCDA/\nlocation.port = 8080\n</code></pre>\n<ul>\n<li>除hash外，只要修改location的属性，就会导致页面重新加载URL</li>\n<li>修改hash的值会在浏览器历史中新增一个记录。早期的IE浏览器点击后退跟前进不会更新hash属性，只有点击包含散列的URL才会更新hash值</li>\n<li>前面的方式修改URL后都会在历史记录中新增URL。点击后退就会返回到前页面，使用replace()方法可以不添加历史记录</li>\n<li>reload()可以重新加载当前的页面，不传参数会议最有效的方式加载，如果页面从上次请求后没有修改过，会从缓存加载。要强制从服务器重新加载，可以传一个true来让它强制从服务器加载，reload之后的代码可能执行可能不执行，取决于当前的网络延迟与系统资源</li>\n</ul>\n<h2>navigator对象</h2>\n<ul>\n<li>navigator是客户端标识浏览器的标准，浏览器启动JavaScript就会存在navigator对象。</li>\n<li>\n<p>每个浏览器都有自己支持的属性。navigator主要实现了下列属性和方法</p>\n<ul>\n<li>activeVrDisplays: 返回数组，包含ispresenting为true的VRDisplay实例</li>\n<li>appCodeName: 非Mozilla也会返回\"Mozilla\"</li>\n<li>appName: 浏览器全名</li>\n<li>appVersion: 浏览器版本，一般跟实际版本不符合</li>\n<li>battery: 返回暴露Battery Status API的BatteryManager对象</li>\n<li>buildId: 浏览器的构建编号</li>\n<li>connection: 返回暴露Network Information API的NetworkInformation对象</li>\n<li>cookieEnable: 布尔值表示是否启用了cookie</li>\n<li>credentials: 返回暴露Credentials Management API的CredentialsContainer对象</li>\n<li>deviceMemory: 返回单位为GB的设备内存容量</li>\n<li>doNotTrack: 返回用户的“不跟踪”(do-not-track)设置</li>\n<li>geolocation: 返回暴露Gelolocation</li>\n<li>getVRDisplays(): 返回数组，包含可用的每个VRDisplay实例</li>\n<li>getUserMedia(): 返回与可用媒体设备硬件关联的流</li>\n<li>hardwareConcurrency: 返回设备的处理器设备核心</li>\n<li>javaEnabled: 返回是否启用java的布尔值</li>\n<li>language: 返回浏览器的主语言</li>\n<li>languages: 返回浏览器偏好的语言数组</li>\n<li>locks: 返回暴露 Web Locks API的LockManager对象</li>\n<li>mediaCapabilities: 返回暴露MediaCapabilities API的MediaCapabilities对象</li>\n<li>mediaDevices: 返回可用的媒体设备</li>\n<li>maxTouchPoints: 返回设备触摸屏支持的最大触点数</li>\n<li>mimeTypes: 返回浏览器注册的MIME类型数组</li>\n<li>onLine: 返回表示浏览器是否联网的布尔值</li>\n<li>oscpu: 返回浏览器运行设备的操作系统和CPU</li>\n<li>permissions: 返回暴露Permissions API的Permissions对象</li>\n<li>platform: 返回浏览器运行的系统平台</li>\n<li>plugins: 返回浏览器中安装的插件数组，IE中包含页面中的所有<embed>元素</li>\n<li>product: 返回产品名称（一般是\"Gecko\"）</li>\n<li>productSub: 返回产品的额外信息（一般是Gecko的版本）</li>\n<li>registerProtocolHandler(): 讲一个网站注册为特定协议的处理程序</li>\n<li>requestMediaKeySystemAccess(): 返回一个Promise，解决为MediaKeySystemAccess对象</li>\n<li>sendBeacon(): 异步传输小数据</li>\n<li>serviceWorker: 返回用来与ServiceWorker实例交互的ServiceWorkerContainer</li>\n<li>share(): 返回当前平台的原生共享机制</li>\n<li>storage: 返回暴露Storage API的StorageManger对象</li>\n<li>userAgent: 返回浏览器的用户代理字符串</li>\n<li>verdor: 返回浏览器的产商名称</li>\n<li>verdorSub: 返回浏览器厂商的更多信息</li>\n<li>vibrate()：触发设备震动</li>\n<li>webdriver:返回浏览器是否能被自动化程序控制</li>\n</ul>\n</li>\n<li>navigator一般用来判断浏览器的类型</li>\n<li>\n<p>检测插件，除IE10以下的浏览器都可以根据plugins数组来确定。数组中的每一项都有如下属性</p>\n<ul>\n<li>name: 插件名称</li>\n<li>description: 插件介绍</li>\n<li>filename: 插件的文件名</li>\n<li>length: 由当前插件处理的MIME类型数量</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"language-js\">function hasPlugin(name){\n  name = name.toLowerCase()\n  for(let plugin of window.navigator.plugins) {\n    if(plugin.name.toLowerCase().indexOf(name) > -1) {\n      return true\n    }\n  }\n  return false\n}\n</code></pre>\n<ul>\n<li>plugins数组中的每个插件对象都有一个MimeType对象，可以通过中括号访问。每个MimeType都有四个属性：descriptor描述MIME类型，enabledPlugin是指向该插件的指针，suffixes是该MIME类型对应拓展名的逗号分割的字符串，type是完整的MIME类型字符串。</li>\n<li>IE11的window.navigator支持plugins和mimeTypes属性。IE11中的ActiveXObject从DOM中隐身，不可再用来检测特性</li>\n<li>IE10及以下的版本检测插件比较麻烦，因为不支持Netscape式的插件。要使用ActiveXObject，并尝试实例化特定插件。</li>\n<li>IE中的插件实习为COM对象，由唯一字符串标识。所以检测插件就必须知道COM标识符。Flah的标识符是\"ShockwaveFlash.ShockwaveFlash\"，有了信息就可以检测插件了</li>\n</ul>\n<pre><code class=\"language-js\">function hasIEPlugin(name){\n  try{\n    new ActiveXObject(name)\n    return true\n  } catch(e) {\n    return false\n  }\n}\n</code></pre>\n<ul>\n<li>plugins有一个refresh()方法，用于刷新plugins属性以反映新安装的插件。接受一个参数布尔值表示刷新时是否重新加载页面。传入true则所有包含插件的页面都会重新加载，否则只刷新plugins，不会从新加载页面</li>\n</ul>\n<h2>注册处理程序</h2>\n<ul>\n<li>现代浏览器支持navigator上的registerProtocolHandler()方法。可以把一个网站注册为处理某种特定类型信息应用程序。在线SSR阅读器跟电子邮件客户端的流行，可以借助这个方法将Web应用程序注册为像桌面软件一样的默认程序。</li>\n<li>使用registerProtocolHandler()方法，必须传入3个参数：要处理的协议（如\"mailto\"或\"ftp\"）、处理该协议的URL、以及应用名称。如下</li>\n</ul>\n<pre><code class=\"language-js\">navigator.registerProtocolHandler('mailto', 'http://www.somemailcient.com?cmd=%s', 'Some Mail Client')\n</code></pre>\n<ul>\n<li>这个例子为\"mailto\"协议注册一个处理程序，这样邮件地址就可以通过指定的Web应用程序打开。第二个参数是负责处理请求的URL，%s表示原始请求</li>\n</ul>\n<h2>screen对象</h2>\n<ul>\n<li>\n<p>screen对象保存纯粹的客户端能力信息，也就是浏览器窗口外面的客户端显示器的信息，比如像素宽度与像素高度。属性如下</p>\n<ul>\n<li>availHeight: 屏幕像素高度减去系统组件高度（只读）</li>\n<li>availLeft: 没有被系统组件占用的屏幕最左侧像素（只读）</li>\n<li>availTop: 没有被系统组件占用的屏幕最顶端像素（只读）</li>\n<li>availWidth: 屏幕像素宽度减去系统组件宽度（只读）</li>\n<li>colorDepth: 屏幕颜色的位数，多数系统是32（只读）</li>\n<li>height: 屏幕像素高度</li>\n<li>left: 当前屏幕左边的像素距离</li>\n<li>pixelDepth: 屏幕的位深（只读）</li>\n<li>top:当前屏幕顶端的像素距离</li>\n<li>width:屏幕像素宽度</li>\n<li>orientation:返回Screen Orientation API中屏幕朝向</li>\n</ul>\n</li>\n</ul>\n<h2>history</h2>\n<ul>\n<li>history对象表示当前窗口建立以来用户的导航历史记录。对象不会对外暴露用户访问过的URL，可以在不知道实际URL的情况下前进和后退</li>\n<li>go()可以在用户历史记录中前进和后退。只接受一个参数，表示前进或后退多少。负值表示后退（类似点击浏览器的后退按钮），正值表示历史记录中前进</li>\n</ul>\n<pre><code class=\"language-js\">history.go(-1) // 后退一页\nhistory.go(1) // 前进一页\nhistory.go(2) // 前进两页\n</code></pre>\n<ul>\n<li>部分旧版浏览器中，go()方法参数可以是一个字符串，这种情况下浏览器会导航到历史中包含该字符串的第一个位置。可能前进也可能后退。如果没有匹配到就什么也不做</li>\n<li>go()有两个简写方法：back()与forward()</li>\n</ul>\n<pre><code class=\"language-js\">history.go('wrox.com')\nhistory.back()\nhistory.forawrd()\n</code></pre>\n<ul>\n<li>history对象还有一个length属性，表示有多个条目，对于第一个页面，history.length为1，通过这个方法可以确定用户浏览起点是不是你的页面</li>\n</ul>\n<h2>历史状态管理</h2>\n<ul>\n<li>hashChange在页面URL散列发生变化时被触发，开发者可以执行部分操作。状态管理API就可以让开发者改变浏览器URL而不用加载新页面。使用history.pushState()方法。接收3个参数：一个state对象、一个新状态的标题和一个（可选的）相对URL：例如</li>\n</ul>\n<pre><code class=\"language-js\">let stateObject = {foo: 'bar'}\nhistory.pushState(stateObject, 'My title', 'baz.html')\n</code></pre>\n<ul>\n<li>pushState方法执行后，状态信息会被推到历史记录中，浏览器地址栏会改变。除了这个变化外，即使location.href返回的是地址栏中的内容，浏览器也不会发送请求。第二个参数并未被当前实现使用，所以可以传一个空字符串或者一个短标题。</li>\n<li>第一个参数应该包含正确初始化页面状态所需的信息。状态大小有限制，通常在500k-1M以内</li>\n<li>pushState()会创建新的历史记录，所以会启用后退按钮，点击后退触发window对象的popstate事件。popstate事件有一个state属性，包含通过pushState第一个参数传入的state对象：</li>\n</ul>\n<pre><code class=\"language-js\">window.addEventListener('popstate', (event) => {\n  let state = event.state\n  if(state) {\n    console.log(state)\n  }\n})\n</code></pre>\n<ul>\n<li>基于这个状态应该把页面重置为状态锁边傲视的状态（浏览器不会为你做这些）。页面初次加载时没有状态，所以点击后退返回到最初页面时，event.state为null</li>\n<li>可以通过history.state获取当前的状态对象，也可以使用replaceState()并传入与pushState同样的前两个参数来更新状态。更新状态不会创建新历史，只会覆盖当前状态：</li>\n</ul>\n<pre><code class=\"language-js\">history.replaceState({ newFoo: 'newBar' }, 'New Title')\n</code></pre>\n<ul>\n<li>传给pushState与replaceState的state对象应该只包含可以被序列化的内容。所以DOM信息不适合放到状态对象里面。</li>\n</ul>","fields":{"slug":"/locationAndNavigator/"},"frontmatter":{"title":"location对象与navigator对象","tags":["JavaScript回顾"],"categories":"JavaScript"}}},{"node":{"html":"<h1>客户端检测</h1>\n<ul>\n<li>客户端在Web开发中是绕不过的话题，浏览器之间的差异与奇异行为，让我们必须使用客户端检测来进行补救，常见的补救方式为先设计最常用的方案，然后针对其他浏览器进行补救</li>\n</ul>\n<h2>能力检测</h2>\n<ul>\n<li>能力检测基于JavaScript测试浏览器是否支持某种特性，不需要知道浏览器的信息，只需要知道这种能力浏览器是否存在即可，常见的IE5之前没有document.getElementById()方法，但可以通过document.all属性实现同样的功能</li>\n</ul>\n<pre><code class=\"language-js\">function getElement(id){\n    if(document.getElementById){\n        return document.getElementById(id)\n    } else if(document.all) {\n        return document.all[id]\n    } else {\n        throw new Error('No way to retrive element')\n    }\n}\n</code></pre>\n<ul>\n<li>能力检测最有效的就是检测属性不仅存在，还要能够有预期的表现，以确定一个对象是否可以排序时</li>\n</ul>\n<pre><code class=\"language-js\">// 错误形式\nfunction isSortable(object) {\n    return !!object.sort\n}\nisSortable({ sort: true })\n\n// 正确形式\nfunction isSortable(object){\n    return typeof object.sort === 'function'\n}\n</code></pre>\n<!--more-->\n<ul>\n<li>恰当的使用能力检测可以分析运行代码的浏览器，一般将这些按照能力归类浏览器的操作集中进行，不用等到执行代码在检测</li>\n</ul>\n<pre><code class=\"language-js\">// 浏览器是否支持Netscape式的插件\nlet hasNSPugins = !!(navigator.plugins &#x26;&#x26; navigator.plugins.length)\n// 是否具有DOM Level 1 能力\nlet hasDom1 = !!(document.getElementById &#x26;&#x26; document.createElenment &#x26;&#x26; document.getElementByTagName)\n</code></pre>\n<ul>\n<li>下面是根据浏览器独特行为判断浏览器身份的方法</li>\n</ul>\n<pre><code class=\"language-js\">class BrowserDetector {\n    constructor(){\n        // IE6 - IE 10\n        this.isIE_Gte6Lte10 = /*@cc_on!@*/false\n        // IE7 - 11支持\n        this.isIEGte7Lte11 = !!document.documentMode\n        // Edge 20及以上\n        this.isEdge_Gte20 = !!window.StyleMedia\n        // 所有Firefox\n        this.isFirefox_Gte1 = typeof InstanllTrigger !== 'undefined'\n        // chrome对象\n        this.isChrome_Gte1 = !!window.chrome &#x26;&#x26; !!window.chrome.webstore\n        // safari 3-9.1\n        this.isSafari_Gte3Lte9_1 = /constructor/i.test(window.Element)\n        // safari 7.1及以上\n        this.isSafari_Gte7_1 = (({ pushNotification = {} } = {}) => pushNotification.toString() == '[object SafariRemoteNotification]')(window.safari)\n        // opera 20及以上\n        this.isOpera_Gte20 = !!window.opr &#x26;&#x26; !!window.opr.addons\n    }\n\n    isIE(){\n        return this.isIE_Gte6Lte10 || this.isIEGte7Lte11\n    }\n    isEdge(){\n        return this.isEdge_Gte20 &#x26;&#x26; !this.isIE()\n    }\n    isFirefox(){\n        return this.isFirefox_Gte1\n    }\n    isChrome(){\n        return this.isChrome_Gte1\n    }\n    isSafari(){\n        return this.isSafari_Gte3Lte9_1 || this.isSafari_Gte7_1\n    }\n    isOpera(){\n        return this.isOpera_Gte20\n    }\n}\n</code></pre>\n<h2>用户代理检测</h2>\n<ul>\n<li>用户代理检测可以通过浏览器的用户代理字符串确定使用的浏览器。用户代理字符串包含在每个http请求头的头部，JavaScript中可以通过navigator.useAgent访问。在服务器端，浏览器通过用户代理字符串确定浏览器并执行操作。</li>\n<li>但在客户端，用户代理字符串都被认为不可靠，因为很长一段时间，浏览器都通过用户代理字符串包含错误或诱导信息欺骗服务器</li>\n<li>http规范（1.0和1.1）要求浏览器要向服务器发送包含浏览器名称和版本信息的简短字符串。一般要求用户代理字符串应该以“标记/版本”形式的产品列表</li>\n<li>为分析代码运行在什么浏览器下，开发者一般会用window.navigator.userAgent返回的字符串值来分析。</li>\n<li>相比于能力检测，用户代理检测的优势在于：能力检测可以保证脚本不必理会浏览器而正常执行。现代浏览器用户代理字符串的过去、现在和未来都是有章可循的，可以准确识别。</li>\n</ul>\n<h2>伪造用户代理</h2>\n<ul>\n<li>通过检测用户代理来识别浏览器并不是完美的方式，因为它可以造假。不过所有实现window.navigator对象的浏览器都提供userAgent只读属性，简单的给它设置其他值不会生效。</li>\n<li>但是有很多简单的方法可以绕过这个限制，有些浏览器提供了<strong>defineGetter</strong>方法，利用它可以篡改用户代理字符串</li>\n</ul>\n<pre><code class=\"language-js\">console.log(window.navigator.userAgent)\n\nwindow.navigator.__defineGetter__('userAgent', () => 'foo')\nconsole.log(window.navigator.userAgent)\n</code></pre>\n<ul>\n<li>所以如果我们相信浏览器返回的用户代理字符串，那就可以用来判断浏览器。如果怀疑脚本或浏览器修改，那还是使用能力检测</li>\n</ul>","fields":{"slug":"/client_detect/"},"frontmatter":{"title":"客户端检测--高程4","tags":["JavaScript回顾"],"categories":"JavaScript"}}},{"node":{"html":"<h1>DOM</h1>\n<ul>\n<li>文档对象类型（DOM,Document Object Model）是HTML和XML文档的编程接口。DOM表示由多层节点构成的文档，通过它开发者可以添加、删除、修改页面部分。DOM现在是真正跨平台、语言无关的表示和操作王爷的方式。</li>\n<li>IE8及以下的DOM都是通过COM对象实现的，也就是这些版本中的DOM对象与原生JavaScript具有不同的行为和功能。</li>\n<li>document为每个文档的根节点。根节点的唯一子节点是html，我们成为文档元素(documentElement)，每个文档只能有一个文档元素。HTML页面中，文档元素始终是<html>元素，XML文档中就没有这个限制。</li>\n<li>DOM中有12中节点类型，这些类型都继承一种基本类型。</li>\n</ul>\n<h2>Node类型</h2>\n<ul>\n<li>DOM Level 1描述了名为Node的接口，这个接口是所有DOM节点类型都必须实现的。Node接口在JavaScript中被实现为Node类型，除IE外的所有浏览器都可以直接访问这个类型。所有节点类型都继承Node类型，因此所有类型都共享相同的基本属性和方法</li>\n<li>\n<p>每个节点都有nodeType属性，表示该节点的类型，类型值如下</p>\n<ul>\n<li>Node.ELEMENT_NODE (1)</li>\n<li>Node.ATTRIBUTE_NODE (2)</li>\n<li>NODE.TEXT_NODE (3)</li>\n<li>NODE.CDATA<em>SECTION</em>NODE (4)</li>\n<li>NODE.ENTITY<em>REFERENCE</em>NODE (5)</li>\n<li>NODE.ENTITY_NODE (6)</li>\n<li>NODE.PROCESSING<em>INSTRUCTION</em>NODE (7)</li>\n<li>NODE.COMMENT_NODE (8)</li>\n<li>NODE.DOCUMENT_NODE (9)</li>\n<li>NODE.DOCUMENT<em>TYPE</em>NODE (10)</li>\n<li>NODE.DOCUMENT<em>FRAGMENT</em>NODE (11)</li>\n<li>NODE.NOTATION_NODE (12)</li>\n</ul>\n</li>\n<li>\n<p>节点类型可以与这些常量对比</p>\n<!--more-->\n<pre><code class=\"language-js\">if(someNode.nodeType == NODE.ELEMENT_NODE) {\nconsole.log(\"Node is an element\")\n}\n</code></pre>\n</li>\n<li>nodeName与nodeValue保存节点的相关信息，使用前最好先检测节点类型，对元素而言，nodeName始终为元素的标签名，nodeValue则为null</li>\n</ul>\n<pre><code class=\"language-js\">if(someNode.nodeType == 1) {\n    value = someNode.nodeName // 元素的标签名\n}\n</code></pre>\n<ul>\n<li>每个节点都有一个childNodes属性，包含一个NodeList的实例。NodeList是一个类数组对象那个，用于存储按位置存储的有序节点。</li>\n<li>NodeList是对DOM的查询，DOM的变动会自动在NodeList中反映出来，我们说的NodeList是实时的活动对象，不是第一次访问时所获得内容的快照</li>\n<li>可以使用中括号或者使用item()方法访问NodeList中的元素</li>\n</ul>\n<pre><code class=\"language-js\">let firstChild = someNode.childNodes[0]\nlet secondChild = someNode.childNodes.item(1)\n</code></pre>\n<ul>\n<li>每个节点都有一个parentNode属性，指向DOM树中的父元素。childNodes所有节点都有一个父元素，所以它们的parentNode都指向同一个节点，而且childNodes列表中的每个节点都是其他节点的同胞节点，可以使用previousSibling和nextSibling可以用来在其中导航。列表第一个元素的previousSibling跟最后一个节点的nextSibling属性都是null</li>\n<li>父节点的firstChild属性与lastChild属性分别指向它的第一个和最后一个子节点。只有一个子节点，firstChild与lastChild指向同一个节点，没有子节点就都是null</li>\n<li>一个节点可以调用hasChildNodes()返回true说明节点有一个或多个子节点。</li>\n<li>所有节点都共享的关系。ownerDocument属性是指向整个文档的文档节点的指针。</li>\n</ul>\n<h2>操纵节点</h2>\n<ul>\n<li>appendChild()用于在childNodes列表尾部添加节点，并更新相关的关系指针（如firstChild等），返回值为新添加的节点</li>\n</ul>\n<pre><code class=\"language-js\">let returnNode = someNode.appendChild(newNode)\nconsole.log(returnNode === newNode) // true\nconsole.log(someNode.lastChild === newNode) // true\n</code></pre>\n<ul>\n<li>如果把文档中已经存在的节点传入appendChild中，那这个节点会被移动到新位置。如果传入了这个节点的第一个子节点，那这个子节点就会变成最后一个子节点</li>\n<li>可以使用insertBefore()将节点放到childNodes中的特定位置，接受两个参数：要插入的节点和参照节点，调用方法后，插入的节点变成参照节点的前一个节点，并被返回，如果参照节点为null，那调用效果与appendChild相同</li>\n<li>replaceChild()接受两个参数：要插入的节点和要替换的节点，要替换的节点会被返回并从文档中移除。</li>\n<li>removeChild()可以移除节点，接收一个参数：要移除的节点，被移除的节点会被返回</li>\n<li>所有节点类型还共享了两个方法</li>\n<li>cloneNode()会返回一个与节点一样的节点。接收一个参数表示是否深复制。为true时执行深复制，即复制节点与整个子DOM树。为false时只会复制调用该方法的节点。返回的节点属于文档所有，但没有指定父节点，也叫做孤儿节点</li>\n</ul>\n<pre><code class=\"language-js\">&#x3C;ul>\n    &#x3C;li>item 1&#x3C;/li>\n    &#x3C;li>item 2&#x3C;/li>\n    &#x3C;li>item 3&#x3C;/li>\n&#x3C;/ul>\n\n// Mylist保存对上面元素的引用\nlet deepList = Mylist.cloneNode(true)\nconsole.log(deepList.childNodes.length) // 3\nlet deepList = Mylist.cloneNode(false)\nconsole.log(deepList.childNodes.length) // 0\n</code></pre>\n<ul>\n<li>cloneNode不会复制添加到DOM节点的JavaScript属性（事件处理程序等），指挥复制HTML属性以及可选的复制子节点。IE在很长时间内会复制事件处理程序，所以推荐在复制前先删除事件处理程序</li>\n<li>另一个是normalize()方法，唯一的作用就是处理文档子树中的文本节点。由于解析器或者DOM等操作导致出现不包含文本的文本节点或者两个相邻的文本节点。调用normalize()方法后会检测这个节点的所有后代，发现空文本节点就删除，相邻文本节点就合并</li>\n</ul>\n<h2>Document类型</h2>\n<ul>\n<li>\n<p>Document类型是JavaScript中表示文档类型的类型。浏览器中，文档对象document是HTMLDocument的实例（HTMLDocument继承Document），表示整个HTML页面。document是window对象的属性，因此是全局对象，有以下特征</p>\n<ul>\n<li>nodeType等于9</li>\n<li>nodeName为\"#document\"</li>\n<li>nodeValue为null</li>\n<li>ownerDocument值为null</li>\n<li>子节点可以为DocumentType(最多一个)、Element(最多一个)、ProcessingInstruction或Comment类型</li>\n</ul>\n</li>\n<li>Document类型可以表示HTML页面或其他XML文档，最常用的还是通过HTMLDocument取得document对象，document对象可以用于获取页面信息和操纵其外观和底层结构</li>\n<li>document.documentElement属性始终指向HTML中的html元素</li>\n<li>document.body始终指向body元素</li>\n<li>Document类型另一种可能的子节点DocumentType，&#x3C;!doctype>标签是文档中独立部分，信息可以通过document.doctype访问</li>\n<li>document.title可用于读写页面的标题</li>\n<li>document.URL包含页面的完整URL</li>\n<li>document.domain获取当前页面的域名</li>\n<li>document.referrer包含链接到当前页面的那个页面的URL，如果当前页面没有来源，那document.referrer包含空字符串。所有这些信息都可以在HTTP头部信息获取。</li>\n<li>这些属性中只有域名是可设置的，出于安全考虑，给domain设置的值有限制，如果URL包含子域名如p2p.wrox.com，则可以设置为\"wrop.com\"，不能设置URL中不包含的值。</li>\n<li>当页面中包含来自不同子域的窗格（<frame>）或内嵌窗格(<iframe>)时，可以设置document.domain来绕过浏览器跨域通信的限制，实现JavaScript通信。在每个页面上把document.domain设置为相同的值，那就可以互相访问对方的JavaScript对象了。比如，一个加载自www.wrox.com的页面包含内嵌窗格，其中页面加载自p2p.wrox.com。两个页面的document.domain包含不同的字符串，内部与外部不能相互访问。要是把document.domain都设为wrox.com后就可以通信了</li>\n<li>浏览器对domain还有一个限制，将document.domain设置为\"wrox.com\"后就不能设置回\"p2p.wrox.com\"</li>\n</ul>\n<h2>定位元素</h2>\n<ul>\n<li>document.getElementById()接收一个参数，获取元素的id，找到了返回元素，没找到返回null，参数区分大小写，有多个相同id时返回文档中出现的第一个元素</li>\n<li>document.getElementsByTagName()接收一个元素的标签名，返回包含一个或多个元素的NodeList。在HTML文档中，返回一个HTMLCollection对象，也是一个实时列表。可以使用中括号或者item()方法取值。</li>\n<li>HTMLCollection对象有一个额外的方法namedItem()，可通过标签的name取得某一项的引用。比如</li>\n<li>对于name属性的元素，也可以直接通过中括号来获取</li>\n</ul>\n<pre><code class=\"language-js\">&#x3C;img src=\"a.gif\" name=\"myImage\"/>\n\nlet images = document.getElementsByTagName('img')\nlet myImage = images.namedItem('myImage')\nlet myImage = images['myImage']\n</code></pre>\n<ul>\n<li>对HTMLCollection对象，中括号可接受数值索引，也可以接受字符串索引，在后台，数值索引会调用item()，字符串索引调用namedItem()</li>\n<li>匹配所有元素可以传入*</li>\n<li>document.getElementsByName()接收一个字符串，返回具有给定name属性的元素</li>\n<li>\n<p>document对象还暴露了几个特殊集合，这些集合也都是HTMLCollection的实例，如下</p>\n<ul>\n<li>document.authors包含文档中所有带name属性的<a>元素</li>\n<li>document.applets包含文档中的所有<applet>元素（applet元素不推荐使用，所以集合已经废弃）</li>\n<li>document.forms包含文档中的所有<form>元素</li>\n<li>document.images包含文档中的所有<img>元素</li>\n<li>document.links包含文档中的所有带href属性的<a>元素</li>\n</ul>\n</li>\n<li>这些特殊集合都存在与HTMLDocument对象上，内容也都是实时更新的</li>\n</ul>\n<h2>DOM兼容性测试</h2>\n<ul>\n<li>由于DOM有多个Level和多个部分，所以需要确定浏览器实现了哪些DOM。</li>\n<li>document.implementation属性是一个对象，提供了浏览器DOM实现的信息与能力。DOM Level 1在document.implementation只定义了一个方法hasFeature()，接受两个参数：特性名称和DOM版本。如果浏览器支持特性和版本就返回true</li>\n</ul>\n<pre><code class=\"language-js\">let hasXmlDom = document.implementation.hasFeature('XML', '1.0')\n</code></pre>\n<ul>\n<li>\n<p>可以用hasFeature()方法检测的特性及版本如下</p>\n<ul>\n<li>Core: 1.0、2.0、3.0，定义属性文档结构的基本DOM</li>\n<li>XML: 1.0、2.0、3.0,Core的XML拓展，增加了对CDATA区块、处理指令和实体的支持</li>\n<li>HTML: 1.0、2.0，XML的HTML拓展，增加了HTML特定的元素和实体</li>\n<li>Views: 2.0，文档基于某些样式的实现格式</li>\n<li>StyleSheets: 2.0，文档的相关样式表</li>\n<li>CSS: 2.0，Cascading Style Sheets Level 1</li>\n<li>CSS2: 2.0，Cascading Style Sheets Level 1</li>\n<li>Events: 2.0、3.0， 通用DOM事件</li>\n<li>UIEvents: 2.0、3.0，用户界面事件</li>\n<li>TextEvents: 3.0，文本输入设备触发的事件</li>\n<li>MouseEvents: 2.0、3.0，鼠标触发的事件</li>\n<li>MutationEvents: 2.0、3.0，DOM树变化时触发的事件</li>\n<li>MutationNameEvents: 3.0，DOM元素或元素属性被重命名时触发的事件</li>\n<li>HTMLEvents: 2.0，HTML 4.01事件</li>\n<li>Range: 2.0，在DOM树中操作一定范围的对象和方法</li>\n<li>Traversal: 2.0，遍历DOM树的方法</li>\n<li>LS:3.0，文件与DOM树之间的同步加载与保存</li>\n<li>LS-Async: 3.0，文件与DOM树之间的异步加载与保存</li>\n<li>Validation: 3.0，修改DOM树并保证其继续有效的方法</li>\n<li>XPath: 3.0，访问XML文档不同部分的语言</li>\n</ul>\n</li>\n<li>由于实现不一致，hasFeature()返回值并不可靠，方法现在已经被废弃。为了向后兼容，目前主流浏览器仍然支持这个方法，但不论检测什么都返回true</li>\n</ul>\n<h2>文档写入</h2>\n<ul>\n<li>document对象早期留存了一个可以向网页输出流写入内容的能力。对应方法：write()、writeln()、open()、close()。</li>\n<li>write与writeln都接受一个字符串参数，可将此字符串写入网页中，write只是写入，writeln写入后还会在字符串尾部加一个换行符。</li>\n</ul>\n<pre><code class=\"language-js\">document.write(\"&#x3C;strong>\" + (new Date()).toStirng() + '&#x3C;/strong>')\n</code></pre>\n<ul>\n<li>write写入html标签时要注意对字符串的转义</li>\n<li>write在页面加载完成后调用会重写整个页面</li>\n<li>open跟close方法用于打开和关闭网页输出流。</li>\n<li>严格的XHTML文档不支持文档写入。对于内容类型为 application/xml+xhtml的页面，这些方法无用</li>\n</ul>\n<h2>Element类型</h2>\n<ul>\n<li>\n<p>Element表示XML或HTML元素，对外暴露访问元素标签名、子节点和属性的能力，特征如下</p>\n<ul>\n<li>nodeType为1</li>\n<li>nodeName值为元素的标签名</li>\n<li>nodeValue为null</li>\n<li>parentNode值为Document或Element对象</li>\n</ul>\n</li>\n<li>子节点可以使Element、Text、Comment、ProcessingInstruction、CDATASection、EntityReference类型</li>\n<li>通过nodeName或tagName获取元素的标签名，两个属性返回同样的值</li>\n<li>HTML中，元素标签名始终以全大写表示；在XML（XHTML）中，标签名始终与源代码中的一致。所以在比较时最好将签名转为小写模式</li>\n<li>\n<p>所有HTML元素都通过HTMLElement类型表示，包括直接实例跟间接实例。HTMLElement直接继承Element并增加了下列属性之一，它们是所有HTML元素上都有的标准属性</p>\n<ul>\n<li>id，元素在文档中的唯一标识符</li>\n<li>title: 元素的额外信息，一般以提示条形式展示</li>\n<li>lang: 元素内容的语言代码</li>\n<li>dir:语言的书写方向（\"ltr\"表示左到右，\"rtl\"表示右到左）</li>\n<li>className: 相当于class属性，用于指定元素的CSS类（class为关键字，不能直接用）</li>\n</ul>\n</li>\n<li>每个元素都有零个或多个属性，与属性相关的DOM方法主要有下三个</li>\n<li>getAttribute()、setAttribute()、removeAttribute()</li>\n</ul>\n<pre><code class=\"language-js\">let div = document.getElementById('myDiv')\n\nconsole.log(div.getAttribute('id'))\nconsole.log(div.getAttribute('class'))\n</code></pre>\n<ul>\n<li>这里传给getAttribute的属性名与实际的属性名是一致的，所以这里传class而不是className，如果属性不存在，返回null</li>\n<li>getAttribute可以获取自定义的属性，在html5规范中，自定义属性名前缀应该是data-的形式</li>\n<li>元素的所有属性也可以通过相应DOM元素对象的属性来获取。包括HTMLElement上得直接映射对象和所有公认的属性（不包括自定义属性）</li>\n<li>\n<p>通过DOM对象访问的属性中有两个属性的返回值跟使用getAttribute获取到的值不一致</p>\n<ul>\n<li>一个是style属性，使用getAttribute获取到的是字符串，通过DOM访问到的是一个（CSSStyleDeclaration）对象。</li>\n<li>第二个属性是事件处理程序，比如onclick，在元素上使用事件属性时，属性值是一段JavaScript代码。使用getAttribute获取到的是字符串形式的源码；通过DOM对象的属性访问事件属性时返回的是一个JavaScript函数。这是因为onclick等事件属性是可以接收函数值的</li>\n</ul>\n</li>\n<li>考虑到上面的差异，开发者一般都会放弃使用getAttribute来获取值，只使用对象属性。getAttribute主要用来获取自定义属性的值。</li>\n<li>setAttribute接收两个参数：要设置的属性名及属性值。属性值已存在会替换原来的值，属性不存在，就会以指定的值进行创建</li>\n<li>使用setAttribute设置的属性名会规范为小写形式，所以\"ID\"会变成\"id\"</li>\n<li>在DOM对象上设置自定义属性，不会自动让它变成元素的属性</li>\n</ul>\n<pre><code class=\"language-js\">div.mycolor = 'red'\nconsole.log(div.getAttribute('mycolor')) // null\n</code></pre>\n<ul>\n<li>removeAttribute用于从元素中删除属性，将整个属性完全从元素中去掉</li>\n<li>\n<p>Element是唯一使用attributes属性的DOM节点类型，attributes属性包含一个NamedNodeMap实例，是一个实时的集合。元素的每个属性都表现为一个Attr节点，并保存在这个NamedNodeMap对象中，NamedNodeMap对象包含下方法</p>\n<ul>\n<li>getNamedItem(name)， 返回nodeName属性等于name的节点</li>\n<li>removeNamedItem(name)，删除nodeName属性等于name的节点</li>\n<li>setNamedItem(node)，向列表中添加node节点，以其nodeName作为索引</li>\n<li>item(pos)，返回索引pos处的节点</li>\n</ul>\n</li>\n<li>attributes属性中的每个节点的nodeName是对应属性的名字，nodeValue是属性的值。比如要取元素id属性的值</li>\n</ul>\n<pre><code class=\"language-js\">let id = element.attributes.getNamedItem('id').nodeValue\n\n// 中括号简写\nlet id = element.attributes['id'].nodeValue\nelement.attribute['id'].nodeValue = 'someOtherId'\nelement.attributes.removeNamedItem('id')\n</code></pre>\n<ul>\n<li>可以使用createElement()方法创建新元素，接收一个参数，即要创建的元素的标签名，使用createElement的同时也会把ownerDocument属性设为document</li>\n<li>元素可以拥有任意多个子元素和后代元素，childNodes包含元素所有的子节点，可能是其他元素、文本节点、注释或处理命令</li>\n</ul>\n<pre><code class=\"language-js\">&#x3C;ul>\n  &#x3C;li>Item 1&#x3C;/li>\n  &#x3C;li>Item 2&#x3C;/li>\n  &#x3C;li>Item 3&#x3C;/li>\n&#x3C;/ul>\n\n&#x3C;ul>&#x3C;li>Item 1&#x3C;/li>&#x3C;li>Item 2&#x3C;/li>&#x3C;li>Item 3&#x3C;/li>&#x3C;/ul>\n</code></pre>\n<ul>\n<li>不同浏览器识别上面的节点时有不同的差异，有些浏览器会返回七个子节点，三个li元素，4个Text节点，要是下面的格式，就统一返回一样的3个节点数。</li>\n<li>所以这种情况下我们会先检查一下节点的nodeType，在执行操作</li>\n</ul>\n<pre><code class=\"language-js\">for (let i = 0; i &#x3C; element.childNodes.length; i++) {\n  if(element.childNodes[i].nodeType === 1) {}\n}\n</code></pre>\n<ul>\n<li>要取得某个元素的子节点可以在元素上调用getElementsByTagName()方法，跟在document上的调用形式是一致的，只不过搜索范围变成了当前节点下</li>\n</ul>\n<h2>Text类型</h2>\n<ul>\n<li>\n<p>Text节点由Text类型表示，包含按字面展示的纯文本，也有可能是转义后的HTML字符串，但不含有HTML代码</p>\n<ul>\n<li>nodeType为3</li>\n<li>nodeName为\"#text\"</li>\n<li>nodeValue值为节点中包含的文本</li>\n<li>parentNode值为Element对象</li>\n<li>不支持子节点</li>\n</ul>\n</li>\n<li>\n<p>Text节点中的文本可以用nodeValue访问，也可以通过data属性访问，修改任意一个值都会反映到另一个值上面，暴露了以下方法</p>\n<ul>\n<li>appendData(text)，向节点末尾加text</li>\n<li>deleteData(offset, count),从offset位置删除count个字符</li>\n<li>insertData(offset, text)，从offset位置插入text</li>\n<li>replaceData(offset, count, text)，用text文本替换从位置offset到offset + count位置的文本</li>\n<li>splitText(offset)，在offset位置将文本拆为两个节点</li>\n<li>substringData(offset, count)，提取从offset到offset + count的文本</li>\n<li>还可以通过length获取文本节点中包含的字符数量</li>\n</ul>\n</li>\n<li>默认情况下，包含文本内容的每个元素最多只能有一个文本节点</li>\n<li>修改文本值时注意HTML或XML代码会被转为实体编码，即小于号、大于号或引号会被转义，如下</li>\n</ul>\n<pre><code class=\"language-js\">div.firstChild.nodeValue = \"some &#x3C;strong>other&#x3C;/strong> message\"\n// 输出为 \"some &#x26;lt;strong&#x26;gt;other&#x26;lt;/strong&#x26;gt;message\"\n</code></pre>\n<ul>\n<li>document.createTextNode()可以用来创建文本节点，接受一个参数，就是要插入节点的文本，跟上面的规则一样，这些要插入的值也会被转义</li>\n</ul>\n<h2>Comment类型</h2>\n<ul>\n<li>\n<p>DOM中的注释通过Comment类型实现，特征如下</p>\n<ul>\n<li>nodeType为8</li>\n<li>nodeName值为\"#comment\"</li>\n<li>nodeValue的值为注释的内容</li>\n<li>parentNode值为Document或者Element对象</li>\n<li>不支持子节点</li>\n</ul>\n</li>\n<li>Comment类型与Text类型继承自同一个基类(CharacterData)，所以有除了splitText方法外的所有Text节点操作字符串方法</li>\n<li>可以使用createComment方法创造注释节点，参数为注释文本</li>\n</ul>\n<h2>CDATASection类型</h2>\n<ul>\n<li>\n<p>CDATASection类型表示XML中特有的CDATA区块。CDATASection类型继承Text类型，因此有包括splitText方法在内的所有字符串操作方法，特点如下</p>\n<ul>\n<li>nodeType为4</li>\n<li>nodeName为\"#cdata-section\"</li>\n<li>nodeValue值为CDATA区块的内容</li>\n<li>parentNode值为Document或Element对象</li>\n<li>不支持子节点</li>\n</ul>\n</li>\n<li>CDATA只会在XML文档中有效，有些旧的浏览器会将CDATA区块解析为Comment或Element</li>\n</ul>\n<pre><code class=\"language-js\">&#x3C;div id=\"myDiv\">&#x3C;![CDATA[This is some conent.]]>&#x3C;/div>\n</code></pre>\n<ul>\n<li>这里div的第一个子节点应该是CDATASection节点，但主流的浏览器没有一个将其识别为CDATASection。在有效的XHTML文档中，这些浏览器也不能恰当的支持嵌入的CDATA区块</li>\n</ul>\n<h2>DocumentType类型</h2>\n<ul>\n<li>\n<p>DocumentType类型的节点包含文档的文档类型(doctype)信息，特征如下</p>\n<ul>\n<li>nodeType为10</li>\n<li>nodeName值为文档类型的名称</li>\n<li>nodeValue值为null</li>\n<li>parentNode值为Document对象</li>\n<li>不支持子节点</li>\n</ul>\n</li>\n<li>DocumentType在DOM Level 1中不支持动态创建，只能在解析文档时创建。对于支持此类型的浏览器，DocumentType对象保存在document.doctype中</li>\n<li>\n<p>DOM Level 1规定了DocumentType类型的三个属性：name、entities、notations。</p>\n<ul>\n<li>name为文档类型的名称</li>\n<li>entities是文档类型描述的实体的NamedNodeMap</li>\n<li>notations是文档类型描述的表示法的NamedNodeMap。</li>\n</ul>\n</li>\n<li>因为浏览器中文档类型通常为HTML或者XHTML类型，所以entities跟notations列表为空</li>\n<li>所以只有name属性是有用的，这个属性包含文档类型的名称，即紧跟&#x3C;!DOCTYPE 后面的文本</li>\n</ul>\n<pre><code class=\"language-js\">&#x3C;!DOCTYPE HTML PUBLIC \"-//W3C// DTD HTML 4.01// EN\" \"http:// www.w3.org/TR/html4/strict.dtd\">\nconsole.log(document.doctype.name)  // 'html'\n</code></pre>\n<h2>DocumentFragment类型</h2>\n<ul>\n<li>\n<p>DocumentFragment类型是唯一在标记中没有对应表示的类型。DOM将文档片段定义为\"轻量级\"文档，能够包含和操作节点，却没有完整文档那样的消耗，特点如下</p>\n<ul>\n<li>NodeType为11</li>\n<li>nodeName值为\"#document-fragment\"</li>\n<li>nodeValue值为null</li>\n<li>parentNode值为null</li>\n<li>子节点可以是Element、ProcessingInstruction、Comment、Text、CDATASection或EntityReference</li>\n</ul>\n</li>\n<li>不能直接将文档碎片添加到文档。文档碎片充当其他要被添加到文档的节点的仓库。</li>\n<li>可以使用document.createDocumentFragment()方法创建文档</li>\n<li>文档类型从Node继承了所有文档类型具备的可以执行DOM操作的方法。如果文档中一个节点被添加到文档片段，那该节点会从文档树删除，不在被渲染</li>\n<li>添加到文档片段的新节点也不属于文档数，也不会被渲染，可以使用appendChild方法将文档片段内容添加到文档，将文档片段当做参数传给这些方法时，文档片段的所有子节点都会被添加到文档数</li>\n</ul>\n<pre><code class=\"language-js\">let fragment = document.createDocumentFragment()\nfor(let i = 0; i &#x3C; 3; i++){\n  let li = document.createElement('li')\n  li.appendChild(document.createTextNode(`Item ${ i }`))\n  fragment.appendChild(li)\n}\ndocument.body.appendChild(fragment)\n</code></pre>\n<h2>Attr类型</h2>\n<ul>\n<li>\n<p>元素数据在DOM中通过Attr类型表示。Attr类型构造函数和原型在所有浏览器都可以直接访问。技术上来说，属性是存在于元素attributes属性中的节点，特征如下</p>\n<ul>\n<li>nodeType为2</li>\n<li>nodeName等于属性名</li>\n<li>nodeValue为属性值</li>\n<li>parentNode值为null</li>\n<li>HTML中不支持子节点</li>\n<li>XML中子节点可以是Text或EntityReference</li>\n</ul>\n</li>\n<li>属性节点虽然是节点，但不被认为是DOM文档树的一部分，Attr节点很少被直接引用，一般更喜欢getAttribute、removeAttribute、setAttribute方法</li>\n<li>Attr对象有三个属性：name、value和specified。name包含属性名，value包含属性值，specified是布尔值，表示属性使用的是默认值还是指定值</li>\n<li>可以使用document.createAttribute()方法创建新的Attr节点，参数为属性名。</li>\n</ul>\n<pre><code class=\"language-js\">let attr = document.createAttribute('align')\nattr.value = 'left'\nelement.setAttributeNode(attr)\n\nconsole.log(element.attributes['align']) // left\nconsole.log(element.attributeNode('align').value)  // left\nconsole.log(element.getAttribute('align')) // left\n</code></pre>","fields":{"slug":"/DOM/"},"frontmatter":{"title":"DOM--高程4","tags":["JavaScript回顾"],"categories":"JavaScript"}}}]}},"pageContext":{"limit":10,"skip":50,"currentIndex":5}},"staticQueryHashes":["2566592090"]}