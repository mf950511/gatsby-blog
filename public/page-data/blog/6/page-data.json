{"componentChunkName":"component---src-templates-index-jsx","path":"/blog/6","result":{"data":{"allMarkdownRemark":{"totalCount":52,"edges":[{"node":{"html":"<h1>JS中的继承-（高程4）</h1>\n<h2>原型链继承</h2>\n<ul>\n<li>基本思想为：每个构造函数都有一个原型对象，原型有一个属性指回构造函数，实例有一个内部指针指向原型。</li>\n<li>如果一个原型是另一个原型的实例，就是说这个原型内部有一个内部指针指向另一个原型，相应的另一个原型也有一个指针指向另一个构造函数。</li>\n<li>\n<p>这样就在原型和实例间构造了原型链</p>\n<!--more-->\n<pre><code class=\"language-js\">function SuperType(){\nthis.property = true\n}\n</code></pre>\n</li>\n</ul>\n<p>SuperType.prototype.getSuperValue = function(){\nconsole.log(333)\nreturn this.property\n}</p>\n<p>function SubType (){\nthis.subproperty = false\n}</p>\n<p>SubType.prototype = new SuperType()</p>\n<p>SubType.prototype.getSubValue = function(){\nreturn this.subproperty\n}</p>\n<p>var instance = new SubType()\nconsole.log(instance.getSuperValue()) // true</p>\n<pre><code>- 这里SubType没有用默认的原型对象，用了SuperType的实例。这样SubType与SuperType就挂上了构，所以instance内部的[[Prototype]]指向了SubType.prototype，而SubType.prototype内部的[[Prototype]]指向了SuperType.prototype。这样就通过原型链查找实现了继承\n- 因为SubType.prototype的constructor属性被重写为指向了SuperType，所以instance.constructor也指向了SuperType\n- isPrototypeOf方法，用于判断一个原型是否在手里的原型链上，每个原型都可以调用，只要在原型链就返回true\n\n```js\nconsole.log(Object.prototype.isPrototypeOf(instance)) // true\n</code></pre>\n<h3>原型继承现存问题</h3>\n<ul>\n<li>原型包含引用值时，会在所有实例共享</li>\n<li>子类型在实例化时无法给父类型的构造函数传参</li>\n</ul>\n<h2>经典继承或对象伪装</h2>\n<ul>\n<li>基本思路：在子类的构造函数中调用父类的构造函数。然后使用call或者apply方法以新创建的对象作为上下文执行构造函数</li>\n</ul>\n<pre><code class=\"language-js\">function SuperType (){\n  this.colors = ['red', 'blue']\n}\nfunction SubType(){\n  // 继承实现\n  SuperType.call(this)\n}\n\nlet instance1 = new SubType()\ninstance1.colors.push('black')\nconsole.log(instance1.colors) // ['red', 'blue', 'black']\nlet instance2 = new SubType()\nconsole.log(instance2.colors) // ['red', 'blue']\n</code></pre>\n<ul>\n<li>盗用构造函数还可以向父类构造函数传递参数</li>\n</ul>\n<pre><code class=\"language-js\">function SuperType (name){\n  this.name = name\n  this.age = 28\n}\nfunction SubType(name){\n  // 继承实现\n  SuperType.call(this, name)\n}\n\nlet instance1 = new SubType('张三')\nconsole.log(instance1.name) // '张三'\nlet instance2 = new SubType('李四')\nconsole.log(instance2.name) // '李四'\n</code></pre>\n<h3>经典继承现存问题</h3>\n<ul>\n<li>必须在构造函数中定义方法，函数无法重用</li>\n<li>子类型无法访问父类原型上的方法，所有类型都只能用构造函数模式</li>\n</ul>\n<h2>组合继承（伪经典继承）</h2>\n<ul>\n<li>将原型链与盗用构造函数结合起来，使用原型链继承原型上的属性和方法，通过盗用构造函数继承实例属性。</li>\n</ul>\n<pre><code class=\"language-js\">function SuperType (name){\n  this.name = name\n  this.colors = ['red', 'blue']\n}\nSuperType.prototype.sayName = function(){\n  return this.name\n}\n\nfunction SubType(name, age){\n  SuperType.call(this, name)\n  this.age = age\n}\nSubType.prototype = new SuperType()\nSubType.prototype.constructor = SubType\nSubType.prototype.sayAge = function(){\n  return this.age\n}\n\nlet instance1 = new SubType('张三', 27)\ninstance1.colors.push('black')\ninstance1.sayName() // '张三'\nconsole.log(instance1.colors) // ['red', 'blue', 'black']\ninstance1.sayAge() // 27\n\n\n\nlet instance2 = new SubType('李四', 28)\ninstance2.sayName() // '李四'\nconsole.log(instance2.colors) // ['red', 'blue']\ninstance2.sayAge() // 28\n</code></pre>\n<ul>\n<li>组合继承弥补了原型继承与盗用构造函数的不足，是javascript中使用最多的继承，而且也保留了instanceof与isPrototypeOf的识别能力</li>\n</ul>\n<h3>组合式继承问题</h3>\n<ul>\n<li>组合继承存在效率问题，主要问题便是父元素构造函数会被调用两次，一次是创建子类型时调用，另一次是子类构造函数中使用。</li>\n</ul>\n<h2>原型式继承</h2>\n<ul>\n<li>原型式继承是不自定义类型也能通过原型实现对象之间的信息共享，原理就一个函数</li>\n</ul>\n<pre><code class=\"language-js\">function object(o) {\n  function F(){}\n  F.prototype = o\n  return new F()\n}\n</code></pre>\n<ul>\n<li>创建一个临时的构造函数，原型指向传入的对象，然后再返回这个临时类型的实例</li>\n</ul>\n<pre><code class=\"language-js\">function object(o) {\n  function F(){}\n  F.prototype = o\n  return new F()\n}\nlet person = {\n  name: 'Nick',\n  friends: ['Shel', 'Court']\n}\n\nlet anotherPerson = object(person)\nanotherPerson.name = 'Greg'\nanotherPerson.friends.push('Rob')\n\nlet yetAnotherPerson = object(person)\nyetAnotherPerson.name = 'Linda'\nyetAnotherPerson.friends.push('Barieb')\n\nconsole.log(person.friends) // [\"Shel\", \"Court\", \"Rob\", \"Barieb\"]\n</code></pre>\n<ul>\n<li>这里的原型式继承适用于：你有一个对象，在现有基础上创建一个新对象。</li>\n<li>ECMAScript 5 增加了Object.create()来将原型式继承规范化了。接收两个参数：作为新对象原型的对象，给新对象定义额外属性的对象。</li>\n</ul>\n<pre><code class=\"language-js\">let person = {\n  name: 'Nick',\n  friends: ['Shel', 'Court']\n}\n\nlet anotherPerson = Object.create(person)\nanotherPerson.name = 'Greg'\nanotherPerson.friends.push('Rob')\n\nlet yetAnotherPerson = Object.create(person)\nyetAnotherPerson.name = 'Linda'\nyetAnotherPerson.friends.push('Barieb')\n\nconsole.log(person.friends) // [\"Shel\", \"Court\", \"Rob\", \"Barieb\"]\n\nlet morePerson = Object.create(person, { name: { value: 'Francis' } })\nmorePerson.name // Francis\n</code></pre>\n<ul>\n<li>这里Object.create方法第二个参数跟Object.defineProperties方法第二个参数一样，都需要通过各自的描述符来描述。</li>\n</ul>\n<h2>寄生式继承</h2>\n<ul>\n<li>寄生式继承的原理：创建一个实现继承的函数，以某种方式增强对象，然后返回对象</li>\n</ul>\n<pre><code class=\"language-js\">function object(o){\n  function F(){}\n  F.prototype = o\n  return new F()\n}\n\nfunction createAnother(original) {\n  let clone = object(original)\n  clone.sayHi = function(){\n    console.log('Hi')\n  }\n  return clone\n}\n\n\nlet person = {\n  name: 'Nick',\n  friends: ['Shel', 'Court']\n}\nlet another = createAnother(person)\nanother.sayHi() // 'Hi'\n</code></pre>\n<h3>问题</h3>\n<ul>\n<li>通过寄生式继承给对象添加函数难以复用，与构造函数模式类似</li>\n</ul>\n<h2>寄生式组合继承</h2>\n<ul>\n<li>前面说到组合继承存在效率问题，本质上子类原型只需要包含超类对象的所有实例属性，子函数在执行时重写自己的原型就可以了</li>\n</ul>\n<pre><code class=\"language-js\">function SuperType (name){\n  this.name = name\n  this.colors = ['red', 'blue']\n}\nSuperType.prototype.sayName = function(){\n  return this.name\n}\n\nfunction SubType(name, age){\n  // 第二次调用\n  SuperType.call(this, name)\n  this.age = age\n}\nSubType.prototype = new SuperType() // 第一次调用\nSubType.prototype.constructor = SubType\nSubType.prototype.sayAge = function(){\n  return this.age\n}\n\nlet instance1 = new SubType('张三', 27)\n</code></pre>\n<ul>\n<li>寄生式组合继承通过盗用构造函数继承属性，但是使用混合式原型链集成方法。</li>\n<li>基本思路就是不通过调用父类构造函数给子类原型赋值，而是取得父元素原型的一个副本。</li>\n<li>就是使用寄生式继承继承父类原型，然后将获取到的新对象赋值给子类原型。</li>\n</ul>\n<pre><code class=\"language-js\">function object(o) {\n  function F(){}\n  F.prototype = o\n  return new F()\n}\nfunction inheritPrototype(subType, superType) {\n  let prototype = object(superType)\n  // 解决由于原型重写导致的默认constructor丢失问题\n  prototype.constructor = subType\n  subType.prototype = prototype\n}\n\nfunction SuperType (name){\n  this.name = name\n  this.colors = ['red', 'blue']\n}\nSuperType.prototype.sayName = function(){\n  return this.name\n}\n\nfunction SubType(name, age){\n  SuperType.call(this, name)\n  this.age = age\n}\ninheritPrototype(SubType, SuperType)\nSubType.prototype.sayAge = function(){\n  return this.age\n}\n</code></pre>\n<ul>\n<li>这里只调用了一次SuperType的构造函数，避免了SubType上用不到的属性，所以效率更高。</li>\n<li>而且原型链也保持不变，可以说是引用类型继承的最佳模式</li>\n</ul>","fields":{"slug":"/extend2/"},"frontmatter":{"title":"继承--高程4","tags":["JavaScript回顾"],"categories":"JavaScript"}}},{"node":{"html":"<h1>代理</h1>\n<ul>\n<li>ECMAScript 6新增了代理与反射为开发者提供了拦截并向基本操作嵌入额外行为的能力</li>\n<li>就是可以给目标对象定义一个关联的代理对象，代理对象可以作为抽象的目标对象来使用，在对目标对象实行的各种操作影响目标对象之前，都可以在代理对象中对这些操作加以控制</li>\n<li>代理是新的基础性语言能力，所以转移程序无法将其转为之前的ECMAScript代码，因为代理是无可替代的，所以在使用前要检测平台是否支持</li>\n</ul>\n<h2>代理基础</h2>\n<ul>\n<li>\n<p>代理使用Proxy构造函数来创建，接收两个参数： 目标对象和处理程序对象，缺少任何一个参数都会报错，创建一个空代理只需要将对象字面量作为处理程序传递即可，如下</p>\n<!--more-->\n<pre><code class=\"language-js\">const target = {\nid: 'target'\n}\nconst handler = {}\nconst proxy = new Proxy(target, handler)\nconsole.log(target.id) // target\nconsole.log(proxy.id)   // target \n</code></pre>\n</li>\n</ul>\n<p>target.id = 'foo'\nconsole.log(target.id) // foo\nconsole.log(proxy.id)  // foo</p>\n<p>proxy.id = 'bar'\nconsole.log(target.id) // bar\nconsole.log(proxy.id)  // bar</p>\n<p>console.log(target.hasOwnProperty('id')) // true\nconsole.log(proxy.hasOwnProperty('id'))  // true</p>\n<p>console.log(target instanceof Proxy) // Uncaught TypeError: Function has non-object prototype 'undefined' in instanceof check\nconsole.log(proxy instanceof Proxy)  // Uncaught TypeError: Function has non-object prototype 'undefined' in instanceof check</p>\n<p>console.log(target === proxy) // false</p>\n<pre><code>- 这里属性会访问同一个值，对目标属性赋值会反映在两个对象，因为它们访问的是一个值\n- 对代理赋值会反应在两个对象，因为赋值会转移到目标对象\n- hasOwnProperty()在两个地方都会应用到目标对象\n- Proxy.prototype是undefined，所以不能使用instanceof\n- 目标跟代理对象不是严格相等\n\n## 定义捕获器\n\n- 捕获器就是处理程序对象中定义的“基本操作的拦截器”。每个处理程序对象可以包含任意个捕获器，每个捕获器都对应一个基本操作，可以直接或间接在代理对象上调用。\n- 每次在代理上调用这些基本操作，代理都可以在这些操作到达目标对象前调用捕捉器函数，从而拦截并修改相应的行为\n- 如下就是定义了一个get()捕捉器\n\n```js\nconst target = {\n  foo: 'bar'\n}\nconst handler = {\n  get () {\n    return 'handler override'\n  }\n}\n\nconst proxy = new Proxy(target, handler)\nconsole.log(target.foo) // bar\nconsole.log(proxy.foo)  // handler override\n</code></pre>\n<ul>\n<li>当通过代理对象触发get操作时就会触发定义的get()捕获器，get()方法不是ECMAScript对象可以调用的方法，而是通过其他形式触发被捕获的</li>\n<li>proxy[property]、proxy.property 或者 Object.create(proxy)[property]等操作都会触发get()方法</li>\n<li>在目标对象上执行这些操作仍然是正常的行为</li>\n</ul>\n<h2>捕获器参数与反射API</h2>\n<ul>\n<li>捕获器都可以访问相应的参数，基于这些参数可以重建被捕获方法的原始行为。例如get()捕获器可以收到目标对象、要查询的属性和代理对象三个参数</li>\n</ul>\n<pre><code class=\"language-js\">const target = {\n  foo: 'bar'\n}\nconst handler = {\n  get (tarpTarget, property, receiver) {\n    console.log(tarpTarget === target)  // true\n    console.log(property)  // 'foo'\n    console.log(receiver === proxy) // true\n  }\n}\n\nconst proxy = new Proxy(target, handler)\nproxy.foo\n</code></pre>\n<ul>\n<li>有了这些参数我们就可以重建被捕获方法的原始行为</li>\n</ul>\n<pre><code class=\"language-js\">const target = {\n  foo: 'bar'\n}\nconst handler = {\n  get (tarpTarget, property, receiver) {\n    return tarpTarget[property]\n  }\n}\n\nconst proxy = new Proxy(target, handler)\nconsole.log(target.foo) // bar\nconsole.log(proxy.foo)  // bar\n</code></pre>\n<ul>\n<li>所有的捕获器都可以基于自己的参数重建原始操作，但是有些原始操作很复杂，手写太麻烦，所以我们可以调用全局Reflect（封装了原始行为）对象上的同名方法来重建</li>\n<li>处理程序对象中的所有可以捕获的方法都由对应的反射（Reflect）API方法。这些方法与捕获器拦截的方法有相同的名称和函数签名，与被拦截方法有相同的行为，所以可以使用如下方式定义</li>\n</ul>\n<pre><code class=\"language-js\">const target = {\n  foo: 'bar'\n}\nconst handler = {\n  get () {\n    return Reflect.get(...arguments)\n  }\n}\n\nconst proxy = new Proxy(target, handler)\nconsole.log(target.foo) // bar\nconsole.log(proxy.foo)  // bar\n\n// 或者\nconst target = {\n  foo: 'bar'\n}\nconst handler = {\n  get: Reflect.get\n}\n\nconst proxy = new Proxy(target, handler)\nconsole.log(target.foo) // bar\nconsole.log(proxy.foo)  // bar\n</code></pre>\n<ul>\n<li>如果只是想捕获所有方法，然后转发给对应的反射API的空代理，都不需要定义处理程序对象</li>\n</ul>\n<pre><code class=\"language-js\">const target = {\n  foo: 'bar'\n}\n\nconst proxy = new Proxy(target, Reflect)\nconsole.log(target.foo) // bar\nconsole.log(proxy.foo)  // bar\n\nconst target = {\n  foo: 'bar',\n  bar: 'baz'\n}\nconst handler = {\n  get(tarpTarget, property, receiver) {\n    let decoration = ''\n    if(property === 'foo') {\n      decoration = '!!!'\n    }\n    return Reflect.get(...arguments) + decoration\n  }\n}\n\nconst proxy = new Proxy(target, handler)\nconsole.log(proxy.foo) // bar!!!\nconsole.log(proxy.bar)  // baz\n</code></pre>\n<ul>\n<li>捕获器可以改变几乎所有的基本方法，但是有限制，每个捕获的方法都知道目标对象上下文、捕获函数签名，捕获函数处理程序的行为必须遵循“捕获器不变式”</li>\n<li>比如目标对象有一个不可配置不可写的数据属性，那么捕获器返回一个与该属性不同的值会报错</li>\n</ul>\n<pre><code class=\"language-js\">const target = {}\nObject.defineProperty(target, 'foo', {\n  configurable: false,\n  wirtable: false,\n  value: 'bar'\n})\nconst handler = {\n  get(){\n    return 'qux'\n  }\n}\nconst proxy = new Proxy(target, handler)\nconsole.log(proxy.foo) // Uncaught TypeError: 'get' on proxy: property 'foo' is a read-only and non-configurable data property on the proxy target but the proxy did not return its actual value (expected 'bar' but got 'qux')\n</code></pre>\n<h3>可撤销代理</h3>\n<ul>\n<li>对使用new Proxy创建的代理会在代理对象的生命周期中一直存在，有时候我们需要终端代理对象与目标对象的联系，这个时候就要用到Proxy暴露的revocable()方法</li>\n<li>这个方法支持撤销目标对象跟对象的关联，是不可逆的，调用多次结果都是一样，撤销之后在调用代理会抛错</li>\n</ul>\n<pre><code class=\"language-js\">const target = {\n  foo: 'bar'\n}\nconst handler = {\n  get () {\n    return \"interceped\"\n  }\n}\n\nconst { proxy, revoke } = Proxy.revocable(target, handler)\nconsole.log(proxy.foo)  // interceped\n\nrevoke()\nconsole.log(proxy.foo) // Uncaught TypeError: Cannot perform 'get' on a proxy that has been revoked\n</code></pre>\n<ul>\n<li>特定情况下应该优先使用反射API，理由如下</li>\n<li>反射API不限于捕捉处理程序</li>\n<li>大多数反射API方法在Object类型上有对应的方法</li>\n<li>通常Object上的方法是用于通用程序，而反射方法适用于细粒度的对象控制</li>\n<li>很多反射方法会返回“状态标记”的布尔值，表示该操作是否成功，很多时候，状态标记比返回修改后的对象或错误更有用，看以下对比</li>\n</ul>\n<pre><code class=\"language-js\">const o = {}\ntry {\n  Object.defineProperty(o, 'foo', 'bar')\n  console.log('success')\n} catch(e){\n  console.log('failuer')\n}\n\n// 重构后\nconst o = {}\nif(Reflect.defineProperty(o, 'foo', { value: 'bar' })) {\n  console.log('success')\n} else {\n  console.log('failure')\n}\n</code></pre>\n<ul>\n<li>\n<p>以下方法会提供状态标记</p>\n<ul>\n<li>Reflect.defineProperty()</li>\n<li>Reflect.preventExtensions()</li>\n<li>Reflect.setPrototypeOf()</li>\n<li>Relfect.set()</li>\n<li>Relfect.deleteProperty()</li>\n</ul>\n</li>\n<li>\n<p>用一等函数替代操作符，以下反射方法只有通过操作符才可以完成</p>\n<ul>\n<li>Reflect.get(): 可以替代对象属性访问操作符</li>\n<li>Reflect.set(): 可以替代=赋值操作符</li>\n<li>Reflect.has(): 可以替代in操作符</li>\n<li>Reflect.deleteProperty(): 可以替代delete操作符</li>\n<li>Reflect.construct(): 可以替代new操作符</li>\n</ul>\n</li>\n<li>\n<p>安全的使用函数</p>\n<ul>\n<li>通过apply方法调用函数时，被调用函数可能定义了自己的apply属性。为了绕过这个问题，可以使用定义在Function原型上的apply方法</li>\n<li>但是调用Function原型上的方法会很难读，所以可以使用Reflect.apply来替代</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"language-js\">Function.prototype.apply.call(muFunc, thisVal, argumentList)\n\n// 用Reflect.apply替代\nReflect.apply(myFunc, thisVal, argumentList)\n</code></pre>\n<ul>\n<li>代理另一个代理，代理可以拦截反射API的操作，所以我们可以创建一个代理，利用它去代理另一个代理，就构建了多层拦截网</li>\n</ul>\n<pre><code class=\"language-js\">const target = {\n  foo: 'bar'\n}\nconst firstProxy = new Proxy(target, {\n  get() {\n    console.log('first proxy')\n    return Reflect.get(...arguments)\n  }\n})\n\nconst secondProxy = new Proxy(firstProxy, {\n  get() {\n    console.log('seond proxy')\n    return Reflect.get(...arguments)\n  }\n})\nconsole.log(secondProxy.foo)\n\n// seond proxy\n// first proxy\n// bar\n</code></pre>\n<h2>代理的问题与不足</h2>\n<ul>\n<li>代理中的this，方法中的this通常指向调用这个方法的对象，如果目标依赖于对象表示，可能会出问题，如下用WeakMap报错私有变量的例子，简化版</li>\n</ul>\n<pre><code class=\"language-js\">const wm = new WeakMap()\n\nclass User{\n  constructor(userid){\n    wm.set(this, userid)\n  }\n  set id(userid){\n    wm.set(this, userid)\n  }\n  get id(userid) {\n    return wm.get(this)\n  }\n}\n\nconst user = new User(123)\nconsole.log(user.id)  // 123\n\nconst userInstanceProxy = new Proxy(user, {})\nconsole.log(userInstanceProxy.id) // undefined\n</code></pre>\n<ul>\n<li>这里User实例使用目标对象作为WeakMap的键，但是代理对象却从自身取这个实例，所以就出问题了</li>\n<li>解决问题就是将代理User实例改为代理User类本身，之后在创建代理实例就会以代理实例作为WeakMap的值了</li>\n</ul>\n<pre><code class=\"language-js\">const UserClassProxy = new Proxy(User, {})\nconst proxyUser = new UserClassProxy(456)\nconsole.log(proxyUser.id)\n</code></pre>\n<ul>\n<li>代理与内置类型（如Array）的实例可以很好地协作，但有些ECMAScript内置类型可能会导致代理某些方法出错，比如Date类型</li>\n<li>Date类型依赖this值上的[[NumberDate]]槽位，这个槽位无法通过get()跟set()方法访问到，所以代理拦截后转发给目标对象的方法会报错</li>\n</ul>\n<pre><code class=\"language-js\">const target = new Date()\nconst proxy = new Proxy(target, {})\nconsole.log(proxy instanceof Date) // true\nproxy.getDate() // Uncaught TypeError: this is not a Date object.\n</code></pre>\n<h2>代理捕获器与反射方法</h2>\n<ul>\n<li>代理可以捕获13中不同的基本操作。这些操作有各自不同的反射API方法、参数、关联的ECMAScript方法与不变式</li>\n<li>不同的JavsScript操作可以出发同一个捕获器处理。但是对于在代理对象上的任何操作，都只会有一个捕获处理程序被调用，不存在重复捕获的情况</li>\n</ul>\n<h3>get()</h3>\n<ul>\n<li>get()捕获器会在获取属性值的操作被调用，对应的反射API为Reflect.get()</li>\n<li>返回值无限制</li>\n<li>\n<p>拦截的操作： </p>\n<ul>\n<li>proxy.property</li>\n<li>proxy[property]</li>\n<li>Object.create(proxy)[Property]</li>\n<li>Reflect.get(proxy, property, receiver)</li>\n</ul>\n</li>\n<li>\n<p>捕获器处理程序参数</p>\n<ul>\n<li>target: 目标对象</li>\n<li>property: 引用目标对象上的字符串属性（也有可能是符号键）</li>\n<li>receiver: 代理对象或继承代理对象的对象</li>\n</ul>\n</li>\n<li>\n<p>捕获器不定式</p>\n<ul>\n<li>如果target.property不可写切不可配置，则返回的值必须跟target.property一致</li>\n<li>如果target.property不可写且[[Get]]特性为undefined，处理程序的返回值也必须是undefined</li>\n</ul>\n</li>\n</ul>\n<h3>set()</h3>\n<ul>\n<li>set()会在设置属性值的操作中被调用，对应的反射API为Reflect.set()</li>\n<li>返回值为true表示成功；为false表示失败，严格模式下抛错</li>\n<li>\n<p>拦截的操作</p>\n<ul>\n<li>proxy.property = value</li>\n<li>proxy[property] = value</li>\n<li>Object.create(proxy)[property] = value</li>\n<li>Reflect.set(proxy, property, value, receiver)</li>\n</ul>\n</li>\n<li>\n<p>捕获器处理程序参数</p>\n<ul>\n<li>target: 目标对象</li>\n<li>property: 引用目标对象的字符串健属性</li>\n<li>value: 要赋给属性的值</li>\n<li>receiver: 接收最初赋值的对象</li>\n</ul>\n</li>\n<li>\n<p>捕获器不定式</p>\n<ul>\n<li>如果target.property不可写且不可配置，则不能修改目标属性的值</li>\n<li>如果target.property不可配置且[[Set]]特性为undefined，则不可修改目标属性的值</li>\n<li>严格模式下，处理程序返回false会报错</li>\n</ul>\n</li>\n</ul>\n<h3>has()</h3>\n<ul>\n<li>has()捕获器在in操作符中被调用，对应的反射API为Reflect.has()</li>\n<li>返回值必须式布尔值，表示属性是否存在。非布尔值会被转为布尔值</li>\n<li>\n<p>拦截的操作</p>\n<ul>\n<li>property in proxy</li>\n<li>property in Object.create(proxy)</li>\n<li>with(proxy){(property)}</li>\n<li>Reflect.has(proxy, property)</li>\n</ul>\n</li>\n<li>\n<p>捕获器处理程序参数</p>\n<ul>\n<li>target: 目标对象</li>\n<li>property: 引用的目标对象上的字符串键属性</li>\n</ul>\n</li>\n<li>\n<p>捕获器不定式</p>\n<ul>\n<li>如果target.property存在且不可配置，则处理程序必须返回true</li>\n<li>如果target.property存在目标且目标对象不可拓展，则处理程序必须返回true</li>\n</ul>\n</li>\n</ul>\n<h3>defineProperty</h3>\n<ul>\n<li>defineProperty()捕获器会在Object.defineProperty()中被调用，对应的反射API为Reflect.defineProperty()</li>\n<li>返回值必须为布尔值，表示属性是否定义成功。返回非布尔值会被转为布尔值</li>\n<li>\n<p>拦截的操作</p>\n<ul>\n<li>Object.defineProperty(proxy, property, descriptor)</li>\n<li>Reflect.defineProperty(proxy, property, descriptor)</li>\n</ul>\n</li>\n<li>\n<p>捕获器处理程序参数</p>\n<ul>\n<li>target: 目标对象</li>\n<li>property: 引用目标对象上的字符串键属性</li>\n<li>descriptor: 包含可选的enumerable、configuable、writable、value、get、set定义的对象</li>\n</ul>\n</li>\n<li>\n<p>捕获器不定式</p>\n<ul>\n<li>如果目标对象不可拓展，则无法定义属性</li>\n<li>如果目标对象有一个可配置的属性，则不能添加同名的不可配置的属性</li>\n<li>如果目标对象有一个不可配置的属性，则不能添加同名的可配置属性</li>\n</ul>\n</li>\n</ul>\n<h3>getOwnPropertyDescriptor()</h3>\n<ul>\n<li>getOwnPropertyDescriptor()捕获器会在Object.getOwnPropertyDescriptor中被调用，对应的反射API为Reflect.getOwnPropertyDescriptor</li>\n<li>返回值必须返回对象，如果在属性不存在时返回undefined</li>\n<li>\n<p>拦截的操作</p>\n<ul>\n<li>Object.getOwnPropertyDescriptor(proxy, property)</li>\n<li>Reflect.getOwnPropertyDescriptor(proxy, property)</li>\n</ul>\n</li>\n<li>\n<p>捕获器处理程序参数</p>\n<ul>\n<li>target: 目标对象</li>\n<li>property: 引用的目标对象上的字符串键值</li>\n</ul>\n</li>\n<li>\n<p>捕获器不变式</p>\n<ul>\n<li>如果自有的target.property存在且不可配置，则处理程序必须返回一个表示该属性存在的对象</li>\n<li>如果自有的target.property存在且target可拓展，则处理程序必须返回一个表示该属性可配置的对象</li>\n<li>如果自有的target.property存在且target不可拓展，则处理程序必须返回一个表示该属性存在的对象</li>\n<li>如果自有的target.property不存在且target不可拓展，则处理程序必须返回undefined表示该属性不存在</li>\n<li>如果target.property不存在，则处理程序不能返回表示该属性可配置的对象</li>\n</ul>\n</li>\n</ul>\n<h3>deleteProperty</h3>\n<ul>\n<li>deleteProperty会在delete操作符中被调用，对应的反射API为Reflect.deleteProperty()</li>\n<li>返回值必须为布尔值，表示删除属性是否成功。返回非布尔值会被转为布尔值</li>\n<li>\n<p>拦截的操作</p>\n<ul>\n<li>delete proxy.property</li>\n<li>delete proxy[property]</li>\n<li>Reflect.deleteProperty(proxy, property)</li>\n</ul>\n</li>\n<li>\n<p>捕获器处理程序参数</p>\n<ul>\n<li>target: 目标对象</li>\n<li>property: 引用的目标对象上的字符串键值</li>\n</ul>\n</li>\n<li>\n<p>捕获器不变式</p>\n<ul>\n<li>如果自有的target.property存在且不可配置，则处理程序不能删除这个属性</li>\n</ul>\n</li>\n</ul>\n<h3>ownKeys</h3>\n<ul>\n<li>ownKeys会在Object.keys()及类似方法中被调用，对应的反射API为Reflect.ownKeys()</li>\n<li>返回值必须返回包含字符串或符号的可枚举对象</li>\n<li>\n<p>拦截的操作</p>\n<ul>\n<li>Object.getOwnPropertyNames(proxy)</li>\n<li>Object.getOwnPropertySymbols(proxy)</li>\n<li>Object.keys()</li>\n<li>Reflect.ownKeys(proxy)</li>\n</ul>\n</li>\n<li>\n<p>捕获器处理程序参数</p>\n<ul>\n<li>target: 目标对象</li>\n</ul>\n</li>\n<li>\n<p>捕获器不定式</p>\n<ul>\n<li>返回的可枚举对象必须包含target的所有不可配置的自有属性</li>\n<li>如果target不可拓展，则返回可枚举对象必须军却包含自有属性键</li>\n</ul>\n</li>\n</ul>\n<h3>getPrototypeOf()</h3>\n<ul>\n<li>getPrototypeOf()会在Object.getPrototypeOf()中被调用，对应的反射API为Reflect.getPrototypeOf()</li>\n<li>返回值必须返回对象或者null</li>\n<li>\n<p>拦截的操作</p>\n<ul>\n<li>Object.getPrototypeOf(proxy)</li>\n<li>Reflect.getPrototypeOf(proxy)</li>\n<li>proxy.<strong>proto</strong></li>\n<li>Object.prototype.isPrototypeOf(proxy)</li>\n<li>proxy instanceof Object</li>\n</ul>\n</li>\n<li>\n<p>捕获器处理程序参数</p>\n<ul>\n<li>target: 目标对象</li>\n</ul>\n</li>\n<li>\n<p>捕获器不定式</p>\n<ul>\n<li>如果target不可拓展，则Object.getPrototypeOf(proxy)唯一有效的返回值就是Object.getPrototypeOf(target)的返回值</li>\n</ul>\n</li>\n</ul>\n<h3>setPrototypeOf()</h3>\n<ul>\n<li>setPrototypeOf()会在Object.setPrototypeOf()中被调用，对应的反射API为Reflect.setPrototypeOf()</li>\n<li>返回值必须返回布尔值，表示原型赋值是否成功，非布尔值会被转为布尔值</li>\n<li>\n<p>拦截的操作</p>\n<ul>\n<li>Object.setPrototypeOf(proxy)</li>\n<li>Reflect.setPrototypeOf(proxy)</li>\n</ul>\n</li>\n<li>\n<p>捕获器处理程序参数</p>\n<ul>\n<li>target: 目标对象</li>\n<li>prototype: target的替代原型，如果是顶级原型则为null</li>\n</ul>\n</li>\n<li>\n<p>捕获器不定式</p>\n<ul>\n<li>如果target不可拓展，则唯一有效的prototype参数就是Object.getPrototypeOf(target)的返回值</li>\n</ul>\n</li>\n</ul>\n<h3>isExtensible()</h3>\n<ul>\n<li>isExtensible()会在Object.isExtensible()中被调用，对应的反射API为Reflect.isExtensible()</li>\n<li>返回值必须为布尔值，表示target是否可拓展，非布尔值会转为布尔值</li>\n<li>\n<p>拦截的操作</p>\n<ul>\n<li>Object.isExtensible(proxy)</li>\n<li>Reflect.isExtensible(proxy)</li>\n</ul>\n</li>\n<li>\n<p>捕获器处理程序参数</p>\n<ul>\n<li>target: 目标对象</li>\n</ul>\n</li>\n<li>\n<p>捕获器不定式</p>\n<ul>\n<li>如果target可拓展，处理程序必须返回true</li>\n<li>如果target不可拓展，处理程序必须返回false</li>\n</ul>\n</li>\n</ul>\n<h3>preventExtensions()</h3>\n<ul>\n<li>preventExtensions()捕获器会在Object.preventExtensions()中被调用，对应的反射API为Reflect.preventExtensions()</li>\n<li>返回值必须为布尔值，表示target是否已经不可拓展，返回非布尔值会被转为布尔值</li>\n<li>\n<p>拦截的操作</p>\n<ul>\n<li>Object.preventExtensions(proxy)</li>\n<li>Relfect.preventExtensions(proxy)</li>\n</ul>\n</li>\n<li>\n<p>捕获器处理程序参数</p>\n<ul>\n<li>target: 目标对象</li>\n</ul>\n</li>\n<li>\n<p>捕获器不定式</p>\n<ul>\n<li>如果Object.isExtensible(proxy)返回false，则处理程序必须返回true</li>\n</ul>\n</li>\n</ul>\n<h3>apply()</h3>\n<ul>\n<li>apply()会在调用函数时被调用，对应的反射API为Reflect.apply()</li>\n<li>返回值无限制</li>\n<li>\n<p>拦截的操作</p>\n<ul>\n<li>proxy(...argumentsList)</li>\n<li>Function.prototype.apply(thisArg, argumentsList)</li>\n<li>Function.prototype.call(thisArg, ...argumentsList)</li>\n<li>Reflect.apply(target, thisArgument, argumentsList)</li>\n</ul>\n</li>\n<li>\n<p>捕获器处理程序参数</p>\n<ul>\n<li>target: 目标对象</li>\n<li>thisArg: 调用此函数时的this参数</li>\n<li>argumentsList: 调用函数时的参数列表</li>\n</ul>\n</li>\n<li>\n<p>捕获器不定式</p>\n<ul>\n<li>target必须是函数对象</li>\n</ul>\n</li>\n</ul>\n<h3>construct()</h3>\n<ul>\n<li>construct()捕获器会在new操作符中被调用，对应的反射API为Reflect.construct()</li>\n<li>返回值必须返回一个对象</li>\n<li>\n<p>拦截的操作</p>\n<ul>\n<li>new Proxy(...argumentsList)</li>\n<li>Reflect.construct(target, argumentsList, newTarget)</li>\n</ul>\n</li>\n<li>\n<p>捕获器处理程序参数</p>\n<ul>\n<li>target: 目标构造函数</li>\n<li>argumentsList: 传给构造函数的参数列表</li>\n<li>最初被调用的构造函数</li>\n</ul>\n</li>\n<li>\n<p>捕获器不定式</p>\n<ul>\n<li>target必须可以用作构造函数</li>\n</ul>\n</li>\n</ul>\n<h2>代理模式</h2>\n<ul>\n<li>利用代理可以做一些有用的编程模式</li>\n<li>可以捕获get、set、has等操作，知道对象属性什么时候被访问</li>\n</ul>\n<pre><code class=\"language-js\">const user = {\n  name: 'jack'\n}\n\nconst proxy = new Proxy(user, {\n  get (target, property, receiver){\n    console.log(`Getting ${property}`)\n    Reflect.get(...arguments)\n  },\n  set (target, property, value, receiver){\n    console.log(`Setting ${property}=${value}`)\n    Reflect.set(...arguments)\n  }\n})\n\nproxy.name  // Getting name\nproxy.age = 27 // Setting age=27\n</code></pre>\n<ul>\n<li>可以用于隐藏属性</li>\n</ul>\n<pre><code class=\"language-js\">const hiddenProperties = ['foo', 'bar']\nconst targetObject = {\n  foo: 1,\n  bar: 2,\n  baz: 3\n}\nconst proxy = new Proxy(targetObject, {\n  get(target, property) {\n    if(hiddenProperties.includes(property)) {\n      return undefined\n    } else {\n      return Reflect.get(...arguments)\n    }\n  },\n  has(target, property){\n    if(hiddenProperties.includes(property)) {\n      return false\n    } else {\n      return Reflect.has(...arguments)\n    }\n  }\n})\n\nconsole.log(proxy.foo) // undefined\nconsole.log(proxy.bar) // undefined\nconsole.log(proxy.baz) // 3\nconsole.log('foo' in proxy) // false\nconsole.log('bar' in proxy) // false\nconsole.log('baz' in proxy) // true\n</code></pre>\n<ul>\n<li>可以根据所赋的值决定是否允许赋值</li>\n</ul>\n<pre><code class=\"language-js\">const target = {\n  onlyNumbersGoHere: 0\n}\n\nconst proxy = new Proxy(target, {\n  set (target, property, value, receiver){\n    if(typeof value !== 'number') {\n      return false\n    } else {\n      return Reflect.set(...arguments)\n    }\n  }\n})\n\nproxy.onlyNumbersGoHere = 1\nconsole.log(proxy.onlyNumbersGoHere) // 1\n\nproxy.onlyNumbersGoHere = '2'\nconsole.log(proxy.onlyNumbersGoHere) // 1\n</code></pre>\n<ul>\n<li>函数跟构造函数参数验证，指定函数只接受某种类型的值</li>\n</ul>\n<pre><code class=\"language-js\">function median(...nums){\n  return nums.sort()[Math.floor(nums.length / 2)]\n}\nconst proxy = new Proxy(median, {\n  apply(target, thisArg, argumentsList) {\n    for(const arg of argumentsList) {\n      if(typeof arg !== 'number') {\n        throw 'Non-number argument provided'\n      }\n    }\n    return Reflect.apply(...arguments)\n  }\n})\n\nconsole.log(proxy(4, 7, 1)) // 4\nconsole.log(proxy(4, '7', 1)) // Uncaught Non-number argument provided\n</code></pre>\n<ul>\n<li>通过代理可以把原来不关联的部分联系到一起。这样就能实现各种模式，让不同的代码互操作</li>\n<li>例如，可以将被代理的类放到一个全局实例集合</li>\n</ul>\n<pre><code class=\"language-js\">const userList = []\nclass User{\n  constructor(name){\n    this._name = name\n  }\n}\n\nconst proxy = new Proxy(User, {\n  construct(){\n    const newUser = Reflect.construct(...arguments)\n    userList.push(newUser)\n    return newUser\n  }\n})\n\nnew proxy('John')\nnew proxy('Jacob')\nnew proxy('Jing')\nconsole.log(userList) // [User, User, User]\n</code></pre>\n<ul>\n<li>可以把集合绑定到一个事件分配程序，每次插入新实例都会发送消息</li>\n</ul>\n<pre><code class=\"language-js\">const userList = []\nfunction emit(newValue) {\n  console.log(newValue)\n}\n\nconst proxy = new Proxy(userList, {\n  set(target, property, value, receiver) {\n    const result = Reflect.set(...arguments)\n    if(result) {\n      emit(Reflect.get(target, property, receiver))\n    }\n    return result\n  }\n})\nproxy.push('John') // John\nproxy.push('Jacob') // Jacob\nproxy.push('Jing') // Jing\n</code></pre>","fields":{"slug":"/proxy/"},"frontmatter":{"title":"代理","tags":["JavaScript回顾"],"categories":"JavaScript"}}}]}},"pageContext":{"limit":10,"skip":50,"currentIndex":5}},"staticQueryHashes":["2566592090"]}