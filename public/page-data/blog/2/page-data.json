{"componentChunkName":"component---src-templates-index-jsx","path":"/blog/2","result":{"data":{"allMarkdownRemark":{"totalCount":62,"edges":[{"node":{"html":"<h1>new的原理与实现</h1>\n<ul>\n<li>在javascript中我们经常看到在实例化某个类的时候都会在构造函数前面加一个new调用函数来获取我们的实例，但却没有想过new这个操作符在这里面做了什么，是如何生成的实例，所以这段时间我也大概了解了下new的工作原理，并随手写一下自己的感悟</li>\n</ul>\n<h2>原理</h2>\n<ul>\n<li>构造函数实例都具有该构造函数内的共用属性与方法，同时也会拥有构造函数原型对象上的方法，所以构造函数生成实例其实会经历三个步骤</li>\n<li>第一步，构造一个实例 空对象</li>\n<li>第二步，将构造函数的this值赋给这个对象，并执行构造函数内的赋值操作，这样该实例就有了构造函数相应的属性值</li>\n<li>第三步，使实例拥有构造函数原型链上的方法，这就需要我们将该对象的<strong>proto</strong>属性指向我们的构造函数的原型对象上（涉及到对象属性的查找原理，对象查找某方法或属性时，会先在对象自身上找，当自身查找不到时，就会在<strong>proto</strong>指向的对象上面找，如果第一个<strong>proto</strong>对象上面也没有就会继续沿着<strong>proto</strong>往上找，一直到找到该属性或者null为止，对这一块感兴趣的话，可以先了解一下原型与原型链）</li>\n</ul>\n<!--more-->\n<h2>实现</h2>\n<ul>\n<li>知道了原理其实实现一个相同的方法也就简单了</li>\n</ul>\n<pre><code class=\"language-js\">  // 这里使用ES6的结构来获取构造函数所需的参数\n  // 因为结构之后获取的是一个数组结构，所以使用apply来进行构造函数this的赋值\n  // 也可以使用arguments来获取，不过ES6中不这么建议了，要用的话进行arguments[0]的提取与裁剪就可以了\n  function New(Fn, ...args){\n    var obj = {} // 构造空对象\n    Fn.apply(obj, args) // 构造函数赋值与this指向的修改\n    obj.__proto__ = Fn.prototype // 对该对象赋值构造函数原型对象上的方法\n    return obj // 返回该实例\n  }\n\n  function Person(name){\n    this.name = name\n  }\n  Person.prototype.showName = function(){\n    console.log(this.name)\n  }\n\n  var p1 = New(Person, '张三')\n  p1.showName() // 张三\n</code></pre>","fields":{"slug":"/new/"},"frontmatter":{"title":"JavaScript中new的原理与手动实现一个new","tags":["JavaScript回顾","设计模式","进修"],"categories":"JavaScript"}}},{"node":{"html":"<h1>js中的继承（二）</h1>\n<h2>原型式继承</h2>\n<ul>\n<li>原型式继承：原型式继承可以根据现有对象创建一个新的对象，并且不用显式的创建一个新的自定义类型对象（道格拉斯说的）。这也就是原型式继承的作用，创建一个继承某对象属性并可进行拓展的的新对象。</li>\n<li>原型式继承采用的其实还是类式继承的原理，只不过不会显式的构建一个对象子类，而是用一个空的构造函数类来做过渡类，然后把被继承的对象设置为过渡类的原型对象，然后返回一个过渡类的实例，这样这个返回的对象就有了被继承对象的属性与方法，具体实现见下代码</li>\n</ul>\n<!--more-->\n<pre><code class=\"language-js\">  function inheritObject(obj){\n    function F(){} // 过渡类，一般为空\n    F.prototype = obj // 设置过渡类原型对象\n    return new F() // 返回新的实例\n  }\n\n  let book = {\n    books: ['css', 'js', 'html'],\n    name: 'css book',\n    showBooks: function(){\n      console.log(this.books, this.name)\n    }\n  }\n\n  let b1 = inheritObject(book)\n  let b2 = inheritObject(book)\n  b1.name = 'js book'\n  b2.name = 'html book'\n  b2.showBooks() // [\"css\", \"js\", \"html\"]  \"html book\"\n  b1.books.push('php')\n  // 这里可以看到对b1的books属性进行操作会影响到b2的books属性\n  b2.showBooks() // [\"css\", \"js\", \"html\", \"php\"]  \"html book\"\n  b1.showBooks() // [\"css\", \"js\", \"html\", \"php\"]  \"js book\"\n</code></pre>\n<ul>\n<li>原型式继承其实就是对类式继承的另类使用，只不过使用一个空构造函数的过渡类来替代子类减少开销，用于创建对象是一个蛮不错的选择，也是后来Object.create()的实现思想来源。</li>\n</ul>\n<h2>寄生式继承</h2>\n<ul>\n<li>寄生式继承：就是对原型式继承的二次封装，并且在二次封装中对继承的对象进行了拓展，这样对象不仅拥有了父类中的对象与属性，也有了新的属性与方法</li>\n</ul>\n<pre><code class=\"language-js\">  function inheritObject(obj){\n    function F(){} // 过渡类，一般为空\n    F.prototype = obj // 设置过渡类原型对象\n    return new F() // 返回新的实例\n  }\n  function createBook(obj){\n    var o = inheritObject(obj) // 获取原型式继承的对象\n    // 对该对象进行拓展\n    o.getName = function(){ \n      console.log(this.name)\n    }\n    return o\n  }\n  let book = {\n    books: ['css', 'js', 'html'],\n    name: 'css book',\n    showBooks: function(){\n      console.log(this.books, this.name)\n    }\n  }\n\n  let b1 = createBook(book)\n  b1.getName() // css book\n</code></pre>\n<ul>\n<li>只是比原型式继承多了一个函数封装，使其拥有了自己的属性与方法，产生这个继承方式的目的也是为了寄生组合式继承模型的实现</li>\n</ul>\n<h2>完美的继承模式——寄生组合式继承</h2>\n<ul>\n<li>寄生组合式继承：是寄生式继承与构造函数继承的组合形式，取了两个继承的优点产生的目前最完美的继承形式</li>\n<li>构造函数继承使子类具有父类构造函数内的属性与方法，寄生式继承获取一个继承自父类原型对象的子对象，避免了父类原型对象的二次调用，因为该对象可获取父类原型对象上的属性与方法，设置该对象为子类原型对象继承父类原型对象上的属性与方法，最后对该对象进行属性增强修正其constructor不指向子类的错误</li>\n</ul>\n<pre><code class=\"language-js\">  function inheritObject(obj){\n    function F(){}\n    F.prototype = obj\n    return new F()\n  }\n\n  function inherit(Subclass, Superclass){\n    // 生成一个继承父类原型对象的子对象\n    let sup = inheritObject(Superclass.prototype) \n    // 该对象的constructor并不是指向子类，所以要对其进行属性拓展，修改其constructor属性至子类\n    sup.constructor = Subclass\n    // 将这个拓展过后的对象作为子类的原型对象\n    Subclass.prototype = sup\n  }\n\n  function SuperClass(name){\n    this.name = name\n    this.favite = ['吃饭', '喝酒', '打篮球']\n  }\n  // 原型对象方法\n  SuperClass.prototype.showFavite = function(){\n    console.log(this.favite)\n  }\n\n  function SubClass(name){\n    SuperClass.call(this, name)\n  }\n  // 实现继承\n  inherit(SubClass, SuperClass)\n\n  let s1 = new SubClass('张三')\n  let s2 = new SubClass('李四')\n  s2.showFavite() //  [\"吃饭\", \"喝酒\", \"打篮球\"]\n  s1.favite.push('打豆豆')\n  s2.showFavite() //  [\"吃饭\", \"喝酒\", \"打篮球\"]\n  s1.showFavite() //  [\"吃饭\", \"喝酒\", \"打篮球\", \"打豆豆\"]\n</code></pre>\n<ul>\n<li>原型链与构造函数的组合继承中子类的原型对象为父类的一个实例，也就导致在对子类实现继承的时候会执行两次父类的构造函数（一次子类构造函数调用父类构造函数，一次生成父类实例时调用）。</li>\n<li>而在寄生组合式继承中，每次继承都会由过渡类继承父类原型对象返回一个新的实例，而且由于过渡类的空构造函数并不会导致有太大的内存开销，就避免了父类构造函数的二次调用，所以这也是当下最完美的继承形式</li>\n</ul>","fields":{"slug":"/extends_new_2/"},"frontmatter":{"title":"JavaScript中的继承（二）","tags":["JavaScript回顾","设计模式","进修"],"categories":"JavaScript"}}},{"node":{"html":"<h1>JavaScript中的设计模式——工厂模式</h1>\n<ul>\n<li>在我们的项目开发中会定义很多的类，当协作开发时，每个人都有可能定义很多的类，若是不对每个人或者每一种类进行管理的话，开发中对类的使用将会极其困难，而工厂模式就是对类进行管理的一种模式</li>\n<li>工厂模式一般有以下几种，分别对应不同的使用场景</li>\n</ul>\n<!--more-->\n<h2>简易工厂模式</h2>\n<ul>\n<li>简易工厂模式：不去关心子类的创建过程，只是提供一个函数向外提供他们想要的子类即可</li>\n<li>该模式就是单纯的对同一类型的类进行管理，使用者只需要传入每一个类的别名或简称即可获取该类</li>\n</ul>\n<pre><code class=\"language-js\">    function LoginClass(){\n        console.log('我是登录模块类')\n    }\n    function RegisterClass(){\n        console.log('我是注册模块类')\n    }\n    function LogoutClass(){\n        console.log('我是退出登录模块类')\n    }\n\n    function createUserClass(name){\n        switch(name) {\n            case 'login':\n                return new LoginClass()\n            case 'register':\n                return new RegisterClass()\n            case 'logout':\n                return new LogoutClass()\n        }\n    }\n    let login = createUserClass('login') // 构建登录模块\n    let register = createUserClass('register') // 构建注册模块\n    let logout = createUserClass('logout') // 构建退出登录模块\n</code></pre>\n<ul>\n<li>上面就是一个简易的工厂模式，一般用于管理同类型的类，对外提供每个类型的别名即可使用</li>\n</ul>\n<h2>工厂模式</h2>\n<ul>\n<li>工厂模式：工厂模式一般用于会不断创建新类时使用，比如我初始提供了三个类，突然需求变化新增了一个类，如果还使用建议工厂模式的话就需要先创建这个新类，然后在对外暴露的函数中再加一条case语句，会比较繁琐，所以就产生了工厂模式</li>\n<li>工厂模式是对一个工厂类的拓展，在该类的原型对象上面绑定工厂内所能提供的子类，调用者通过传入不同的类名可获取相应的实例</li>\n<li>工厂模式由于对外提供的是一个工厂类，若是项目新成员或者不熟悉开发的成员在调用过程中将其当做普通函数处理可能会出现异常并且会在全局对象上挂载太多全局变量，所以我们这里要对工厂类进行安全模式</li>\n</ul>\n<pre><code class=\"language-js\">    function Factory(name){\n        // 是否是类式调用，即有没有使用new方法来调用，若是按普通函数来调用则this会指向window，若以new的形式来调用，则会指向当前类\n        if(this instanceof Factory) {\n            // 采用new的形式调用则直接返回他想要的类\n            return new Factory[name]()\n        } else {\n            // 若是不熟悉或者忘了new的调用则我们帮他们调用一下工厂类，最终还是返回他们想要的类\n            return new Factory(name)\n        }\n    }\n</code></pre>\n<ul>\n<li>上面就是对工厂类的安全模式，可防止意外调用导致的一系列问题</li>\n<li>对安全模式的工厂类进行原型对象绑定即可实现我们最终的工厂模式，按需创建类，按需获取类</li>\n</ul>\n<pre><code class=\"language-js\">    function Factory(name){\n        // 是否是类式调用，即有没有使用new方法来调用，若是按普通函数来调用则this会指向window，若以new的形式来调用，则会指向当前类\n        if(this instanceof Factory) {\n            // 采用new的形式调用则直接返回他想要的类，会获取原型对象上的属性，从而获取所需类的构造函数\n            return new this[name]()\n        } else {\n            // 若是不熟悉或者忘了new的调用则我们帮他们调用一下工厂类，最终还是返回他们想要的类\n            return new Factory(name)\n        }\n    }\n    // 通过对工厂类原型对象的修改来获取工厂内存在的各个类，从而可以在工厂内提供人们需要的类\n    Factory.prototype = {\n        JS: function(){\n            this.name = 'js'\n        },\n        PHP: function(){\n            this.name = 'php'\n            this.age = 16\n            this.say = function(){\n                console.log('php是世界上最好的语言')\n            }\n        },\n        JAVA: function(){\n            this.name = 'java'\n            this.advantage = '我是最稳定的'\n            this.say = function(){\n                console.log(this.advantage)\n            }\n        }\n    }\n\n    var js = new Factory('JS')          \n    var php = Factory('PHP')        // 异常调用，可正常返回所需实例\n    var java = new Factory('JAVA')  // 正常调用\n    php.say()   // php是世界上最好的语言\n    java.say()  // 我是最稳定的\n</code></pre>\n<ul>\n<li>上面就是最终的工厂模式，可以看到，当我们需要添加新类的时候只需要在工厂类的原型对象上添加即可，添加完成便可以在别的地方传入名称直接由工厂类生成，需求变化也只需要修改一个地方即可</li>\n</ul>\n<h2>抽象类</h2>\n<ul>\n<li>了解抽象工厂类之前我们需要先了解抽象类，抽象类就是只能继承，无法实例化的一种类，实例化时会抛出异常，且继承抽象类的子类必须重写抽象类的方法。js中abstract仍然只是一个保留字，并没有实现抽象类，所以抽象类需要我们模拟实现</li>\n<li>抽象类在实现上与普通类相似，只是对其方法进行了限制，下面的Car就是一个抽象类</li>\n</ul>\n<pre><code class=\"language-js\">    let Car = function(){\n        this.name = 'Car'\n    }\n    // 如果对Car直接进行实例化或者继承类没有重写下面的方法，则调用时会弹出报错\n    Car.prototype = {\n        getSpeed: function(){\n            throw new Error('不可调用抽象方法')\n        },\n        getPrice: function(){\n            throw new Error('不可调用抽象方法')\n        }\n    }\n</code></pre>\n<h2>抽象工厂类</h2>\n<ul>\n<li>抽象工厂类是对外提供抽象类的工厂模式，下面就是一个抽象工厂模式</li>\n</ul>\n<pre><code class=\"language-js\">    function VehicleFactory(SubClass, SuperClass){\n        // 判断工厂内是否存在该抽象类，存在则进行子类的继承\n        if(typeof VehicleFactory[SuperClass] === 'function'){\n            function F(){}\n            F.prototype = new VehicleFactory[SuperClass]()\n            SubClass.prototype = new F()\n            SubClass.prototype.constructor = SubClass\n        } else {\n            // 若不存在，则抛出异常\n            throw new Error('未创建该抽象类')\n        }\n    }\n    // 抽象小汽车类\n    VehicleFactory.Car = function(){\n        this.name = 'Car'\n    }\n    VehicleFactory.Car.prototype = {\n        getSpeed: function(){\n            throw new Error('不可调用抽象方法')\n        },\n        getPrice: function(){\n            throw new Error('不可调用抽象方法')\n        }\n    }\n\n    // 抽象公交车类\n    VehicleFactory.Bus = function(){\n        this.name = 'Bus'\n    }\n    VehicleFactory.Bus.prototype = {\n        getSpeed: function(){\n            throw new Error('不可调用抽象方法')\n        },\n        getPrice: function(){\n            throw new Error('不可调用抽象方法')\n        }\n    }\n    // 实体类\n    function BWM(price, speed){\n        this.price = price\n        this.speed = speed\n    }\n    // 实现BWM对抽象类Car的继承,但不重写抽象方法\n    VehicleFactory(BWM, 'Car')\n    var b = new BWM(500000, 100)\n    b.getPrice()    // Uncaught Error: 不可调用抽象方法\n    b.getSpeed()    // Uncaught Error: 不可调用抽象方法\n    // 实体类\n    function BRT(price, speed){\n        this.price = price\n        this.speed = speed\n    }\n    // 实现BRT对抽象类Bus的继承\n    VehicleFactory(BRT, 'Bus')\n    // 重写抽象类中的方法\n    BRT.prototype.getPrice = function(){\n        console.log(this.price)\n    }\n    BRT.prototype.getSpeed = function(){\n        console.log(this.speed)\n    }\n    var t = new BRT(300000, 80)\n    t.getPrice()    // 300000\n    t.getSpeed()    // 80\n</code></pre>\n<ul>\n<li>这里我们的抽象工厂可以实现一个实体类对其想要的抽象类的继承，注意点就是要重写抽象类的方法再调用，否则会抛出异常</li>\n</ul>","fields":{"slug":"/factory_mode/"},"frontmatter":{"title":"JavaScript中的设计模式——工厂模式","tags":["JavaScript回顾","设计模式","进修"],"categories":"JavaScript"}}},{"node":{"html":"<h1>采用迭代器形式封装轮播图对象</h1>\n<ul>\n<li>轮播图是我们开发中经常需要实现的一个小功能，但是应用于不同的场景需要对应不同的效果，有的需要淡入淡出，有的需要左侧划入，有的则需要上一张下一张的按钮</li>\n<li>如果针对每个效果都要重新实现的话就会做太多的无用功，所以我们可以看看轮播图的共同点，然后封装一个迭代函数来帮助我们处理轮播图</li>\n<li>轮播图都会接收一个数组作为图片的来源，轮播中我们可能会遇到上一张下一张的显示，所以我们对上一张下一张还有第一张与最后一张做特殊处理，也有可能会对轮播对象中的几个图片不做显示</li>\n<li>所以我们可以提供一个迭代器对象，能对外提供操作数据的方法，包括next、pre、first、last的获取，包括对所有元素的初始化方法，包括对个别元素的操作方法</li>\n</ul>\n<!--more-->\n<pre><code class=\"language-js\">function Iterator(item) {\n  let container = document.querySelector('.container')\n  let items = container.getElementsByTagName(item)\n  let length = items.length\n  let index = 0\n  return {\n    // 获取下一张\n    next: function(){\n      if(index === length - 1) {\n        index = length - 1\n        return null\n      } else {\n        return items[++index]\n      }\n    },\n    // 获取下一张\n    pre: function(){\n      if(index === 0) {\n        index = 0\n        return null\n      } else {\n        return items[--index]\n      }\n    },\n    // 获取第一张\n    first: function(){\n      return items[0]\n    },\n    // 获取最后一张\n    last: function(){\n      return items[length - 1]\n    },\n    // 获取指定序号一张\n    get: function(index){\n      index = index >= 0 ? index % length : index % length + length\n      return items[index]\n    },\n    // 所有图片统一处理方式\n    dealEach: function(fn){\n      Array.prototype.slice.call(items).forEach(item => {\n        fn.call(item)\n      })\n    },\n    // 单张图片特殊处理函数\n    dealItem: function(index, fn){\n      fn.call(items[index])\n    },\n    // 部分图片的排他处理\n    exclusive: function(num, allFn, itemFn){\n      this.dealEach(allFn)\n      if(Object.prototype.toString.call(num) === '[object Array]') {\n        num.forEach(item => {\n          this.dealItem(item, itemFn)\n        })\n      } else {\n        this.dealItem(num, itemFn)\n      }\n    }\n  }\n}\n</code></pre>\n<ul>\n<li>上面我们提供了一个处理轮播图对象的迭代器函数，分别对外暴露了pre,next,last,first,get,dealEach,dealItem,exlusive几个功能函数，使用时只需要指定轮播对象就可以正常使用了，使用方法如下</li>\n</ul>\n<pre><code class=\"language-js\">  var it = Iterator('li')\n  console.log(it.first()) // 获取第一个对象\n  console.log(it.next())  // 获取下一个对象\n  console.log(it.pre())   // 获取上一个对象\n  console.log(it.last())  // 获取最后一个对象\n\n  // 为元素统一设置背景色\n  it.dealEach(function(){\n    this.style.background = 'red'\n  })\n  // 单个元素修改其内容\n  it.dealItem([2], function(){\n      this.innerHTML = 'dealItem'\n  })\n  // 修改其他元素内容\n  it.exclusive([1,3], function(){\n      this.innerHTML = 'exclusive'\n  }, function(){\n      console.log(234, this)\n      this.innerHTML = 'each'\n  })\n</code></pre>\n<ul>\n<li>这样就提供了轮播图的操作对象，具体的轮播实现还要看各自的需求，借助这个轮播对象应该都会比较轻松</li>\n</ul>","fields":{"slug":"/iterator_loop/"},"frontmatter":{"title":"迭代器在轮播图中的应用","tags":["JavaScript回顾","设计模式","进修"],"categories":"JavaScript"}}},{"node":{"html":"<h1>jQuery选择器的简单实现</h1>\n<ul>\n<li>jQuery是前几年前端开发中的老大哥了，而我们最喜欢的也是他提供的选择器跟链式调用的方法了，最近在看了原型与原型链之后也是有点简单的想法，想尝试着实现以下jquery的选择器</li>\n<li>首先需要构建一个函数A可以接受一个id名，返回一个新的对象，而且对象具有jquery提供的一系列方法，所以我们可以构造一个拥有这些方法的B对象并返回</li>\n</ul>\n<pre><code class=\"language-js\">  function A(selector){\n    return B\n  }\n  let B = {\n    length: 3,\n    size: function(){\n      return this.length\n    }\n  }\n</code></pre>\n<!--more-->\n<ul>\n<li>但是单纯的B对象的没办法接收选择器名称，所以我们可以给B添加一个初始化函数init，接收一个选择器名称，并返回最后的对象，因为返回的对象需要拥有B上面的方法，所以我们还是选择将B对象返回，但是我们也需要获取到的dom元素，所以，参照jquery的方法，我们可以将B对象的0属性设置为获取到的dom元素,并且更新B对象的length属性。那如何在函数内返回B对象那？因为init方法是挂载在对象身上的，所以，我们需要返回B对象的时候只需要返回this就可以了</li>\n</ul>\n<pre><code class=\"language-js\">  function A(selector){\n    return B.init(selector)\n  }\n  let B = {\n    init: function(selector){\n      let dom = document.getElementById(selector)\n      this[0] = dom\n      this.length = 1\n      return this\n    },\n    length: 3,\n    size: function(){\n      return this.length\n    }\n  }\n</code></pre>\n<ul>\n<li>这里的话我们需要手动实现一个B对象，过于繁琐，其实我们可以将A函数的fn属性设置为这个对象，这样就省去了显式的创建B对象</li>\n</ul>\n<pre><code class=\"language-js\">  function A(selector){\n    return A.fn.init(selector)\n  }\n  A.fn = {\n    init: function(selector){\n      let dom = document.getElementById(selector)\n      this[0] = dom\n      this.length = 1\n      return this\n    },\n    length: 3,\n    size: function(){\n      return this.length\n    }\n  }\n\n  var a = A('demo') // Object {0: #demo, init: f, length: 1, size: f}\n  var t = A('test') // Object {0: #test, init: f, length: 1, size: f}\n  console.log(a)    // Object {0: #test, init: f, length: 1, size: f}\n</code></pre>\n<ul>\n<li>上面我们能发现，如果直接返回A.fn这个对象的话则所有通过A函数获取到的对象会公用一个对象，包括属性，这样的话就会相互影响，取不到我们想要的dom，所以我们可以在返回前使用new进行修饰，但是new的特性导致返回的对象中的this将不再指向我们的A.fn，也就意味这我们不能使用size()方法，所以我们可以指定A.fn.init的prototype到A.fn从而获取size方法</li>\n</ul>\n<pre><code class=\"language-js\">  function A(selector){\n    return new A.fn.init(selector)\n  }\n  A.fn = {\n    init: function(selector){\n      let dom = document.getElementById(selector)\n      this[0] = dom\n      this.length = 1\n      return this\n    },\n    length: 3,\n    size: function(){\n      return this.length\n    }\n  }\n\n  A.fn.init.prototype = A.fn\n\n  var a = A('demo')         // Object {0: #demo, init: f, length: 1, size: f}\n  var t = A('test')         // Object {0: #test, init: f, length: 1, size: f}\n  console.log(a.size())     // 1\n</code></pre>\n<h2>extend方法实现</h2>\n<ul>\n<li>上面我们就简单的实现了一个id选择器，下面的话我们需要实现一下jQuery拓展插件的方式extend，extend方法其实就是对对象的整合并返回新的对象，所以要根据参数进行拓展，单对象则在当前对象拓展，多对象则融合并返回</li>\n</ul>\n<pre><code class=\"language-js\">  A.extend = A.fn.extend = function(...args){\n    let len = args.length, target\n    if(len === 0) {\n      return\n    }\n    if(len === 1) {\n      target = this\n      for(let key in args[0]) {\n        target[key] = args[0][key]\n      }\n    } else {\n      target = args[0]\n      for(let i = 1; i &#x3C; len; i++) {\n        for(let key in args[i]) {\n          target[key] = args[i][key]\n        }\n      }\n    }\n    return target\n  }\n\n  var a = A('demo')\n  a.extend({b: 3, d: 4})\n  console.log(a) // Object {0: #demo, length: 1, b:3, d: 4}\n\n  A.extend(a, {e: 4})\n\n  console.log(a) // Object {0: #demo, length: 1, b:3, d: 4, e:4}\n</code></pre>\n<ul>\n<li>上面就是拓展插件extend方法的实现，利用这个方法，可以在A函数或者选择之后的对象进行拓展</li>\n</ul>\n<h2>链式调用的实现</h2>\n<ul>\n<li>链式调用就是在每个方法执行完成之后都将当前this放回，这样接下来的方法便都可以拿到这个对象并接着调用，所以我们可以先拓展几个常用的jquery的方法</li>\n<li>on方法的实现，由于各浏览器的兼容性问题，所以我们对事件绑定方式on进行一个简单的实现，还是要用到我们的extend方法，因为选择器返回的对象都可以调用这个方法，所以我们将其拓展到A.fn对象上面</li>\n</ul>\n<pre><code class=\"language-js\">A.fn.extend({\n  // 立即执行函数获取各浏览器下的绑定方式并绑定到on方法上，避免每次调用都要判断浏览器环境\n  on: (function(){\n    if(document.addEventListener) {\n      return function(type, fn){\n        for(let i = 0; i &#x3C; this.length; i++) {\n          this[i].addEventListener(type, fn, false)\n        }\n      }\n    } else if(document.addEvent) {\n      return function(type, fn){\n        for(let i = 0; i &#x3C; this.length; i++) {\n          this[i].addEvent('on'+type, fn)\n        }\n      }\n    } else {\n      return function(type, fn){\n        for(let i = 0; i &#x3C; this.length; i++) {\n          this[i]['on' + type] = fn\n        }\n      }\n    }\n  })()\n})\n\na.on('click', function(){\n  console.log(this.innerHTML) // 1\n})\n</code></pre>\n<ul>\n<li>上面我们对A.fn进行了拓展，使所有选择器返回的对象都可以进行数据绑定，并且可以成功打印1</li>\n<li>接下来我们依次对其进行attr,css,html方法的拓展，在对css方法进行拓展的时候我们先对A进行了拓展，使其拥有可以将-连接的css属性转为驼峰命名的css属性，从而实现我们的赋值</li>\n</ul>\n<pre><code class=\"language-js\">A.extend({\n  // 常用css转驼峰\n  cameName: function(str){\n    return str.replace(/\\-(\\w)/g, function(all, letter){\n      return letter.toUpperCase()\n    })\n  }\n})\n\nA.fn.extend({\n  attr: function(...args){\n    if(args.length &#x3C; 1) {\n      return\n    }\n    if(args.length === 1) {\n      if(typeof args[0] === 'string') {\n        return this[0].getAttribute(args[0])\n      } else {\n        for(let i = 0; i &#x3C; this.length; i++) {\n          for(let key in args[0]) {\n            this[i].setAttribute(key, args[0][key])\n          }\n        }\n      }\n    } else {\n      for(let i = 0; i &#x3C; this.length; i++) {\n        this[i].setAttribute(args[0], args[1])\n      }\n    }\n    return this\n  },\n  html: function(...args){\n    console.log(args)\n    if(args.length) {\n      for(let i = 0; i &#x3C; this.length; i++) {\n        this[i].innerHTML = args[0]\n      }\n      return this\n    } else {\n      return this[0].innerHTML\n    }\n  },\n  css: function(...args){\n    if(args.length &#x3C; 1) {\n      return\n    }\n    if(args.length === 1) {\n      const name = args[0]\n      if(typeof args[0] === 'string') {\n        if(this[0].currentStyle){\n          return this[0].currentStyle[name]\n        } else {\n          return getComputedStyle(this[0], false)[name]\n        }\n      }else if(typeof args[0] === 'object') {\n        for(let i = 0; i &#x3C; this.length; i++) {\n          for(let key in args[0]) {\n            this[i].style[A.cameName(key)] = args[0][key]\n          }\n        }\n      }\n    } else {\n      const name = args[0]\n      for(let i = 0; i &#x3C; this.length; i++) {\n        this[i].style[A.cameName(name)] = args[1]\n      }\n    }\n    return this\n  }\n})\n</code></pre>\n<ul>\n<li>上面我们就实现了jquery常用的几个方法与链式调用，下面我们就可以使用上面的方法进行调用</li>\n</ul>\n<pre><code class=\"language-js\">a.css('background-color', '#0f0').html('我是链式调用').attr('data-tag', 'div').on('click', function(){\n    alert(this.innerHTML)\n})\n</code></pre>","fields":{"slug":"/jQuery/"},"frontmatter":{"title":"jquery选择器的实现","tags":["JavaScript回顾","设计模式","进修"],"categories":"JavaScript"}}},{"node":{"html":"<h1>事件绑定的两种优化方式</h1>\n<ul>\n<li>事件绑定在我们的项目中是经常存在的，但因为各浏览器对事件绑定的支持度不同，使我们不得不写一个兼容函数来实现事件绑定，常规的写法如下</li>\n</ul>\n<pre><code class=\"language-js\">function on(dom, type, fn){\n  if(document.addEventListener) { // IE9以上及主流浏览器\n    dom.addEventListener(type, fn, false)\n  } else if(document.attachEvent) { // IE8一下浏览器\n    dom.attachEvent('on' + type, fn)\n  } else { // dom0级支持浏览器\n    dom['on' + type] = fn\n  }\n}\n</code></pre>\n<ul>\n<li>上面的写法虽然能解决我们的问题，但是在页面中使用时，每绑定一次就要走一次逻辑判断，而这一部分其实是可以优化的，优化的方式一般有两种，一种是页面加载完毕便执行一个立即执行函数完成on的赋值，另一个则是在第一次调用的时候完成on的重新赋值</li>\n<li>页面加载完成赋值的实现如下</li>\n</ul>\n<!--more-->\n<pre><code class=\"language-js\">var on = (function(){\n  if(document.addEventListener) {\n    return function(dom, type, fn){\n      dom.addEventListener(type, fn)\n    }\n  } else if(document.attachEvent) {\n    return function(dom, type, fn){\n      dom.attachEvent('on' + type, fn)\n    }\n  } else {\n    return function(dom, type, fn){\n      dom['on' + type] = fn\n    }\n  }\n})()\n</code></pre>\n<ul>\n<li>通过开始的立即执行函数完成条件判断，并重新返回一个符合该浏览器兼容的绑定函数给on，这样在之后的函数绑定时就会使用这个返回的函数而不用再去判断一次浏览器情况</li>\n<li>缺陷就是在页面开始加载的时候就会执行，如果页面依赖比较多的情况下建议使用第二种方式</li>\n<li>第一次调用时绑定，也就是利用懒性模式实现绑定，实现方式如下</li>\n</ul>\n<pre><code class=\"language-js\">function on(dom, type, fn){\n  if(document.addEventListener) {\n    on = function(dom, type, fn){\n      dom.addEventListener(type, fn, false)\n    }\n  }else if(document.attachEvent) {\n    on = function(dom, type, fn){\n      dom.attachEvent('on' + type, fn)\n    }\n  } else {\n    on = function(dom, type, fn){\n      dom['on' + type] = fn\n    }\n  }\n  on(dom, type, fn)\n}\n</code></pre>\n<ul>\n<li>这种方式的实现是在浏览器判断条件完成之后对on重新赋值，并且在赋值之后进行函数的调用，这样在第一次执行之后on就被重新赋值，下次绑定就不会再走条件判断了，适用于首屏加载依赖比较多的情况</li>\n</ul>","fields":{"slug":"/lazy_event/"},"frontmatter":{"title":"事件绑定的两种优化方式","tags":["JavaScript回顾","设计模式","进修"],"categories":"JavaScript"}}},{"node":{"html":"<h1>字符串模板的实现</h1>\n<ul>\n<li>字符串模板是针对大批量、多频率操作dom的解决方案，比如我们要根据数据动态创建一个多嵌套的元素并将其插入到页面中，如果我们采用常规创建dom元素的方式进行插，代码量会极其庞大，下面就是常规方式实现的功能</li>\n</ul>\n<!--more-->\n<pre><code class=\"language-js\">// 源数据\nlet data = {\n  data: {\n    li: [\n      {\n        span: '我是span',\n        strong: '我是strong'\n      },\n      {\n        span: '我是span',\n        strong: '我是strong'\n      },\n      {\n        span: '我是span',\n        strong: '我是strong'\n      }\n    ],\n    h2: '我是第二标题',\n    p: '我是p标签'\n  },\n  id: 'containter',\n}\n\nfunction createDom(data){\n  let div = document.createElement('div')\n  div.id = data.id\n  let ul = document.createElement('ul')\n  let p = document.createElement('p')\n  let pt = document.createTextNode(data.data.p)\n  let h2 = document.createElement('h2')\n  let ph = document.createTextNode(data.data.h2)\n  p.appendChild(pt)\n  h2.appendChild(ph)\n  let liData = data.data.li\n  for(let i = 0, len = liData.length; i &#x3C; len; i++) {\n    let li = document.createElement('li')\n    let span = document.createElement('span')\n    let strong = document.createElement('strong')\n    let t = document.createTextNode(liData[i].strong)\n    let p = document.createTextNode(liData[i].span)\n    span.appendChild(p)\n    strong.appendChild(t)\n    li.appendChild(span)\n    li.appendChild(strong)\n    ul.appendChild(li)\n  }\n\n  div.appendChild(ul)\n  div.appendChild(p)\n  div.appendChild(h2)\n  document.body.appendChild(div)\n}\n</code></pre>\n<ul>\n<li>上面的方式可以看到在大批量的创造dom，然后不停地嵌套添加，代码量大，并且效率低下</li>\n<li>所以这里我们提供了一个模板字符串的函数来生成这个模板并最后插入到页面中，首先我们要提供一个字符串替换的一个函数用来将数据替换到页面中</li>\n</ul>\n<pre><code class=\"language-js\">// 替换字符串模板中的数据\nfunction formatString(str, data){\n  return str.replace(/\\{\\{(\\w+)\\}\\}/g, function(all, key){\n    return data[key]\n  })\n}\n</code></pre>\n<ul>\n<li>然后根据数据结构创建我们的模板字符串与生成模板字符串的函数</li>\n</ul>\n<pre><code class=\"language-js\">// 生成数据的函数\nfunction createStrTemplate(data){\n  let div = document.createElement('div')\n  div.id = data.id\n  // 获取li遍历的数据\n  let liData = data.data.li\n  let ulStr = ''\n  // 根元素div的子元素模板\n  let divStr = [\n    '&#x3C;p>{{p}}&#x3C;/p>',\n    '&#x3C;h2>{{h2}}&#x3C;/h2>',\n    '&#x3C;ul>{{ul}}&#x3C;/ul>'\n  ].join('')\n  // li的模板\n  let liStr = [\n    '&#x3C;li>',\n    '&#x3C;span>{{span}}&#x3C;/span>',\n    '&#x3C;strong>{{strong}}&#x3C;/strong>',\n    '&#x3C;/li>'\n  ].join('')\n  for(let i = 0, len = liData.length; i &#x3C; len; i++) {\n    // 遍历li数组生成li元素并将内里的数据进行填充\n    ulStr += formatString(liStr, liData[i])\n  }\n  // 将填充好的字符串作为ul的源数据进行赋值\n  data.data.ul = ulStr\n  // 对div模板内的数据进行替换，并作为html内容进行赋值\n  let divStrTemplate = formatString(divStr, data.data)\n  div.innerHTML = divStrTemplate\n  document.body.appendChild(div)\n}\n\ncreateStrTemplate(data)\n</code></pre>\n<ul>\n<li>这样便实现了我们的模板字符串函数，只操作了一次dom创建与一次添加便完成了功能，能极大地提升我们的执行效率</li>\n<li>上面得代码可以看到创建的模板字符串都是同名标签加同名变量，我们可以对其进行进一步的处理</li>\n<li>构造一个生产标签加变量的函数</li>\n</ul>\n<pre><code class=\"language-js\">// 此函数可以接收字符串或者数组来生产对应的标签加变量\nfunction view(name){\n  if(Object.prototype.toString.call(name) === '[object Array]') {\n    let str = ''\n    for(let i = 0, len = name.length; i &#x3C; len; i++) {\n      str += view(name[i])\n    }\n    return str\n  } else {\n    return `&#x3C;${name}>{{${name}}}&#x3C;/${name}>`\n  }\n}\n</code></pre>\n<ul>\n<li>有了这个函数之后我们就可以对上面得代码进行进一步的优化</li>\n</ul>\n<pre><code class=\"language-js\">function createStringTemplate(data){\n  let div = document.createElement('div')\n  div.id = data.id\n  // 生成div子元素模板\n  let divStr = view(['p', 'h2', 'ul'])\n  let ulStr = ''\n  let liData = data.data.li\n  // 这一句先是生成了li子元素的模板，生成了li模板，然后又将li子元素模板作为模板数据填充进li中\n  let liTpl = formatString(view('li'), {li: view(['span', 'strong'])})\n  for(let i = 0, len = liData.length; i &#x3C; len; i++) {\n    // 遍历li数组生成li元素并将内里的数据进行填充\n    ulStr += formatString(liTpl, liData[i])\n  }\n  data.data.ul = ulStr\n  // 对div模板内的数据进行替换，并作为html内容进行赋值\n  let divStrTemplate = formatString(divStr, data.data)\n  div.innerHTML = divStrTemplate\n  document.body.appendChild(div)\n}\n\ncreateStringTemplate(data)\n</code></pre>\n<ul>\n<li>以上便是我们最终版的利用模板字符串替换频繁的dom操作，极大程度的提升我们的执行效率</li>\n</ul>","fields":{"slug":"/string_template/"},"frontmatter":{"title":"字符串模板的实现","tags":["JavaScript回顾","设计模式","进修"],"categories":"JavaScript"}}},{"node":{"html":"<h1>Storage工具类的封装</h1>\n<ul>\n<li>日常开发中我们都会涉及到前端数据的存储，对一些需要长期保存在客户端的数据，我们通常会采用浏览器提供的localStorage对象，简称Storage对象。</li>\n<li>由于所有的页面处于同一个浏览器环境下，所以各个开发工程师所存储的Storage数据可能会出现同名情况，这样就会相互覆盖相互影响，所以为了解决这一问题，我们需要每个开发者都对自己的存储数据进行前缀命名好避免数据的污染</li>\n<li>Storage的存储api提供的比较简单，所以要实现这个功能就要我们进行进一步的封装与拓展，以实现我们的需求，首先我们构建一个Storage类，接收一个开发者id与数据分隔符（用于区分内容值与内容有效时间），并初始化状态对象</li>\n</ul>\n<!--more-->  \n<pre><code class=\"language-js\">function Storage(userId, sep){\n  this.userId = userId  // 开发者标识\n  this.sep = sep || '|_|'       // 数据分隔符\n  this.Storage = localStorage || window.localStorage\n  this.status = { // 操作状态值\n    FAILUER: 0,   // 失败\n    SUCCESS: 1,   // 成功\n    TIMEOUT: 2,   // 过期\n    OVERFLOW: 3   // 溢出\n  }\n}\n</code></pre>\n<ul>\n<li>之后我们需要对这个类提供操作方法，常用的方法为get,set,remove，get方法一般接受键名与一个回调函数，set接受键名，键值，有限期与回调函数，remove接收一个键名与一个回调函数，下面我们分别来实现这几个方法</li>\n<li>为了Storage实例可以调用这几个方法，所以我们将其绑定到Storage的原型上面</li>\n</ul>\n<pre><code class=\"language-js\">Storage.prototype = {\n  // 方便后续获取键名\n  getKey: function(key){\n    return this.userId + key\n  },\n  get: function(userKey, cb){\n    let key = this.getKey(userKey)\n    let status = this.status.SUCCESS\n    let value, sepIndex, time, result\n    try {\n      value = this.Storage.getItem(key)\n    } catch(e) {\n      value = null\n      status = this.status.FAILURE\n      result = {\n        value,\n        status\n      }\n      cb &#x26;&#x26; cb(result)\n      return result\n    }\n    if(value) {\n      sepIndex = value.indexOf(this.sep)\n      time = value.slice(0, sepIndex)\n      // 查看内容是否过期\n      if(new Date().getTime() &#x3C; new Date(time).getTime() || +time === 0){\n        value = value.slice(sepIndex + this.sep.length)\n      } else {\n        status = this.status.TIMEOUT\n        value = null\n        this.remove(key)\n      }\n    } else {\n      value = null\n    }\n    result = {\n      value,\n      status\n    }\n    cb &#x26;&#x26; cb(result)\n    return result\n  },\n  set: function(userKey, value, time, time = 0, cb){\n    let key = this.getKey(userKey)\n    let status = this.status.FAILURE\n    let result\n    // 是否设置时间，未设置默认一个月\n    try {\n      time = new Date(time).getTime()\n    } catch (e) {\n      time = new Date().getTime() + 30 * 24 * 60 * 60 * 1000\n    }\n    const realValue = time + this.sep + value\n    // 检查是否数据过多溢出\n    try {\n      this.Storage.setItem(key, realValue)\n    } catch (e) {\n      status = this.status.OVERFLOW\n    }\n    result = {\n      status\n    }\n    cb &#x26;&#x26; cb(result)\n    return result\n  },\n  remove: function(userKey, cb){\n    let status = this.status.FAILUER\n    let key = this.getKey(userKey)\n    let result\n    try {\n      this.Storage.removeItem(key)\n      status = this.status.SUCCESS\n    } catch(e) {\n    }\n    result = {\n      status\n    }\n    cb &#x26;&#x26; cb(result)\n    return result\n  }\n}\n</code></pre>\n<ul>\n<li>上面就是我们对Storage操作方法的实现，实现很简单，主要是处理一下各个情况下的状态值还有错误屏蔽，防止意外报错</li>\n<li>下面我们可以尝试一下为张三设置一下存储信息</li>\n</ul>\n<pre><code class=\"language-js\">let zsStorage = new Storage('zhangsan-')\nmyStorage.set('name', '张三')  // zhangsan-name: 0|_|张三\nmyStorage.get('name')         // {value: '张三', status: 1}\nmyStorage.remove('name')\n</code></pre>\n<ul>\n<li>这样一来就可以实现了一个适合我们使用的Storage的工具类</li>\n</ul>","fields":{"slug":"/storage/"},"frontmatter":{"title":"storage工具类的封装","tags":["JavaScript回顾","设计模式","进修"],"categories":"JavaScript"}}},{"node":{"html":"<h1>栈</h1>\n<ul>\n<li>栈是我们经常听到的数据结构，拥有后入先出的特性，可以理解为存放箱子的过程，存的时候后来的都放到先来的上面，取得时候也是从上面往下取，因为上面都是后来的箱子，所以会被先取出来</li>\n<li>JavaScript并没有栈这个数据类型，所以需要我们手动来实现，因为要涉及到一堆数据的存储，并且有先后顺序，还能实现存入与取出，最理想的实现数据类型自然就是我们的数组了，下面我们来实现一下栈</li>\n<li>首先定义一个栈类，应该拥有一个存放数据的数组，以及标记最上面元素的一个标记</li>\n</ul>\n<pre><code class=\"language-js\">function Stack(){\n  this.top = 0\n  this.dataStore = []\n}\n</code></pre>\n<!--more-->\n<ul>\n<li>上面就是一个栈的基本属性了，接下来就是栈拥有的方法，分别为存入，取出,因为所有的栈都有这些方法，所以我们定义在Stack的原型上</li>\n</ul>\n<pre><code class=\"language-js\">Stack.prototype = {\n  insert: function(data){\n    // 因为top初始值为0，所以我们可以采用后加加的方式实现赋值后对top的加一来标识下一个位置\n    this.dataStore[this.top++] = data\n  },\n  pop: function(){\n    // 这里要移除最后一个元素并返回，这里top已经指向了下一个位置，所以我们返回元素需要前减减来返回我们最顶部的元素。而且我们并没有用数组pop的方式对数组进行改变，因为我们的插入方式是针对下标赋值的，只需要将下标改到最后一个元素，这样下次插入就会直接改变最后一个值了\n    return this.dataStore[--this.top] \n  },\n  peek: function(){\n    // 这里我们只是要获取栈顶元素，并不是要从栈中移除元素，所以我们不改变top值\n    return this.dataStore[this.top - 1]\n  },\n  length: function(){\n    return this.top\n  }\n}\n</code></pre>\n<ul>\n<li>上面就是一个完整的数据类型栈的实现，我们可以拿来尝试一下栈的经典案例</li>\n</ul>\n<h2>栈实现进制转换</h2>\n<ul>\n<li>进制转换的方式，对一个数值，不停的整除以要转换的进制，取余数后继续整除以，直到最后整除以后为0截至，然后将所有余数倒置拼接即可拿到转换后的数值，按照这个规则，我们可利用栈来进行进制转换</li>\n</ul>\n<pre><code class=\"language-js\">function toFixed(number, fix){\n  let stack = new Stack()\n  let str = ''\n  while(number > 0) {\n    stack.insert(number % fix)\n    number = Math.floor(number / fix)\n  }\n  while(stack.length() > 0) {\n    str += stack.pop()\n  }\n  return str\n}\n\ntoFixed(12, 2) // 1100\n</code></pre>","fields":{"slug":"/stack/"},"frontmatter":{"title":"JavaScript中实现数据结构栈","tags":["JavaScript回顾","数据结构","进修"],"categories":"数据结构"}}},{"node":{"html":"<h1>队列</h1>\n<ul>\n<li>队列也是我们编程当中经常用到的一个数据结构，具有先入先出的特性，跟平时我们的排队一样，先进来先走</li>\n<li>同样，JavaScript并没有队列这个数据类型，所以需要我们自己来实现，因为队列同样具有顺序，且可以存入与去除，所以我们采用数组来做一个简单的实现</li>\n<li>首先定义一个队列类，因为只涉及到数据的存储，所以初始设置一个容器就可以</li>\n</ul>\n<pre><code class=\"language-js\">function Quene(){\n  this.dataStore = []\n}\n</code></pre>\n<ul>\n<li>上面就是一个队列的基本属性了，接下来就是队列拥有的方法，分别为入队，出队,获取队首元素，队尾元素，队列是否为空</li>\n</ul>\n<!--more-->\n<pre><code class=\"language-js\">Quene.prototype = {\n  enquene: function(data){\n    // 队列元素只能添加到队列最后面，所以我们直接使用数组push方法即可\n    this.dataStore.push(data)\n  },\n  dequene: function(){\n    // 队列元素出队是移除第一个元素，可以使用数组的shift方法移除数组的第一个元素\n    return this.dataStore.shift()\n  },\n  front: function(){\n    // 查询队首的元素\n    return this.dataStore[0]\n  },\n  back: function(){\n    // 查询队尾的元素\n    return this.dataStore[this.dataStore.length - 1]\n  },\n  isEmpty: function(){\n    return this.dataStore.length === 0 ? true : false\n  },\n  toString: function(){\n    // 用于遍历展示队列的元素\n    let str = ''\n    for(let i = 0; i &#x3C; this.dataStore.length; i++) {\n      str += '下一个是: ' + this.dataStore[i] + ' ,'\n    }\n    return str\n  }\n}\n</code></pre>\n<ul>\n<li>上面就是一个完整的数据类型队列的实现，我们可以拿来尝试一下队列的经典案例</li>\n</ul>\n<h2>队列实现舞池效果</h2>\n<ul>\n<li>舞池效果，舞池可供男女组队跳舞，但是男女的人数都不固定，所以需要一套匹配系统，当同时有男生女生排队时则播报入场男生名字与女方入场名字，若是只有男生或者女生，则播报男生或者女生的等待名称</li>\n<li>根据这个需求，我们需要确立一个舞者的类，具有性别与姓名的属性</li>\n</ul>\n<pre><code class=\"language-js\">// 舞者类\nfunction Dancer(name, sex){\n  this.name = name\n  this.sex = sex\n}\n\n// 跳舞者的文档资料，前面为性别，后面为名称\nlet dancers = `\nF A\nM B\nF C\nM D\nF E\nM F\nM G\n`\n// 用于存储男女舞者\nlet M = new Quene()\nlet F = new Quene()\n\nfunction initDancer(){\n  let dancerArr = dancers.split('\\n')\n  // 剔除空字符串\n  dancerArr = dancerArr.filter(item => {\n    if(item.trim()) {\n      return item.trim()\n    }\n  })\n  // 对所有舞者进行分组排列\n  dancerArr.forEach(item => {\n    let name = item.split(' ')[1], sex = item.split(' ')[0]\n    if(sex === 'F') {\n      F.enquene(new Dancer(name, sex))\n    } else {\n      M.enquene(new Dancer(name, sex))\n    }\n  })\n}\n\ninitDancer()\n\nfunction dancer(){\n  console.log('The dancer parters are \\n')\n  while(!M.isEmpty() &#x26;&#x26; !F.isEmpty()) {\n    console.log(`男方入场者为：${ M.dequene().name }，女方入场者为${ F.dequene().name }`)\n  }\n  if(!M.isEmpty()){\n    console.log(`男方等待区为：${ M.dequene().name }`)\n  }\n  if(!F.isEmpty()){\n    console.log(`女方等待区为: ${ F.dequene().name }`)\n  }\n}\n\ndancer()\n// The dancer parters are \n// 男方入场者为：B，女方入场者为A\n// 男方入场者为：D，女方入场者为C\n// 男方入场者为：F，女方入场者为E\n// 男方等待区为：G\n</code></pre>","fields":{"slug":"/quene/"},"frontmatter":{"title":"JavaScript中实现数据结构队列","tags":["JavaScript回顾","数据结构","进修"],"categories":"数据结构"}}}]}},"pageContext":{"limit":10,"skip":10,"currentIndex":1}},"staticQueryHashes":["2566592090"]}