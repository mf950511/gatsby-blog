{"componentChunkName":"component---src-templates-blog-small-jsx","path":"/blog/Map/","result":{"data":{"markdownRemark":{"html":"<h1>Map与WeakMap</h1>\n<h2>Map</h2>\n<ul>\n<li>Map是ES6新增的键值存储类型</li>\n<li>创建方式为 new 关键字加 Map构造函数</li>\n<li>可以通过在构造函数内传入可迭代对象来初始化该实例，可迭代对象的每一项需要包含键/值对数组，如下</li>\n</ul>\n<pre><code class=\"language-js\">const m = new Map()\nconst m1 = new Map([['key1', 'value1'], ['key2', 'value2'], ['key3', 'value3']])\nconst m2 = new Map({\n  [Symbol.iterator]: function*(){\n    yield ['key1', 'value1']\n    yield ['key2', 'value2']\n  }\n})\nconsole.log(m1) // {\"key1\" => \"value1\", \"key2\" => \"value2\", \"key3\" => \"value3\"}\nconsole.log(m2) // {\"key1\" => \"value1\", \"key2\" => \"value2\"}\n\n// Map会映射它期待的键值对，无论你提供不提供，如下，因为没有提供对应的键值，Map会自动以undefined填充\nconst m3 = new Map([[]])\nconsole.log(m3) // {undefined => undefined}\n</code></pre>\n<ul>\n<li>set()方法可以给Map添加新的键值对，get可以查询对应键下面的值，has可以判断该Map是否有对应的键</li>\n<li>\n<p>size可以获取Map的键值对数量，delete()用于删除指定值，clear()用于清空Map，如下</p>\n<!--more-->\n<pre><code class=\"language-js\">const m4 = new Map()\nconsole.log(m4.has('first'))  // false\nconsole.log(m4.get('first'))  // undefined\nconsole.log(m4.size)          // 0\n</code></pre>\n</li>\n</ul>\n<p>// set方法会返回它自身，所以可以连续set\nm4.\nset('first', 'matt').\nset('last', 'kuni')\nconsole.log(m4.has('first'))  // true\nconsole.log(m4.get('first'))  // 'matt'</p>\n<p>m4.delete('first')\nconsole.log(m4.has('first'))  // false<br>\nconsole.log(m4.has('last'))   // true\nconsole.log(m4.get('first'))  // undefined\nconsole.log(m4.get('last'))   // 'last'\nconsole.log(m4.size)          // 1</p>\n<p>m4.clear()</p>\n<p>console.log(m4.has('last'))   // false\nconsole.log(m4.size)          // 0</p>\n<pre><code>- Map可以使用任何类型作为键，has与get使用严格相等来判定该键是否存在\n\n```js\nconst m5 = new Map()\nconst funcKey = function(){}\nconst objectKey = {}\nconst symbolKey = Symbol()\n\nm5.\nset(funcKey, 'function').\nset(objectKey, 'object').\nset(symbolKey, 'symbol')\n\nconsole.log(m5.get(funcKey))    // function\nconsole.log(m5.get(objectKey))  // object\nconsole.log(m5.get(symbolKey))  // symbol\n\n// 全等判断，所以独立实例不冲突\nconsole.log(m5.get(function(){})) // undefined\n</code></pre>\n<ul>\n<li>全等判断，所以用作键和值的对象在自己的内容或属性变更时仍然保持不变</li>\n</ul>\n<pre><code class=\"language-js\">const m6 = new Map()\nconst objKey = {}\nconst objVal = {}\n\nm6.\nset(objKey, objVal)\n\nobjKey.m1 = 'm1'\nobjVal.m2 = 'm2'\n\nconsole.log(m6.get(objKey))    // {m2: \"m2\"}\n\n\n// 全等判断，所以独立实例不冲突\nconsole.log(m6.get({})) // undefined\n</code></pre>\n<ul>\n<li>全等判断，所以下面情况可能出问题</li>\n</ul>\n<pre><code class=\"language-js\">const m7 = new Map()\nconst a = 0/'', b = 0/'',pz = +0, nz = -0;\nconsole.log(a === b)\nconsole.log(pz === nz)\n\nm7.set(a, 'foo')  // false\nm7.set(pz, 'bar') // true\n\nconsole.log(m7.get(b))  // 'foo'\nconsole.log(m7.get(nz)) // 'bar'\n</code></pre>\n<h2>Map顺序与迭代</h2>\n<ul>\n<li>Map维护键值插入的顺序，所以是可迭代的，实例提供了一个迭代器，以插入顺序生成[key, value]形式的数组。</li>\n<li>通过entries()方法或者Symbol.iterator属性（引用的就是entries()）获取迭代器</li>\n</ul>\n<pre><code class=\"language-js\">const m8 = new Map([['key1', 'value1'], ['key2', 'value2'], ['key3', 'value3']])\nconsole.log(m8.entries === m8[Symbol.iterator]) // true\n\nfor(let pairs of m8[Symbol.iterator]()) {\n  console.log(pairs)\n}\n// [\"key1\", \"value1\"]\n// [\"key2\", \"value2\"]\n// [\"key3\", \"value3\"]\n</code></pre>\n<ul>\n<li>entries()是默认迭代器，所以可以对实例使用拓展操作</li>\n</ul>\n<pre><code class=\"language-js\">const m8 = new Map([['key1', 'value1'], ['key2', 'value2'], ['key3', 'value3']])\n\nconsole.log([...m8]) // [[\"key1\", \"value1\"], [\"key2\", \"value2\"], [\"key3\", \"value3\"]]\n</code></pre>\n<ul>\n<li>也可以不用迭代器，使用回调方法，用映射的forEach方法并传入回调，依次接受每个键/值对。回调可接受可选的第二个参数，用于重写内部的this值</li>\n<li>forEach中的第一个参数是对应的值，第二个为对应的键。</li>\n</ul>\n<pre><code class=\"language-js\">const m8 = new Map([['key1', 'value1'], ['key2', 'value2'], ['key3', 'value3']])\n\nm8.forEach((val, key) => { console.log(`${ key } -> ${ val }`) })\n// key1 -> value1\n// key2 -> value2\n// key3 -> value3\n\nm8.forEach(function(val, key){ console.log(`${ key } -> ${ this.name } -> ${ val}`) }, { name: 'm8' })\n// key1 -> m8 -> value1\n// key2 -> m8 -> value2\n// key3 -> m8 -> value3\n</code></pre>\n<ul>\n<li>keys()跟values()分别返回以插入顺序生成的键跟值</li>\n</ul>\n<pre><code class=\"language-js\">const m8 = new Map([['key1', 'value1'], ['key2', 'value2'], ['key3', 'value3']])\n\nfor(let key of m8.keys()) {\n  console.log(key)\n}\n// key1\n// key2\n// key3\n\nfor(let val of m8.values()) {\n  console.log(val)\n}\n\n// value1\n// value2\n// value3\n</code></pre>\n<ul>\n<li>\n<p>Object与Map的对比</p>\n<ul>\n<li>内存情况，Object与Map占用的内存都会随键的数量线性增加。在给定固定大小内存的情况下，Map可以比Object多存储 50% 的键值对</li>\n<li>插入性能，Object与Map对插入的消耗差不多，但是Map要快一点，所以大量的插入操作使用Map</li>\n<li>查找速度，包含少量的键值时，Object的速度更快，涉及大量的查找操作使用Object更好</li>\n<li>删除性能，Object的delete性能很差，Map的delete()比插入和查找更快。所以涉及大量删除使用Map</li>\n</ul>\n</li>\n</ul>\n<h2>WeakMap</h2>\n<ul>\n<li>WeakMap是Map的兄弟类型，API也是Map的子集，“weak”描述的时Javascrip垃圾回收程序对待“弱映射”中键的形式</li>\n<li>WeakMap中的键只能是Object或者继承自Object的类型，使用非对象设置键会抛出TypeError，值类型无限制</li>\n<li>初始化时只要有一个键无效就会抛错，其他的初始化全部失败</li>\n</ul>\n<pre><code class=\"language-js\">const key1 = { id: 1 }\nconst key2 = { id: 2 }\nconst key3 = { id: 3 }\n\nconst wm = new WeakMap([[key1, 'val1'], ['BADKEY', 'val2']]) // VM648:5 Uncaught TypeError: Invalid value used as weak map key\n\n// 要使用非对象的值可以使用构造函数包装再使用\nconst wm = new WeakMap([[key1, 'val1'], [new String('BADKEY'), 'val2']]) // {String => \"val2\", {…} => \"val1\"}\n</code></pre>\n<ul>\n<li>其他的基本方法set、get、has与Map保持一致</li>\n<li>“weak”表示键不属于正式引用，可以被回收，当键被回收后，键值对消失</li>\n</ul>\n<pre><code class=\"language-js\">const wm2 = new WeakMap()\nconst container = {\n  key:{}\n}\nwm2.set(container.key, 'val')\nfunction removeReference(){\n  container.key = null\n}\nremoveReference()\n</code></pre>\n<ul>\n<li>上例中container对象维护着弱映射键的引用，所以不会被回收，但是要是执行了removeReference方法，那么键的引用就消失了，那么键值对就会消失</li>\n<li>WeakMap中的键值随时可能消失，所以没有迭代能力，也没有提供clear()清空的方法</li>\n<li>WeabMap之所以限制只能使用对象，是为了保证只有通过键对象的引用才能取到值。要是允许原始值就无法区分初始化时的字符串字面量跟初始化之后使用一个相同的字符串了</li>\n</ul>\n<h3>WeakMap的应用</h3>\n<ul>\n<li>私有变量</li>\n</ul>\n<pre><code class=\"language-js\">const User = (() => {\n  const wm = new WeakMap()\n  class User {\n    constructor(id) {\n      this.idProperty = Symbol('id')\n      this.setId(id)\n    }\n    setPrivate(property, value) {\n      const propertyMembers = wm.get(this) || {}\n      propertyMembers[property] = value\n      wm.set(this, propertyMembers)\n    }\n    getPrivate(property) {\n      return wm.get(this)[property]\n    }\n    setId(id) {\n      this.setPrivate(this.idProperty, id)\n    }\n    getId(){\n      return this.getPrivate(this.idProperty)\n    }\n  }\n  return User\n})()\n\nconst user = new User(123)\nconsole.log(user.getId()) // 123\nuser.setId(456)\nconsole.log(user.getId()) // 456\n</code></pre>\n<ul>\n<li>DOM节点元数据</li>\n<li>WeakMap不会阻止垃圾回收，适合保存元数据</li>\n</ul>\n<pre><code class=\"language-js\">const m = new Map()\nconst loginButton = document.querySelector('#login')\nm.set(loginButton, { disabled: true })\n</code></pre>\n<ul>\n<li>上面的实现在登录按钮被DOM树删除了，但因为Map中存在着按钮的引用，所以DOM节点还会在内存中存在</li>\n</ul>\n<pre><code class=\"language-js\">const m = new WeakMap()\nconst loginButton = document.querySelector('#login')\nm.set(loginButton, { disabled: true })\n</code></pre>\n<ul>\n<li>使用WeakMap后当节点被删除后这里的引用也会消失，内存可直接被回收</li>\n</ul>","frontmatter":{"title":"Map与WeakMap","date":"2020-10-16","tags":["JavaScript回顾"],"categories":"JavaScript"},"fields":{"slug":"/Map/"}}},"pageContext":{"slug":"/Map/"}},"staticQueryHashes":["2566592090"]}