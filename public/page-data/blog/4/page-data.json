{"componentChunkName":"component---src-templates-index-jsx","path":"/blog/4","result":{"data":{"allMarkdownRemark":{"totalCount":68,"edges":[{"node":{"html":"<ul>\n<li>javascript中的垃圾回收历史有两种，一种是最常用的标记清除，一种是不常用的引用计数清除法。</li>\n</ul>\n<h2>标记清除</h2>\n<ul>\n<li>标记清除是现代浏览器最常用的垃圾回收方式，原理是：</li>\n<li>当上下文有变量进入的时候就为它添加一个标记，这样整个程序执行时每一个创建的变量都会被添加标记。当变量离开上下文时也会被加上离开上下文的标记。然后当垃圾回收进程执行时，会把当前上下文的所有变量跟被引用的变量去除标记，这样剩下的有标记就都是不被引用也不被使用的变量了，这样就可以做内存清理了，销毁带标记的值并回收内存。</li>\n</ul>\n<h2>引用计数清除</h2>\n<ul>\n<li>这种计数方式在早期浏览器有使用过，后面就基本不怎么使用了，原理如下：</li>\n<li>当一个值被赋值给一个变量时就会把该值的引用数加一。比如，当声明一个变量并引用该值，则该值的引用数加一，当这个值被赋给另一个变量时，引用数继续加一。当一个引用该值的变量被其他值覆盖了，则该值的引用数减一，当引用数为0则表示该值不可被访问了，就会被垃圾回收。</li>\n<li>\n<p>该方式不常用是因为在循环引用时会无法释放内存，比如当a是一个对象，b也是一个对象，a的某个属性指向了b，b的某个属性指向了a，这样他们的引用值一直都不会为0，也就导致了该值一直存在无法回收。只有当我们显示的将a对应的属性跟b对应的属性都赋值null才会让他们进入垃圾回收。</p>\n<!--more-->\n<h2>性能优化</h2>\n</li>\n<li>现代浏览器的垃圾回收都是按照已分配对象的大小跟数量来判断的，这是因为早期IE是根据分配数来进行垃圾回收，比如设定了256个变量或者64k的字符串等，当满足其中的条件就会进行回收，这有可能整个脚本始终存在这么多的变量就导致了一直在运行，严重影响性能。</li>\n<li>所以改为了现有的根据分配对象来进行，首先它的起始阈值跟之前是一致的，只不过当某次垃圾回收的内存不到已分配的15%，那么就说明程序过大，这个阈值不够了，就会对阈值进行翻倍，然后下一次如果还是不到15%就继续翻倍，直到它满足15%以上为止</li>\n<li>如果某次的内存已经达到了85%，说明这个阈值已经过大了，应该再频繁一点，然后就会重置为默认值，重复进行这两个步骤，这样我们的性能就有很好的提升</li>\n<li>对声明的全局变量要是不再使用应该置为null</li>\n<li>多使用let、const提升性能，因为都是块级作用域，肯定会比全局变量更早终止，也就有可能更早的被回收</li>\n</ul>\n<h2>隐藏类优化性能</h2>\n<ul>\n<li>当我们的两个对象共享一个构造函数与原型时，在v8引擎会默认两个实例引用同一个隐藏类，如下：</li>\n</ul>\n<pre><code class=\"language-js\">function Article(){\n  this.title = \"my name\"\n}\nlet a1 = new Article()\nlet a2 = new Article()\n</code></pre>\n<ul>\n<li>这种情况下会默认使用一个隐藏类，但是当我们对对象进行了删除或者新增属性就会打破这个规则，如下</li>\n</ul>\n<pre><code class=\"language-js\">// 新增属性\nfunction Article(){\n  this.title = \"my name\"\n}\nlet a1 = new Article()\nlet a2 = new Article()\na2.name = 'danny'\n\n// 删除属性\nfunction Article(){\n  this.title = \"my name\"\n}\nlet a1 = new Article()\nlet a2 = new Article()\ndelete a2.title\n</code></pre>\n<ul>\n<li>这两种情况都会导致不再共享一个隐藏类，对应两个隐藏类，如果隐藏类过大就会影响性能，我们可以进行下面的优化</li>\n<li>对需要新增的属性操作添加在原型内，如下</li>\n</ul>\n<pre><code class=\"language-js\">function Article(name){\n  this.title = \"my name\"\n  this.name = name\n}\nlet a1 = new Article()\nlet a2 = new Article('danny')\n</code></pre>\n<ul>\n<li>这样还是共用一个隐藏类，针对删除操作，我们不要显示的删除，只需要将值设为null即可，如下</li>\n</ul>\n<pre><code class=\"language-js\">function Article(){\n  this.title = \"my name\"\n}\nlet a1 = new Article()\nlet a2 = new Article()\na2.title = null\n</code></pre>","fields":{"slug":"/collect-garbage/"},"frontmatter":{"title":"javascript中的垃圾回收","tags":["JavaScript回顾"],"categories":"JavaScript"}}},{"node":{"html":"<h1>乘、除、取余、指数、加法、减法、比较、相等操作符</h1>\n<h2>乘</h2>\n<ul>\n<li>乘法的计算遵循下面的原则</li>\n<li>如果结果超出ECMAScript所表示的范围，那么最终会得到 Infinity 或者 -Infinity</li>\n<li>NaN参与运算，得到NaN</li>\n<li>Infinity 与 0 相乘得 NaN </li>\n<li>Infinity 与 非 0 数相乘得 Infinity 或者 -Infinity ，由非 0 数决定符号</li>\n<li>如果其中一个是非数值，将会被Number()强制转为数值参与计算</li>\n</ul>\n<h2>除</h2>\n<ul>\n<li>除法的计算遵循下原则</li>\n<li>如果结果超出ECMAScript所表示的范围，那么最终会得到 Infinity 或者 -Infinity</li>\n<li>NaN参与运算，得到NaN</li>\n<li>Infinity 除以 Infinity 得到 NaN</li>\n<li>0 除以 0 得 NaN</li>\n<li>Infinity 除以 任何数都得 Infinity 或者 -Infinity ，符号由除数决定</li>\n<li>\n<p>如果其中一个操作符为非数值，则被Number()转为数值参与计算</p>\n<!--more-->\n<h2>取余</h2>\n</li>\n<li>取余的计算规则如下</li>\n<li>如果被除数是 Infinity ，除数是有限值，那么结果为 NaN</li>\n<li>如果被除数是 有限值，除数为 0，那么结果为 NaN</li>\n<li>除数跟被除数都是Infinity,则结果为NaN</li>\n<li>被除数是有限值，除数是Infinity,结果是被除数</li>\n<li>被除数是0，除数是非0，结果是0</li>\n<li>如果其中一个操作符为非数值，则被Number()转为数值参与计算</li>\n</ul>\n<h2>指数操作符</h2>\n<ul>\n<li>指数被用来表示某个数的多少次方，用<code>Math.pow()</code>来计算，在ECMAScript 7中可以使用 <code>**</code> 来表示</li>\n</ul>\n<pre><code class=\"language-js\">console.log(Math.pow(3, 2)) // 9\nconsole.log(3 ** 2) // 9\n</code></pre>\n<ul>\n<li>有了 <code>**</code>操作符自然也就有了对应的速写计算符<code>**=</code>，如下</li>\n</ul>\n<pre><code class=\"language-js\">let square = 3\nsquare **= 2\nconsole.log(square) // 9\n</code></pre>\n<h2>加法操作符</h2>\n<ul>\n<li>加法操作符比较特殊，对应不同的数据状态会发生不同的数据类型转换，规则如下</li>\n</ul>\n<h3>两个数都是数值的计算规则</h3>\n<ul>\n<li>如果两个数都是数值类型，那么对应规则如下</li>\n<li>有NaN参与计算，则值为NaN</li>\n<li>Infinity 加 -Infinity，结果为NaN</li>\n<li>-0 加 +0，结果为+0</li>\n<li>-0 加 -0，为-0， +0 加 +0，为+0</li>\n<li>Infinity 加 Infinity为Infinity，-Infinity 加 -Infinity 为 -Infinity</li>\n</ul>\n<h3>字符串参与计算的规则如下</h3>\n<ul>\n<li>其中一个值为字符串，则另一个值会被转为字符串然后进行拼接</li>\n</ul>\n<h2>减法操作符</h2>\n<ul>\n<li>减法操作符的计算规则</li>\n<li>NaN参与运算结果为NaN</li>\n<li>Infinity 减 Infinity ,结果为NaN</li>\n<li>-Infinity 减 -Infinity，结果为NaN</li>\n<li>Infinity 减 -Infinity，结果为Infinity</li>\n<li>-Infiniy 减 Infinity，结果为 -Infinity</li>\n<li>+0 减 +0 结果为 +0</li>\n<li>-0 减 +0 结果为 -0</li>\n<li>-0 减 -0 结果为 +0</li>\n<li>如果其中一个是 字符串、布尔值、null或者undefined，会使用Number()转为数值参与计算</li>\n<li>如果其中一个是对象，则会调用该对象的 valueOf() 方法来获取数值进行计算，如果对象没有valueOf方法，那么会调用toString()方法来获取值并转为对象参与计算</li>\n</ul>\n<h2>比较运算符</h2>\n<ul>\n<li>比较运算法有 >, &#x3C;, &#x3C;=, >=</li>\n<li>用来比较两个变量的大小关系，会返回一个布尔值</li>\n<li>针对不同数据类型，比较规则如下</li>\n<li>数值则直接比较大小</li>\n<li>都是字符串则依次比较每个字符对应的字符编码</li>\n<li>其中一个是数值则把另一个转为数值进行比较</li>\n<li>如果是对象，则调用 valueOf() 获取值参与比较，没有该属性就获取 toString()方法获取值参与比较</li>\n<li>如果其中一个是布尔值，则把它转为数值参与计算</li>\n<li>字符串比较时，所有的小写字母都要大于大写字母，所以要是想按字母顺序比较的话需要同时转为大写或者小写，如下</li>\n</ul>\n<pre><code class=\"language-js\">let result = \"Brick\" &#x3C; \"alphabet\"\nconsole.log(result) // true，并不是我们的预期\n\nlet result = \"Brick\".toLowerCase() &#x3C; \"alphabet\".toLowerCase()\nconsole.log(result) // false\n</code></pre>\n<ul>\n<li>NaN参与比较运算符永远都得false，哪怕是比较两个 NaN</li>\n</ul>\n<pre><code class=\"language-js\">let result = NaN > 3 // false\nlet result = NaN &#x3C;= 3 // false\n\nlet result = NaN > NaN // false\nlet result = NaN &#x3C;= NaN // false\n</code></pre>\n<h2>相等运算符</h2>\n<ul>\n<li>相等运算符分为全等与不全等运算符，不全等运算符不会比较类型，而是在比较时进行类型转换</li>\n</ul>\n<h3>不全等运算符规则</h3>\n<ul>\n<li>null 跟 undefined 相等</li>\n<li>null 跟 undefined 不会被转为其他类型进行比较</li>\n<li>NaN 参与比较永远返回false</li>\n<li>两个对象比较则对比是否两个是同一个对象，是就返回true，不是就返回false</li>\n<li></li>\n</ul>","fields":{"slug":"/multiplicative-operators/"},"frontmatter":{"title":"常用计算符独特的计算属性","tags":["JavaScript回顾"],"categories":"JavaScript"}}},{"node":{"html":"<h1>循环语句</h1>\n<h2>for-in 循环语句</h2>\n<ul>\n<li>for-in是严格迭代语句，会迭代一个对象中非Symbol的其他属性值，语法如下</li>\n</ul>\n<pre><code class=\"language-js\">for(const prop in obj) {\n  console.log(prop)  \n}\n</code></pre>\n<ul>\n<li>for-in迭代对象是无序的，各浏览器下返回的顺序可能不一致</li>\n<li>const并不是必须的，但建议使用，避免影响外界变量</li>\n<li>迭代null或undefined则迭代内的表达式不会被执行</li>\n</ul>\n<h2>for-of 循环语句</h2>\n<ul>\n<li>for-of也是迭代语句，只能迭代一个可迭代对象，语法如下</li>\n</ul>\n<pre><code class=\"language-js\">for(const value in obj) {\n  console.log(value)  \n}\n</code></pre>\n<ul>\n<li>迭代是有序的，由对象内部的next()方法决定</li>\n<li>\n<p>迭代一个非迭代器对象会抛出错误</p>\n<!--more-->\n<h2>标记语法</h2>\n</li>\n<li>用来标记一个表达式，用于在后续使用，一般用于配合break、continue打破循环使用</li>\n<li>标记语法如下</li>\n</ul>\n<pre><code class=\"language-js\">label: statement\n</code></pre>\n<ul>\n<li>break用于结束这个循环体，执行循环体后的语句</li>\n<li>continue用于结束单次循环，进行该循环体的下一次循环</li>\n<li>配合标记语法如下</li>\n</ul>\n<pre><code class=\"language-js\">let num = 0\noutermost: for(let i = 0; i &#x3C; 10; i++) {\n  for(let j = 0; j &#x3C; 10; j++) {\n    if(i === 5 &#x26;&#x26; j === 5) {\n      break outermost\n    }\n    num++\n  }\n}\n\nconsole.log(num) // 55\n</code></pre>\n<ul>\n<li>这里当执行到i跟j都是5的时候，我们的break将外层循环结束了，导致后续的4次大循环与当次剩余的5次小循环无法继续，所以导致最终的输出为55</li>\n</ul>\n<pre><code class=\"language-js\">let num = 0\noutermost: for(let i = 0; i &#x3C; 10; i++) {\n  for(let j = 0; j &#x3C; 10; j++) {\n    if(i === 5 &#x26;&#x26; j === 5) {\n      continue outermost\n    }\n    num++\n  }\n}\n\nconsole.log(num) // 95\n</code></pre>\n<ul>\n<li>这里的continue跳过了外层循环，导致子循环后续的5次没法执行直接到了下一个循环，所以最终次数会少5，变成了95</li>\n</ul>\n<h2>with语法</h2>\n<ul>\n<li>with语法用于将一个代码执行块与一个变量绑定，语法如下</li>\n</ul>\n<pre><code class=\"language-js\">with (expression) statement;\n</code></pre>\n<ul>\n<li>当一个对象被一次又一次的引用执行的时候就可以使用with语法来简化，比如下场景</li>\n</ul>\n<pre><code class=\"language-js\">let qs = location.search.substring(1)\nlet hostname = location.hostname\nlet url = location.href\n</code></pre>\n<ul>\n<li>这里我们的location对象被多次重复引用，我们可以使用with进行简化</li>\n</ul>\n<pre><code class=\"language-js\">with(location){\n  let qs = search.substring(1)\n  let hostname = hostname\n  let url = href\n}\n</code></pre>\n<ul>\n<li>with工作原理会在当前的作用域内查找是否有对应的变量，如果没有就会从对应location对象上面查找对应的同名属性</li>\n<li>在严格模式下with语法会报错</li>\n<li>with语法会降低代码性能与导致一些奇怪的bug，所以不推荐使用</li>\n</ul>","fields":{"slug":"/loop-statement/"},"frontmatter":{"title":"常用循环语句的基本属性","tags":["JavaScript回顾"],"categories":"JavaScript"}}},{"node":{"html":"<h1>script不为人知的标签属性</h1>\n<h2>普通引用</h2>\n<ul>\n<li>js加载与执行都会阻塞页面渲染与执行，等到js加载并执行完成后才会继续页面的渲染</li>\n</ul>\n<h2>async</h2>\n<ul>\n<li>js加载不会阻塞页面渲染，js加载后就会立即执行，执行时会阻塞页面渲染，有多个async的文件时，跟引入的顺序无关，谁先加载完就执行谁</li>\n</ul>\n<h2>defer</h2>\n<ul>\n<li>\n<p>js加载不会阻塞页面渲染，js加载后不会立即执行，等页面渲染完成后才执行，在 DOMContentLoaded 事件之前执行，有多个 defer 文件时，规范应该是按引入的顺序执行，但实际情况下并不一定按原有顺序执行，所以多个 defer 引入需注意</p>\n<!--more-->\n<h2>charset</h2>\n</li>\n<li>定义js脚本使用的编码值，大多数浏览器都没有遵守它，无意义</li>\n</ul>\n<h2>crossorigin</h2>\n<ul>\n<li>当正常引入跨域资源脚本时，因为浏览器限制，如果该脚本报错我们是拿不到报错信息的，监听onerror只能拿到script error，但是最新的html5规范又规定允许本地获取到跨域脚本错误的，这个时候，满足两个条件就可以实现</li>\n<li>跨域资源服务器通过 Access-Control-Allow-Origin 头信息允许当前域名可以获取错误信息。</li>\n<li>script标签指定脚本地址是跨域资源，也就是我们的 crossorigin，当值为 anonymous 时不携带cookie等认证信息，当值为 use-credentials 会携带cookie等认证信息</li>\n</ul>\n<h2>integrity</h2>\n<ul>\n<li>又称SRI，子资源完整性完整性。该值由两部分组成签名算法跟摘要签名内容组成，用 - 连接。</li>\n<li>指定了该值之后，浏览器在拿到资源后会用 integrity 指定的签名算法对资源进行计算并与 摘要签名内容 进行比较，如果值不统一，说明是经过篡改的，就不会执行该资源</li>\n</ul>\n<h2>type</h2>\n<ul>\n<li>传统意义上该值为\"text/javscript\"或者\"text/ecmascript\"，但是这两个值已经不赞成使用了</li>\n<li>通常我们应该设置该值为\"application/x-javascript\"，虽然设置该值可能会导致脚本被忽略</li>\n<li>其他在非IE浏览器下，我们可以设置为\"application/javascript\"或者\"application/ecmascript\"</li>\n<li>如果设置该值为\"module\"，则该文件下的code会被视为ES6模块，只有这样才能使用import跟export关键字</li>\n</ul>","fields":{"slug":"/script-element/"},"frontmatter":{"title":"script不为人知的标签属性","tags":["JavaScript回顾"],"categories":"JavaScript"}}},{"node":{"html":"<h1>符号类型(symbol)</h1>\n<ul>\n<li>Symbol是ES6新增的一种数据类型，用以标识独一无二的类型，所有的Symbol实例都是独一无二的</li>\n</ul>\n<h2>Symbol的使用方式</h2>\n<ul>\n<li>Symbol跟其他类不同，生成实例不需要使用 new 关键字，使用 new 关键字会报错，可以接受一个字符串作为Symbol的入参，也可以不传参直接生成，如下</li>\n</ul>\n<pre><code class=\"language-js\">let sm = new Symbol() // TypeError: Symbol is not a constructor\n\nlet sm1 = Symbol()\nconsole.log(sm1) // Symbol()\nconsole.log(typeof sm1) // symbol\nlet sm2 = Symbol('test')\nconsole.log(sm2) // Symbol('test')\n</code></pre>\n<!--more-->\n<ul>\n<li>每一个Symbol实例都不相同，如下实验</li>\n</ul>\n<pre><code class=\"language-js\">let sm = Symbol()\nlet sm1 = Symbol()\nconsole.log(sm === sm1) // false\n\nlet sm2 = Symbol('test')\nlet sm3 = Symbol('test')\nconsole.log(sm2 === sm3) // false\n</code></pre>\n<ul>\n<li>这也是Symbol最显著的特殊，可以让我们无后顾之忧的拓展对象属性，而不用担心会跟其现有的属性或方法冲突</li>\n</ul>\n<h2>Symbol.for()</h2>\n<ul>\n<li>如果都是使用上面的Symbol()来给对象赋值的的话我们就没法读取到该属性值了，如下</li>\n</ul>\n<pre><code class=\"language-js\">let a = {}\na[Symbol('test')] = 123\nconsole.log(a[Symbol('test')]) // undefined\n</code></pre>\n<ul>\n<li>因为在这里我们赋值跟取值的Symbol是完全不同的，为了避免这种情况，且能获取到对应的值我们需要使用Symbol.for()</li>\n<li>Symbol.for()方法的使用跟Symbol()的使用是一致的，可以接收一个字符串来做Symbol的唯一表示，调用该方式时，会从全局运行注册对象中查找有没有该Symbol，如果没有找到，就会生成一个Symbol对象并注册到全局运行注册对象中，然后返回该对象，如果查到了该Symbol，则直接返回该对象，所以看下示例：</li>\n</ul>\n<pre><code class=\"language-js\">let a = Symbol.for('test') // 没找到，创建实例\nlet b = Symbol.for('test') // 找到，直接返回实例\nconsole.log(a === b) // true\n\nlet c = {}\nc[Symbol.for('foo')] = 123\nconsole.log(c[Symbol.for('foo')]) // 123\n</code></pre>\n<ul>\n<li>使用Symbol()给对象赋值的方式，如下</li>\n</ul>\n<pre><code class=\"language-js\">let s1 = Symbol('foo'),\n  s2 = Symbol('bar'),\n  s3 = Symbol('baz'),\n  s4 = Symbol('qux')\nlet o = {\n  [s1]: 'foo val'\n}\nconsole.log(o) // {Symbol(foo): \"foo val\"}\nObject.defineProperty(o, s2, { value: 'bar val' })\nconsole.log(o) // {Symbol(foo): \"foo val\", Symbol(bar): \"bar val\"}\nObject.defineProperties(o, {\n  [s3]: { value: 'baz val' },\n  [s4]: { value: 'qux val' }\n})\nconsole.log(o) // {Symbol(foo): \"foo val\", Symbol(bar): \"bar val\", Symbol(baz): \"baz val\", Symbol(qux): \"qux val\"}\n</code></pre>\n<h2>Symbol.keyFor()</h2>\n<ul>\n<li>我们可以使用 Symbol.keyFor() 来检查一个Symbol实例是否存在与全局运行注册表中，该方法接收一个Symbol实例，如果全局注册表中存在该实例，则返回对应的key值，如果不存在，就会返回一个undefined，如下</li>\n</ul>\n<pre><code class=\"language-js\">Symbol.keyFor(Symbol.for('test')) // 'test'，通过Symbol.for()创建的Symbol实例会自动在注册表中注册\nSymbol.keyFor(Symbol('test')) // undefined 通过Symbol()方式创建的不会在注册表中注册，所以会返回undefined\n</code></pre>\n<h2>Object.getOwnPropertyNames() 跟 Object.getOwnPropertySymbols()</h2>\n<ul>\n<li>然后我们尝试使用 Object.getOwnPropertyNames 跟 Object.getOwnPropertySymbols 来获取一下对象o的值来看一下</li>\n</ul>\n<pre><code class=\"language-js\">Object.getOwnPropertyNames(o) // []\nObject.getOwnPropertySymbols(o) // [Symbol(foo), Symbol(bar), Symbol(baz), Symbol(qux)]\n</code></pre>\n<ul>\n<li>这里我们能看到使用 Object.getOwnPropertyNames 好像并不能获取到我们Symbol实例键，我们再给o拓展几个普通属性试试</li>\n</ul>\n<pre><code class=\"language-js\">o['baz'] = '123'\no['foo'] = '234'\n\nObject.getOwnPropertyNames(o) // [\"baz\", \"foo\"]\nObject.getOwnPropertySymbols(o) // [Symbol(foo), Symbol(bar), Symbol(baz), Symbol(qux)]\n</code></pre>\n<ul>\n<li>看到上结果我们也能知道，Object.getOwnPropertyNames 用于获取我们的常规除Symbol外的常规键值，Object.getOwnPropertySymbols 用于获取我们的Symbol键值</li>\n</ul>\n<h2>Object.getOwnPropertyDescriptors() 跟 Reflect.ownKeys()</h2>\n<ul>\n<li>然后我们再使用 Object.getOwnPropertyDescriptors() 跟 Reflect.ownKeys()来获取一下o的属性</li>\n</ul>\n<pre><code class=\"language-js\">Object.getOwnPropertyDescriptors(o) // {baz: {…}, foo: {…}, Symbol(foo): {…}, Symbol(bar): {…}, Symbol(baz): {…},Symbol(qux): {...}}\nReflect.keys(o) // [\"baz\", \"foo\", Symbol(foo), Symbol(bar), Symbol(baz), Symbol(qux)]\n</code></pre>\n<ul>\n<li>从中我们能看到 Object.getOwnPropertyDescriptors() 可以获取对象的常规值跟Symbol对应的值，Reflec.ownKeys() 可以获取对象的常规键跟Symbol键</li>\n</ul>","fields":{"slug":"/symbol/"},"frontmatter":{"title":"符号类型(symbol)","tags":["JavaScript回顾"],"categories":"JavaScript"}}},{"node":{"html":"<h1>字符串模板标记函数</h1>\n<h2>字符串模板</h2>\n<ul>\n<li>ES6新增的字符串定义方式，可以通过 <code></code> 配合${} 来进行变量的嵌入，如下示例</li>\n</ul>\n<pre><code class=\"language-js\">let name = '张三'\nlet age = 24\n// 常规定义字符串的方式\nlet str = '我的名字叫' + name + ', 我今年' + age + '岁了'\n\n// 字符串模板定义\nlet str1 = `我的名字叫${ name },我今年${ age }岁了`\n\nconsole.log(str === str1) // true\n</code></pre>\n<!--more-->\n<h2>模板标记函数</h2>\n<ul>\n<li>模板标记函数的定义跟普通函数一致，但是在使用它之前要准备一个字符串模板，调用方式也跟常规的函数调用方法不同，不需要使用 functionName() 的形式调用，直接在函数名后面跟模板字符串即可，如下:</li>\n</ul>\n<pre><code class=\"language-js\">let a = 6\nlet b = 9\nlet sum = 15\nfunction tagTemplate(strings, aVariable, bVariable, sumVariable) {\n  console.log(strings)        // ['', ' + ', ' = ', '']\n  console.log(aVariable)      // 6\n  console.log(bVariable)      // 9\n  console.log(sumVariable)    // 15\n}\n\ntagTemplate`${a} + ${b} = ${sum}`\n\nlet c = '张三'\nlet d = 24\nfunction tagTemplate(strings, cVariable, dVariable, notVariable) {\n  console.log(strings)        // ['我叫', '，今年', '岁了']\n  console.log(cVariable)      // '张三'\n  console.log(dVariable)      // 24\n  console.log(notVariable)    // undefined\n}\n\ntagTemplate`我叫${c}，今年${d}岁了`\n</code></pre>\n<ul>\n<li>使用标记函数可以看到，参数里面的第一个参数是数组，是由字符串模板被插入变量分割之后剩余字符串组成的数组，之后的参数依次就是按顺序插入变量的值了</li>\n<li>知道参数的形式后我们就可以用ES6的结构对插入变量进行一个遍历了</li>\n</ul>\n<pre><code class=\"language-js\">let c = '张三'\nlet d = 24\nfunction tagTemplate(strings, ...variable) {\n  console.log(strings)        // ['我叫', '，今年', '岁了']\n  for(let i = 0; i &#x3C; variable.length; i++) {\n    console.log(variable[i])\n  }\n  // '张三'  24\n}\n\ntagTemplate`我叫${c}，今年${d}岁了`\n</code></pre>\n<h3>模板标记函数下的raw数组</h3>\n<ul>\n<li>采用模板标记函数后，第一个数组返回的是我们的非变量插入的字符串片段，这里的字符串片段是会转换成我们的实际展示形式的，比如 \\u00A9 会转为 ©，\\n 会转为一个空格</li>\n<li>如果我们想要拿到没有经过转换的原版字符串，这里我们就可以使用这个数组上的raw属性来获取原版字符串的数组，我们可以看下代码</li>\n</ul>\n<pre><code class=\"language-js\">function tagTest(strings, ...rest){\n  for(let value of strings) {\n    console.log(value)\n  }\n  for(let value of strings.raw) {\n    console.log(value)\n  }\n}\nlet a = '张三'\nlet b = 24\ntagTest`你${ a }\\u00A9,哈哈\\n${ b }我`\n// strings遍历\n// 你\n// ©,哈哈 \n// 我\n\n// strings.raw遍历\n// 你\n// \\u00A9,哈哈\\n\n// 我\n</code></pre>\n<ul>\n<li>这就是模板标记函数给我们提供的一些特性，其实归结起来就是插入变量的提取跟原始字符串的收集，方便我们的使用</li>\n</ul>\n<h2>String.raw</h2>\n<ul>\n<li>String.raw是ES6标准的一个字符串方法，使用方式类似于模板标记函数，后面直接跟一个模板字符串即可，会原样返回该模板字符串的值，不受可编译字符的影响，普通的字符串会返回经过转义的字符串结果，如下</li>\n</ul>\n<pre><code class=\"language-js\">console.log(`\\u00A9`)\n// ©\nconsole.log(String.raw`\\u00A9`)\n// \\u00A9\n\nconsole.log(`Hi\\n`)\n// Hi\nconsole.log(String.raw`Hi\\n`)\n// Hi\\n\n\nconsole.log(`Hi\n张三`)\n// Hi\n// 张三\nconsole.log(String.raw`Hi\n张三`)\n// Hi\n// 张三\n</code></pre>\n<ul>\n<li>它只对会被重新编译的字符串生效，实际的回车或者空格是不会被转义回去的</li>\n<li>其实我也没想好这玩意哪里能用到，既然看到了就记录一下</li>\n</ul>","fields":{"slug":"/template-tag-function/"},"frontmatter":{"title":"字符串模板标记函数","tags":["JavaScript回顾"],"categories":"JavaScript"}}},{"node":{"html":"<h1>Well-Known Symbols</h1>\n<ul>\n<li>well-known symbols 是es6引入的在整个javascript中使用的一系列方法，用于直接访问、重写、模拟语言内部的一系列行为。这些方法或者说符号以字符串属性存在于Symbol的工厂函数上。</li>\n<li>这些符号存在的主要意义就是重新定义它们用于修改原生语言中的构造函数表现形式。例如，for of 循环其实是依靠于对象原型提供的 Symbol.iterator 属性，所以我们可以通过重新定义对象的 Symbol.iterator 属性来控制它的for of 表现。</li>\n<li>well-known symbols 这些符号就是Symbol对象上的一些字符串属性，定义良好的符号都具有不可写入、不可重复、不可配置的特性。</li>\n</ul>\n<h2>Symbol.asyncIterator</h2>\n<ul>\n<li>ECMAScript规范中，此符号用于描述一个对象返回默认异步迭代对象的方法属性。当对象具有该属性则该对象是异步可迭代的，可以被 for await of 表达式调用。</li>\n<li>语言构造器例如 for await of 利用该符号对应的方法来实现异步迭代。</li>\n<li>所以我们可以对一个自定义对象添加该符号方法实现其可被for await of 调用</li>\n<li>\n<p>for await of 的调用必须在async 函数下才可以</p>\n<!--more-->\n<pre><code class=\"language-js\">var a = { a :1, b: 2 }\nasync function b(){\nfor await(var value of a) {\nconsole.log(a)\n}\n}\nb() // TypeError: a is not async iterable\n</code></pre>\n</li>\n</ul>\n<p>var a = {\na :1,\nb: 2,\n*<a href=\"\">Symbol.asyncIterator</a>{\n}\n}\nasync function b(){\nfor await(var value of a) {\nconsole.log(a)\n}\n}\nb() // Promise {<resolved>: undefined}</p>\n<pre><code>- 可以看出只要我们实现了符号对应的异步方法，就可以正常调用，下面我们可以自定义我们想要的表现形式\n\n```js\nclass Emitter {\n  constructor(max) {\n    this.max = max\n    this.asyncIdx = 0\n  }\n  async*[Symbol.asyncIterator] () {\n    while(this.asyncIdx &#x3C; this.max) {\n      if(this.asyncIdx % 2 === 0) {\n        yield new Promise(resolve => resolve(this.asyncIdx++))\n      } else {\n        yield new Promise(resolve => {\n          setTimeout(() => {\n            resolve(this.asyncIdx++)\n          }, 1000)\n        })\n      }\n    }\n  }\n}\nvar a = new Emitter(6)\nasync function b(){\n  for await(let value of a) {\n    console.log(value)\n  }\n}\nb() // 0 1 2 3 4 5 \n</code></pre>\n<h2>Symbol.hasInstance</h2>\n<ul>\n<li>在ECMAScript标准中，该符号用做决定对象是否为构造器的实例。也就是“一个方法用来决定构造函数是否识别一个对象为它的实例。在语法上由instanceof方法调用”。instanceof操作符提供了一个方法判断一个对象实例在其原型链中是否有该原型。</li>\n<li>instanceof使用如下</li>\n</ul>\n<pre><code class=\"language-js\">function Foo(){}\nlet f = new Foo()\n\nconsole.log(f instanceof Foo) // true\n</code></pre>\n<ul>\n<li>在ES6中，instanceof 操作使用 SYmbol.hasInstance 来衡量这个关系。该键对应一个函数具有跟instanceof相同的表现，但是操作方式相反，如下</li>\n</ul>\n<pre><code class=\"language-js\">function Foo(){}\nlet f = new Foo()\nconsole.log(Foo[Symbol.hasInstance](f)) // true\n</code></pre>\n<ul>\n<li>该属性被定义到了函数原型上面，所以所有的函数跟类都自动具有了该方法，因为instanceof操作符会在原型链上查找这个属性值，所以我们可以在一个继承类上来重新定义该属性。</li>\n</ul>\n<pre><code class=\"language-js\">class Bar{}\nclass Baz extends Bar{\n  static [Symbol.hasInstance] (){\n    return false\n  }\n}\n\nlet b = new Baz()\nconsole.log(Bar[Symbol.hasInstance](b)) // true\nconsole.log(b instanceof Bar) // true\nconsole.log(Baz[Symbol.hasInstance](b)) // false\nconsole.log(b instanceof Baz) // false\n</code></pre>\n<ul>\n<li>我们能看到，当我们查找是否是Bar的实例时，因为我们的构造函数就是继承自Bar，并且没有修改Bar的相关属性，所以能正常返回true。但是当我们修改了Baz的构造函数之后，再次调用Baz返回的就是我们修改后的函数值了</li>\n</ul>\n<h2>Symbol.isConcatSpreadable</h2>\n<ul>\n<li>在ECMAScript标准中，此符号用来决定一个对象在被Array.prototype.concat()方法调用的时候是否要被扁平化。Array.prototype.concat()方法在ES6中将会基于传入的类数组对象来决定如何将其与数组实例拼接。符号Symbol.isConcatSpreadable将允许你重写这个方法。</li>\n<li>数组对象在默认情况下将会被扁平化处理到当前数组中，当对应实例的Symbol.isConcatSpreadable属性为false或者falsy数据时，则数组对象会被整个塞到当前数组中。如下</li>\n</ul>\n<pre><code class=\"language-js\">let initial = ['foo']\nlet array = ['baz']\nconsole.log(initial.concat(array)) // [\"foo\", \"baz\"]\n\nlet initial = ['foo']\nlet array = ['baz']\narray[Symbol.isConcatSpreadable] = false\nconsole.log(initial.concat(array)) // [\"foo\", Array(1)]\n</code></pre>\n<ul>\n<li>类数组对象在默认情况下会被整个塞到当前数组中，类似于append表现，当我们修改其Symbol.isConcatSpreadable属性为true或者truthy时，这个对象将会被扁平化处理，然后拼接到数组中。</li>\n<li>类数组对象有两个特征，一个是length属性值为数值，一个是有数字键值，看以下表现</li>\n</ul>\n<pre><code class=\"language-js\">// 默认值\nlet arrayLikeObject = { length: 1, 0: 'baz'}\nlet initial = ['foo']\nconsole.log(initial.concat(arrayLikeObject)) // [\"foo\", {…}]\n\n// 修改后\nlet arrayLikeObject = { length: 1, 0: 'baz'}\nlet initial = ['foo']\narrayLikeObject[Symbol.isConcatSpreadable] = true\nconsole.log(initial.concat(arrayLikeObject)) // [\"foo\", \"baz\"]\n</code></pre>\n<ul>\n<li>其他的非数组或者类数组对象在设置了Symbol.isConcatSpreadable为true时都会被忽略，并不会被添加进去</li>\n</ul>\n<pre><code class=\"language-js\">let otherObject = new Set().add('qux')\nlet initial = ['foo']\nconsole.log(initial.concat(otherObject)) // [\"foo\", Set(1)]\n\nlet otherObject = new Set().add('qux')\nlet initial = ['foo']\notherObject[Symbol.isConcatSpreadable] = true\nconsole.log(initial.concat(otherObject)) // [\"foo\"]\n</code></pre>\n<h2>Symbol.iterator</h2>\n<ul>\n<li>在ECMAScript标准中，该符号用于描述一个对象返回默认迭代器对象的方法属性。当对象具有该属性则该对象是可迭代的，可以被for of 循环调用。</li>\n<li>for of 语句就是利用此符号来执行迭代，该语句将会调用Symbol.iterator对应的函数，并期望它返回一个实现了迭代器的对象，在很多场景下会返回一个生成器(一个实现了Iterator api的对象。)</li>\n</ul>\n<pre><code class=\"language-js\">class Foo{\n  *[Symbol.iterator](){}\n}\nlet f = new Foo()\nconsole.log(f[Symbol.iterator]()) // Generator {&#x3C;suspended>}\n</code></pre>\n<ul>\n<li>需要注意的是，通过Symbol.iterator生产的对象需要能够连续生产对象凭借 next() 方法。这可以通过显示声明next方法或者通过生成器函数生成。</li>\n</ul>\n<pre><code class=\"language-js\">// 显式定义next\nclass Emitter{\n  constructor(max){\n    this.max = max\n    this.idx = 0\n  }\n  [Symbol.iterator](){\n    return {\n      next:() => {\n        if(this.idx &#x3C; this.max) {\n          return { value: this.idx++, done: false}\n        } else {\n          return { done: true }\n        }\n      }\n    }\n  }\n}\nfunction count(){\n  let emitter = new Emitter(6)\n  for(let x of emitter) {\n    console.log(x)\n  }\n}\ncount() // 0 1 2 3 4 5\n\n// 生成器函数生成\nclass Emitter{\n  constructor(max){\n    this.max = max\n    this.idx = 0\n  }\n  *[Symbol.iterator](){\n    while(this.idx &#x3C; this.max) {\n      yield this.idx++\n    }\n  }\n}\n\nfunction count(){\n  let emitter = new Emitter(5)\n  for(const x of emitter) {\n    console.log(x)\n  }\n}\n\ncount()  // 0 1 2 3 4\n</code></pre>\n<h2>Symbol.match</h2>\n<ul>\n<li>ECMAScript标准中，此符号是用于描述一个字符串与正则表达式的匹配关系的方法属性。被String.prototype.match()方法调用，String.prototype.match()方法会调用Symbol.match对应的函数去计算表达式，因为正则表达式的原型上有该方法属性，所以所有的正则表达式都可以被String.prototype.mactch()方法调用。</li>\n<li>如果提供其他的非正则表达式参数给String.prototype.match()将会把参数转为正则表达式。</li>\n<li>如果要避免此行为并且想要将参数直接使用，我们可以通过为参数指定 Symbol.match 属性为函数来绕过这个限制，该函数只接受一个参数，参数为调用match方法的字符串实例，返回值为任意类型。</li>\n</ul>\n<pre><code class=\"language-js\">// 正常情况\nvar a = {}\n'123123'.match(a) // null\n\n// 添加值\nvar a = {}\nObject.prototype[Symbol.match] = string => string.includes('123')\n'123123'.match(a) // true\n</code></pre>\n<ul>\n<li>上面我们就是为对象指定了Symbol.match属性，所以但我们传递进去对象值时都会返回true</li>\n</ul>\n<h2>Symbol.replace</h2>\n<ul>\n<li>ECMAScript标准中，此符号是用于描述“替换字符串中匹配到的子字符串的一个正则表达式方法，被String.prototype.replace()方法调用”</li>\n<li>String.prototype.replace将会调用参数上的Symbol.replace对应的方法来进行表达式计算</li>\n<li>正则表达式原型有Symbol.replace方法，所以所有的正则表达式都可以被replace方法调用。</li>\n<li>同样的，如果传入的是非正则类型，则会被强制转为正则类型。我们可以通过为入参定义Symbol.replace方法来绕过并重新定义行为</li>\n<li>定义的方法有两个参数，一个是原始字符串，一个是要替换的字符串</li>\n</ul>\n<pre><code class=\"language-js\">// 原表现形式\nclass Test{\n  constructor(str){\n    this.str = str\n  }\n}\n\"aaasdasddd\".replace(new Test('asd'), '123') // 'aaasdasddd'\n\n// 重新定义属性\nclass Test{\n  constructor(str){\n    this.str = str\n  }\n  [Symbol.replace] = (str, replaceStr) => str.split(this.str).join(replaceStr)\n}\n\"aaasdasddd\".replace(new Test('asd'), '123') // 'aa123123dd'\n</code></pre>\n<ul>\n<li>上面我们就实现了传递一个非正则对象给replace方法并成功完成我们想要的展示形式</li>\n</ul>\n<h2>Symbol.search</h2>\n<ul>\n<li>在ECMAScript规范中，该符号用来描述“一个用来返回字符串中符合对应正则表达式的字符串的位置，被String.prototype.search()方法调用”</li>\n<li>String.prototype.search将会调用参数上的Symbol.search对应的方法来进行表达式计算</li>\n<li>正则表达式原型有Symbol.search方法属性，所以所有的正则表达式都可以被search方法调用。</li>\n<li>同样的，如果传入的是非正则类型，则会被强制转为正则类型。我们可以通过为入参定义Symbol.search方法来绕过并重新定义行为</li>\n<li>定义的方法只有一个参数，就是对应的字符串实例，返回值为任意类型</li>\n</ul>\n<pre><code class=\"language-js\">// 原表现形式\nclass Search{\n  constructor(str){\n    this.str = str\n  }\n}\n\"hahaha\".search(new Search('ha')) // -1\n\n// 重新定义属性\nclass Search{\n  constructor(str){\n    this.str = str\n  }\n  [Symbol.replace] = (str) => str.indexOf(this.str)\n}\n\"hahaha\".replace(new Search('ha')) // 0\n</code></pre>\n<h2>Symbol.species</h2>\n<ul>\n<li>该符号被构建函数调用创造派生实例</li>\n<li>在构造类中声明静态getter方法Symbol.species将会覆盖新创建实例原型的构建函数</li>\n<li>当我们调用map方法或者concat方法时会默认返回对应实例的默认构造函数，如果我们这里通过声明getter方法Symbol.species来将其修改为其他构建对象，那在map或concat方法后返回的对象类型就会发生变化</li>\n</ul>\n<pre><code class=\"language-js\">class Bar extends Array {}\nvar b = new Bar(1, 2, 3)\nconsole.log(b instanceof Array) // true\nconsole.log(b instanceof Bar) // true\n\n// 添加getter方法\nclass Baz extends Array {\n  static get [Symbol.species] () {\n    return Number\n  }\n}\nvar c = new Baz(1, 2, 3)\nconsole.log(c instanceof Array)   // true\nconsole.log(c instanceof Baz)     // true\nconsole.log(c instanceof Number)  // false\n\nconsole.log(c.concat(c) instanceof Array)   // false\nconsole.log(c.concat(c) instanceof Baz)     // false\nconsole.log(c.concat(c) instanceof Number)  // true\n</code></pre>\n<ul>\n<li>从上面我们可以看出，声明getter方法Symbol.species后，对单独的实例不会有影响，但是当返回默认的构造函数时，就会使用我们Symbol.species中返回的构造函数了</li>\n</ul>\n<h2>Symbol.split</h2>\n<ul>\n<li>该符号用于描述“一个用于在匹配正则表达式的位置进行字符串分割的正则表达式方法，被String.prototype.split()方法调用”</li>\n<li>String.prototype.split将会调用入参对象的Symbol.split属性方法来进行表达式计算。</li>\n<li>正则表达式原型有Symbol.split方法属性，所以所有的正则表达式都可以被split方法调用。</li>\n<li>同样的，如果传入的是非正则类型，则会被强制转为正则类型。我们可以通过为入参定义Symbol.split方法来绕过并重新定义行为</li>\n<li>定义的方法只有一个参数，就是对应的字符串实例，返回值为任意类型</li>\n</ul>\n<pre><code class=\"language-js\">// 原表现形式\nclass Split{\n  constructor(str){\n    this.str = str\n  }\n}\n\"123hahaha123\".split(new Split('ha')) // [\"123hahaha123\"]\n\n// 重新定义属性\nclass Split{\n  constructor(str){\n    this.str = str\n  }\n  [Symbol.split](target){\n    console.log(123, target, this.str)\n    return target.split(this.str)\n  }\n}\n\"123hahaha123\".split(new Split('ha')) // [\"123\", \"\", \"\", \"123\"]\n</code></pre>\n<h2>Symbol.toPrimitive</h2>\n<ul>\n<li>该符号用于描述“一个将对象转换为常规数据类型的方法，被强制类型操作符所调用”。很多内置操作符都会尝试将对象转为基本数据类型，例如：string类型、number类型、number类型，或者其他的基本类型。</li>\n<li>对一个自定义的对象，我们可以通过定义它的Symbol.toPrimitive属性来决定它的强制类型转换方式。该方法接收一个它原本会被转换为的数据类型的类型字符串名称，所以我们根据这个情况构造我们想要的形式</li>\n</ul>\n<pre><code class=\"language-js\">// 原始类型\nclass Foo{}\nlet foo = new Foo()\nconsole.log(3 + foo) // \"3[object Object]\"\nconsole.log(3 - foo)  // NaN\nconsole.log(String(foo))  // \"[object Object]\"\n\n// 自定义表现形式\nclass Bar {\n  constructor(){\n    this[Symbol.toPrimitive] = function (hint){\n      switch(hint) {\n        case 'string':\n          return 'string bar'\n        case 'number':\n          return 3\n        case 'default':\n        default:\n          return 'default bar'\n      }\n    }\n  }\n}\nlet bar = new Bar()\nconsole.log(3 + bar) // 3default bar\nconsole.log(3 - bar)  // 0\nconsole.log(String(bar))  // string bar\n</code></pre>\n<ul>\n<li>上面我们可以看到，当对象遇到 + 操作符时它无法确定要执行字符串拼接的 + 操作还是数值的相加 + 操作，所以就返回了默认的 default bar;当对象遇到 - 操作时明确的知道自己要被转为数值类型，所以走了 case 'number' ，返回了3，然后被执行操作；当预定String()方法时也明确的知道自己要返回字符串类型，所以返回了 string bar</li>\n</ul>\n<h2>Symbol.toStringTag</h2>\n<ul>\n<li>该符号用于描述“一个对象的创建对象类型的默认字符串描述，被Object.prototype.toString所调用”，该创建对象的字符串描述会依靠Symbol.toStringTag方法来获取，默认为\"Object\"</li>\n<li>内置类型都有声明这个属性方法，但是自定义对象就需要我们显式声明了</li>\n</ul>\n<pre><code class=\"language-js\">// 内置对象\nvar s = new Set()\nconsole.log(s)                      // Set(0) {}\nconsole.log(s.toString())           // [object Set]\nconsole.log(s[Symbol.toStringTag])  // Set\n// 自定义对象\nclass Foo{}\nvar f = new Foo()\nconsole.log(f)                      // Foo {}\nconsole.log(f.toString())           // [object Object]\nconsole.log(f[Symbol.toStringTag])  // undefined\n\n// 修改后的自定义对象\nclass Bar{\n  constructor(){\n    this[Symbol.toStringTag] = 'Bar'\n  }\n}\nvar b = new Bar()\nconsole.log(b)                      // Bar {Symbol(Symbol.toStringTag): \"Bar\"}\nconsole.log(b.toString())           // [object Bar]\nconsole.log(b[Symbol.toStringTag])  // Bar\n</code></pre>\n<h2>Symbol.unscopables</h2>\n<ul>\n<li>该符号用于描述“防止被width操作绑定到该对象的自有属性或者继承属性”，设置这个属性将指定键值改为true则with方法将无法在该对象上查找指定属性</li>\n</ul>\n<pre><code class=\"language-js\">// 正常形式\nvar o = { foo: 'asd' }\nwith(o) {\n  console.log(foo) // 'asd'\n}\n\n// 自定义后\nvar o = { foo: 'asd' }\no[Symbol.unscopables] = {\n  foo: true\n}\nwith(o) {\n  console.log(foo)  // Uncaught ReferenceError: foo is not defined\n}\n</code></pre>\n<ul>\n<li>新的ECMAScript规范中已经不推荐使用with方法了，所以，我们的Symbol.unscopables也不再推荐使用</li>\n</ul>","fields":{"slug":"/well-known-symbol/"},"frontmatter":{"title":"Well-Known Symbols","tags":["JavaScript回顾"],"categories":"JavaScript"}}},{"node":{"html":"<h1>Date 类型</h1>\n<ul>\n<li>Date构造函数可以接收毫秒数来创建时间对象，对此提供了辅助函数来进行毫秒数的获取</li>\n</ul>\n<h2>Date.parse()</h2>\n<ul>\n<li>\n<p>该方法接收一个表示日期的字符串，并转为对应的毫秒数，接受的格式如下</p>\n<ul>\n<li>\"月/日/年\"，如\"5/23/2019\"</li>\n<li>\"月名日,年\"，如\"May 23, 2019\"</li>\n<li>\"周几月名日年时:分:秒:时区\"，如\"Tue May 23 2020 00:00:00 GMT-0700\"</li>\n<li>拓展格式\"YYYY-MM-DDTHH:mm:ss.sssZ\"，如：\"2020-05-23T00:00:00\"</li>\n</ul>\n</li>\n<li>使用方式如下</li>\n</ul>\n<pre><code class=\"language-js\">let time1 = new Date(Date.parse(\"May 23, 2020\"))\n// Sat May 23 2020 00:00:00 GMT+0800 (中国标准时间)\n</code></pre>\n<ul>\n<li>如果传给Date.parse()的字符串不能表示时间该方法返回NaN</li>\n<li>如果在给new Date()传参时直接传了表示时间的字符串，那Date会在后台隐式调用Date.parse()，下代码与上面同样</li>\n</ul>\n<pre><code class=\"language-js\">let time1 = new Date(\"May 23, 2020\")\n// Sat May 23 2020 00:00:00 GMT+0800 (中国标准时间)\n</code></pre>\n<ul>\n<li>\n<p>关于越界时间，当我们传了一个不存在的时间比如3月32号时部分浏览器会返回4月1号的时间，有些浏览器则会直接返回当前时间，比如你在5月1日运行代码就会返回5月1号的时间</p>\n<!--more-->\n<h2>Date.UTC()</h2>\n</li>\n<li>这个方法也是用于返回日期的毫秒数，但是参数不一样，参数是年，零起点的月数（也就是1月用0表示，2月用1表示，依次类推），日，时（0-24），分，秒，毫秒</li>\n<li>只有年跟月是必须，其他的不填都默认为0，使用方式如下</li>\n</ul>\n<pre><code class=\"language-js\">let time2 = new Date(Date.UTC(2020, 09, 12, 15, 44, 03))\n// Mon Oct 12 2020 23:44:03 GMT+0800 (中国标准时间)\n</code></pre>\n<ul>\n<li>可以看到其实会被我们的参数当做UTC时间来做解析，最后得到的是本地的 23：44</li>\n<li>当我们在new Date()的时候使用Date.UTC形式的参数，那Date也会隐式调用Date.UTC()，但是不同的是不会被当做UTC时间处理而是当做本地时间处理，如下</li>\n</ul>\n<pre><code class=\"language-js\">let time2 = new Date(2020, 09, 12, 15, 44, 03)\n// Mon Oct 12 2020 15:44:03 GMT+0800 (中国标准时间)\n</code></pre>\n<h2>Date原型方法</h2>\n<ul>\n<li>Date对象重写了toString、valueOf、toLocalString方法</li>\n<li>toLocalString与toString，两个方法分别返回对应的GMT时间与本地时间，如下</li>\n</ul>\n<pre><code class=\"language-js\">new Date().toLocaleString()\n// \"2020/10/12 下午3:53:58\"\nnew Date().toString()\n// \"Mon Oct 12 2020 15:54:04 GMT+0800 (中国标准时间)\"\n</code></pre>\n<ul>\n<li>valueOf方法会返回对应时间的毫秒数，数字类型</li>\n</ul>\n<pre><code class=\"language-js\">new Date().valueOf()\n// 1602489459169\n</code></pre>\n<ul>\n<li>\n<p>Date格式时间的方法</p>\n<ul>\n<li>toDateString()，显示时间中的周几、月、日、年</li>\n<li>toTimeString()，显示时间中的时、分、秒、时区</li>\n<li>toLocalDateString()，获取本地时间的周几、月、日、年</li>\n<li>toLocalTimeString()，获取本地时间的时、分、秒、时区</li>\n<li>toUTCString()，显示完整的UTC时间</li>\n</ul>\n</li>\n</ul>","fields":{"slug":"/Date/"},"frontmatter":{"title":"Date类型","tags":["JavaScript回顾"],"categories":"JavaScript"}}},{"node":{"html":"<h1>Number 类型</h1>\n<ul>\n<li>Number对象也重写了toString、toLocalString、valueOf方法</li>\n<li>valueOf返回原数值</li>\n<li>toString()接收一个参数用于表示该数字的几进制数，如下</li>\n</ul>\n<pre><code class=\"language-js\">let num = 10\nconsole.log(num.toString()) // '10'\nconsole.log(num.toString(2)) // '1010'\nconsole.log(num.toString(8)) // '12'\nconsole.log(num.toString(10)) // '10'\nconsole.log(num.toString(16)) // 'a'\n</code></pre>\n<ul>\n<li>toExponential()用于表示数值的科学技术法的表示字符串</li>\n</ul>\n<pre><code class=\"language-js\">console.log(num.toExponential()) // 1e+1\n</code></pre>\n<ul>\n<li>\n<p>toPrecision()会根据你传入的参数决定输出结果，该参数表示结果中的数字的位数，如下</p>\n<!--more-->\n<pre><code class=\"language-js\">let num1 = 99\nconsole.log(num1.toPrecision(1)) // 1e+2\nconsole.log(num1.toPrecision(2)) // 99\nconsole.log(num1.toPrecision(3)) // 99.0\n</code></pre>\n</li>\n<li>ES6新增isInteger()用于判断是否是整数</li>\n</ul>\n<pre><code class=\"language-js\">console.log(Number.isInteger(1)) // true\nconsole.log(Number.isInteger(1.00)) // true\nconsole.log(Number.isInteger(1.01)) // false\n</code></pre>\n<ul>\n<li>该方法不会受到小数点后都是0的影响</li>\n<li>IEEE 754数值格式有一个特殊的数值范围，此范围内的二进制值可表示一个整数，该范围为Number.MIN<em>SAFE</em>INTEGER((-2) ** 53 + 1) 到 Number.MAX<em>SAFE</em>INTEGER(2 ** 53 - 1)</li>\n<li>超出这个范围的值在保存为整数时数值可能会变化，所以我们可以通过 Number.isSafeInteger()来判断一个整数是否在该范围内</li>\n</ul>\n<pre><code class=\"language-js\">console.log(Number.isSafeInteger(-1 * (2 ** 53))) // false\nconsole.log(Number.isSafeInteger(-1 * (2 ** 53) + 1)) // true\n</code></pre>","fields":{"slug":"/Number/"},"frontmatter":{"title":"Number类型","tags":["JavaScript回顾"],"categories":"JavaScript"}}},{"node":{"html":"<h1>String类型</h1>\n<ul>\n<li>字符串由16位码元组成，多数字符都是16位码元对应一个字符，length属性就是表示有多少个16位码元</li>\n<li>charAt()方法返回给定索引位置的字符，参数为索引位置</li>\n<li>javascript采用UCS-2和UTF-16两种Unicode编码混合策略，对于(U+0000~U+FFFF)，这两种编码是一样的</li>\n<li>charCodeAt()可以查看对应索引位置的字符编码，参数为索引位置</li>\n<li>fromCharCode()可以根据给定的UTF-16码元创建字符串，然后将其拼接返回</li>\n</ul>\n<pre><code class=\"language-js\">let message = 'abcde'\nconsole.log(message.charAt(2)) // 'c'\nconsole.log(message.charCodeAt(2)) // 99\n// 可以16进制入参\nconsole.log(String.fromCharCode(0x61, 0x62, 0x63, 0x64, 0x65)) // \"abcde\"\nconsole.log(String.fromCharCode(97, 98, 99, 100, 101)) // \"abcde\"\n</code></pre>\n<ul>\n<li>对于在U+0000~U+FFFF范围内的字符，length、charAt()、charCodeAt()、fromCharCode()都可以正常运行</li>\n<li>当拓展到Unicode增补字符平面就不行了，上面的16位只能标识65536个字符，这些表示基本多语言平面，为了表示更多的字符，采用了每个字符使用另外16位去选择一个增补平面。这种每个字符使用两个16位码元的策略称为代理对</li>\n<li>\n<p>当我们对含有代理对编码的字符串就会有问题，如下</p>\n<!--more-->\n<pre><code class=\"language-js\">let message = 'ab😊de'\nconsole.log(message.length)     // 6\nconsole.log(message.charAt(1))  // b\nconsole.log(message.charAt(2))  // �\nconsole.log(message.charAt(3))  // �\nconsole.log(message.charAt(4))  // d \nconsole.log(message.charCodeAt(1))  // 98\nconsole.log(message.charCodeAt(2))  // 55357\nconsole.log(message.charCodeAt(3))  // 56842\nconsole.log(message.charCodeAt(4))  // 100\n</code></pre>\n</li>\n</ul>\n<p>console.log(String.fromCharCode(97, 98, 55357, 56842, 100, 101)) // ab😊de</p>\n<pre><code>- 这里我们能看到笑脸符明显占了两个字符，然后我们尝试使用fromCharCode()来将代理对进行解析为字符串是没有问题的，这是因为浏览器可以正常解析代理对\n- 针对这种情况，我们可以使用codePointAt()来替代charCodeAt()\n- codePointAt()使用方法跟charCodeAt()基本一致，也是接受一个表示索引的参数并返回该索引的码点。码点是Unicode中一个字符的完整标识，可能是16位，也有可能32位，codePointAt()可以查看完整的码点\n\n```js\nlet message = 'ab😊de'\nconsole.log(message.codePointAt(1))  // 98\nconsole.log(message.codePointAt(2))  // 128522\nconsole.log(message.codePointAt(3))  // 56842\nconsole.log(message.codePointAt(4))  // 100\n</code></pre>\n<ul>\n<li>我们可以通过字符串解析来识别代理对，如下</li>\n</ul>\n<pre><code class=\"language-js\">let message = 'ab😊de'\nconsole.log([...message]) // [\"a\", \"b\", \"😊\", \"d\", \"e\"]\n</code></pre>\n<ul>\n<li>这样就将我们的代理对给完整解析了</li>\n<li>对应的，我们也有fromCodePoint()来讲对应的码点转为字符串，并拼接返回</li>\n</ul>\n<pre><code class=\"language-js\">// 使用 fromCharCode要有6位数字才可以\nconsole.log(String.fromCharCode(97, 98, 55357, 56842, 100, 101)) // ab😊de\n// 使用 fromCodePoint\nconsole.log(String.fromCodePoint(97, 98, 128522, 100, 101)) // ab😊de\n</code></pre>\n<h2>normalize 方法</h2>\n<ul>\n<li>该方法针对一些可以使用多种编码方式表达的unicode字符，比如下面字符</li>\n</ul>\n<pre><code class=\"language-js\">// 上面带圆圈的 A\nconsole.log(String.fromCharCode(0x00C5))          // Å\n// 长度单位 “埃”\nconsole.log(String.fromCharCode(0x212B))          // Å\n// U+004大写字符 A, U+030A 上面的圆圈\nconsole.log(String.fromCharCode(0x0041, 0x030A))  // Å\n</code></pre>\n<ul>\n<li>上面三种编码返回的字符串看上去是一样的，其实编码不一样，所以比较起来也不会一样</li>\n</ul>\n<pre><code class=\"language-js\">let a1 = String.fromCharCode(0x00C5),\na2 = String.fromCharCode(0x212B),\na3 = String.fromCharCode(0x0041, 0x030A)\nconsole.log(a1 === a2)  // false\nconsole.log(a1 === a3)  // false\nconsole.log(a2 === a3)  // false\n</code></pre>\n<ul>\n<li>针对上情况，Unicode提供了4种格式化方法，将类似上面的字符串转为一致格式，分别是NFD、NFC、NFKD、NFKC</li>\n<li>然后我们就可以使用normalize方法跟对应的优化方法名称来进行格式化</li>\n</ul>\n<pre><code class=\"language-js\">let a1 = String.fromCharCode(0x00C5),\na2 = String.fromCharCode(0x212B),\na3 = String.fromCharCode(0x0041, 0x030A)\n\n// U+005C是对U+212B进行NFC/NFKC规范之后的结果\nconsole.log(a1 === a1.normalize('NFD')) // false\nconsole.log(a1 === a1.normalize('NFC')) // true\nconsole.log(a1 === a1.normalize('NFKD')) // false\nconsole.log(a1 === a1.normalize('NFKC')) // true\n\n// U+212B是未规范化的\nconsole.log(a2 === a2.normalize('NFD')) // false\nconsole.log(a2 === a2.normalize('NFC')) // false\nconsole.log(a2 === a2.normalize('NFKD')) // false\nconsole.log(a2 === a2.normalize('NFKC')) // false\n\n// U+0041/U+030A是对U+212B进行NFD/NFKD规范之后的结果\nconsole.log(a3 === a3.normalize('NFD')) // true\nconsole.log(a3 === a3.normalize('NFC')) // false\nconsole.log(a3 === a3.normalize('NFKD')) // true\nconsole.log(a3 === a3.normalize('NFKC')) // false\n</code></pre>\n<ul>\n<li>当对上述编码采用同样的规范方式可以让比较操作符返回正确结果</li>\n</ul>\n<pre><code class=\"language-js\">let a1 = String.fromCharCode(0x00C5),\na2 = String.fromCharCode(0x212B),\na3 = String.fromCharCode(0x0041, 0x030A)\n\nconsole.log(a1.normalize(\"NFD\") === a2.normalize(\"NFD\")) // true\nconsole.log(a1.normalize(\"NFKC\") === a3.normalize(\"NFKC\")) // true\nconsole.log(a2.normalize(\"NFC\") === a3.normalize(\"NFC\")) // true\n</code></pre>\n<h2>slice、substr、substring对比</h2>\n<ul>\n<li>这三种方法都是从字符串中提取子字符串</li>\n<li>都接收一个或两个参数，第一个参数为开始位置</li>\n<li>slice跟substring第二个参数为提取结束的位置，该位置之前的字符串都会被提取</li>\n<li>substr第二个参数表示要提取的字符串的长度</li>\n<li>忽略第二个参数这三个方法的返回值一致，都会提取到字符串尾</li>\n</ul>\n<pre><code class=\"language-js\">let stringValue = 'hello world'\nconsole.log(stringValue.slice(3))      //  'lo world'\nconsole.log(stringValue.substring(3))  //  'lo world'\nconsole.log(stringValue.substr(3))     //  'lo world'\nconsole.log(stringValue.slice(3, 7))      //  'lo w'\nconsole.log(stringValue.substring(3, 7))  //  'lo w'\nconsole.log(stringValue.substr(3, 7))     //  'lo worl'\n</code></pre>\n<ul>\n<li>当参数为负数时，slice会将所有负数跟字符串长度相加作为新的参数</li>\n<li>substr会将第一个负数参数与字符串长度相加，第二个负数参数转为0</li>\n<li>substring会将所有的负数参数转为0，会将小的参数作为起点，大的参数作为终点</li>\n</ul>\n<pre><code class=\"language-js\">let stringValue = 'hello world'\nconsole.log(stringValue.slice(-3))      //  'rld'\nconsole.log(stringValue.substring(-3))  //  'hello world'\nconsole.log(stringValue.substr(-3))     //  'rld'\nconsole.log(stringValue.slice(3, -4))      //  'lo w'\nconsole.log(stringValue.substring(3, -4))  //  'hel'\nconsole.log(stringValue.substr(3, -4))     //  ''\n</code></pre>\n<h2>indexOf与lastIndexOf</h2>\n<ul>\n<li>都是查找指定字符串，接受两个参数，第一个是查找字符串，第二个是起始位置</li>\n<li>indexOf默认从0开始向后找，指定第二个参数后会从第二个参数指定的下标开始找，忽略该下标之前的字符</li>\n<li>lastIndexOf默认从字符串最后一位开始向前找，指定第二个参数则会从参数指定的下标向前找，忽略该下标之前的字符</li>\n</ul>\n<h2>startsWith、endsWith、includes</h2>\n<ul>\n<li>ES6新增用于判断字符串中是否包含另外字符串的方法，都返回布尔值</li>\n<li>startsWith检查开始于索引0的匹配项</li>\n<li>endsWith检查开始于索引(string.length - subString.length)的匹配项</li>\n<li>includes检查整个字符串</li>\n</ul>\n<pre><code class=\"language-js\">let message = 'foobarbaz'\n\nconsole.log(message.startsWith('foo')) // true\nconsole.log(message.startsWith('bar')) // false\n\nconsole.log(message.endsWith('baz')) // true\nconsole.log(message.endsWith('bar')) // false\n\nconsole.log(message.includes('bar')) // true\nconsole.log(message.includes('foo')) // true\n</code></pre>\n<ul>\n<li>startsWith与includes可接收第二个参数，用于表示开始查找的位置，传入该参数会忽略该参数之前的字符</li>\n<li>endsWith也可以接收第二个参数，用于表示字符串末尾的位置，传入该参数就好像将被查找字符串截断了一样</li>\n</ul>\n<pre><code class=\"language-js\">let message = 'foobarbaz'\n\nconsole.log(message.startsWith('foo')) // true\nconsole.log(message.startsWith('foo', 1)) // false\n\nconsole.log(message.includes('bar')) // true\nconsole.log(message.includes('bar', 4)) // false\n\nconsole.log(message.endsWith('bar')) // false\nconsole.log(message.endsWith('bar', 6)) // true\n</code></pre>\n<h2>trim、trimRight、trimLeft</h2>\n<ul>\n<li>分别用于去除两端的空格、右面的空格、左面的空格</li>\n</ul>\n<h2>repeat方法</h2>\n<ul>\n<li>接收一个整数参数，表示将该字符串复制多少次然后拼接返回</li>\n</ul>\n<pre><code class=\"language-js\">let stringValue = 'na '\nconsole.log(stringValue.repeat(8)) // 'na na na na na na na na '\n</code></pre>\n<h2>padStart、padEnd方法</h2>\n<ul>\n<li>这两个方法会复制字符串，如果小于指定字符串，则在相应的一边填充字符，直到满足条件，第一个参数是长度，第二个参数是可选的填充字符串，默认为空格</li>\n</ul>\n<pre><code class=\"language-js\">let stringValue = 'foo'\nconsole.log(stringValue.padStart(6))      // '   foo'\nconsole.log(stringValue.padStart(6, '.')) // '...foo'\nconsole.log(stringValue.padEnd(6))        // 'foo   '\nconsole.log(stringValue.padEnd(6, '.'))   // 'foo...'\n</code></pre>\n<ul>\n<li>要是第二个参数指定的是多个字符的字符串，那么在复制后如果长度超出会把参数指定的字符串裁剪</li>\n<li>如果第一个参数指定的长度小于等于原始字符串长度，则返回原始字符串</li>\n</ul>\n<pre><code class=\"language-js\">let stringValue = 'foo'\nconsole.log(stringValue.padStart(8, 'bar')) // 'barbafoo'\nconsole.log(stringValue.padStart(2))        // 'foo'\nconsole.log(stringValue.padEnd(8, 'bar'))   // 'foobarba'\nconsole.log(stringValue.padEnd(2))          // 'foo'\n</code></pre>\n<h2>字符串解析与迭代</h2>\n<ul>\n<li>字符串原型暴露了 @@iterator方法，所以字符串可以被解析与迭代，如下</li>\n</ul>\n<pre><code class=\"language-js\">let a = 'abcde'\nfor(const c of a) {\n  console.log(c)\n}\n// a\n// b\n// c\n// d\n// e\nconsole.log([...a])\n// [\"a\", \"b\", \"c\", \"d\", \"e\"]\n</code></pre>\n<h2>toLowerCase、toUpperCase、toLocalLowerCase、toLocalUpperCase</h2>\n<ul>\n<li>都是用于进行大小写转换的，toLowerCase与toLocalLowerCase都是将字符串转为小写字母表示，toLocalLowerCase是为了防止出现地方字符无法转换的情况</li>\n<li>toUpperCase与toLocalUpperCase都是将字符串转为大写字母表示，toLocalUpperCase是为了防止出现地方字符无法转换的情况</li>\n</ul>\n<h2>match、search、replace方法</h2>\n<ul>\n<li>match方法接收一个正则表达式或正则表达式字符串，返回一个数组，第一个元素是与正则匹配的字符串，其余的元素是表达式中的捕获组匹配到的字符串('()'中的内容)</li>\n<li>search方法是查找方法，也是接收一个正则表达式或者正则表达式字符串，返回匹配到的第一个的索引，没有找到返回-1</li>\n<li>replace是替换方法，接受两个参数，第一个参数是正则表达式或者字符串（该字符串时不会转为正则表达式），第二个参数是字符串或者函数。当地一个参数为字符串时只会替换查找到的第一个字符串，要想全部替换必须用正则表达式</li>\n</ul>\n<pre><code class=\"language-js\">let text = 'cat, bat, sat, fat'\nconsole.log(text.replace('at', 'ond'))    // cond, bat, sat, fat\nconsole.log(text.replace(/at/g, 'ond'))   // cond, bond, sond, fond\nconsole.log(text.replace(/(.at)/g, 'word ($1)')) // word (cat), word (bat), word (sat), word (fat)\n</code></pre>\n<ul>\n<li>第二个参数为函数时，当匹配项只有一个时，有三个参数，整个模式匹配的字符串、匹配字符串的开始位置、整个字符串。</li>\n<li>当有多个捕获组的情况下，每个匹配的捕获组的字符串也会被当做参数，最后两个参数仍然是匹配字符串的开始位置、整个字符串</li>\n<li>这个函数应该返回一个字符串，表示把匹配项换成什么</li>\n</ul>\n<h2>split方法</h2>\n<ul>\n<li>split会根据传入的参数将字符串转为数组，参数可以是字符串，也可以是RegExp对象。还可以接收第二个参数来表示数组大小，确保数组不会超过指定大小</li>\n</ul>\n<pre><code class=\"language-js\">let color = 'red,blue,green,yellow'\nconsole.log(color.split(','))     // [\"red\", \"blue\", \"green\", \"yellow\"]\nconsole.log(color.split(',', 2))  // [\"red\", \"blue\"]\nconsole.log(color.split(/[^,]+/)) // [\"\", \",\", \",\", \",\", \"\"]\n</code></pre>\n<h2>localeCompare方法</h2>\n<ul>\n<li>用于比较字符串</li>\n<li>按照字母排序，如果字符串应该排在字符串参数之前，返回负数</li>\n<li>字符串与参数字符串相同，返回0</li>\n<li>字符串应该在字符串参数之后，返回正数</li>\n</ul>\n<pre><code class=\"language-js\">let stringValue = 'yellow'\nconsole.log(stringValue.localeCompare('brick'))   // 1\nconsole.log(stringValue.localeCompare('yellow'))  // 0\nconsole.log(stringValue.localeCompare('zoo'))     // -1\n</code></pre>","fields":{"slug":"/String/"},"frontmatter":{"title":"String类型","tags":["JavaScript回顾"],"categories":"JavaScript"}}}]}},"pageContext":{"limit":10,"skip":30,"currentIndex":3}},"staticQueryHashes":["2566592090"]}