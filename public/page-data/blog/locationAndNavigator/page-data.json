{"componentChunkName":"component---src-templates-blog-small-jsx","path":"/blog/locationAndNavigator/","result":{"data":{"markdownRemark":{"html":"<h1>location对象与navigator对象</h1>\n<h2>location对象</h2>\n<ul>\n<li>location是常用的BOM对象，提供了当前窗口中加载文档的信息，以及常用的导航功能</li>\n<li>它既是window属性，也是document属性，window.location跟document.location两个指向同一个对象</li>\n<li>location对象保存着当前加载文档的信息，还有URL解析为离散片段后能够属性访问的信息。</li>\n<li>\n<p>以下URL来做实例 \"<a href=\"http://ouser:barpassword@www.wrox.com:80/WileyCDA/?q=javascript#contents\">http://ouser:barpassword@www.wrox.com:80/WileyCDA/?q=javascript#contents</a>\"</p>\n<ul>\n<li>location.hash: '#contents',散列值，#后跟零或者多个字符串，没有就是空字符串</li>\n<li>location.host: 'www.wrox.com:80'，服务器名及端口号</li>\n<li>locaion.hostname: 'www.wrox.com'，服务器名</li>\n<li>location.href: '<a href=\"http://www.wrox.com:80/WileyCDA/?q=javascript#contents&#x27;\">http://www.wrox.com:80/WileyCDA/?q=javascript#contents'</a>, 当前加载页面的完整URL。location.toString就返回这个值</li>\n<li>location.pathname: '/WileyCDA/'，URL中的路径和（或）文件名</li>\n<li>location.port: \"80\"，请求的端口，如果URL中没有端口返回空字符串</li>\n<li>location.portocol: 'http:'，页面使用协议，一般是\"http:\"或\"https:\"</li>\n<li>location.search: \"?q=javascript\"，URL的查询字符串，以问号开头</li>\n<li>location.username: 'ouser'，域名前指定的用户名</li>\n<li>location.password: 'barpassword'，域名前指定的密码</li>\n<li>location.origin: '<a href=\"http://www.wrox.com&#x27;%EF%BC%8CURL%E7%9A%84%E6%BA%90%E5%9C%B0%E5%9D%80%EF%BC%8C%E5%8F%AA%E8%AF%BB\">http://www.wrox.com'，URL的源地址，只读</a></li>\n</ul>\n</li>\n<li>\n<p>URL中的多数信息都能通过以上方法获取，search中的查询字符串就需要我们单独处理了</p>\n<!--more-->\n<pre><code class=\"language-js\">function getQueryStringArgs (search){\nlet qs = (search.length > 0 ? search.substring(1) : '')\nlet args = {}\nfor(let item of qs.split('&#x26;').map(kv => kv.split('='))) {\nlet name = decodeURIComponent(item[0]), value = decodeURIComponent(item[1])\nif(name.length) {\n  args[name] = value\n}\n}\nreturn args\n}\nlet qs = '?q=javascript&#x26;num=10'\nconsole.log(getQueryStringArgs(qs)) // {q: \"javascript\", num: \"10\"}\n</code></pre>\n</li>\n<li>URLSearchParams提供了标准API来检查和修改字符串。给URLSearchParams构造函数传入一个查询字符串，就可以创造一个实例，实例暴露了get()、set()、delete()等方法。</li>\n<li>大多数支持URLSearchParams的浏览器也都支持URLSearchParams作为迭代对象</li>\n</ul>\n<pre><code class=\"language-js\">let qs = '?q=javascript&#x26;num=10'\nlet searchParams = new URLSearchParams(qs)\n\nfor(let params of searchParams) {\n  console.log(params)\n}\n// [\"q\", \"javascript\"]\n// [\"num\", \"10\"]\n\nconsole.log(searchParams.toString()) // q=javascript&#x26;num=10\nconsole.log(searchParams.has(\"num\")) // true\nconsole.log(searchParams.get(\"num\")) // 10\nsearchParams.set(\"page\", \"3\")\nconsole.log(searchParams.toString()) // q=javascript&#x26;num=10&#x26;page=3\nsearchParams.delete(\"q\")\nconsole.log(searchParams.toString()) // num=10&#x26;page=3\n</code></pre>\n<ul>\n<li>可以通过修改location对象修改浏览器地址。常用的是使用assign并传入URL</li>\n</ul>\n<pre><code class=\"language-js\">location.assign('http://www.wrox.com')\n</code></pre>\n<ul>\n<li>这行代码会启动导航到新URL，同时在浏览器历史记录中加一条。给location.href或window.location设置一个url也会以同一个URL来调用assign方法，下面的方法跟显示调用assign一样</li>\n</ul>\n<pre><code class=\"language-js\">window.location = 'http://www.wrox.com'\nlocation.href = 'http://www.wrox.com'\n</code></pre>\n<ul>\n<li>修改location对象的属性也会修改当前加载页面。hash、search、hostname、pathname、port设置后都会修改当前URL，如下例所示</li>\n</ul>\n<pre><code class=\"language-js\">// 假设当前URL为 http://www.wrox.com/WileyCDA/\n// 修改为 http://www.wrox.com/WileyCDA/#section1\nlocation.hash = '#section1'\n// 修改为 http://www.wrox.com/WileyCDA/?q=javascript\nlocation.search = '?q=javascript'\n// 修改为 http://www.somewhere.com/WileCDA/\nlocation.hostname = 'www.somewhere.com'\n// 修改为 http://www.wrox.com/myDir/\nlocation.pathname = 'myDir'\n// 修改为 http://www.wrox.com:8080/WileyCDA/\nlocation.port = 8080\n</code></pre>\n<ul>\n<li>除hash外，只要修改location的属性，就会导致页面重新加载URL</li>\n<li>修改hash的值会在浏览器历史中新增一个记录。早期的IE浏览器点击后退跟前进不会更新hash属性，只有点击包含散列的URL才会更新hash值</li>\n<li>前面的方式修改URL后都会在历史记录中新增URL。点击后退就会返回到前页面，使用replace()方法可以不添加历史记录</li>\n<li>reload()可以重新加载当前的页面，不传参数会议最有效的方式加载，如果页面从上次请求后没有修改过，会从缓存加载。要强制从服务器重新加载，可以传一个true来让它强制从服务器加载，reload之后的代码可能执行可能不执行，取决于当前的网络延迟与系统资源</li>\n</ul>\n<h2>navigator对象</h2>\n<ul>\n<li>navigator是客户端标识浏览器的标准，浏览器启动JavaScript就会存在navigator对象。</li>\n<li>\n<p>每个浏览器都有自己支持的属性。navigator主要实现了下列属性和方法</p>\n<ul>\n<li>activeVrDisplays: 返回数组，包含ispresenting为true的VRDisplay实例</li>\n<li>appCodeName: 非Mozilla也会返回\"Mozilla\"</li>\n<li>appName: 浏览器全名</li>\n<li>appVersion: 浏览器版本，一般跟实际版本不符合</li>\n<li>battery: 返回暴露Battery Status API的BatteryManager对象</li>\n<li>buildId: 浏览器的构建编号</li>\n<li>connection: 返回暴露Network Information API的NetworkInformation对象</li>\n<li>cookieEnable: 布尔值表示是否启用了cookie</li>\n<li>credentials: 返回暴露Credentials Management API的CredentialsContainer对象</li>\n<li>deviceMemory: 返回单位为GB的设备内存容量</li>\n<li>doNotTrack: 返回用户的“不跟踪”(do-not-track)设置</li>\n<li>geolocation: 返回暴露Gelolocation</li>\n<li>getVRDisplays(): 返回数组，包含可用的每个VRDisplay实例</li>\n<li>getUserMedia(): 返回与可用媒体设备硬件关联的流</li>\n<li>hardwareConcurrency: 返回设备的处理器设备核心</li>\n<li>javaEnabled: 返回是否启用java的布尔值</li>\n<li>language: 返回浏览器的主语言</li>\n<li>languages: 返回浏览器偏好的语言数组</li>\n<li>locks: 返回暴露 Web Locks API的LockManager对象</li>\n<li>mediaCapabilities: 返回暴露MediaCapabilities API的MediaCapabilities对象</li>\n<li>mediaDevices: 返回可用的媒体设备</li>\n<li>maxTouchPoints: 返回设备触摸屏支持的最大触点数</li>\n<li>mimeTypes: 返回浏览器注册的MIME类型数组</li>\n<li>onLine: 返回表示浏览器是否联网的布尔值</li>\n<li>oscpu: 返回浏览器运行设备的操作系统和CPU</li>\n<li>permissions: 返回暴露Permissions API的Permissions对象</li>\n<li>platform: 返回浏览器运行的系统平台</li>\n<li>plugins: 返回浏览器中安装的插件数组，IE中包含页面中的所有<embed>元素</li>\n<li>product: 返回产品名称（一般是\"Gecko\"）</li>\n<li>productSub: 返回产品的额外信息（一般是Gecko的版本）</li>\n<li>registerProtocolHandler(): 讲一个网站注册为特定协议的处理程序</li>\n<li>requestMediaKeySystemAccess(): 返回一个Promise，解决为MediaKeySystemAccess对象</li>\n<li>sendBeacon(): 异步传输小数据</li>\n<li>serviceWorker: 返回用来与ServiceWorker实例交互的ServiceWorkerContainer</li>\n<li>share(): 返回当前平台的原生共享机制</li>\n<li>storage: 返回暴露Storage API的StorageManger对象</li>\n<li>userAgent: 返回浏览器的用户代理字符串</li>\n<li>verdor: 返回浏览器的产商名称</li>\n<li>verdorSub: 返回浏览器厂商的更多信息</li>\n<li>vibrate()：触发设备震动</li>\n<li>webdriver:返回浏览器是否能被自动化程序控制</li>\n</ul>\n</li>\n<li>navigator一般用来判断浏览器的类型</li>\n<li>\n<p>检测插件，除IE10以下的浏览器都可以根据plugins数组来确定。数组中的每一项都有如下属性</p>\n<ul>\n<li>name: 插件名称</li>\n<li>description: 插件介绍</li>\n<li>filename: 插件的文件名</li>\n<li>length: 由当前插件处理的MIME类型数量</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"language-js\">function hasPlugin(name){\n  name = name.toLowerCase()\n  for(let plugin of window.navigator.plugins) {\n    if(plugin.name.toLowerCase().indexOf(name) > -1) {\n      return true\n    }\n  }\n  return false\n}\n</code></pre>\n<ul>\n<li>plugins数组中的每个插件对象都有一个MimeType对象，可以通过中括号访问。每个MimeType都有四个属性：descriptor描述MIME类型，enabledPlugin是指向该插件的指针，suffixes是该MIME类型对应拓展名的逗号分割的字符串，type是完整的MIME类型字符串。</li>\n<li>IE11的window.navigator支持plugins和mimeTypes属性。IE11中的ActiveXObject从DOM中隐身，不可再用来检测特性</li>\n<li>IE10及以下的版本检测插件比较麻烦，因为不支持Netscape式的插件。要使用ActiveXObject，并尝试实例化特定插件。</li>\n<li>IE中的插件实习为COM对象，由唯一字符串标识。所以检测插件就必须知道COM标识符。Flah的标识符是\"ShockwaveFlash.ShockwaveFlash\"，有了信息就可以检测插件了</li>\n</ul>\n<pre><code class=\"language-js\">function hasIEPlugin(name){\n  try{\n    new ActiveXObject(name)\n    return true\n  } catch(e) {\n    return false\n  }\n}\n</code></pre>\n<ul>\n<li>plugins有一个refresh()方法，用于刷新plugins属性以反映新安装的插件。接受一个参数布尔值表示刷新时是否重新加载页面。传入true则所有包含插件的页面都会重新加载，否则只刷新plugins，不会从新加载页面</li>\n</ul>\n<h2>注册处理程序</h2>\n<ul>\n<li>现代浏览器支持navigator上的registerProtocolHandler()方法。可以把一个网站注册为处理某种特定类型信息应用程序。在线SSR阅读器跟电子邮件客户端的流行，可以借助这个方法将Web应用程序注册为像桌面软件一样的默认程序。</li>\n<li>使用registerProtocolHandler()方法，必须传入3个参数：要处理的协议（如\"mailto\"或\"ftp\"）、处理该协议的URL、以及应用名称。如下</li>\n</ul>\n<pre><code class=\"language-js\">navigator.registerProtocolHandler('mailto', 'http://www.somemailcient.com?cmd=%s', 'Some Mail Client')\n</code></pre>\n<ul>\n<li>这个例子为\"mailto\"协议注册一个处理程序，这样邮件地址就可以通过指定的Web应用程序打开。第二个参数是负责处理请求的URL，%s表示原始请求</li>\n</ul>\n<h2>screen对象</h2>\n<ul>\n<li>\n<p>screen对象保存纯粹的客户端能力信息，也就是浏览器窗口外面的客户端显示器的信息，比如像素宽度与像素高度。属性如下</p>\n<ul>\n<li>availHeight: 屏幕像素高度减去系统组件高度（只读）</li>\n<li>availLeft: 没有被系统组件占用的屏幕最左侧像素（只读）</li>\n<li>availTop: 没有被系统组件占用的屏幕最顶端像素（只读）</li>\n<li>availWidth: 屏幕像素宽度减去系统组件宽度（只读）</li>\n<li>colorDepth: 屏幕颜色的位数，多数系统是32（只读）</li>\n<li>height: 屏幕像素高度</li>\n<li>left: 当前屏幕左边的像素距离</li>\n<li>pixelDepth: 屏幕的位深（只读）</li>\n<li>top:当前屏幕顶端的像素距离</li>\n<li>width:屏幕像素宽度</li>\n<li>orientation:返回Screen Orientation API中屏幕朝向</li>\n</ul>\n</li>\n</ul>\n<h2>history</h2>\n<ul>\n<li>history对象表示当前窗口建立以来用户的导航历史记录。对象不会对外暴露用户访问过的URL，可以在不知道实际URL的情况下前进和后退</li>\n<li>go()可以在用户历史记录中前进和后退。只接受一个参数，表示前进或后退多少。负值表示后退（类似点击浏览器的后退按钮），正值表示历史记录中前进</li>\n</ul>\n<pre><code class=\"language-js\">history.go(-1) // 后退一页\nhistory.go(1) // 前进一页\nhistory.go(2) // 前进两页\n</code></pre>\n<ul>\n<li>部分旧版浏览器中，go()方法参数可以是一个字符串，这种情况下浏览器会导航到历史中包含该字符串的第一个位置。可能前进也可能后退。如果没有匹配到就什么也不做</li>\n<li>go()有两个简写方法：back()与forward()</li>\n</ul>\n<pre><code class=\"language-js\">history.go('wrox.com')\nhistory.back()\nhistory.forawrd()\n</code></pre>\n<ul>\n<li>history对象还有一个length属性，表示有多个条目，对于第一个页面，history.length为1，通过这个方法可以确定用户浏览起点是不是你的页面</li>\n</ul>\n<h2>历史状态管理</h2>\n<ul>\n<li>hashChange在页面URL散列发生变化时被触发，开发者可以执行部分操作。状态管理API就可以让开发者改变浏览器URL而不用加载新页面。使用history.pushState()方法。接收3个参数：一个state对象、一个新状态的标题和一个（可选的）相对URL：例如</li>\n</ul>\n<pre><code class=\"language-js\">let stateObject = {foo: 'bar'}\nhistory.pushState(stateObject, 'My title', 'baz.html')\n</code></pre>\n<ul>\n<li>pushState方法执行后，状态信息会被推到历史记录中，浏览器地址栏会改变。除了这个变化外，即使location.href返回的是地址栏中的内容，浏览器也不会发送请求。第二个参数并未被当前实现使用，所以可以传一个空字符串或者一个短标题。</li>\n<li>第一个参数应该包含正确初始化页面状态所需的信息。状态大小有限制，通常在500k-1M以内</li>\n<li>pushState()会创建新的历史记录，所以会启用后退按钮，点击后退触发window对象的popstate事件。popstate事件有一个state属性，包含通过pushState第一个参数传入的state对象：</li>\n</ul>\n<pre><code class=\"language-js\">window.addEventListener('popstate', (event) => {\n  let state = event.state\n  if(state) {\n    console.log(state)\n  }\n})\n</code></pre>\n<ul>\n<li>基于这个状态应该把页面重置为状态锁边傲视的状态（浏览器不会为你做这些）。页面初次加载时没有状态，所以点击后退返回到最初页面时，event.state为null</li>\n<li>可以通过history.state获取当前的状态对象，也可以使用replaceState()并传入与pushState同样的前两个参数来更新状态。更新状态不会创建新历史，只会覆盖当前状态：</li>\n</ul>\n<pre><code class=\"language-js\">history.replaceState({ newFoo: 'newBar' }, 'New Title')\n</code></pre>\n<ul>\n<li>传给pushState与replaceState的state对象应该只包含可以被序列化的内容。所以DOM信息不适合放到状态对象里面。</li>\n</ul>","frontmatter":{"title":"location对象与navigator对象","date":"2020-12-23","tags":["JavaScript回顾"],"categories":"JavaScript"},"fields":{"slug":"/locationAndNavigator/"}}},"pageContext":{"slug":"/locationAndNavigator/"}},"staticQueryHashes":["2566592090"]}