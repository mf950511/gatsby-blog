{"componentChunkName":"component---src-templates-blog-small-jsx","path":"/blog/extend2/","result":{"data":{"markdownRemark":{"html":"<h1>JS中的继承-（高程4）</h1>\n<h2>原型链继承</h2>\n<ul>\n<li>基本思想为：每个构造函数都有一个原型对象，原型有一个属性指回构造函数，实例有一个内部指针指向原型。</li>\n<li>如果一个原型是另一个原型的实例，就是说这个原型内部有一个内部指针指向另一个原型，相应的另一个原型也有一个指针指向另一个构造函数。</li>\n<li>\n<p>这样就在原型和实例间构造了原型链</p>\n<!--more-->\n<pre><code class=\"language-js\">function SuperType(){\nthis.property = true\n}\n</code></pre>\n</li>\n</ul>\n<p>SuperType.prototype.getSuperValue = function(){\nconsole.log(333)\nreturn this.property\n}</p>\n<p>function SubType (){\nthis.subproperty = false\n}</p>\n<p>SubType.prototype = new SuperType()</p>\n<p>SubType.prototype.getSubValue = function(){\nreturn this.subproperty\n}</p>\n<p>var instance = new SubType()\nconsole.log(instance.getSuperValue()) // true</p>\n<pre><code>- 这里SubType没有用默认的原型对象，用了SuperType的实例。这样SubType与SuperType就挂上了构，所以instance内部的[[Prototype]]指向了SubType.prototype，而SubType.prototype内部的[[Prototype]]指向了SuperType.prototype。这样就通过原型链查找实现了继承\n- 因为SubType.prototype的constructor属性被重写为指向了SuperType，所以instance.constructor也指向了SuperType\n- isPrototypeOf方法，用于判断一个原型是否在手里的原型链上，每个原型都可以调用，只要在原型链就返回true\n\n```js\nconsole.log(Object.prototype.isPrototypeOf(instance)) // true\n</code></pre>\n<h3>原型继承现存问题</h3>\n<ul>\n<li>原型包含引用值时，会在所有实例共享</li>\n<li>子类型在实例化时无法给父类型的构造函数传参</li>\n</ul>\n<h2>经典继承或对象伪装</h2>\n<ul>\n<li>基本思路：在子类的构造函数中调用父类的构造函数。然后使用call或者apply方法以新创建的对象作为上下文执行构造函数</li>\n</ul>\n<pre><code class=\"language-js\">function SuperType (){\n  this.colors = ['red', 'blue']\n}\nfunction SubType(){\n  // 继承实现\n  SuperType.call(this)\n}\n\nlet instance1 = new SubType()\ninstance1.colors.push('black')\nconsole.log(instance1.colors) // ['red', 'blue', 'black']\nlet instance2 = new SubType()\nconsole.log(instance2.colors) // ['red', 'blue']\n</code></pre>\n<ul>\n<li>盗用构造函数还可以向父类构造函数传递参数</li>\n</ul>\n<pre><code class=\"language-js\">function SuperType (name){\n  this.name = name\n  this.age = 28\n}\nfunction SubType(name){\n  // 继承实现\n  SuperType.call(this, name)\n}\n\nlet instance1 = new SubType('张三')\nconsole.log(instance1.name) // '张三'\nlet instance2 = new SubType('李四')\nconsole.log(instance2.name) // '李四'\n</code></pre>\n<h3>经典继承现存问题</h3>\n<ul>\n<li>必须在构造函数中定义方法，函数无法重用</li>\n<li>子类型无法访问父类原型上的方法，所有类型都只能用构造函数模式</li>\n</ul>\n<h2>组合继承（伪经典继承）</h2>\n<ul>\n<li>将原型链与盗用构造函数结合起来，使用原型链继承原型上的属性和方法，通过盗用构造函数继承实例属性。</li>\n</ul>\n<pre><code class=\"language-js\">function SuperType (name){\n  this.name = name\n  this.colors = ['red', 'blue']\n}\nSuperType.prototype.sayName = function(){\n  return this.name\n}\n\nfunction SubType(name, age){\n  SuperType.call(this, name)\n  this.age = age\n}\nSubType.prototype = new SuperType()\nSubType.prototype.constructor = SubType\nSubType.prototype.sayAge = function(){\n  return this.age\n}\n\nlet instance1 = new SubType('张三', 27)\ninstance1.colors.push('black')\ninstance1.sayName() // '张三'\nconsole.log(instance1.colors) // ['red', 'blue', 'black']\ninstance1.sayAge() // 27\n\n\n\nlet instance2 = new SubType('李四', 28)\ninstance2.sayName() // '李四'\nconsole.log(instance2.colors) // ['red', 'blue']\ninstance2.sayAge() // 28\n</code></pre>\n<ul>\n<li>组合继承弥补了原型继承与盗用构造函数的不足，是javascript中使用最多的继承，而且也保留了instanceof与isPrototypeOf的识别能力</li>\n</ul>\n<h3>组合式继承问题</h3>\n<ul>\n<li>组合继承存在效率问题，主要问题便是父元素构造函数会被调用两次，一次是创建子类型时调用，另一次是子类构造函数中使用。</li>\n</ul>\n<h2>原型式继承</h2>\n<ul>\n<li>原型式继承是不自定义类型也能通过原型实现对象之间的信息共享，原理就一个函数</li>\n</ul>\n<pre><code class=\"language-js\">function object(o) {\n  function F(){}\n  F.prototype = o\n  return new F()\n}\n</code></pre>\n<ul>\n<li>创建一个临时的构造函数，原型指向传入的对象，然后再返回这个临时类型的实例</li>\n</ul>\n<pre><code class=\"language-js\">function object(o) {\n  function F(){}\n  F.prototype = o\n  return new F()\n}\nlet person = {\n  name: 'Nick',\n  friends: ['Shel', 'Court']\n}\n\nlet anotherPerson = object(person)\nanotherPerson.name = 'Greg'\nanotherPerson.friends.push('Rob')\n\nlet yetAnotherPerson = object(person)\nyetAnotherPerson.name = 'Linda'\nyetAnotherPerson.friends.push('Barieb')\n\nconsole.log(person.friends) // [\"Shel\", \"Court\", \"Rob\", \"Barieb\"]\n</code></pre>\n<ul>\n<li>这里的原型式继承适用于：你有一个对象，在现有基础上创建一个新对象。</li>\n<li>ECMAScript 5 增加了Object.create()来将原型式继承规范化了。接收两个参数：作为新对象原型的对象，给新对象定义额外属性的对象。</li>\n</ul>\n<pre><code class=\"language-js\">let person = {\n  name: 'Nick',\n  friends: ['Shel', 'Court']\n}\n\nlet anotherPerson = Object.create(person)\nanotherPerson.name = 'Greg'\nanotherPerson.friends.push('Rob')\n\nlet yetAnotherPerson = Object.create(person)\nyetAnotherPerson.name = 'Linda'\nyetAnotherPerson.friends.push('Barieb')\n\nconsole.log(person.friends) // [\"Shel\", \"Court\", \"Rob\", \"Barieb\"]\n\nlet morePerson = Object.create(person, { name: { value: 'Francis' } })\nmorePerson.name // Francis\n</code></pre>\n<ul>\n<li>这里Object.create方法第二个参数跟Object.defineProperties方法第二个参数一样，都需要通过各自的描述符来描述。</li>\n</ul>\n<h2>寄生式继承</h2>\n<ul>\n<li>寄生式继承的原理：创建一个实现继承的函数，以某种方式增强对象，然后返回对象</li>\n</ul>\n<pre><code class=\"language-js\">function object(o){\n  function F(){}\n  F.prototype = o\n  return new F()\n}\n\nfunction createAnother(original) {\n  let clone = object(original)\n  clone.sayHi = function(){\n    console.log('Hi')\n  }\n  return clone\n}\n\n\nlet person = {\n  name: 'Nick',\n  friends: ['Shel', 'Court']\n}\nlet another = createAnother(person)\nanother.sayHi() // 'Hi'\n</code></pre>\n<h3>问题</h3>\n<ul>\n<li>通过寄生式继承给对象添加函数难以复用，与构造函数模式类似</li>\n</ul>\n<h2>寄生式组合继承</h2>\n<ul>\n<li>前面说到组合继承存在效率问题，本质上子类原型只需要包含超类对象的所有实例属性，子函数在执行时重写自己的原型就可以了</li>\n</ul>\n<pre><code class=\"language-js\">function SuperType (name){\n  this.name = name\n  this.colors = ['red', 'blue']\n}\nSuperType.prototype.sayName = function(){\n  return this.name\n}\n\nfunction SubType(name, age){\n  // 第二次调用\n  SuperType.call(this, name)\n  this.age = age\n}\nSubType.prototype = new SuperType() // 第一次调用\nSubType.prototype.constructor = SubType\nSubType.prototype.sayAge = function(){\n  return this.age\n}\n\nlet instance1 = new SubType('张三', 27)\n</code></pre>\n<ul>\n<li>寄生式组合继承通过盗用构造函数继承属性，但是使用混合式原型链集成方法。</li>\n<li>基本思路就是不通过调用父类构造函数给子类原型赋值，而是取得父元素原型的一个副本。</li>\n<li>就是使用寄生式继承继承父类原型，然后将获取到的新对象赋值给子类原型。</li>\n</ul>\n<pre><code class=\"language-js\">function object(o) {\n  function F(){}\n  F.prototype = o\n  return new F()\n}\nfunction inheritPrototype(subType, superType) {\n  let prototype = object(superType)\n  // 解决由于原型重写导致的默认constructor丢失问题\n  prototype.constructor = subType\n  subType.prototype = prototype\n}\n\nfunction SuperType (name){\n  this.name = name\n  this.colors = ['red', 'blue']\n}\nSuperType.prototype.sayName = function(){\n  return this.name\n}\n\nfunction SubType(name, age){\n  SuperType.call(this, name)\n  this.age = age\n}\ninheritPrototype(SubType, SuperType)\nSubType.prototype.sayAge = function(){\n  return this.age\n}\n</code></pre>\n<ul>\n<li>这里只调用了一次SuperType的构造函数，避免了SubType上用不到的属性，所以效率更高。</li>\n<li>而且原型链也保持不变，可以说是引用类型继承的最佳模式</li>\n</ul>","frontmatter":{"title":"继承--高程4","date":"2020-12-08","tags":["JavaScript回顾"],"categories":"JavaScript"},"fields":{"slug":"/extend2/"}}},"pageContext":{"slug":"/extend2/"}},"staticQueryHashes":["2566592090"]}