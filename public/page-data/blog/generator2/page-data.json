{"componentChunkName":"component---src-templates-blog-small-jsx","path":"/blog/generator2/","result":{"data":{"markdownRemark":{"html":"<h1>生成器</h1>\n<ul>\n<li>生成器是ECMAScript 6新增的拥有在一个函数块内暂停和恢复代码执行的能力</li>\n<li>使用该能力可以自定义迭代器和实现协称</li>\n<li>生成器是一个函数，函数名前加一个 * 表示它是一个生成器</li>\n<li>可以定义函数的地方都可以定义生成器</li>\n<li>箭头函数不可以定义生成器函数</li>\n</ul>\n<pre><code class=\"language-js\">function *generatorFn(){}\nlet generatorFn = function* () {}\nlet foo = {\n  *generatorFn(){}\n}\nclass Foo{\n  *generatorFn(){}\n}\nclass Bar{\n  static *generatorFn(){}\n}\n</code></pre>\n<ul>\n<li>生成器函数的 * 不受两侧空格影响</li>\n</ul>\n<pre><code class=\"language-js\">// 等价的生成方式\nfunction *generatorFn(){}\nfunction* generatorFn(){}\nfunction * generatorFn(){}\n</code></pre>\n<!--more-->\n<ul>\n<li>调用生成器函数会生成一个生成器对象。</li>\n<li>生成器对象开始处于暂停状态</li>\n<li>与迭代器相似，生成器对象也实现了Iterator接口，因此也有next方法。调用这个方法可以开始或恢复执行</li>\n</ul>\n<pre><code class=\"language-js\">const generatorFn = function* (){}\nconst g = generatorFn()\nconsole.log(g) // generatorFn {&#x3C;suspended>}\nconsole.log(g.next) // ƒ next() { [native code] }\nconsole.log(g.next()) // {value: undefined, done: true}\n</code></pre>\n<ul>\n<li>next返回的值类似于迭代器，有一个done跟value属性。函数体为空的生成器函数中间不会停留，调用一次就会让生成器到达done: true的状态</li>\n<li>value属性是生成器函数的返回值，默认为undefined，可以通过生成器函数的返回值指定</li>\n</ul>\n<pre><code class=\"language-js\">const generatorFn1 = function* (){\n  return 'bar'\n}\nconst g1 = generatorFn1()\nconsole.log(g1.next()) // {value: \"bar\", done: true}\n</code></pre>\n<ul>\n<li>生成器函数只会在初次调用next方法后开始执行，如下所示</li>\n</ul>\n<pre><code class=\"language-js\">const generatorFn2 = function* (){\n  console.log('foobar')\n}\nconst generatorObject2 = generatorFn2()\ngeneratorObject2.next() // 'foobar'\n</code></pre>\n<ul>\n<li>生成器对象实现了Iterator接口，它们默认的迭代器是自引用的</li>\n</ul>\n<pre><code class=\"language-js\">const generatorFn3 = function* (){\n}\nconsole.log(generatorFn3)  // ƒ* (){}\nconsole.log(generatorFn3()) // generatorFn3 {&#x3C;suspended>}\nconsole.log(generatorFn3()[Symbol.iterator]) // ƒ [Symbol.iterator]() { [native code] }\nconsole.log(generatorFn3()[Symbol.iterator]()) // generatorFn3 {&#x3C;suspended>}\n\nconst g3 = generatorFn3()\nconsole.log(g3 === g3[Symbol.iterator]()) // true\n</code></pre>\n<h2>yield</h2>\n<ul>\n<li>yield关键字可以让生成器停止和开始执行</li>\n<li>生成器函数再遇到yield之前正常执行，遇到这个关键字会停止执行，函数作用域状态保留</li>\n<li>停止执行的生成器函数只能通过在生成器对象上调用next方法恢复执行</li>\n</ul>\n<pre><code class=\"language-js\">const generatorFn4 = function* (){\n  yield\n}\nconst generatorObject4 = generatorFn4()\nconsole.log(generatorObject4.next()) // {value: undefined, done: false}\nconsole.log(generatorObject4.next()) // {value: undefined, done: true}\n</code></pre>\n<ul>\n<li>yield关键字类似于函数中的中间返回语句，生成的值会在next方法返回的对象里，通过yield退出的生成器函数会处在done: false的状态，通过return方法退出的生成器函数会处在 done: true的状态</li>\n</ul>\n<pre><code class=\"language-js\">const generatorFn5 = function* (){\n  yield 'foo'\n  yield 'bar'\n  return 'baz'\n}\nconst generatorObject5 = generatorFn5()\nconsole.log(generatorObject5.next()) // {value: \"foo\", done: false}\nconsole.log(generatorObject5.next()) // {value: \"bar\", done: false}\nconsole.log(generatorObject5.next()) // {value: \"baz\", done: true}\n</code></pre>\n<ul>\n<li>生成器函数内部的执行流程会对每个生成器对象区分作用域。在一个生成器上调用next不会影响其他生成器</li>\n</ul>\n<pre><code class=\"language-js\">const generatorFn6 = function* (){\n  yield 'foo'\n  yield 'bar'\n  return 'baz'\n}\nconst generatorObject6 = generatorFn6()\nconst generatorObject61 = generatorFn6()\nconsole.log(generatorObject6.next()) // {value: \"foo\", done: false}\nconsole.log(generatorObject61.next()) // {value: \"foo\", done: false}\nconsole.log(generatorObject6.next()) // {value: \"bar\", done: false}\nconsole.log(generatorObject61.next()) // {value: \"bar\", done: false}\n</code></pre>\n<ul>\n<li>yield关键字只能在生成器函数内部使用，其他地方会报错。类似return语句，yield必须直接位于生成器函数定义中，出现在嵌套的非生成器函数会抛错</li>\n</ul>\n<pre><code class=\"language-js\">// 有效\nfunction* validGeneratorFn(){\n  yield\n}\n\n// 无效\nfunction* invalidGeneratorFn(){\n  function a(){\n    yield\n  }\n}\n\n// 无效\nfunction* invalidGeneratorFn(){\n  const b = () => {\n    yield\n  }\n}\n\n// 无效\nfunction* invalidGeneratorFn(){\n  (() => {\n    yield\n  })()\n}\n</code></pre>\n<h2>生成器作为可迭代对象</h2>\n<ul>\n<li>可以把生成器当做可迭代对象使用</li>\n</ul>\n<pre><code class=\"language-js\">function* generatorFn7(){\n  yield 1\n  yield 2\n  yield 3\n}\nfor(const x of generatorFn7()) {\n  console.log(x) // 1, 2, 3\n}\n</code></pre>\n<ul>\n<li>在需要自定义迭代对象时我们可以使用生成器对象。比如，当我们需要定义一个可迭代对象，它会产生一个迭代器，迭代器会执行指定的次数</li>\n<li>使用生成器可以用一个简单地循环实现</li>\n</ul>\n<pre><code class=\"language-js\">function* generatorFn8(n){\n  while(n--) {\n    yield\n  }\n}\nfor(let _ of generatorFn8(3)) {\n  console.log('foo') // 'foo', 'foo', 'foo'\n}\n</code></pre>\n<h2>yield实现输入输出</h2>\n<ul>\n<li>除了作为函数的中间返回语句，yield还可以作为函数的中间参数使用。上一次让生成器函数暂停的yield关键字会接收到传给next的第一个值。</li>\n<li>第一次调用next方法传入的值不会被使用，因为第一次是为了开始执行生成器函数</li>\n</ul>\n<pre><code class=\"language-js\">function* generatorFn9(initial){\n  console.log(initial)\n  console.log(yield)\n  console.log(yield)\n}\nlet generatorObject9 = generatorFn9('foo')\n\ngeneratorObject9.next('bar') // foo\ngeneratorObject9.next('baz') // baz\ngeneratorObject9.next('qux') // qux\n</code></pre>\n<ul>\n<li>yield还可以同时用于输入输出</li>\n</ul>\n<pre><code class=\"language-js\">function* generatorFn10(){\n  return yield 'foo'\n}\nlet generatorObject10 = generatorFn10()\n\nconsole.log(generatorObject10.next()) // {value: \"foo\", done: false}\nconsole.log(generatorObject10.next('bar')) // {value: 'bar', done: true}\n</code></pre>\n<ul>\n<li>因为函数必须要对整个表达式求值才可以返回，再遇到yield时暂停并计算返回的值'foo'。下一次调用next()传入了'bar'，作为交给同一个yield的值。然后这个值被定为生成器函数要返回的值</li>\n<li>yield关键字可以多次使用</li>\n<li>如果我们定义一个生成器函数，根据配制的值迭代相应次数，并产生迭代索引。初始化一个数组可以实现，不用数组也可以</li>\n</ul>\n<pre><code class=\"language-js\">function* nTimes(n){\n  for(let i = 0; i &#x3C; n; ++i) {\n    yield i\n  }\n}\n\n// 或者用while实现\nfunction* nTimes(n){\n  let i = 0\n  while(n--) {\n    yield i++\n  }\n}\n</code></pre>\n<ul>\n<li>使用生成器可以填充范围数组</li>\n</ul>\n<pre><code class=\"language-js\">function* range(start, end) {\n  while(end > start) {\n    yield start++\n  }\n}\nfor(let x of range(4, 7)) {\n  console.log(x) // 4, 5, 6\n}\n\nfunction* zeroes(n) {\n  while(n--) {\n    yield 0\n  }\n}\nconsole.log(Array.from(zeroes(8))) // [0, 0, 0, 0, 0, 0, 0, 0]\n</code></pre>\n<h2>产生可迭代对象</h2>\n<ul>\n<li>可以使用 * 加强yield的行为，让它迭代一个可迭代对象，从而一次产出一个值</li>\n</ul>\n<pre><code class=\"language-js\">function* generatorFn11(){\n  yield* [1, 2, 3]\n}\nfor(let x of generatorFn11()) {\n  console.log(x)\n}\n\n// 等价于\nfunction* generatorFn11(){\n  for(const x of [1, 2, 3]) {\n    yield x\n  }\n}\n</code></pre>\n<ul>\n<li>yield星号两侧也不受空格影响</li>\n<li>yield* 其实只是将一个可迭代对象序列化为一串可以单独产出的值，跟放在循环里没有什么不同</li>\n<li>yield* 的值是关联迭代器返回done:true时的value属性。对于普通迭代器来说，这个值是undefined</li>\n</ul>\n<pre><code class=\"language-js\">function* generatorFn12(){\n  console.log('iter value:', yield* [1, 2, 3])\n}\nfor(const x of generatorFn12()) {\n  console.log('value: ', x)\n}\n// value:  1\n// value:  2\n// value:  3\n// iter value: undefined\n</code></pre>\n<ul>\n<li>对于生成器函数产生的迭代器来说，这个值就是生成器函数返回的值</li>\n</ul>\n<pre><code class=\"language-js\">function* generatorFn13(){\n  yield 'foo'\n  return 'bar'\n}\nfunction* othergeneratorFn13(genObj){\n  console.log('iter value:', yield* generatorFn13())\n}\nfor(const x of othergeneratorFn13()) {\n  console.log('value: ', x)\n}\n\n// value:  foo\n// iter value: bar\n</code></pre>\n<h2>yield*实现递归</h2>\n<ul>\n<li>这也是yield*最有用的地方</li>\n</ul>\n<pre><code class=\"language-js\">function* nTimes(n) {\n  if(n > 0) {\n    yield* nTimes(n - 1)\n    yield n - 1\n  }\n}\nfor(const x of nTimes(3)) {\n  console.log(z)\n}\n// 0\n// 1\n// 2\n</code></pre>\n<ul>\n<li>这里每个生成器都会从新创建的生成器对象产出值，然后再产生一个整数。</li>\n<li>下面是一个图的实现，生成一个随机的双向图</li>\n</ul>\n<pre><code class=\"language-js\">class Node {\n  constructor(id){\n    this.id = id\n    this.neighbors = new Set()\n  }\n  connect(node){\n    if(node !== this) {\n      this.neighbors.add(node)\n      node.neighbors.add(this)\n    }\n  }\n}\nclass RandomGraph {\n  constructor(size) {\n    this.nodes = new Set()\n    for(let i = 0; i &#x3C; size; ++i) {\n      this.nodes.add(new Node(i))\n    }\n    const threshold = 1 / size\n    for(const x of this.nodes) {\n      for(const y of this.nodes) {\n        if(Math.random() &#x3C; threshold) {\n          x.connect(y)\n        }\n      }\n    }\n  }\n\n  print(){\n    for(const node of this.nodes) {\n      // console.log([...node.neighbors])\n      const ids = [...node.neighbors].map((n) => n.id).join(',')\n      console.log(`${ node.id }: ${ ids }`)\n    }\n  }\n}\n\nconst gra = new RandomGraph(6)\ngra.print()\n// 0: 1,5\n// 1: 0,2,5\n// 2: 1,3,5\n// 3: 2\n// 4: 5\n// 5: 0,2,1,4\n</code></pre>\n<ul>\n<li>图结构数据适合递归遍历，而递归生成器可以实现这个需求。生成器函数必须包含一个可迭代对象，产出该对象的每个值，并对值进行递归。如此可以测试是否有某个点不可到达。</li>\n</ul>\n<pre><code class=\"language-js\">class Node {\n  constructor(id){\n    this.id = id\n    this.neighbors = new Set()\n  }\n  connect(node){\n    if(node !== this) {\n      this.neighbors.add(node)\n      node.neighbors.add(this)\n    }\n  }\n}\nclass RandomGraph {\n  constructor(size) {\n    this.nodes = new Set()\n    for(let i = 0; i &#x3C; size; ++i) {\n      this.nodes.add(new Node(i))\n    }\n    const threshold = 1 / size\n    for(const x of this.nodes) {\n      for(const y of this.nodes) {\n        if(Math.random() &#x3C; threshold) {\n          x.connect(y)\n        }\n      }\n    }\n  }\n\n  print(){\n    for(const node of this.nodes) {\n      // console.log([...node.neighbors])\n      const ids = [...node.neighbors].map((n) => n.id).join(',')\n      console.log(`${ node.id }: ${ ids }`)\n    }\n  }\n\n  isConnect(){\n    let visitedNode = new Set()\n    function* traverse(nodes){\n      for(let node of nodes) {\n        if(!visitedNode.has(node)) {\n          yield node\n          yield* traverse(node.neighbors)\n        }\n      }\n    }\n    const firstNode = this.nodes[Symbol.iterator]().next().value\n    for(const node of traverse([firstNode])) {\n      visitedNode.add(node)\n    }\n    return visitedNode.size === this.nodes.size\n  }\n}\n</code></pre>\n<ul>\n<li>因为生成器对象实现了Iterable接口，而且生成器函数和默认迭代器对象调用之后都会产生迭代器，所以生成器格外适合做为默认迭代器，下面是一个简单地例子</li>\n</ul>\n<pre><code class=\"language-js\">class Foo{\n  constructor(){\n    this.values = [1, 2, 3]\n  }\n  * [Symbol.iterator]() {\n    yield* this.values\n  }\n}\n\nconst f = new Foo()\nfor(const x of f) {\n  console.log(x)\n}\n// 1, 2, 3\n</code></pre>\n<ul>\n<li>for-of循环调用默认迭代器（刚好也是一个生成器函数）并产生一个生成器对象，生成器对象是可迭代的，所以可以在迭代中使用</li>\n</ul>\n<h2>提前终止生成器</h2>\n<ul>\n<li>生成器支持“可关闭”的概念。一个实现Iterator接口的对象一定有next方法，还有一个可选的return方法用于提前终止迭代器。生成器对象除了这两个方法，还有第三个方法： throw</li>\n</ul>\n<pre><code class=\"language-js\">function* generatorF(){}\nconst ge = generatorF()\nconsole.log(ge) // generatorF {&#x3C;suspended>}\nconsole.log(ge.next) // ƒ next() { [native code] }\nconsole.log(ge.return) // ƒ return() { [native code] }\nconsole.log(ge.throw) // ƒ throw() { [native code] }\n</code></pre>\n<ul>\n<li>return与throw都可以强制生成器进入关闭状态</li>\n<li>return 方法强制生成器进入关闭状态，提供给return的值就是终止迭代器对象的值</li>\n</ul>\n<pre><code class=\"language-js\">function* generatorF1(){\n  for(const x of [1,2,3]) {\n    yield x\n  }\n}\nconst ge1 = generatorF1()\nconsole.log(ge1) // generatorF1 {&#x3C;suspended>}\nconsole.log(ge1.return(3)) // {value: 3, done: true}\nconsole.log(ge1) // generatorF1 {&#x3C;closed>}\n</code></pre>\n<ul>\n<li>跟迭代器不一样，生成器对象一旦进入关闭状态就无法恢复了。后续调用next会显示done: true的状态，而且这个值不会被存储或传播</li>\n</ul>\n<pre><code class=\"language-js\">function* generatorF2(){\n  for(const x of [1,2,3]) {\n    yield x\n\nconst ge2 = generatorF2()\nconsole.log(ge2.next()) // {value: 1, done: false}\nconsole.log(ge2.return(4)) // {value: 4, done: true}\nconsole.log(ge2.next()) // {value: undefined, done: true}\nconsole.log(ge2.next()) // {value: undefined, done: true}  }\n}\n</code></pre>\n<ul>\n<li>for-of循环等内置语言结构会忽略状态为done: true的IteratorObject内部的值</li>\n</ul>\n<pre><code class=\"language-js\">function* generatorF3(){\n  for(const x of [1,2,3]) {\n    yield x\n  }\n}\nconst ge3 = generatorF3()\nfor(const x of ge3) {\n  if(x > 1) {\n    ge3.return(4)\n  }\n  console.log(x)\n}\n// 1\n// 2\n</code></pre>\n<ul>\n<li>throw方法会在暂停时讲一个提供的错误注入到生成器对象中，要是错误没有被处理，生成器就会关闭</li>\n</ul>\n<pre><code class=\"language-js\">function* generatorF4(){\n  for(const x of [1,2,3]) {\n    yield x\n  }\n}\nconst ge4 = generatorF4()\nconsole.log(ge4) // generatorF4 {&#x3C;suspended>}\ntry {\n  ge4.throw('foo')\n} catch(e) {\n  console.log(e) // foo\n}\nconsole.log(ge4) // generatorF4 {&#x3C;closed>}\n</code></pre>\n<ul>\n<li>要是生成器内部处理了这个值，那生成器就不会关闭，而且可以恢复执行。错误处理会跳过对应的yield，因此下例中会跳过一个值</li>\n</ul>\n<pre><code class=\"language-js\">function* generatorF5(){\n  for(const x of [1,2,3]) {\n    try {\n      yield x\n    } catch (e) {\n      console.log(e)\n    }\n  }\n}\nconst ge5 = generatorF5()\nge5.throw('foo') // 'foo'\nconsole.log(ge5.next()) // {value: 3, done: false}\n</code></pre>\n<ul>\n<li>上面生成器在try/catch块中的yield关键字暂停执行。暂停期间throw向生成器对象内部注入了一个错误：字符串\"foo\"。因为错误是在生成器的try/catch抛出，仍然在生成器内部捕获。</li>\n<li>由于yield抛出了错误，生成器不会产出2.此时，生成器函数继续执行，下一次迭代再次遇到yield关键字时产出了3</li>\n<li>如果生成器还没有开始执行，那么调用throw抛出的错误不会在函数内部被捕获，因为这相当于在函数外部抛出了错误</li>\n</ul>\n<h2>小结</h2>\n<ul>\n<li>生成器是一种特殊的函数，调用返回一个生成器对象。生成器对象实现了Iterable接口，因此能用在任何消费可迭代对象的地方。</li>\n<li>生成器支持yield关键字，该关键字可以暂停执行生成器函数。yield关键字可以通过next接收输入和输出。</li>\n<li>yield加上 * 后可以将后面的可迭代对象序列化为一串值</li>\n</ul>","frontmatter":{"title":"再读生成器","date":"2020-10-22","tags":["JavaScript回顾"],"categories":"JavaScript"},"fields":{"slug":"/generator2/"}}},"pageContext":{"slug":"/generator2/"}},"staticQueryHashes":["2566592090"]}