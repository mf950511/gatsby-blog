{"componentChunkName":"component---src-templates-blog-small-jsx","path":"/blog/react_md_1/","result":{"data":{"markdownRemark":{"html":"<h1>从零搭建一个react-hooks项目（一）</h1>\n<ul>\n<li>最近有打算仿vue-admin项目构造一个react的项目，不引用官方脚手架，从webpack开始配置一套基于react,redux,typescript的项目，并实时记录一下项目中的一些配置情况</li>\n<li>首先搭建一个基本的webpack环境</li>\n</ul>\n<h2>webpack项目搭建</h2>\n<ul>\n<li>前置基础，电脑有安装node环境，可以使用npm工具</li>\n<li>新建文件夹，命名项目名称（react-admin）,进入文件夹，使用命令 npm init ，然后一路确定生成package.json文件</li>\n<li>webpack需要安装基本依赖 webpack webpack-cli webpack-dev-server, 命令为 npm i webpack webpack-cli webpack-dev-server -D</li>\n<li>安装依赖完成，则需要进行webpack的基本配置，我们在根目录构建 webpack.config.js 文件用于配置webpack</li>\n<li>然后在根目录创建一个index.js作为入口文件，我们先构造index.js这个入口文件，代码如下</li>\n</ul>\n<!--more-->\n<pre><code class=\"language-js\">function a(number){\n  console.log(number)\n}\na(12)\n</code></pre>\n<ul>\n<li>然后开始配置我们的webpack，webpack需要配置入口及输出位置，分别对应entry与output属性</li>\n<li>entry可以接收一个字符串作为主入口的文件路径，但只能用于单入口项目。也可以接收一个对象作为入口的文件路径，如下所示</li>\n<li>output用来描述打包后的文件应该放到哪，叫什么名字，也有两个基本属性，一个是打包后的文件名，一个是打包后的文件路径，这里我们通过[name].js来获取他在入口文件中的对应名称并生成文件名，如果是单入口并且直接用字符串指定的文件路径，比如entry: './index.js'，这样最后生成的文件名就是main.js，如果采用对象形式设定的entry属性，比如entry: { app: './index.js' }，则最后生成的文件就是对应的键值app.js。 路径使用path.resolve()来在根目录下生成dist文件夹并将打包文件放到其中</li>\n</ul>\n<pre><code class=\"language-js\">const path = require('path') // node环境自带，无需下载\n// 单入口文件\nmodule.exports = {\n  entry: './index.js', // 入口为index.js\n  output: {  // 输出就是 dist/main.js\n    filename: '[name].js',\n    path: path.resolve(__dirname, 'dist')\n  }\n}\n\n// 多入口文件\nmodule.exports = {\n  entry: { // 入口也是index.js\n    app: './index.js'\n  }, \n  output: {  // 输出为dist/app.js\n    filename: '[name].js',\n    path: path.resolve(__dirname, 'dist')\n  }\n}\n</code></pre>\n<ul>\n<li>配置到这就算完成了最基本的配置，我们可以来测试一下，先在package.json中的 scripts 下新建指令 \"start\": \"webpack --config webpack.config.js\"</li>\n<li>然后再执行npm run start 就可以看到执行了打包过程，生成了dist文件夹</li>\n<li>这里我们完成了基本的配置，但是这里还有一个问题，当我们修改entry对应的文件名时，重新执行打包，会发现之前的打包文件还存在，这样就会导致我们的dist文件夹会包含很多之前打包的跟当前代码无关的文件，这样其实对我们的项目并不友好，这里我们想要在每次打包的时候都把dist给移除了，并重新生成</li>\n<li>clean-webpack-plugin 插件可以帮助我们实现这个需求，先下载这个包  npm i clean-webpack-plugin -D</li>\n<li>然后在webpack.config.js中进行配置，如下，plugins用于我们配置我们想要的相关插件，接收一个数组值，这样我们的项目就可以在每次打包前都将dist清空了，就不会存在无用文件在内了</li>\n</ul>\n<pre><code class=\"language-js\">const path = require('path')\nconst { CleanWebpackPlugin } = require('clean-webpack-plugin');\n\nmodule.exports = {\n  entry: {\n    app: './index.js'\n  },\n  output: {\n    filename: '[name].js',\n    path: path.resolve(__dirname, 'dist'),\n    chunkFilename: '[name].bundle.js'\n  },\n  plugins: [\n    new CleanWebpackPlugin()\n  ]\n}\n</code></pre>\n<ul>\n<li>接下来就让我们开始配置react相关吧，react开发中我们会用到jsx或者es6的语法，而这些语法在低版本浏览器都是不兼容的，所以我们需要配置babel来实现低版本浏览器的兼容</li>\n<li>这里我们需要下载 babel-loader @babel/preset-env(根据环境转换代码) @babel/preset-react(react使用) @babel/preset-polyfill(Babel默认只转换新的JavaScript语法，但是不转换新的API，比如 <code>Iterator</code>、<code>Generator</code>、<code>Set</code>、<code>Maps</code>、<code>Proxy</code>、<code>Reflect</code>、<code>Symbol</code>、<code>Promise</code> 等全局对象，以及一些定义在全局对象上的方法（比如<code>Object.assign</code> ）都不会转码。而<code>@babel/preset-polyfill</code>可以转码。) @babel/proposal-object-rest-spread(处理react中对象的rest写法) @babel/proposal-object-rest-spread (处理类里面的箭头函数this绑定，static属性等 ), 依赖下载完成后就需要进行babel配置了</li>\n<li>我们在根目录构建 .babelrc 文件，内里配置如下</li>\n</ul>\n<pre><code class=\"language-js\">{\n  \"presets\": [\n    \"@babel/preset-env\",\n    \"@babel/preset-react\"\n  ],\n  \"plugins\": [\n    \"@babel/proposal-object-rest-spread\", // 处理对象的rest写法\n    \"@babel/proposal-class-properties\" // 处理类里面的箭头函数绑定，static属性等 \n  ]\n}\n</code></pre>\n<ul>\n<li>然后就需要在webpack里面配置编译规则了，还是在webpack.config.js里面，新增module模块，添加不同文件的解析规则，如下</li>\n</ul>\n<pre><code class=\"language-js\">module.exports = {\n  entry: {\n    app: './index.js'\n  },\n  output: {\n    filename: '[name].js',\n    path: path.resolve(__dirname, 'dist'),\n    chunkFilename: '[name].bundle.js'\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.(js)x?$/,\n        use: ['babel-loader'],\n        exclude: /node-modules/ // 不解析node_modules中的文件\n      }\n    ]\n  },\n  plugins: [\n    new CleanWebpackPlugin()\n  ]\n}\n</code></pre>\n<ul>\n<li>然后我们可以写代码来测试一下，react 要基于 dom 展示，所以我们新建一个index.html用于dom展示，index.jsx用于执行react挂载，新建一个文件夹src用于放置react相关的组件及内里逻辑，并在里面新建一个app.jsx用于做初始组件，代码分别如下</li>\n</ul>\n<pre><code class=\"language-js\">// index.html\n&#x3C;!DOCTYPE html>\n&#x3C;html lang=\"en\">\n&#x3C;head>\n  &#x3C;meta charset=\"UTF-8\">\n  &#x3C;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  &#x3C;title>Document&#x3C;/title>\n&#x3C;/head>\n&#x3C;body>\n  \n&#x3C;div id=\"app\">&#x3C;/div>\n&#x3C;script src=\"./dist/app.js\">&#x3C;/script>\n&#x3C;script src=\"./dist/test.js\">&#x3C;/script>\n&#x3C;/body>\n&#x3C;/html>\n</code></pre>\n<pre><code class=\"language-js\">// index.jsx\nimport * as React from 'react'\nimport * as ReactDOM from 'react-dom'\nimport App from './src/app.jsx'\nReactDOM.render(\n  &#x3C;App/>\n  ,document.querySelector('#app')\n)\n</code></pre>\n<pre><code class=\"language-js\">// app.jsx\nimport * as React from 'react'\nclass App extends React.Component{\n  render(){\n    return (\n      &#x3C;div>123&#x3C;/div>\n    )\n  }\n}\nexport default App\n</code></pre>\n<ul>\n<li>然后需要在我们的webpack配置中新增加一个入口文件，如我们在html中的引入一样，需要命名为test，配置如下</li>\n</ul>\n<pre><code class=\"language-js\">module.exports = {\n  entry: {\n    app: './index.js',\n    test: './index.jsx'\n  },\n  ...// 省略\n}\n</code></pre>\n<ul>\n<li>接下来执行npm run start 执行打包，打包完成后打开页面 index.html 查看就可以发现已经插入了123进去</li>\n<li>这里我们可以发现我们需要新建一个index.html然后再主动根据生成的文件路径将其引入进去，要是生成的文件比较多则会很麻烦，所以我们接下来使用插件让其自动生成</li>\n<li>首先下载插件 html-webpack-plugin，命令为 npm i html-webpack-plugin</li>\n<li>然后再webpack.config.js里进行相关配置，还是用在plugins模块中，如下所示</li>\n</ul>\n<pre><code class=\"language-js\">const path = require('path')\nconst webpack = require('webpack')\nconst { CleanWebpackPlugin } = require('clean-webpack-plugin');\nconst HTMLWebpackPlugin = require('html-webpack-plugin')\n\nmodule.exports = {\n  entry: {\n    app: './index.js',\n    test: './index.jsx'\n  },\n  output: {\n    filename: '[name].js',\n    path: path.resolve(__dirname, 'dist'),\n    chunkFilename: '[name].bundle.js'\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.(js)x?$/,\n        use: ['babel-loader'],\n        exclude: /node-modules/\n      }\n    ]\n  },\n  plugins: [\n    new HTMLWebpackPlugin({\n      inject: true, // 所有js脚本放于body之后\n      hash: true, // 为静态资源生成hash，用于清楚缓存\n      cache: true, // 仅在文件被更改时发出文件\n      title: 'react admin',\n      filename: 'index.html',\n      template: path.resolve(__dirname, 'index.html'),\n      minify: {\n        collapseWhitespace: true, // 折叠空白\n        removeComments: true, // 删除注释\n        removeRedundantAttributes: true,\n        removeScriptTypeAttributes: true,\n        removeStyleLinkTypeAttributes: true\n      }\n    }),\n    new CleanWebpackPlugin()\n  ]\n}\n</code></pre>\n<ul>\n<li>然后在根目录放置我们的模板index.html，不需要主动引入js文件了，内容如下</li>\n</ul>\n<pre><code class=\"language-js\">// index.html\n&#x3C;!DOCTYPE html>\n&#x3C;html lang=\"en\">\n&#x3C;head>\n  &#x3C;meta charset=\"UTF-8\">\n  &#x3C;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  &#x3C;title>react admin&#x3C;/title>\n&#x3C;/head>\n&#x3C;body>\n  \n&#x3C;div id=\"app\">&#x3C;/div>\n&#x3C;/body>\n&#x3C;/html>\n</code></pre>\n<ul>\n<li>之后再执行我们的npm run start 就可以在dist中自动生成我们的index.html文件了，直接打开就能发现已经有我们要渲染的内容了</li>\n<li>react相关的就配置完成了，接下来我们需要配置一下css部分，开发中以less作为示例配置一下</li>\n<li>首先安装相关的依赖 less-loader style-loader postcss-loader css-loader autoprefixer，命令为 npm i less-loader style-loader postcss-loader css-loader autoprefixer -D</li>\n<li>接下来进行webpack配置，用以处理less文件的解析及处理</li>\n<li>还是在 module 下面的 rules 中配置规则，如下</li>\n</ul>\n<pre><code class=\"language-js\">const path = require('path')\nconst webpack = require('webpack')\nconst { CleanWebpackPlugin } = require('clean-webpack-plugin');\nconst HTMLWebpackPlugin = require('html-webpack-plugin')\n\nmodule.exports = {\n  entry: {\n    app: './index.js',\n    test: './index.jsx'\n  },\n  output: {\n    filename: '[name].js',\n    path: path.resolve(__dirname, 'dist'),\n    chunkFilename: '[name].bundle.js'\n  },\n  module: {\n    rules: [\n      { \n        test: /\\.(le|c)ss$/,\n        use: [ // 解析规则为从右向左，即 less-loader, postcss-loader, css-loader, style-loader\n          'style-loader',\n          {\n            loader: 'css-loader',\n            options: {\n              sourceMap: true //是否打开样式查找\n            }\n          },\n          {\n            loader: 'postcss-loader', // 为浏览器加前缀\n            options: {\n              ident: 'postcss',\n              sourceMap: true,\n              plugins: loaders => [\n                require('autoprefixer')({\n                })\n              ]\n            }\n          },\n          {\n            loader: 'less-loader', // 解析样式文件\n            options: {\n              sourceMap: true\n            }\n          }\n        ]\n      },\n      {\n        test: /\\.(js)x?$/,\n        use: ['babel-loader'],\n        exclude: /node-modules/\n      }\n    ]\n  },\n  plugins: [\n    new HTMLWebpackPlugin({\n      inject: true, // 所有js脚本放于body之后\n      hash: true, // 为静态资源生成hash，用于清楚缓存\n      cache: true, // 仅在文件被更改时发出文件\n      title: 'react admin',\n      filename: 'index.html',\n      template: path.resolve(__dirname, 'index.html'),\n      minify: {\n        collapseWhitespace: true, // 折叠空白\n        removeComments: true, // 删除注释\n        removeRedundantAttributes: true,\n        removeScriptTypeAttributes: true,\n        removeStyleLinkTypeAttributes: true\n      }\n    }),\n    new CleanWebpackPlugin()\n  ]\n}\n</code></pre>\n<ul>\n<li>配置完成之后我们简单做个测试，在app.jsx目录下新建app.less文件，并简单书写样式</li>\n</ul>\n<pre><code class=\"language-css\">.red{\n  color: red;\n  .blue{\n    background: blue;\n  }\n  .orange{\n    background: orange;\n  }\n}\n</code></pre>\n<ul>\n<li>修改app.jsx中的渲染内容为</li>\n</ul>\n<pre><code class=\"language-js\">import * as React from 'react'\nimport './app.less'\n\nclass App extends React.Component{\n  render(){\n    return (\n      &#x3C;div className=\"red\">\n        &#x3C;div className=\"blue\">123&#x3C;/div>\n        &#x3C;div className=\"orange\">345&#x3C;/div>\n      &#x3C;/div>\n    )\n  }\n}\n\nexport default App\n</code></pre>\n<ul>\n<li>然后执行npm run start,之后打开dist中的index.html，就发现样式已经生效了，然后F12打开开发者工具调试，能查找到对应的div生效样式的所在位置</li>\n<li>上面就完成了一个简单的demo，接下来就是要针对项目做一些配置化了</li>\n</ul>","frontmatter":{"title":"从零搭建一个react-hooks项目（一）","date":"2020-06-11","tags":["react","react hooks","redux","webpack"],"categories":"Webpack"},"fields":{"slug":"/react_md_1/"}}},"pageContext":{"slug":"/react_md_1/"}},"staticQueryHashes":["2566592090"]}