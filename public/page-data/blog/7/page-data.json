{"componentChunkName":"component---src-templates-index-jsx","path":"/blog/7","result":{"data":{"allMarkdownRemark":{"totalCount":62,"edges":[{"node":{"html":"<h1>DOM编程</h1>\n<ul>\n<li>下面是我们常见的DOM编程方法</li>\n<li>动态插入script标签</li>\n</ul>\n<pre><code class=\"language-js\">function loadScript(code){\n  var script = document.createElement('script')\n  try {\n    // 旧版本IE中有问题，IE对script做了特殊处理，不允许常规DOM访问子节点，所以可以在\n    script.appendChild(document.createTextNode(code))\n  } catch () {\n    script.text = code\n  }\n  document.body.appendChild(script)\n}\nloadScript('function sayHi(){alert(\"hi\")}')\n</code></pre>\n<ul>\n<li>这种方法会在返回后立即生效，通过innerHTML创建的 script 元素不会执行，会创建但不会执行</li>\n<li>\n<p>动态插入CSS样式</p>\n<!--more-->\n<pre><code class=\"language-js\">// 所有主流浏览器都支持\nfunction loadStyles(url) {\nlet link = document.createElement('link')\nlink.rel = 'stylesheet'\nlink.type = 'text/css'\nlink.href = url\nlet head = document.getElementsByTagName('head')[0]\nhead.appendChild(link)\n}\n</code></pre>\n</li>\n</ul>\n<p>// 插入动态语句\nfunction loadStyleString(css) {\nlet style = document.createElement('style')\nstyle.type = 'text/css'\ntry{\nstyle.appendChild(document.createTextNode(css))\n} catch() {\nstyle.styleSheet.cssText = css\n}\nlet head = document.getElementsByTagName('head')[0]\nhead.appendChild(style)\n}</p>\n<p>loadStyleString(\"body{background:#fff}\")</p>\n<pre><code>- 这样添加也会立即生效，在IE中要注意使用styleSheet.cssText，如果重用同一个 style 元素并设置该属性超一次，会导致浏览器奔溃，设置cssText为空也会导致奔溃\n\n## 操作表格\n\n- 下面是按常规DOM形式创建的表格\n\n```js\n// 创建表格\nlet table = document.createElement('table')\ntable.border = 1\ntable.width = '100%'\n// 创建表体\nlet tbody = document.createElement('tbody')\ntable.appendChild(tbody)\n\n// 创建行\nlet row1 = document.createElement('tr')\ntbody.appendChild(row1)\nlet cell_1 = document.createElement('td')\ncell_1.appendChild(document.createTextNode('Cell_1'))\nrow1.appendChild(cell_1)\n\nlet cell_2 = document.createElement('td')\ncell_2.appendChild(document.createTextNode('Cell_2'))\nrow1.appendChild(cell_2)\n\ndocument.body.appendChild(table)\n</code></pre>\n<ul>\n<li>上面创建的形式太过繁琐，所以新增了以下属性</li>\n<li>\n<p>table新增的属性</p>\n<ul>\n<li>caption，指向<caption>元素的指针</li>\n<li>tBodies，包含<tbody>的HTMLCollection</li>\n<li>tFoot，指向<tfoot>元素</li>\n<li>tHead，指向<thead>元素</li>\n<li>rows：包含所有行的HTMLCollection</li>\n<li>createTHead()：创建<thead>标签，插入表格，返回引用</li>\n<li>createTFoot()：创建<tfoot>元素，插入表格，返回引用</li>\n<li>createCaption()：创建<caption>元素，插入表格，返回引用</li>\n<li>deleteTHead()：删除<thead>元素</li>\n<li>deleteTFoot()：删除<tfoot>元素</li>\n<li>deleteCaption()：删除<caption>元素</li>\n<li>deleteRow(pos): 删除给定的行</li>\n<li>insertRow(pos)，在给定位置插入一行</li>\n</ul>\n</li>\n<li>\n<p>tbody元素添加以下方法</p>\n<ul>\n<li>rows，包含<tbody>中所有行的HTMLCollection</li>\n<li>deleteRow(pos)，删除指定位置行</li>\n<li>insertRow(pos)，指定位置插入一行，返回改行的引用</li>\n</ul>\n</li>\n<li>\n<p>tr元素新增以下属性和方法</p>\n<ul>\n<li>cells，包含<tr>元素所有表元的HTMLCollection</li>\n<li>deleteCell(pos)，删除指定位置表元</li>\n<li>insertCell(pos)，指定位置插入表元返回引用</li>\n</ul>\n</li>\n<li>重写上面代码</li>\n</ul>\n<pre><code class=\"language-js\">let table = document.createElement('table')\ntable.border = 1\ntable.width = '100%'\n// 创建表体\nlet tbody = document.createElement('tbody')\ntable.appendChild(tbody)\n\ntbody.insertRow(0)\ntbody.rows[0].insertCell(0)\ntbody.rows[0].cells[0].appendChild(document.createTextNode('Cell_1'))\ntbody.rows[0].insertCell(1)\ntbody.rows[0].cells[1].appendChild(document.createTextNode('Cell_2'))\n</code></pre>\n<ul>\n<li>NodeList、NamedNodeMap、HTMLCollection三个集合类型都是实时的，文档结构变化会实时反应，所以下面代码会死循环</li>\n</ul>\n<pre><code class=\"language-js\">let divs = document.getElementsByTagName('div')\nfor(let i = 0 ; i &#x3C; divs.length; i++) {\n  let div = document.createElement('div')\n  document.body.appendChild(div)\n}\n</code></pre>\n<h2>MutationObserver接口</h2>\n<ul>\n<li>DOM规范中的MutationObserver接口可以在DOM被修改时异步执行回调，使用它能够观察整个文档、DOM树的一部分，或某个元素。还能观察元素属性、子节点、文本或者它们的任意组合</li>\n<li>MutationObserver是为了替代废弃的MutationEvent</li>\n<li>基本用法如下</li>\n</ul>\n<pre><code class=\"language-js\">let observer = new MutationObserver(() => {\n  console.log('&#x3C;body> attributes changed')\n})\n\nobserver.observe(document.body, { attributes: true })\ndocument.body.className = 'foo'\nconsole.log('Changed body')\n\n// Changed body\n// &#x3C;body> attributes changed\n</code></pre>\n<ul>\n<li>创建后使用observer()方法关联DOM对象，接收两个参数为：要观察变化的DOM节点，以及一个MutationObserverInit对象</li>\n<li>MutationObserverInit对象用于控制观察哪些方面的变化，是一个键/值形式配置选项的字典。上述代码就是观察body上attributes的变化</li>\n<li>从上面能看出来，观察的回调执行在后面，所以是一个异步函数</li>\n<li>每个回调都会收到一个MutationRecord实例的数组，实例包含的信息包括发生了什么变化，以及DOM的哪一部分受影响了。回调执行之前可能同时发生多个满足条件的事件，所以每次执行回调都会传入一个包含按顺序入队的MutationRecord实例的数组</li>\n</ul>\n<pre><code class=\"language-js\">let observer = new MutationObserver((mutationRecord) => { console.log(mutationRecord) })\nobserver.observe(document.body, { attributes:true })\ndocument.body.setAttribute('foo', 'bar')\n// [\n//   {\n//     addedNodes: NodeList []\n//     attributeName: \"foo\"\n//     attributeNamespace: null\n//     nextSibling: null\n//     oldValue: null\n//     previousSibling: null\n//     removedNodes: NodeList []\n//     target: body.page-v3.eye-protector-processed\n//     type: \"attributes\"\n//   }\n// ]\ndocument.body.setAttributeNS('baz', 'foo', 'bar')\n// [\n//   {\n//     addedNodes: NodeList []\n//     attributeName: \"foo\"\n//     attributeNamespace: \"baz\"\n//     nextSibling: null\n//     oldValue: null\n//     previousSibling: null\n//     removedNodes: NodeList []\n//     target: body.page-v3.eye-protector-processed\n//     type: \"attributes\"\n//   }\n// ]\n</code></pre>\n<ul>\n<li>连续修改会生成多个MutationRecord实例，下次回调就会收到所有包含这些实例的数组，顺序为变化事件发生的顺序</li>\n</ul>\n<pre><code class=\"language-js\">let observer = new MutationObserver((mutationRecords) => { console.log(mutationRecords) })\nobserver.observe(document.body, { attributes:true })\ndocument.body.className = 'foo'\ndocument.body.className = 'bar'\ndocument.body.className = 'baz'\n// [MutationRecord, MutationRecord, MutationRecord]\n</code></pre>\n<ul>\n<li>\n<p>下面是MutationRecord实例的属性</p>\n<ul>\n<li>target: 被修改影响的目标节点</li>\n<li>type: 字符串，表示变化的类型：\"attributes\"、\"characterData\"、\"childList\"</li>\n<li>oldValue: 如果在MutationObserverInit中启用（attributeOldValue或characterData oldValue为true）\"attributes\"或\"characterData\"的事件变化会设置这个属性为被替代的值，\"childList\"类型的变化始终将这个属性设置为null</li>\n<li>attributeName: 对于\"attributes\"类型的变化，这里保存被修改属性的名字，其他变化事件为null</li>\n<li>attributeNameSpace: 对于使用命名空间的\"attributes\"类型变化，这里保存被修改属性的名字，其他事件为null</li>\n<li>addedNodes: 对于\"childList\"类型的变化，返回包含变化中添加节点的NodeList，默认为空NodeList</li>\n<li>removeNodes: 对于\"childList\"类型的变化，返回包含变化中删除节点的NodeList，默认为空NodeList</li>\n<li>previousSibling: 对于\"childList\"类型的变化，返回变化节点的前一个同胞Node，默认为null</li>\n<li>nextSibling: 对于\"childList\"类型的变化，返回变化后节点的后一个同胞Node，默认为null</li>\n</ul>\n</li>\n<li>传给回调的第二个参数是观察变化的MutationObserver的实例</li>\n</ul>\n<pre><code class=\"language-js\">let observer = new MutationObserver((mutationRecords, mutationObserver) => { console.log(mutationRecords, mutationObserver) })\nobserver.observe(document.body, { attributes:true })\ndocument.body.className = 'foo'\n//[MutationRecord] MutationObserver {}\n</code></pre>\n<ul>\n<li>disconnect()方法：默认情况下，只要被观察的元素不被垃圾回收，MutationObserver回调就会响应DOM变化，从而被执行。要提前终止执行回调，调用disconnect()方法。</li>\n</ul>\n<pre><code class=\"language-js\">let observer = new MutationObserver((mutationRecords, mutationObserver) => { console.log(mutationRecords, mutationObserver) })\nobserver.observe(document.body, { attributes:true })\ndocument.body.className = 'foo'\nobserver.disconnect()\ndocument.body.className = 'bar'\n// 没有输出日志\n</code></pre>\n<ul>\n<li>上面可以看出，当调用了disconnect之后，不仅之后变化事件的回调不会执行，已经加入到任务队列的事件也不会执行</li>\n<li>所以想要被加入的事件可以被执行，在调用disconnect方法的时候加一个setTimeout(() => {}, 0)</li>\n<li>多次调用observer()方法，可以复用一个MutationObserver对象观察多个不同的目标节点。</li>\n</ul>\n<pre><code class=\"language-js\">let observer = new MutationObserver((mutationRecords) => console.log(mutationRecords.map(x => x.target)))\n\nlet childA = document.createElement('div'), childB = document.createElement('span')\ndocument.body.appendChild(childA)\ndocument.body.appendChild(childB)\n\n// 观察两个元素\nobserver.observe(childA, { attributes: true })\nobserver.observe(childB, { attributes: true })\n\n// 修改子节点属性\nchildA.setAttribute('foo', 'bar')\nchildB.setAttribute('foo', 'bar')\n\n// [div, span]\n\nobserver.disconnect()\nchildA.setAttribute('a', 'b')\nchildB.setAttribute('a', 'b')\n// 没有日志\n</code></pre>\n<ul>\n<li>disconnect()方法是一刀切的方案，会停止观察所有目标</li>\n<li>调用disconnect只是断开连接，没有结束MutationObserver的声明，可以重新用这个观察者关联新的目标节点</li>\n</ul>\n<pre><code class=\"language-js\">let observer = new MutationObserver((mutationRecords) => console.log('&#x3C;body> attributes changed'))\nobserver.observe(document.body, { attributes: true })\ndocument.body.setAttribute('foo', 'bar')\nsetTimeout(() => {\n  observer.disconnect()\n  document.body.setAttribute('baz', 'baz')\n}, 0)\nsetTimeout(() => {\n  observer.observe(document.body, { attributes: true })\n  document.body.setAttribute('qux', 'qux')\n}, 0)\n// &#x3C;body> attributes changed\n// &#x3C;body> attributes changed\n</code></pre>\n<ul>\n<li>\n<p>MutationObserverInit用于控制目标节点的观察范围。可观察的值如下</p>\n<ul>\n<li>subtree: 布尔值，表示除了目标对象，是否观察目标节点的子节点，为true表示观察节点及子节点</li>\n<li>attributes: 布尔值，表示是否观察目标节点的属性变化</li>\n<li>attributeFilter: 字符串数组，表示要观察哪些属性的变化，这个值设为true会将attributes也转换为true，默认观察所有属性</li>\n<li>attributeOldValue: 布尔值，表示MutaionRecord是否记录变化之前的属性值，将这个值设为true也会导致attributes转换为true，默认为false</li>\n<li>characterData: 布尔值，表示修改字符数据是否触发变化事件，默认false</li>\n<li>characterDataOldValue: 布尔值，表示MutationRecord是否记录变化之前的字符数据，这个值设为true会将characterData值也转为true，默认false</li>\n<li>childList: 布尔值，表示修改目标节点的子节点是否触发变化事件，默认false</li>\n</ul>\n</li>\n<li>调用observe()时，MutationObserverInit对象中的attribute、characterData、childList必须至少有一项为true（直接设置或者通过设置attributeOldValue等设置）。否则会报错</li>\n<li>MutationObserver可以观察节点属性的添加、移除、修改。为属性注册回调，需要在MutationObserverInit对象中将attributes设为true</li>\n</ul>\n<pre><code class=\"language-js\">let observer = new MutationObserver((mutationRecords) => console.log(mutationRecords))\nobserver.observe(document.body, { attributeFilter: ['foo'] })\ndocument.body.setAttribute('foo', 'bar')\ndocument.body.setAttribute('bar', 'baz')\ndocument.body.setAttribute('baz', 'qux')\n\n// 只记录了foo的属性变化\n// [MutationRecord]\n</code></pre>\n<ul>\n<li>要想在记录中保存属性原来的值，将attributeOldValue属性设为true</li>\n</ul>\n<pre><code class=\"language-js\">let observer = new MutationObserver((mutationRecords) => console.log(mutationRecords.map(x => x.oldValue)))\nobserver.observe(document.body, { attributeOldValue: true })\ndocument.body.setAttribute('foo', 'bar')\ndocument.body.setAttribute('foo', 'baz')\ndocument.body.setAttribute('foo', 'qux')\n\n// [null, \"bar\", \"baz\"]\n</code></pre>\n<ul>\n<li>MutationObserver可以观察文本节点（Text、Comment、ProcessingInstruction）中字符串的添加、删除、修改。需要为字符数据注册回调，然后将MutatioObserverInit对象中的characterData属性设置为true</li>\n</ul>\n<pre><code class=\"language-js\">let observer = new MutationObserver((mutationRecord) => console.log(mutationRecord))\ndocument.body.innerText = 'foo'\nobserver.observe(document.body.firstChild, { characterData: true })\n\ndocument.body.innerText = 'foo'\ndocument.body.innerText = 'bar'\ndocument.body.innerText = 'baz'\n\n// [MutationRecord, MutationRecord, MutationRecord]\n</code></pre>\n<ul>\n<li>想要在MutationRecord中保村原始数据可以设置characterDataOldValue为true</li>\n<li>MutationObserver观察子节点</li>\n</ul>\n<pre><code class=\"language-js\">let observer = new MutationObserver((mutationRecord) => console.log(mutationRecord))\ndocument.body.innerText = ''\nobserver.observe(document.body, { childList: true })\ndocument.body.appendChild(document.createElement('div'))\n// [\n//   {\n//     addedNodes: NodeList [div]\n//     attributeName: null\n//     attributeNamespace: null\n//     nextSibling: null\n//     oldValue: null\n//     previousSibling: null\n//     removedNodes: NodeList []\n//     target: body.page-v3.eye-protector-processed\n//     type: \"childList\"\n//   }\n// ]\n\nlet observer = new MutationObserver((mutationRecord) => console.log(mutationRecord))\ndocument.body.innerText = ''\ndocument.body.appendChild(document.createElement('span'))\ndocument.body.appendChild(document.createElement('div'))\nobserver.observe(document.body, { childList: true })\ndocument.body.insertBefore(document.body.lastChild, document.body.firstChild)\n\n//[MutationRecord, MutationRecord]\n</code></pre>\n<ul>\n<li>上面进行子节点的交换会发生两次变化，一次是节点被删除，一次是节点被添加</li>\n<li>将MutationObserverInit对象中的subtree设置为true就能观察节点及其所有子节点</li>\n</ul>\n<pre><code class=\"language-js\">let observer = new MutationObserver((mutationRecord) => console.log(mutationRecord))\ndocument.body.innerText = ''\ndocument.body.appendChild(document.createElement('div'))\nobserver.observe(document.body, { attributes: true, subtree: true })\ndocument.body.firstChild.setAttribute('foo', 'bar')\n// [MutationRecord]\n</code></pre>\n<ul>\n<li>这里要注意，被观察子树中的节点在被移出子树后仍然能够触发变化事件。</li>\n<li>MutationObserver接口出于性能考虑，核心是异步回调与记录队列模型。为了在大量变化事件发生时不影响性能，每次变化的信息会保存在MutationRecord实例中，然后添加到记录队列，这个队列对每个MutationObserver实例都是唯一的，是所有DOM变化事件的有序列表</li>\n<li>每次MutationRecord被添加到MutationObserver记录队列时，只有之前没有已排期的微任务回调时，才会将观察者注册的回调作为作为微任务加到任务队列上，这样能保证记录队列的内容不会被回调处理两次</li>\n<li>在回调的微任务异步执行时，可能发生更多变化事件。因此被调用的回调会接收到一个MutationRecord实例的数组，顺序为它们进入记录队列的顺序。回调负责处理这个数组的没一个实例，函数退出之后这些实现就不存在了，回调执行后，这些MutationRecord就用不到了，记录队列会被清空，内容会被丢弃</li>\n<li>调用MutationObserver的takeRecords()方法可以清空记录队列，取出并返回所有的MutationRecord实例</li>\n</ul>\n<pre><code class=\"language-js\">let observer = new MutationObserver((mutationRecord) => console.log(mutationRecord))\nobserver.observe(document.body, { attributes: true })\ndocument.body.className = 'foo'\ndocument.body.className = 'bar'\ndocument.body.className = 'baz'\nconsole.log(observer.takeRecords()) // [MutationRecord, MutationRecord, MutationRecord]\nconsole.log(observer.takeRecords()) // []\n</code></pre>\n<ul>\n<li>在希望断开与观察目标的联系，但是希望处理由于disconnect而被抛弃的记录队列中的MutationRecord时比较有用</li>\n</ul>\n<h2>性能、垃圾回收</h2>\n<ul>\n<li>DOM Level 2中的MutationEvent定义了会在各种DOM变化时触发的事件。由于浏览器的实现机制，接口有严重的性能问题，因此DOM3废弃了这些事件</li>\n<li>使用MutationObserver将变化回调委托给微任务避免事件同步触发，记录队列可以保证变化事件爆发式的触发时，也不会显著拖慢浏览器，但无论如何，使用MutationObserver都是有代价的</li>\n<li>MutationObserver实例与目标节点是非对称引用，MutationObserver对目标节点是弱引用，所以不会妨碍垃圾回收程序回收节点</li>\n<li>目标节点对MutationObserver是强引用，如果目标节点从DOM被移除，随后垃圾回收，那关联的MutationObserver实例也被回收</li>\n<li>MutationRecord实例至少包含对已有DOM节点的一个引用。如果变化是childList类型，会包含多个节点的引用。记录队列和回调处理的默认行为是耗尽这个队列，处理每个MutationRecord，然后让它们超出作用域，之后被垃圾回收</li>\n<li>记录某个观察者的完整变化记录（MutationRecord）时就会保存它们引用的节点，从而妨碍这些节点的回收。如果需要尽快释放内存，建议从每个MutationRecord中抽取有用的信心保存到新对象，然后抛弃MutationRecord</li>\n</ul>","fields":{"slug":"/DOM_programming/"},"frontmatter":{"title":"DOM编程--高程4","tags":["JavaScript回顾"],"categories":"JavaScript"}}},{"node":{"html":"<h1>DOM拓展</h1>\n<h2>Selectors API</h2>\n<ul>\n<li>jQuery可以根据CSS选择符查询获取DOM元素，所以Selector API规定了浏览器原生支持的CSS查询API</li>\n<li>Selector API Level 1核心方法是 querySelector()跟querySelectorAll()，兼容浏览器中，Document类型跟Element类型的实例都会暴露这两个方法</li>\n<li>Selector API Level 2在Element类型上新增了matches()、find()、findAll()等方法，目前还没有浏览器实现find()跟findAll()</li>\n<li>querySelector()接收CSS选择符，返回匹配该模式的第一个后代元素，没有匹配项就返回null</li>\n</ul>\n<pre><code class=\"language-js\">let body = document.querySelector('body')\nlet div = document.querySelector('#div')\nlet img = document.querySelector('img.button')\n</code></pre>\n<ul>\n<li>在Document上使用querySelector会从文档元素开始搜索，在Element元素上使用会从当前元素的后代开始查询</li>\n<li>查询的CSS繁琐度由用户决定，如果选择符有错误或碰到不支持的选择符，querySelector会抛错</li>\n<li>querySelectorAll()跟querySelector接收参数一致，但是会返回所有的匹配项，返回的是NodeList的静态实例，也就是只是静态的快照，不是实时的查询，这么做是为了避免NodeList可能造成的性能问题</li>\n<li>用有效的CSS选择符调用该方法都会返回NodeList，无论匹配多少个，没有匹配项，返回空NodeList实例</li>\n</ul>\n<pre><code class=\"language-js\">let ems = document.getElementById('div').querySelectorAll('em')\nlet selecteds = document.querySelectorAll('.selected')\nlet strongs = document.querySelectorAll('p strong')\n</code></pre>\n<ul>\n<li>\n<p>返回的NodeList可以通过for-of循环，item()方法或中括号取得个别元素</p>\n<!--more-->\n<pre><code class=\"language-js\">let strongElement = document.querySelectorAll('strong')\n// 下面的三种循环效果一样\nfor(let strong of strongElement) {\nstrong.className = 'important'\n}\nfor(let i = 0; i &#x3C; strongElement.length; ++i) {\nstrongElement.item(i).className = 'important'\n}\nfor(let i = 0; i &#x3C; strongElement.length; ++i) {\nstrongElement[i].className = 'important'\n}\n</code></pre>\n</li>\n<li>跟querySelector方法一样，碰到不支持的或者错的选择符会报错</li>\n</ul>\n<h2>matches()</h2>\n<ul>\n<li>matches()方法（规范中叫matchesSelector()）接受一个CSS选择符，如果元素匹配该选择符，返回true，否则返回false</li>\n</ul>\n<pre><code class=\"language-js\">if(document.body.matches('body.page1')) {\n  // true\n}\n</code></pre>\n<ul>\n<li>这个方法可以方便的检测元素会不会被querySelector或querySelectorAll()返回</li>\n<li>所有主流浏览器都支持matches()。Egde、Chrome、Firefox、Safari和Opera完全支持，IE9-11及移动浏览器支持带前缀的方法</li>\n<li>IE9之前的版本不会把元素键的空格当成空白节点，其他浏览器会。导致了childNodes跟firstChild等属性的差异，为了弥补这个差异，W3C通过新的Element Traversal规范定义了一组新属性</li>\n<li>\n<p>Element TraversalAPI为DOM添加了5个属性</p>\n<ul>\n<li>childElementCount，返回子节点数量（不包含文本节点和注释）</li>\n<li>firstElementChild，指向第一个Element类型的子元素</li>\n<li>lastElementChild，指向最后一个Element类型的子元素</li>\n<li>previousElementSibling，指向前一个Element类型的同胞元素</li>\n<li>nextElementSibling，指向后一个Element类型的同胞元素</li>\n</ul>\n</li>\n<li>在支持的浏览器中，所有DOM都会有这些属性，这样就不会担心空白蚊子节点的问题</li>\n<li>比如以前跨浏览器遍历元素特定所有子元素，代码如下</li>\n</ul>\n<pre><code class=\"language-js\">let parentElement = document.getElementById('parent')\nlet currentChildNode = parentElement.firstChild\nwhile(currentChildNode) {\n  if(currentChildNode.nodeType === 1) {\n    processChild(currentChildNode)\n  }\n  if(currentChildeNode === parentElement.lastChild){\n    break\n  }\n  currentChildNode = currentChildNode.nextSibling\n}\n</code></pre>\n<ul>\n<li>使用Element Traversal后，代码如下</li>\n</ul>\n<pre><code class=\"language-js\">let parentElement = document.getElementById('parent')\nlet currentChildElement = parentElement.firstElementChild\nwhile(currentChildElement) {\n  process(currentChildElement)\n  if(currentChildElement == parentElement.lastElementChild) {\n    break\n  }\n  currentCHildElement = currentChildElement.nextElementSibling\n}\n</code></pre>\n<ul>\n<li>IE9及以上版本，以及所有现代浏览器都支持Element Traversal属性</li>\n</ul>\n<h2>HTML5</h2>\n<ul>\n<li>HTML5规范包括了与标记有关的JavaScript API定义，有的API与DOM重合，定义了浏览器应该提供的DOM扩展</li>\n<li>CSS类拓展，新增了下特性方便使用CSS类</li>\n<li>getElementsByClassName()，是HTML5新增的最受欢迎的方法，暴露在document对象及所有HTML元素上，提供了性能更好地原生实现</li>\n<li>该方法接受一个参数，既包含一个或多个类名的字符串，返回类名中包含对应类的元素的NodeList。提供了多个类名，顺序就无所谓了</li>\n</ul>\n<pre><code class=\"language-js\">let allCurrentUsernames = document.getElementsByClassName('username current')\nlet selected = docuement.getElementById('myDiv').getElementsByClassName('selected')\n</code></pre>\n<ul>\n<li>该方法返回以调用它的对象为根元素的子树中所有匹配的元素</li>\n<li>因为返回的是NodeList，所以会有跟getElementsByTagName还有其他返回的NodeList对象的DOM方法同样的问题 （DOM节点是实时查询的，可能出现死循环）</li>\n<li>IE9及以上浏览器及所有现代浏览器都支持getElementsByClassName方法</li>\n<li>操作类名可以使用className属性实现添加、删除和替换。由于它是一个字符串，所以操作完都要重新设置这个值，如下</li>\n</ul>\n<pre><code class=\"language-js\">&#x3C;div class=\"bd user disabled\">&#x3C;/div>\n// 删除user类\nlet targetClass = 'user'\nlet classNames = div.className.split(/\\s+/)\nlet idx = classNames.indexOf(targetClass)\nif(idx > -1) {\n  classNames.splice(i, 1)\n}\ndiv.className = classNames.join(' ')\n</code></pre>\n<ul>\n<li>这里就是对类名字符串做操作的步骤，替换跟检测类名也要有类似的操作</li>\n<li>\n<p>所以classList提供了更安全简单地实现方式，classList是一个新的集合类型DOMTokenList的实例。DOMTokenList也有length属性标识自己多少项，也能通过item()或中括号取得个别元素，DOMTokenList还增加了以下方法</p>\n<ul>\n<li>add(value)，向类名中添加指定的字符串值value，若已经存在就什么都不做</li>\n<li>contains(value)，返回布尔值，表示指定的value是否存在</li>\n<li>remove(value)，从类名列表中删除指定的字符串值</li>\n<li>toggle(value)，如果类名中存在就删除，不存在就添加</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"language-js\">// 上面的删除一行代码就可以\ndiv.classList.remove('user')\nif(div.classList.contains('bd') &#x26;&#x26; !div.classList.contains(disbaled)) {\n  // 操作\n}\nfor(let class of div.classList) {\n  doStuff(class)\n}\n</code></pre>\n<ul>\n<li>添加了classList属性后，除非完全删除或完全重写class属性，否则就不再使用className属性了。IE10及以上版本（部分）跟主流浏览器（全部）都实现了classList属性</li>\n<li>HTML5新增了辅助DOM焦点管理的功能，document.activeElement始终包含当前拥有焦点的元素</li>\n</ul>\n<pre><code class=\"language-js\">let button = document.getElementById('btn')\nbutton.focus()\nconsole.log(document.activeElement === button)\n</code></pre>\n<ul>\n<li>默认情况下，页面加载完成时document.activeElement设置为document.body。页面加载完成之前，document.activeElement是null</li>\n<li>document.hasFocus()方法，该方法返回布尔值，表示文档是否拥有焦点</li>\n</ul>\n<pre><code class=\"language-js\">let button = document.getElementById('btn')\nbutton.focus()\nconsole.log(document.hasFocus()) // true\n</code></pre>\n<ul>\n<li>确定文档是否获取焦点，就可以帮助确定用户是否在操作界面</li>\n<li>HTML5拓展了HTMLDocument类型，增加了以下功能</li>\n<li>\n<p>readyState是IE4早期添加到document对象上的属性，document.readyState属性有两个可能的值</p>\n<ul>\n<li>loading，文档正在加载</li>\n<li>complete，文档加载完成</li>\n</ul>\n</li>\n<li>开发中，最好将document.readyState当做指示器，判断文档是否加载完成，在这个属性得到支持之前，需要使用onLoad来添加标记，表示加载完成了</li>\n</ul>\n<pre><code class=\"language-js\">if(document.readyState === 'complete') {\n  // 操作\n}\n</code></pre>\n<ul>\n<li>IE6提供了以标准或混杂模式渲染页面的功能后，检测页面渲染模式就是一个必要的需求。IE为document添加了compatMode属性，该属性唯一的作用就是指示当前浏览器出于什么渲染模式下</li>\n<li>标准模式下，document.compatMode值时\"CSS1Compat\"，混杂模式下值为\"BackCompet\"</li>\n</ul>\n<pre><code class=\"language-js\">if(document.competMode === 'CSS1Compat') {\n  console.log('standard mode')\n} else {\n  console.log('quirk mode')\n}\n</code></pre>\n<ul>\n<li>新增了document.head属性指向文档的head元素</li>\n<li>HTML5新增了characterSet属性来表示文档实际使用的字符集，也可以用来指定新的字符集。默认值是\"UTF-16\"，可以通过<meta>元素或响应头，以及新增的characterSet属性来修改</li>\n</ul>\n<pre><code class=\"language-js\">let head = document.head\nconsole.log(document.characterSet) // 'UTF-16'\ndocument.characterSet = 'UTF-8'\n</code></pre>\n<ul>\n<li>HTML5允许给元素指定非标准的属性，但是要用data-前缀告诉浏览器，这些属性不包含预渲染有关的信息，也不包含元素的语义信息。除了前缀，没有限制</li>\n<li>定义了自定义数据后，可以通过元素的dataset属性来访问。dataset属性是一个DOMStringMap实例，包含键值对映射</li>\n<li>元素的每个data-name的属性在dataset中都可以通过data-后面的字符串作为键来访问（例如，属性data-myName、data-myname可以通过myname访问，注意：data-my-name、data-My-Name要通过myName来访问）</li>\n</ul>\n<pre><code class=\"language-js\">&#x3C;div id=\"myDiv\" data-appId=\"123\" data-myname=\"Nicholas\" data-my-data=\"23\">&#x3C;/div>\nlet div = document.getElementById('myDiv')\nconsole.log(div.dataset.appId) // undefined\nconsole.log(div.dataset.appid) // 123\nconsole.log(div.dataset.myname) // Nicholas\nconsole.log(div.dataset.myName) // undefined\nconsole.log(div.dataset.mydata) // undefined\nconsole.log(div.dataset.myDame) // 23\n</code></pre>\n<ul>\n<li>DOM提供了便利的操作节点的API，但是一次性插入大量节点还是很麻烦，所以HTML5实现了将一个HTML字符串插入的能力</li>\n<li>innerHTML，读取innerHTML时，会返回元素所有后代的HTML字符串，包括元素、注释和文本节点。写入时会根据提供的字符串值以新的DOM完全替代元素中的所有节点</li>\n<li>读取innerHTML时，返回的文本内容根据浏览器返回的值也不同，IE和Opera会把所有元素标签转为大写，而Safari、Chrome和Firefox则会按照源码返回，包含空格与锁紧。</li>\n<li>写入时，赋给innerHTML的值会被解析为DOM树，并替代之前的所有节点。因此所赋的值默认都是HTML，所有的标签都会以浏览器处理HTML的形式转为元素（转换结果也会因浏览器而不同）。赋值中没有HTML就直接生成文本节点</li>\n<li>因为浏览器会解析设置的值，所以innerHTML设置包含HTML的字符串时，结果会不一样</li>\n</ul>\n<pre><code class=\"language-js\">dib.innerHTML = 'Hello &#x26; welcome,&#x3C;b>\\\"reader\\\"!&#x3C;/b>'\n// 结果相当于\n\n&#x3C;div>Hello &#x26;amp; welcome, &#x3C;b>&#x26;quot;reader$quot;!&#x3C;/b>&#x3C;/div>\n</code></pre>\n<ul>\n<li>设置完innerHTML就可以访问对应的新节点了</li>\n<li>现代浏览器通过innerHTML插入script标签是不会执行的，在IE8之前，要是插入的script标签设置了defer属性，且script之前是“受控元素”，那就可以执行。script跟style或注释都是非受控元素，页面看不到它们。</li>\n<li>读取outerHTML属性会返回调用它的元素（及所有后代元素）的HTML字符串，写入outerHTML时，调用它的元素会被传入的HTML字符串经解释后生成的DOM子树替代</li>\n<li>\n<p>insertAdjacentHTML()与insertAdjacentText()都接受两个参数，要插入标记的位置和要插入的HTML或文本。第一个参数必须是下列值之一</p>\n<ul>\n<li>\"beforebegin\": 插入当前元素前面，作为前一个同胞节点</li>\n<li>\"afterbegin\":插入当前元素内部，作为新的子节点或放在第一个子节点之前</li>\n<li>\"beforeend\": 插入当前元素内部，作为新的子节点或放在最后一个子节点之后</li>\n<li>\"afterend\": 插入当前元素后面，作为下一个同胞节点</li>\n</ul>\n</li>\n<li>这几个值是不区分大小写的，第二个参数会作为HTML字符串解析或作为纯文本解析，如果是HTML，就会在解析出错时抛出错误</li>\n<li>HTML5标准化了控制页面滚动的方法：scrollIntoView()</li>\n<li>\n<p>scrollIntoView方法存在于所有HTML元素上，可以滚动浏览窗口或视图容器元素方便包含元素进入视口，参数如下</p>\n<ul>\n<li>alignToTop是一个布尔值</li>\n<li>true: 窗口滚动后元素的顶部与视口顶部对齐</li>\n<li>false: 窗口滚动后元素底部与视口底部对齐</li>\n<li>scrollIntoViewOptions是可选对象</li>\n<li>behavior: 定义过渡动画，可取值为\"smooth\"和\"auto\"，默认为\"auto\"</li>\n<li>block:定义垂直方向的对齐，可取值为\"start\"，\"center\",\"end\",\"nearest\"，默认为\"start\"</li>\n<li>inline: 定义水平方向的对齐，可取值为\"start\"，\"center\",\"end\",\"nearest\"，默认为\"start\"</li>\n<li>不传参数等价于alignToTop为true</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"language-js\">// 元素可见\ndocument.forms[0].scrollIntoView()\ndocument.forms[0].scrollIntoView(true)\ndocument.forms[0].scrollIntoView({ block: 'start', behavior: 'smooth' }) // 平滑滚动\n</code></pre>\n<h2>专有拓展</h2>\n<ul>\n<li>浏览器也实现了一些专有拓展，这些拓展有可能以后会被标准化，只是在这个阶段还是专有的</li>\n<li>IE9之前的版本与其他浏览器处理空白节点的不一致导致了children属性的出现，children是一个HTMLCollection，只包含元素的Element类型的自己诶单</li>\n<li>IE引入了contains()方法用于让开发者在不便利DOM的情况下知道一个元素是否是另一个元素的后代，在要被搜索的祖先元素上调用，如果目标节点是被搜索节点的后代，就返回true，否则返回false</li>\n</ul>\n<pre><code class=\"language-js\">console.log(document.documentElement.contains(document.body))\n</code></pre>\n<ul>\n<li>\n<p>DOM Level 3中的compareDocumentPosition()方法也可以确定节点间的关系，返回关系的位掩码</p>\n<ul>\n<li>0x1: 断开，传入接点不在文档中</li>\n<li>0x2: 领先（传入接点在DOM树中位于参考节点之前）</li>\n<li>0x4: 落后（传入接点在DOM树中位于参考节点之后）</li>\n<li>0x8: 包含（传入接点是参考节点的祖先）</li>\n<li>0x10: 被包含（传入接点是参考节点的后代）</li>\n</ul>\n</li>\n<li>可以使用compareDocumentPosition()来模仿contains</li>\n</ul>\n<pre><code class=\"language-js\">let result = document.documentElement.compareDocumentPosition(document.body)\nconsole.log(!!(result &#x26; 0x10))\n</code></pre>\n<ul>\n<li>上面代码执行后result值为20（或0x14，0x4表示随后，加上0x10“被包含”）。对result和0x10应用按位与会返回非零值，然后将其转为对应布尔值</li>\n<li>IE9及以后版本以及现代浏览器都支持contains跟compareDocumentPosition方法</li>\n<li>innerText与outerText未进入标准，innerText属性对应元素中包含的所有文本内容，无论文本在子树中哪个层级。在取值时都会按照深度优先的方式把子树中的所有文本节点的值拼起来</li>\n<li>写入时，会移除元素的所有后代并插入一个包含该值的文本节点</li>\n</ul>\n<pre><code class=\"language-js\">div.innerText = div.innerText // 可用于去除所有html标签\n</code></pre>\n<ul>\n<li>innerText获得所有浏览器的支持，取得或设置文本内容时应该作为首选采用</li>\n<li>outerText在取值时跟innerText返回值一样，但是在写入时，outerText不止移除所有后代，还会替换整个元素</li>\n<li>outerText是一个非标准化的属性，不推荐使用这个属性，除Firefox外所有主流浏览器都支持outerText</li>\n<li>HTML5实现了scrollIntoView()方法，但其他浏览器也有专有方法，比如scrollIntoViewIfNeeded()作为HTMLElement类型的拓展在所有元素上使用。</li>\n<li>scrollIntoViewIfNeeded(alingCenter)会在元素不可见得情况下将其滚动到窗口或者包含窗口中，使其可见，如果已经在可见窗口就什么都不会做。如果将可选的参数alingCenter设为true，浏览器会尝试将它放到视口中央，Safari、Chrome、Opera都实现了这个方法</li>\n</ul>\n<h2>内存与性能</h2>\n<ul>\n<li>本节介绍的方法替换子节点可能在浏览器（IE）中导致内存问题，比如被移除的字数元素中有关联的事件处理程序或其他JavaScript对象（作为元素的属性），那它们的存在关系就会留在内存中。这种操作频繁发生，页面的内存就会飙升，所以使用innerHTML、outerHTML、inertAdjacentHTML之前最好手动删除要替换的元素上关联的事件处理程序与JavaScript对象</li>\n<li>使用inerHTML比DOM操作更快是因为HTML解析器会解析设置给innerHTML的值，解析器一般在浏览器中是底层代码，比JavaScript要快很多</li>\n<li>但是使用innerHTML也是有代价的，所以最好限制使用innerHTML的次数，将批量的操作统一处理</li>\n<li>尽管innerHTML不会执行自己创建的script标签，但仍然向恶意用户暴露了很大的攻击面，通过它可以毫不费力的创建元素并执行click等属性，如果页面要使用用户提供的信息，建议不使用innerHTML。防止XSS攻击，所以需要隔离插入的数据，插入页面前使用相关库进行转义</li>\n</ul>","fields":{"slug":"/DOM_API/"},"frontmatter":{"title":"DOM拓展","tags":["JavaScript回顾"],"categories":"JavaScript"}}}]}},"pageContext":{"limit":10,"skip":60,"currentIndex":6}},"staticQueryHashes":["2566592090"]}