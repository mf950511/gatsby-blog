{"componentChunkName":"component---src-templates-index-jsx","path":"/blog/7","result":{"data":{"allMarkdownRemark":{"totalCount":68,"edges":[{"node":{"html":"<h1>DOM编程</h1>\n<ul>\n<li>下面是我们常见的DOM编程方法</li>\n<li>动态插入script标签</li>\n</ul>\n<pre><code class=\"language-js\">function loadScript(code){\n  var script = document.createElement('script')\n  try {\n    // 旧版本IE中有问题，IE对script做了特殊处理，不允许常规DOM访问子节点，所以可以在\n    script.appendChild(document.createTextNode(code))\n  } catch () {\n    script.text = code\n  }\n  document.body.appendChild(script)\n}\nloadScript('function sayHi(){alert(\"hi\")}')\n</code></pre>\n<ul>\n<li>这种方法会在返回后立即生效，通过innerHTML创建的 script 元素不会执行，会创建但不会执行</li>\n<li>\n<p>动态插入CSS样式</p>\n<!--more-->\n<pre><code class=\"language-js\">// 所有主流浏览器都支持\nfunction loadStyles(url) {\nlet link = document.createElement('link')\nlink.rel = 'stylesheet'\nlink.type = 'text/css'\nlink.href = url\nlet head = document.getElementsByTagName('head')[0]\nhead.appendChild(link)\n}\n</code></pre>\n</li>\n</ul>\n<p>// 插入动态语句\nfunction loadStyleString(css) {\nlet style = document.createElement('style')\nstyle.type = 'text/css'\ntry{\nstyle.appendChild(document.createTextNode(css))\n} catch() {\nstyle.styleSheet.cssText = css\n}\nlet head = document.getElementsByTagName('head')[0]\nhead.appendChild(style)\n}</p>\n<p>loadStyleString(\"body{background:#fff}\")</p>\n<pre><code>- 这样添加也会立即生效，在IE中要注意使用styleSheet.cssText，如果重用同一个 style 元素并设置该属性超一次，会导致浏览器奔溃，设置cssText为空也会导致奔溃\n\n## 操作表格\n\n- 下面是按常规DOM形式创建的表格\n\n```js\n// 创建表格\nlet table = document.createElement('table')\ntable.border = 1\ntable.width = '100%'\n// 创建表体\nlet tbody = document.createElement('tbody')\ntable.appendChild(tbody)\n\n// 创建行\nlet row1 = document.createElement('tr')\ntbody.appendChild(row1)\nlet cell_1 = document.createElement('td')\ncell_1.appendChild(document.createTextNode('Cell_1'))\nrow1.appendChild(cell_1)\n\nlet cell_2 = document.createElement('td')\ncell_2.appendChild(document.createTextNode('Cell_2'))\nrow1.appendChild(cell_2)\n\ndocument.body.appendChild(table)\n</code></pre>\n<ul>\n<li>上面创建的形式太过繁琐，所以新增了以下属性</li>\n<li>\n<p>table新增的属性</p>\n<ul>\n<li>caption，指向<caption>元素的指针</li>\n<li>tBodies，包含<tbody>的HTMLCollection</li>\n<li>tFoot，指向<tfoot>元素</li>\n<li>tHead，指向<thead>元素</li>\n<li>rows：包含所有行的HTMLCollection</li>\n<li>createTHead()：创建<thead>标签，插入表格，返回引用</li>\n<li>createTFoot()：创建<tfoot>元素，插入表格，返回引用</li>\n<li>createCaption()：创建<caption>元素，插入表格，返回引用</li>\n<li>deleteTHead()：删除<thead>元素</li>\n<li>deleteTFoot()：删除<tfoot>元素</li>\n<li>deleteCaption()：删除<caption>元素</li>\n<li>deleteRow(pos): 删除给定的行</li>\n<li>insertRow(pos)，在给定位置插入一行</li>\n</ul>\n</li>\n<li>\n<p>tbody元素添加以下方法</p>\n<ul>\n<li>rows，包含<tbody>中所有行的HTMLCollection</li>\n<li>deleteRow(pos)，删除指定位置行</li>\n<li>insertRow(pos)，指定位置插入一行，返回改行的引用</li>\n</ul>\n</li>\n<li>\n<p>tr元素新增以下属性和方法</p>\n<ul>\n<li>cells，包含<tr>元素所有表元的HTMLCollection</li>\n<li>deleteCell(pos)，删除指定位置表元</li>\n<li>insertCell(pos)，指定位置插入表元返回引用</li>\n</ul>\n</li>\n<li>重写上面代码</li>\n</ul>\n<pre><code class=\"language-js\">let table = document.createElement('table')\ntable.border = 1\ntable.width = '100%'\n// 创建表体\nlet tbody = document.createElement('tbody')\ntable.appendChild(tbody)\n\ntbody.insertRow(0)\ntbody.rows[0].insertCell(0)\ntbody.rows[0].cells[0].appendChild(document.createTextNode('Cell_1'))\ntbody.rows[0].insertCell(1)\ntbody.rows[0].cells[1].appendChild(document.createTextNode('Cell_2'))\n</code></pre>\n<ul>\n<li>NodeList、NamedNodeMap、HTMLCollection三个集合类型都是实时的，文档结构变化会实时反应，所以下面代码会死循环</li>\n</ul>\n<pre><code class=\"language-js\">let divs = document.getElementsByTagName('div')\nfor(let i = 0 ; i &#x3C; divs.length; i++) {\n  let div = document.createElement('div')\n  document.body.appendChild(div)\n}\n</code></pre>\n<h2>MutationObserver接口</h2>\n<ul>\n<li>DOM规范中的MutationObserver接口可以在DOM被修改时异步执行回调，使用它能够观察整个文档、DOM树的一部分，或某个元素。还能观察元素属性、子节点、文本或者它们的任意组合</li>\n<li>MutationObserver是为了替代废弃的MutationEvent</li>\n<li>基本用法如下</li>\n</ul>\n<pre><code class=\"language-js\">let observer = new MutationObserver(() => {\n  console.log('&#x3C;body> attributes changed')\n})\n\nobserver.observe(document.body, { attributes: true })\ndocument.body.className = 'foo'\nconsole.log('Changed body')\n\n// Changed body\n// &#x3C;body> attributes changed\n</code></pre>\n<ul>\n<li>创建后使用observer()方法关联DOM对象，接收两个参数为：要观察变化的DOM节点，以及一个MutationObserverInit对象</li>\n<li>MutationObserverInit对象用于控制观察哪些方面的变化，是一个键/值形式配置选项的字典。上述代码就是观察body上attributes的变化</li>\n<li>从上面能看出来，观察的回调执行在后面，所以是一个异步函数</li>\n<li>每个回调都会收到一个MutationRecord实例的数组，实例包含的信息包括发生了什么变化，以及DOM的哪一部分受影响了。回调执行之前可能同时发生多个满足条件的事件，所以每次执行回调都会传入一个包含按顺序入队的MutationRecord实例的数组</li>\n</ul>\n<pre><code class=\"language-js\">let observer = new MutationObserver((mutationRecord) => { console.log(mutationRecord) })\nobserver.observe(document.body, { attributes:true })\ndocument.body.setAttribute('foo', 'bar')\n// [\n//   {\n//     addedNodes: NodeList []\n//     attributeName: \"foo\"\n//     attributeNamespace: null\n//     nextSibling: null\n//     oldValue: null\n//     previousSibling: null\n//     removedNodes: NodeList []\n//     target: body.page-v3.eye-protector-processed\n//     type: \"attributes\"\n//   }\n// ]\ndocument.body.setAttributeNS('baz', 'foo', 'bar')\n// [\n//   {\n//     addedNodes: NodeList []\n//     attributeName: \"foo\"\n//     attributeNamespace: \"baz\"\n//     nextSibling: null\n//     oldValue: null\n//     previousSibling: null\n//     removedNodes: NodeList []\n//     target: body.page-v3.eye-protector-processed\n//     type: \"attributes\"\n//   }\n// ]\n</code></pre>\n<ul>\n<li>连续修改会生成多个MutationRecord实例，下次回调就会收到所有包含这些实例的数组，顺序为变化事件发生的顺序</li>\n</ul>\n<pre><code class=\"language-js\">let observer = new MutationObserver((mutationRecords) => { console.log(mutationRecords) })\nobserver.observe(document.body, { attributes:true })\ndocument.body.className = 'foo'\ndocument.body.className = 'bar'\ndocument.body.className = 'baz'\n// [MutationRecord, MutationRecord, MutationRecord]\n</code></pre>\n<ul>\n<li>\n<p>下面是MutationRecord实例的属性</p>\n<ul>\n<li>target: 被修改影响的目标节点</li>\n<li>type: 字符串，表示变化的类型：\"attributes\"、\"characterData\"、\"childList\"</li>\n<li>oldValue: 如果在MutationObserverInit中启用（attributeOldValue或characterData oldValue为true）\"attributes\"或\"characterData\"的事件变化会设置这个属性为被替代的值，\"childList\"类型的变化始终将这个属性设置为null</li>\n<li>attributeName: 对于\"attributes\"类型的变化，这里保存被修改属性的名字，其他变化事件为null</li>\n<li>attributeNameSpace: 对于使用命名空间的\"attributes\"类型变化，这里保存被修改属性的名字，其他事件为null</li>\n<li>addedNodes: 对于\"childList\"类型的变化，返回包含变化中添加节点的NodeList，默认为空NodeList</li>\n<li>removeNodes: 对于\"childList\"类型的变化，返回包含变化中删除节点的NodeList，默认为空NodeList</li>\n<li>previousSibling: 对于\"childList\"类型的变化，返回变化节点的前一个同胞Node，默认为null</li>\n<li>nextSibling: 对于\"childList\"类型的变化，返回变化后节点的后一个同胞Node，默认为null</li>\n</ul>\n</li>\n<li>传给回调的第二个参数是观察变化的MutationObserver的实例</li>\n</ul>\n<pre><code class=\"language-js\">let observer = new MutationObserver((mutationRecords, mutationObserver) => { console.log(mutationRecords, mutationObserver) })\nobserver.observe(document.body, { attributes:true })\ndocument.body.className = 'foo'\n//[MutationRecord] MutationObserver {}\n</code></pre>\n<ul>\n<li>disconnect()方法：默认情况下，只要被观察的元素不被垃圾回收，MutationObserver回调就会响应DOM变化，从而被执行。要提前终止执行回调，调用disconnect()方法。</li>\n</ul>\n<pre><code class=\"language-js\">let observer = new MutationObserver((mutationRecords, mutationObserver) => { console.log(mutationRecords, mutationObserver) })\nobserver.observe(document.body, { attributes:true })\ndocument.body.className = 'foo'\nobserver.disconnect()\ndocument.body.className = 'bar'\n// 没有输出日志\n</code></pre>\n<ul>\n<li>上面可以看出，当调用了disconnect之后，不仅之后变化事件的回调不会执行，已经加入到任务队列的事件也不会执行</li>\n<li>所以想要被加入的事件可以被执行，在调用disconnect方法的时候加一个setTimeout(() => {}, 0)</li>\n<li>多次调用observer()方法，可以复用一个MutationObserver对象观察多个不同的目标节点。</li>\n</ul>\n<pre><code class=\"language-js\">let observer = new MutationObserver((mutationRecords) => console.log(mutationRecords.map(x => x.target)))\n\nlet childA = document.createElement('div'), childB = document.createElement('span')\ndocument.body.appendChild(childA)\ndocument.body.appendChild(childB)\n\n// 观察两个元素\nobserver.observe(childA, { attributes: true })\nobserver.observe(childB, { attributes: true })\n\n// 修改子节点属性\nchildA.setAttribute('foo', 'bar')\nchildB.setAttribute('foo', 'bar')\n\n// [div, span]\n\nobserver.disconnect()\nchildA.setAttribute('a', 'b')\nchildB.setAttribute('a', 'b')\n// 没有日志\n</code></pre>\n<ul>\n<li>disconnect()方法是一刀切的方案，会停止观察所有目标</li>\n<li>调用disconnect只是断开连接，没有结束MutationObserver的声明，可以重新用这个观察者关联新的目标节点</li>\n</ul>\n<pre><code class=\"language-js\">let observer = new MutationObserver((mutationRecords) => console.log('&#x3C;body> attributes changed'))\nobserver.observe(document.body, { attributes: true })\ndocument.body.setAttribute('foo', 'bar')\nsetTimeout(() => {\n  observer.disconnect()\n  document.body.setAttribute('baz', 'baz')\n}, 0)\nsetTimeout(() => {\n  observer.observe(document.body, { attributes: true })\n  document.body.setAttribute('qux', 'qux')\n}, 0)\n// &#x3C;body> attributes changed\n// &#x3C;body> attributes changed\n</code></pre>\n<ul>\n<li>\n<p>MutationObserverInit用于控制目标节点的观察范围。可观察的值如下</p>\n<ul>\n<li>subtree: 布尔值，表示除了目标对象，是否观察目标节点的子节点，为true表示观察节点及子节点</li>\n<li>attributes: 布尔值，表示是否观察目标节点的属性变化</li>\n<li>attributeFilter: 字符串数组，表示要观察哪些属性的变化，这个值设为true会将attributes也转换为true，默认观察所有属性</li>\n<li>attributeOldValue: 布尔值，表示MutaionRecord是否记录变化之前的属性值，将这个值设为true也会导致attributes转换为true，默认为false</li>\n<li>characterData: 布尔值，表示修改字符数据是否触发变化事件，默认false</li>\n<li>characterDataOldValue: 布尔值，表示MutationRecord是否记录变化之前的字符数据，这个值设为true会将characterData值也转为true，默认false</li>\n<li>childList: 布尔值，表示修改目标节点的子节点是否触发变化事件，默认false</li>\n</ul>\n</li>\n<li>调用observe()时，MutationObserverInit对象中的attribute、characterData、childList必须至少有一项为true（直接设置或者通过设置attributeOldValue等设置）。否则会报错</li>\n<li>MutationObserver可以观察节点属性的添加、移除、修改。为属性注册回调，需要在MutationObserverInit对象中将attributes设为true</li>\n</ul>\n<pre><code class=\"language-js\">let observer = new MutationObserver((mutationRecords) => console.log(mutationRecords))\nobserver.observe(document.body, { attributeFilter: ['foo'] })\ndocument.body.setAttribute('foo', 'bar')\ndocument.body.setAttribute('bar', 'baz')\ndocument.body.setAttribute('baz', 'qux')\n\n// 只记录了foo的属性变化\n// [MutationRecord]\n</code></pre>\n<ul>\n<li>要想在记录中保存属性原来的值，将attributeOldValue属性设为true</li>\n</ul>\n<pre><code class=\"language-js\">let observer = new MutationObserver((mutationRecords) => console.log(mutationRecords.map(x => x.oldValue)))\nobserver.observe(document.body, { attributeOldValue: true })\ndocument.body.setAttribute('foo', 'bar')\ndocument.body.setAttribute('foo', 'baz')\ndocument.body.setAttribute('foo', 'qux')\n\n// [null, \"bar\", \"baz\"]\n</code></pre>\n<ul>\n<li>MutationObserver可以观察文本节点（Text、Comment、ProcessingInstruction）中字符串的添加、删除、修改。需要为字符数据注册回调，然后将MutatioObserverInit对象中的characterData属性设置为true</li>\n</ul>\n<pre><code class=\"language-js\">let observer = new MutationObserver((mutationRecord) => console.log(mutationRecord))\ndocument.body.innerText = 'foo'\nobserver.observe(document.body.firstChild, { characterData: true })\n\ndocument.body.innerText = 'foo'\ndocument.body.innerText = 'bar'\ndocument.body.innerText = 'baz'\n\n// [MutationRecord, MutationRecord, MutationRecord]\n</code></pre>\n<ul>\n<li>想要在MutationRecord中保村原始数据可以设置characterDataOldValue为true</li>\n<li>MutationObserver观察子节点</li>\n</ul>\n<pre><code class=\"language-js\">let observer = new MutationObserver((mutationRecord) => console.log(mutationRecord))\ndocument.body.innerText = ''\nobserver.observe(document.body, { childList: true })\ndocument.body.appendChild(document.createElement('div'))\n// [\n//   {\n//     addedNodes: NodeList [div]\n//     attributeName: null\n//     attributeNamespace: null\n//     nextSibling: null\n//     oldValue: null\n//     previousSibling: null\n//     removedNodes: NodeList []\n//     target: body.page-v3.eye-protector-processed\n//     type: \"childList\"\n//   }\n// ]\n\nlet observer = new MutationObserver((mutationRecord) => console.log(mutationRecord))\ndocument.body.innerText = ''\ndocument.body.appendChild(document.createElement('span'))\ndocument.body.appendChild(document.createElement('div'))\nobserver.observe(document.body, { childList: true })\ndocument.body.insertBefore(document.body.lastChild, document.body.firstChild)\n\n//[MutationRecord, MutationRecord]\n</code></pre>\n<ul>\n<li>上面进行子节点的交换会发生两次变化，一次是节点被删除，一次是节点被添加</li>\n<li>将MutationObserverInit对象中的subtree设置为true就能观察节点及其所有子节点</li>\n</ul>\n<pre><code class=\"language-js\">let observer = new MutationObserver((mutationRecord) => console.log(mutationRecord))\ndocument.body.innerText = ''\ndocument.body.appendChild(document.createElement('div'))\nobserver.observe(document.body, { attributes: true, subtree: true })\ndocument.body.firstChild.setAttribute('foo', 'bar')\n// [MutationRecord]\n</code></pre>\n<ul>\n<li>这里要注意，被观察子树中的节点在被移出子树后仍然能够触发变化事件。</li>\n<li>MutationObserver接口出于性能考虑，核心是异步回调与记录队列模型。为了在大量变化事件发生时不影响性能，每次变化的信息会保存在MutationRecord实例中，然后添加到记录队列，这个队列对每个MutationObserver实例都是唯一的，是所有DOM变化事件的有序列表</li>\n<li>每次MutationRecord被添加到MutationObserver记录队列时，只有之前没有已排期的微任务回调时，才会将观察者注册的回调作为作为微任务加到任务队列上，这样能保证记录队列的内容不会被回调处理两次</li>\n<li>在回调的微任务异步执行时，可能发生更多变化事件。因此被调用的回调会接收到一个MutationRecord实例的数组，顺序为它们进入记录队列的顺序。回调负责处理这个数组的没一个实例，函数退出之后这些实现就不存在了，回调执行后，这些MutationRecord就用不到了，记录队列会被清空，内容会被丢弃</li>\n<li>调用MutationObserver的takeRecords()方法可以清空记录队列，取出并返回所有的MutationRecord实例</li>\n</ul>\n<pre><code class=\"language-js\">let observer = new MutationObserver((mutationRecord) => console.log(mutationRecord))\nobserver.observe(document.body, { attributes: true })\ndocument.body.className = 'foo'\ndocument.body.className = 'bar'\ndocument.body.className = 'baz'\nconsole.log(observer.takeRecords()) // [MutationRecord, MutationRecord, MutationRecord]\nconsole.log(observer.takeRecords()) // []\n</code></pre>\n<ul>\n<li>在希望断开与观察目标的联系，但是希望处理由于disconnect而被抛弃的记录队列中的MutationRecord时比较有用</li>\n</ul>\n<h2>性能、垃圾回收</h2>\n<ul>\n<li>DOM Level 2中的MutationEvent定义了会在各种DOM变化时触发的事件。由于浏览器的实现机制，接口有严重的性能问题，因此DOM3废弃了这些事件</li>\n<li>使用MutationObserver将变化回调委托给微任务避免事件同步触发，记录队列可以保证变化事件爆发式的触发时，也不会显著拖慢浏览器，但无论如何，使用MutationObserver都是有代价的</li>\n<li>MutationObserver实例与目标节点是非对称引用，MutationObserver对目标节点是弱引用，所以不会妨碍垃圾回收程序回收节点</li>\n<li>目标节点对MutationObserver是强引用，如果目标节点从DOM被移除，随后垃圾回收，那关联的MutationObserver实例也被回收</li>\n<li>MutationRecord实例至少包含对已有DOM节点的一个引用。如果变化是childList类型，会包含多个节点的引用。记录队列和回调处理的默认行为是耗尽这个队列，处理每个MutationRecord，然后让它们超出作用域，之后被垃圾回收</li>\n<li>记录某个观察者的完整变化记录（MutationRecord）时就会保存它们引用的节点，从而妨碍这些节点的回收。如果需要尽快释放内存，建议从每个MutationRecord中抽取有用的信心保存到新对象，然后抛弃MutationRecord</li>\n</ul>","fields":{"slug":"/DOM_programming/"},"frontmatter":{"title":"DOM编程--高程4","tags":["JavaScript回顾"],"categories":"JavaScript"}}},{"node":{"html":"<h1>DOM拓展</h1>\n<h2>Selectors API</h2>\n<ul>\n<li>jQuery可以根据CSS选择符查询获取DOM元素，所以Selector API规定了浏览器原生支持的CSS查询API</li>\n<li>Selector API Level 1核心方法是 querySelector()跟querySelectorAll()，兼容浏览器中，Document类型跟Element类型的实例都会暴露这两个方法</li>\n<li>Selector API Level 2在Element类型上新增了matches()、find()、findAll()等方法，目前还没有浏览器实现find()跟findAll()</li>\n<li>querySelector()接收CSS选择符，返回匹配该模式的第一个后代元素，没有匹配项就返回null</li>\n</ul>\n<pre><code class=\"language-js\">let body = document.querySelector('body')\nlet div = document.querySelector('#div')\nlet img = document.querySelector('img.button')\n</code></pre>\n<ul>\n<li>在Document上使用querySelector会从文档元素开始搜索，在Element元素上使用会从当前元素的后代开始查询</li>\n<li>查询的CSS繁琐度由用户决定，如果选择符有错误或碰到不支持的选择符，querySelector会抛错</li>\n<li>querySelectorAll()跟querySelector接收参数一致，但是会返回所有的匹配项，返回的是NodeList的静态实例，也就是只是静态的快照，不是实时的查询，这么做是为了避免NodeList可能造成的性能问题</li>\n<li>用有效的CSS选择符调用该方法都会返回NodeList，无论匹配多少个，没有匹配项，返回空NodeList实例</li>\n</ul>\n<pre><code class=\"language-js\">let ems = document.getElementById('div').querySelectorAll('em')\nlet selecteds = document.querySelectorAll('.selected')\nlet strongs = document.querySelectorAll('p strong')\n</code></pre>\n<ul>\n<li>\n<p>返回的NodeList可以通过for-of循环，item()方法或中括号取得个别元素</p>\n<!--more-->\n<pre><code class=\"language-js\">let strongElement = document.querySelectorAll('strong')\n// 下面的三种循环效果一样\nfor(let strong of strongElement) {\nstrong.className = 'important'\n}\nfor(let i = 0; i &#x3C; strongElement.length; ++i) {\nstrongElement.item(i).className = 'important'\n}\nfor(let i = 0; i &#x3C; strongElement.length; ++i) {\nstrongElement[i].className = 'important'\n}\n</code></pre>\n</li>\n<li>跟querySelector方法一样，碰到不支持的或者错的选择符会报错</li>\n</ul>\n<h2>matches()</h2>\n<ul>\n<li>matches()方法（规范中叫matchesSelector()）接受一个CSS选择符，如果元素匹配该选择符，返回true，否则返回false</li>\n</ul>\n<pre><code class=\"language-js\">if(document.body.matches('body.page1')) {\n  // true\n}\n</code></pre>\n<ul>\n<li>这个方法可以方便的检测元素会不会被querySelector或querySelectorAll()返回</li>\n<li>所有主流浏览器都支持matches()。Egde、Chrome、Firefox、Safari和Opera完全支持，IE9-11及移动浏览器支持带前缀的方法</li>\n<li>IE9之前的版本不会把元素键的空格当成空白节点，其他浏览器会。导致了childNodes跟firstChild等属性的差异，为了弥补这个差异，W3C通过新的Element Traversal规范定义了一组新属性</li>\n<li>\n<p>Element TraversalAPI为DOM添加了5个属性</p>\n<ul>\n<li>childElementCount，返回子节点数量（不包含文本节点和注释）</li>\n<li>firstElementChild，指向第一个Element类型的子元素</li>\n<li>lastElementChild，指向最后一个Element类型的子元素</li>\n<li>previousElementSibling，指向前一个Element类型的同胞元素</li>\n<li>nextElementSibling，指向后一个Element类型的同胞元素</li>\n</ul>\n</li>\n<li>在支持的浏览器中，所有DOM都会有这些属性，这样就不会担心空白蚊子节点的问题</li>\n<li>比如以前跨浏览器遍历元素特定所有子元素，代码如下</li>\n</ul>\n<pre><code class=\"language-js\">let parentElement = document.getElementById('parent')\nlet currentChildNode = parentElement.firstChild\nwhile(currentChildNode) {\n  if(currentChildNode.nodeType === 1) {\n    processChild(currentChildNode)\n  }\n  if(currentChildeNode === parentElement.lastChild){\n    break\n  }\n  currentChildNode = currentChildNode.nextSibling\n}\n</code></pre>\n<ul>\n<li>使用Element Traversal后，代码如下</li>\n</ul>\n<pre><code class=\"language-js\">let parentElement = document.getElementById('parent')\nlet currentChildElement = parentElement.firstElementChild\nwhile(currentChildElement) {\n  process(currentChildElement)\n  if(currentChildElement == parentElement.lastElementChild) {\n    break\n  }\n  currentCHildElement = currentChildElement.nextElementSibling\n}\n</code></pre>\n<ul>\n<li>IE9及以上版本，以及所有现代浏览器都支持Element Traversal属性</li>\n</ul>\n<h2>HTML5</h2>\n<ul>\n<li>HTML5规范包括了与标记有关的JavaScript API定义，有的API与DOM重合，定义了浏览器应该提供的DOM扩展</li>\n<li>CSS类拓展，新增了下特性方便使用CSS类</li>\n<li>getElementsByClassName()，是HTML5新增的最受欢迎的方法，暴露在document对象及所有HTML元素上，提供了性能更好地原生实现</li>\n<li>该方法接受一个参数，既包含一个或多个类名的字符串，返回类名中包含对应类的元素的NodeList。提供了多个类名，顺序就无所谓了</li>\n</ul>\n<pre><code class=\"language-js\">let allCurrentUsernames = document.getElementsByClassName('username current')\nlet selected = docuement.getElementById('myDiv').getElementsByClassName('selected')\n</code></pre>\n<ul>\n<li>该方法返回以调用它的对象为根元素的子树中所有匹配的元素</li>\n<li>因为返回的是NodeList，所以会有跟getElementsByTagName还有其他返回的NodeList对象的DOM方法同样的问题 （DOM节点是实时查询的，可能出现死循环）</li>\n<li>IE9及以上浏览器及所有现代浏览器都支持getElementsByClassName方法</li>\n<li>操作类名可以使用className属性实现添加、删除和替换。由于它是一个字符串，所以操作完都要重新设置这个值，如下</li>\n</ul>\n<pre><code class=\"language-js\">&#x3C;div class=\"bd user disabled\">&#x3C;/div>\n// 删除user类\nlet targetClass = 'user'\nlet classNames = div.className.split(/\\s+/)\nlet idx = classNames.indexOf(targetClass)\nif(idx > -1) {\n  classNames.splice(i, 1)\n}\ndiv.className = classNames.join(' ')\n</code></pre>\n<ul>\n<li>这里就是对类名字符串做操作的步骤，替换跟检测类名也要有类似的操作</li>\n<li>\n<p>所以classList提供了更安全简单地实现方式，classList是一个新的集合类型DOMTokenList的实例。DOMTokenList也有length属性标识自己多少项，也能通过item()或中括号取得个别元素，DOMTokenList还增加了以下方法</p>\n<ul>\n<li>add(value)，向类名中添加指定的字符串值value，若已经存在就什么都不做</li>\n<li>contains(value)，返回布尔值，表示指定的value是否存在</li>\n<li>remove(value)，从类名列表中删除指定的字符串值</li>\n<li>toggle(value)，如果类名中存在就删除，不存在就添加</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"language-js\">// 上面的删除一行代码就可以\ndiv.classList.remove('user')\nif(div.classList.contains('bd') &#x26;&#x26; !div.classList.contains(disbaled)) {\n  // 操作\n}\nfor(let class of div.classList) {\n  doStuff(class)\n}\n</code></pre>\n<ul>\n<li>添加了classList属性后，除非完全删除或完全重写class属性，否则就不再使用className属性了。IE10及以上版本（部分）跟主流浏览器（全部）都实现了classList属性</li>\n<li>HTML5新增了辅助DOM焦点管理的功能，document.activeElement始终包含当前拥有焦点的元素</li>\n</ul>\n<pre><code class=\"language-js\">let button = document.getElementById('btn')\nbutton.focus()\nconsole.log(document.activeElement === button)\n</code></pre>\n<ul>\n<li>默认情况下，页面加载完成时document.activeElement设置为document.body。页面加载完成之前，document.activeElement是null</li>\n<li>document.hasFocus()方法，该方法返回布尔值，表示文档是否拥有焦点</li>\n</ul>\n<pre><code class=\"language-js\">let button = document.getElementById('btn')\nbutton.focus()\nconsole.log(document.hasFocus()) // true\n</code></pre>\n<ul>\n<li>确定文档是否获取焦点，就可以帮助确定用户是否在操作界面</li>\n<li>HTML5拓展了HTMLDocument类型，增加了以下功能</li>\n<li>\n<p>readyState是IE4早期添加到document对象上的属性，document.readyState属性有两个可能的值</p>\n<ul>\n<li>loading，文档正在加载</li>\n<li>complete，文档加载完成</li>\n</ul>\n</li>\n<li>开发中，最好将document.readyState当做指示器，判断文档是否加载完成，在这个属性得到支持之前，需要使用onLoad来添加标记，表示加载完成了</li>\n</ul>\n<pre><code class=\"language-js\">if(document.readyState === 'complete') {\n  // 操作\n}\n</code></pre>\n<ul>\n<li>IE6提供了以标准或混杂模式渲染页面的功能后，检测页面渲染模式就是一个必要的需求。IE为document添加了compatMode属性，该属性唯一的作用就是指示当前浏览器出于什么渲染模式下</li>\n<li>标准模式下，document.compatMode值时\"CSS1Compat\"，混杂模式下值为\"BackCompet\"</li>\n</ul>\n<pre><code class=\"language-js\">if(document.competMode === 'CSS1Compat') {\n  console.log('standard mode')\n} else {\n  console.log('quirk mode')\n}\n</code></pre>\n<ul>\n<li>新增了document.head属性指向文档的head元素</li>\n<li>HTML5新增了characterSet属性来表示文档实际使用的字符集，也可以用来指定新的字符集。默认值是\"UTF-16\"，可以通过<meta>元素或响应头，以及新增的characterSet属性来修改</li>\n</ul>\n<pre><code class=\"language-js\">let head = document.head\nconsole.log(document.characterSet) // 'UTF-16'\ndocument.characterSet = 'UTF-8'\n</code></pre>\n<ul>\n<li>HTML5允许给元素指定非标准的属性，但是要用data-前缀告诉浏览器，这些属性不包含预渲染有关的信息，也不包含元素的语义信息。除了前缀，没有限制</li>\n<li>定义了自定义数据后，可以通过元素的dataset属性来访问。dataset属性是一个DOMStringMap实例，包含键值对映射</li>\n<li>元素的每个data-name的属性在dataset中都可以通过data-后面的字符串作为键来访问（例如，属性data-myName、data-myname可以通过myname访问，注意：data-my-name、data-My-Name要通过myName来访问）</li>\n</ul>\n<pre><code class=\"language-js\">&#x3C;div id=\"myDiv\" data-appId=\"123\" data-myname=\"Nicholas\" data-my-data=\"23\">&#x3C;/div>\nlet div = document.getElementById('myDiv')\nconsole.log(div.dataset.appId) // undefined\nconsole.log(div.dataset.appid) // 123\nconsole.log(div.dataset.myname) // Nicholas\nconsole.log(div.dataset.myName) // undefined\nconsole.log(div.dataset.mydata) // undefined\nconsole.log(div.dataset.myDame) // 23\n</code></pre>\n<ul>\n<li>DOM提供了便利的操作节点的API，但是一次性插入大量节点还是很麻烦，所以HTML5实现了将一个HTML字符串插入的能力</li>\n<li>innerHTML，读取innerHTML时，会返回元素所有后代的HTML字符串，包括元素、注释和文本节点。写入时会根据提供的字符串值以新的DOM完全替代元素中的所有节点</li>\n<li>读取innerHTML时，返回的文本内容根据浏览器返回的值也不同，IE和Opera会把所有元素标签转为大写，而Safari、Chrome和Firefox则会按照源码返回，包含空格与锁紧。</li>\n<li>写入时，赋给innerHTML的值会被解析为DOM树，并替代之前的所有节点。因此所赋的值默认都是HTML，所有的标签都会以浏览器处理HTML的形式转为元素（转换结果也会因浏览器而不同）。赋值中没有HTML就直接生成文本节点</li>\n<li>因为浏览器会解析设置的值，所以innerHTML设置包含HTML的字符串时，结果会不一样</li>\n</ul>\n<pre><code class=\"language-js\">dib.innerHTML = 'Hello &#x26; welcome,&#x3C;b>\\\"reader\\\"!&#x3C;/b>'\n// 结果相当于\n\n&#x3C;div>Hello &#x26;amp; welcome, &#x3C;b>&#x26;quot;reader$quot;!&#x3C;/b>&#x3C;/div>\n</code></pre>\n<ul>\n<li>设置完innerHTML就可以访问对应的新节点了</li>\n<li>现代浏览器通过innerHTML插入script标签是不会执行的，在IE8之前，要是插入的script标签设置了defer属性，且script之前是“受控元素”，那就可以执行。script跟style或注释都是非受控元素，页面看不到它们。</li>\n<li>读取outerHTML属性会返回调用它的元素（及所有后代元素）的HTML字符串，写入outerHTML时，调用它的元素会被传入的HTML字符串经解释后生成的DOM子树替代</li>\n<li>\n<p>insertAdjacentHTML()与insertAdjacentText()都接受两个参数，要插入标记的位置和要插入的HTML或文本。第一个参数必须是下列值之一</p>\n<ul>\n<li>\"beforebegin\": 插入当前元素前面，作为前一个同胞节点</li>\n<li>\"afterbegin\":插入当前元素内部，作为新的子节点或放在第一个子节点之前</li>\n<li>\"beforeend\": 插入当前元素内部，作为新的子节点或放在最后一个子节点之后</li>\n<li>\"afterend\": 插入当前元素后面，作为下一个同胞节点</li>\n</ul>\n</li>\n<li>这几个值是不区分大小写的，第二个参数会作为HTML字符串解析或作为纯文本解析，如果是HTML，就会在解析出错时抛出错误</li>\n<li>HTML5标准化了控制页面滚动的方法：scrollIntoView()</li>\n<li>\n<p>scrollIntoView方法存在于所有HTML元素上，可以滚动浏览窗口或视图容器元素方便包含元素进入视口，参数如下</p>\n<ul>\n<li>alignToTop是一个布尔值</li>\n<li>true: 窗口滚动后元素的顶部与视口顶部对齐</li>\n<li>false: 窗口滚动后元素底部与视口底部对齐</li>\n<li>scrollIntoViewOptions是可选对象</li>\n<li>behavior: 定义过渡动画，可取值为\"smooth\"和\"auto\"，默认为\"auto\"</li>\n<li>block:定义垂直方向的对齐，可取值为\"start\"，\"center\",\"end\",\"nearest\"，默认为\"start\"</li>\n<li>inline: 定义水平方向的对齐，可取值为\"start\"，\"center\",\"end\",\"nearest\"，默认为\"start\"</li>\n<li>不传参数等价于alignToTop为true</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"language-js\">// 元素可见\ndocument.forms[0].scrollIntoView()\ndocument.forms[0].scrollIntoView(true)\ndocument.forms[0].scrollIntoView({ block: 'start', behavior: 'smooth' }) // 平滑滚动\n</code></pre>\n<h2>专有拓展</h2>\n<ul>\n<li>浏览器也实现了一些专有拓展，这些拓展有可能以后会被标准化，只是在这个阶段还是专有的</li>\n<li>IE9之前的版本与其他浏览器处理空白节点的不一致导致了children属性的出现，children是一个HTMLCollection，只包含元素的Element类型的自己诶单</li>\n<li>IE引入了contains()方法用于让开发者在不便利DOM的情况下知道一个元素是否是另一个元素的后代，在要被搜索的祖先元素上调用，如果目标节点是被搜索节点的后代，就返回true，否则返回false</li>\n</ul>\n<pre><code class=\"language-js\">console.log(document.documentElement.contains(document.body))\n</code></pre>\n<ul>\n<li>\n<p>DOM Level 3中的compareDocumentPosition()方法也可以确定节点间的关系，返回关系的位掩码</p>\n<ul>\n<li>0x1: 断开，传入接点不在文档中</li>\n<li>0x2: 领先（传入接点在DOM树中位于参考节点之前）</li>\n<li>0x4: 落后（传入接点在DOM树中位于参考节点之后）</li>\n<li>0x8: 包含（传入接点是参考节点的祖先）</li>\n<li>0x10: 被包含（传入接点是参考节点的后代）</li>\n</ul>\n</li>\n<li>可以使用compareDocumentPosition()来模仿contains</li>\n</ul>\n<pre><code class=\"language-js\">let result = document.documentElement.compareDocumentPosition(document.body)\nconsole.log(!!(result &#x26; 0x10))\n</code></pre>\n<ul>\n<li>上面代码执行后result值为20（或0x14，0x4表示随后，加上0x10“被包含”）。对result和0x10应用按位与会返回非零值，然后将其转为对应布尔值</li>\n<li>IE9及以后版本以及现代浏览器都支持contains跟compareDocumentPosition方法</li>\n<li>innerText与outerText未进入标准，innerText属性对应元素中包含的所有文本内容，无论文本在子树中哪个层级。在取值时都会按照深度优先的方式把子树中的所有文本节点的值拼起来</li>\n<li>写入时，会移除元素的所有后代并插入一个包含该值的文本节点</li>\n</ul>\n<pre><code class=\"language-js\">div.innerText = div.innerText // 可用于去除所有html标签\n</code></pre>\n<ul>\n<li>innerText获得所有浏览器的支持，取得或设置文本内容时应该作为首选采用</li>\n<li>outerText在取值时跟innerText返回值一样，但是在写入时，outerText不止移除所有后代，还会替换整个元素</li>\n<li>outerText是一个非标准化的属性，不推荐使用这个属性，除Firefox外所有主流浏览器都支持outerText</li>\n<li>HTML5实现了scrollIntoView()方法，但其他浏览器也有专有方法，比如scrollIntoViewIfNeeded()作为HTMLElement类型的拓展在所有元素上使用。</li>\n<li>scrollIntoViewIfNeeded(alingCenter)会在元素不可见得情况下将其滚动到窗口或者包含窗口中，使其可见，如果已经在可见窗口就什么都不会做。如果将可选的参数alingCenter设为true，浏览器会尝试将它放到视口中央，Safari、Chrome、Opera都实现了这个方法</li>\n</ul>\n<h2>内存与性能</h2>\n<ul>\n<li>本节介绍的方法替换子节点可能在浏览器（IE）中导致内存问题，比如被移除的字数元素中有关联的事件处理程序或其他JavaScript对象（作为元素的属性），那它们的存在关系就会留在内存中。这种操作频繁发生，页面的内存就会飙升，所以使用innerHTML、outerHTML、inertAdjacentHTML之前最好手动删除要替换的元素上关联的事件处理程序与JavaScript对象</li>\n<li>使用inerHTML比DOM操作更快是因为HTML解析器会解析设置给innerHTML的值，解析器一般在浏览器中是底层代码，比JavaScript要快很多</li>\n<li>但是使用innerHTML也是有代价的，所以最好限制使用innerHTML的次数，将批量的操作统一处理</li>\n<li>尽管innerHTML不会执行自己创建的script标签，但仍然向恶意用户暴露了很大的攻击面，通过它可以毫不费力的创建元素并执行click等属性，如果页面要使用用户提供的信息，建议不使用innerHTML。防止XSS攻击，所以需要隔离插入的数据，插入页面前使用相关库进行转义</li>\n</ul>","fields":{"slug":"/DOM_API/"},"frontmatter":{"title":"DOM拓展","tags":["JavaScript回顾"],"categories":"JavaScript"}}},{"node":{"html":"<h1>DOM2跟DOM3-命名空间及元素属性</h1>\n<ul>\n<li>\n<p>DOM1定义了HTML与XML文档的底层结构。DOM2跟DOM3在结构之上加了交互能力，提供了更高级的XML特性。DOM2跟DOM3按照模块化来制定标准，模块间有关联。模式如下</p>\n<ul>\n<li>DOM Core: 在DOM1核心基础上为节点增加属性和方法</li>\n<li>DOM Views: 定义基于样式的不同视图</li>\n<li>DOM EEvents: 定义通过事件实现DOM文档交互</li>\n<li>DOM Style: 定义以编程方式访问与修改CSS样式</li>\n<li>DOM Traversal And Range: 新增遍历DOM文档及选择文档内容的接口</li>\n<li>DOM HTML: 在DOM1HTML部分基础上，增加属性、方法和接口</li>\n<li>DOM Mutation Observers: 定义基于DOM变化触发回调的接口。这个模块是DOM4级模块，用于取代Mutation Events</li>\n</ul>\n</li>\n<li>DOM2跟DOM3 COre模块目的是拓展DOM API，满足XML的需求并提供更好的错误处理和特性检测。</li>\n</ul>\n<h2>XML命名空间</h2>\n<ul>\n<li>XML空间文档可以实现在一个格式规范的文档中混用不同的XML语言，而不必担心元素命名冲突。严格说XML命名空间在XHTML中才支持，HTML不支持，所以需要使用XHTML做势力</li>\n<li>\n<p>命名空间是使用xmlns指定的。XHTML的命名空间是\"<a href=\"http://www.w3.org/1999/xhtml%22%EF%BC%8C%E5%BA%94%E8%AF%A5%E5%8C%85%E5%90%AB%E5%9C%A8%E4%BB%BB%E4%BD%95%E6%A0%BC%E5%BC%8F%E8%A7%84%E8%8C%83%E7%9A%84XHTML%E9%A1%B5%E9%9D%A2%E7%9A%84\">http://www.w3.org/1999/xhtml\"，应该包含在任何格式规范的XHTML页面的</a><html>元素中</p>\n<!--more-->\n<pre><code class=\"language-js\">&#x3C;html xmlns=\"http://www.w3.org/1999/xhtml\">\n&#x3C;head>\n&#x3C;title>Example XHTML page&#x3C;/title>\n&#x3C;/head>\n&#x3C;body> Hello World!&#x3C;/body>\n&#x3C;/html>\n</code></pre>\n</li>\n<li>这里所有元素都默认属于XHTML命名空间，可以使用xmlns给命名空间加一个前缀，格式为\"xmlns:前缀\"</li>\n<li>这里为XHTML命名空间定义了一个前缀xhtml，同时所有XHTML元素都要加一个前缀。避免混淆，属性也可以加空间命名前缀</li>\n</ul>\n<pre><code class=\"language-js\">&#x3C;xhtml:html xmlns:xhtml=\"http://www.w3.org/1999/xhtml\">\n  &#x3C;xhtml:head>\n    &#x3C;xhtml:title>Example XHTML page&#x3C;/xhtml:title>\n  &#x3C;/xhtml:head>\n  &#x3C;xhtml:body xhtml:class=\"home\"> Hello World!&#x3C;/xhtml:body>\n&#x3C;/xhtml:html>\n</code></pre>\n<ul>\n<li>这里class属性被加上了xhtml前缀。文档中只有一种XML语言，那就没必要使用空间前缀，只有文档中使用多个XML语言时才有必要</li>\n</ul>\n<pre><code class=\"language-js\">&#x3C;html xmlns=\"http://www.w3.org/1999/xhtml\">\n  &#x3C;head>\n    &#x3C;title>Example XHTML page&#x3C;/title>\n  &#x3C;/head>\n  &#x3C;body>\n    &#x3C;svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" viewBox=\"0 0 100 100\" style=\"width:100%; height: 100%\">\n      &#x3C;rect x=\"0\" y=\"0\" width=\"100\" height=\"100\" style=\"fill:red\">&#x3C;/rect>\n    &#x3C;/svg>\n  &#x3C;/body>\n&#x3C;/html>\n</code></pre>\n<ul>\n<li>这里给svg加了命名空间将其标识为外来元素，这样svg元素及其属性以及它的后代都会认为属于\"<a href=\"https://www.w3.org/2000/svg%22%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E3%80%82%E8%99%BD%E7%84%B6%E8%BF%99%E4%B8%AA%E6%96%87%E6%A1%A3%E6%98%AFXHTML%E6%96%87%E6%A1%A3%EF%BC%8C%E4%BD%86%E6%98%AF%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E7%9A%84%E5%AD%98%E5%9C%A8%E4%BD%BF%E5%85%B6SVG%E4%BB%A3%E7%A0%81%E4%B9%9F%E6%9C%89%E6%95%88\">https://www.w3.org/2000/svg\"命名空间。虽然这个文档是XHTML文档，但是命名空间的存在使其SVG代码也有效</a></li>\n<li>这样的文档，调用方法与节点交互，就会出现一个问题：创建的元素属于哪个命名空间？查询特定标签名是，结果应包含那个命名空间下的元素？DOM2 Core为解决这个问题，给大部分的DOM1方法提供了特定命名空间的版本</li>\n<li>\n<p>DOM2中，Node类型包含以下命名空间的属性</p>\n<ul>\n<li>localName:不包含空间命名前缀的节点名</li>\n<li>namespaceURI:节点的空间命名URL，未指定就是null</li>\n<li>prefix:命名空间前缀，未指定就是null</li>\n</ul>\n</li>\n<li>使用空间命名前缀下，nodeName等于prefix + ':' + localName</li>\n</ul>\n<pre><code class=\"language-js\">&#x3C;html xmlns=\"http://www.w3.org/1999/xhtml\">\n  &#x3C;head>\n    &#x3C;title>Example XHTML page&#x3C;/title>\n  &#x3C;/head>\n  &#x3C;body>\n    &#x3C;s:svg xmlns:s=\"http://www.w3.org/2000/svg\" version=\"1.1\" viewBox=\"0 0 100 100\" style=\"width:100%; height: 100%\">\n      &#x3C;s:rect x=\"0\" y=\"0\" width=\"100\" height=\"100\" style=\"fill:red\">&#x3C;/s:rect>\n    &#x3C;/s:svg>\n  &#x3C;/body>\n&#x3C;/html>\n</code></pre>\n<ul>\n<li>上面<html>元素的localName跟tagName都是\"html\"，namespaceURI是\"<a href=\"http://www.w3.org/1999/xhtml%22%EF%BC%8Cprefix%E6%98%AFnull%E3%80%82%E5%AF%B9\">http://www.w3.org/1999/xhtml\"，prefix是null。对</a>&#x3C;s:svg>元素，localName是\"svg\"，tagName是\"s:svg\"，namespaceURI是\"<a href=\"https://www.w3.org/2000/svg%22%EF%BC%8Cprefix%E6%98%AF%22s\">https://www.w3.org/2000/svg\"，prefix是\"s</a>\"</li>\n<li>\n<p>DOM3进一步加强了与命名空间相关的方法</p>\n<ul>\n<li>isDefaultNamespace(namespaceURI)</li>\n<li>lookupNamespaceURI(prefix),返回给定prefix的命名空间URI</li>\n<li>lookupPrefix(namespaceURI)，返回给定namespaceURI的前缀</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"language-js\">console.log(document.body.isDefaultNamespace(\"http://www.w3.org/1999/xhtml\")) // true\nconsole.log(svg.lookupPrefix('http://www.w3.org/2000/svg')) // s\nconsole.log(svg.lookupNamespaceURI('s')) // http://www.w3.org/2000/svg\n</code></pre>\n<ul>\n<li>Document的变化</li>\n<li>\n<p>DOM2在Document类型上新增了下命名空间特定方法</p>\n<ul>\n<li>createElementNS(namespaceURI, tagName),以指定的tagName创建指定命名空间namespaceURI的元素</li>\n<li>createAttributeNS(namespaceURL, attributeName),以指定的属性名attributeName创建指定命名空间namespaceURI的一个新属性</li>\n<li>getElementsByTagNameNS(namespaceURI, tagName),返回指定命名空间namespaceURI中所有标签为tagName的元素的NodeList</li>\n</ul>\n</li>\n<li>使用这些方法都要传入相应的命名空间URI(不是命名空间前缀)</li>\n</ul>\n<pre><code class=\"language-js\">let svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg')\nlet att = document.createAttributeNS('http://www.somewhere.com', 'random')\nlet elems = document.getElementsByTagNameNS('http://www.w3.org/1999/xhtml', '*')\n</code></pre>\n<ul>\n<li>这些特性都只有在文档包含两个以上命名空间时才有用</li>\n<li>\n<p>DOM2 Core对Element类型的更新主要为属性操作，新增方法如下</p>\n<ul>\n<li>getAttributeNS(namespaceURI, localName),取得指定命名空间namespaceURI中名为localName的属性</li>\n<li>getAttributeNodeNS(namespaceURI, localName),取得指定命名空间中名为localName的属性节点</li>\n<li>getElementsByTagNameNS(namespaceURI,tagName)，取得指定命名空间中tagName为tagName的元素的NodeList</li>\n<li>hasAttributeNs(namespaceURI, localName),返回布尔值，表示元素中是否有命名空间namespaceURI下名为localName的属性（DOM2 Core也添加了不带命名空间的hasAttribute方法）</li>\n<li>removeAttributeNS(namespaceURI, localName)，删除指定命名空间namespaceURI中名为localName的属性</li>\n<li>setAttributeNS(namespaceURI, qualifiedName, value),设置指定命名空间namespaceURI中名为qualifiedName的属性为value</li>\n<li>setAttributeNodeNS(attNode),为元素设置包含命名空间信息的属性节点attNode</li>\n</ul>\n</li>\n<li>\n<p>NamedNodeMap也增加了一下处理命名空间的方法，因为NamedNodeMap主要表示属性，所以这些方法大都适用于属性</p>\n<ul>\n<li>getNamedItemNS(namespaceURI, localName),取得指定命名空间namespaceURI中名为localName的项</li>\n<li>removeNamedItemNS(namespaceURI, localName),删除指定命名空间namespaceURI中名为localName的项</li>\n<li>setNameItemNS(node),为元素添加包含命名空间信息的节点</li>\n</ul>\n</li>\n</ul>\n<h2>其他变化</h2>\n<ul>\n<li>除了命名空间，DOM2 Core还对DOM其他部分做了更新，这些更新与XML命名空间无关，主要关注DOM API的完整性与可靠性</li>\n<li>DocumentType的变化</li>\n<li>DocumentType新增了3个属性：publicId, systemId和internalSubset。publicId、systemId属性表示文档类型声明中有效但无法使用DOM1 API访问的数据，如下</li>\n</ul>\n<pre><code class=\"language-js\">&#x3C;!DOCTYPE HTML PUBLIC \"-//W3C// DTD HTML 4.01// EN\" \"http://www.w3.org/TR/html4/strict.dtd\" [&#x3C;!ELEMENT name (#PCDATA)>]>\n// 支持DOM2的浏览器可以运行下代码\nconsole.log(document.systemId) // http://www.w3.org/TR/html4/strict.dtd\nconsole.log(document.publicId) // -// W3C// DTD HTML 4.01// EN\nconsole.log(document.internalSubset) // [&#x3C;!ELEMENT name (#PCDATA)>]\n</code></pre>\n<ul>\n<li>publicId是\"-// W3C// DTD HTML 4.01// EN\"，而systemId是\"<a href=\"http://www.w3.org/TR/html4/strict.dtd\">http://www.w3.org/TR/html4/strict.dtd</a>\"</li>\n<li>internalSubset用于访问文档类型声明中可能包含的额外定义</li>\n<li>Document的变化中唯一跟命名空间无关的方法是importNode()，这个方法目的是从其他文档获取一个节点并导入到新文档，以便将其插入新文档。每个节点都有一个ownerDocument属性，表示所属的文档。如果调用appendChild方法时传入节点的ownerDocument不是指向当前文档，就会报错。调用importNode()导入其他文档的节点会返回一个新节点，这个节点的ownerDocument属性是正确的</li>\n<li>importNode方法跟cloneNode方法类似，也是接受两个参数：要复制的节点和表示是否同时复制子节点的布尔值，返回适合在当前文档中使用的节点</li>\n</ul>\n<pre><code class=\"language-js\">let newNode = document.importNode(oldNode, true)\ndocument.body.appendChild(newNode)\n</code></pre>\n<ul>\n<li>DOM2 View给Document类型增加了新属性defaultView，是一个指向拥有当前文档的窗口（或窗格<frame>）的指针。这个规范中没有明确视图何时可用，因此这是添加的唯一一个属性。defaultView属性得到了除IE8及更早之前版本所有浏览器的支持。IE8及更早版本支持等价的parentWindow属性，Opera也支持这个属性</li>\n<li>DOM2 Core还针对document.implementation对象新增了两个新方法：createDOcumentType()和createDocument()，前者用于创建DocumentType类型的新节点，接受3个参数：文档类型名称、publicId、systemId</li>\n</ul>\n<pre><code class=\"language-js\">let doctype = document.implementation.createDocumentType(\"html\", \"-// W3C// DTD HTML 4.01// EN\", \"http://www.w3.org/TR/html4/strict.dtd\")\n</code></pre>\n<ul>\n<li>已有的文档类型不可变，只有在创建新文档时才能用到，创建新文档要使用createDocument方法，createDocument接受3个参数：文档元素的namespaceURI、文档元素标签名、文档类型</li>\n</ul>\n<pre><code class=\"language-js\">let doctype = document.implementation.createDocumentType(\"html\", \"-// W3C// DTD HTML 4.01// EN\", \"http://www.w3.org/TR/html4/strict.dtd\")\nlet doc = document.implementation.createDocument(\"http://www.w3.org/1999/xhtml\", \"root\", doctype)\n</code></pre>\n<ul>\n<li>这里就创建了一个XHTML文档，文档只有html，其他都需要自己添加</li>\n<li>DOM2 HTML模块也为document.implementation对象新增了createHTMLDocument()方法，这个方法可以创建一个完整的HTML文档，包含html、head、title和body元素。只接受一个参数，创建的文档的标题，返回一个新的HTML文档</li>\n<li>DOM3新增了两个用于比较节点的方法：isSameNode()跟isEqualNode()。这两个方法都接收一个节点参数，节点与参考节点相同或相等，就返回true。节点相同，意味着引用同一个对象；节点相等，意味着类型相同，拥有相等的属性，并且attributes和childNodes也相等</li>\n<li>DOM3新增了给DOM节点添加额外数据的方法。setUserData()方法接受3个参数：键、值、处理函数，用于给节点添加数据。</li>\n</ul>\n<pre><code class=\"language-js\">document.body.setUserData('name', 'Nicholas', function(){})\ndocument.body.getUserData('name')\n</code></pre>\n<ul>\n<li>setUserData处理函数会在包含数据的节点被复制、删除、重命名或导入其他文档时执行，可以在这是决定如何处理用户数据。</li>\n<li>处理函数接收5个参数：表示操作类型的数值(1:复制,2:导入,3:删除,4:重命名)、数据的键、数据的值、源节点和目标节点。删除节点时，源节点时null，除复制外，目标节点都是null</li>\n</ul>\n<pre><code class=\"language-js\">let div = document.createElement('div')\ndiv.setUserData('name', 'Nicholas', function(operation, key, valuem src, dest){\n  if(operation === 1) {\n    dest.setUserData(key, value, function(){})\n  }\n})\nlet newDiv = div.cloneNode(true)\nconsole.log(newDiv.getUserData('name')) // Nicholas\n</code></pre>\n<ul>\n<li>这样，在第一个div被复制时，就会调用处理函数，然后把对应的数据附加到目标节点。</li>\n<li>DOM2 HTML给HTMLIFrameElement(即<iframe>，内嵌表格)类型新增了一个属性，叫contentDocument。这个属性包含代表子内嵌窗格中内容的document对象的指针</li>\n</ul>\n<pre><code class=\"language-js\">let iframe = document.getElementById('myIframe')\nlet iframeDoc = iframe.contentDocument\n</code></pre>\n<ul>\n<li>contentDocument属性是Document的事例，拥有所有文档属性和方法。还有一个属性contentWindow，返回相应窗格的window对象，这个对象上有一个document属性。所有现代浏览器都支持contentDocument和contentWindow属性</li>\n<li>跨源访问子内嵌窗格的document对象会收到安全限制。如果内嵌窗格加载了不同域名（或子域名）的页面，或者该页面使用不同协议，则访问其document对象会报错</li>\n</ul>","fields":{"slug":"/dom2-dom3/"},"frontmatter":{"title":"DOM2跟DOM3-命名空间及元素属性","tags":["JavaScript回顾"],"categories":"JavaScript"}}},{"node":{"html":"<h1>DOM2跟DOM3-CSS</h1>\n<ul>\n<li>支持style属性的HTML元素在JavaScript中都有一个style属性，该属性是CSSStyleDeclaration属性的实例，包含通过HTML style属性为元素设置的所有样式信息，不包含通过层叠样式机制从文档样式和外部样式中继承来的样式</li>\n<li>HTML style属性中的CSS属性在JavaScript style对象中都有对应的属性（JavaScript中会把连字符分割的单词转为驼峰）</li>\n<li>大多数属性都可以直接转换，但是float不可以，因为它在JavaScript中是保留字，所以不能用做属性名。DOM2 Style规定它为cssFloat</li>\n<li>\n<p>DOM2 Style规范在style对象上加了一些属性和方法</p>\n<ul>\n<li>cssText:包含style属性中的CSS代码</li>\n<li>length，应用给元素的css属性数量</li>\n<li>parentRule，表示CSS信息的CSSRule对象</li>\n<li>getPropertyCSSValue(propertyName)，返回包含CSS属性值propertyName值的CSSValue对象（已废弃）</li>\n<li>getPropertyPriority(propertyeName)，如果CSS属性PropertyName使用了!important则返回\"important\"，否则返回空字符串</li>\n<li>getPropertyValue(propertyName),返回属性propertyName的字符串值</li>\n<li>item(index)，返回索引index的CSS属性名</li>\n<li>removeProperty(propertyName)，从样式中删除CSS属性</li>\n<li>setProperty(propertyName, value, priority)，设置CSS属性propertyName值为value，priority是\"important\"或空字符串</li>\n</ul>\n</li>\n<li>cssText可以存取样式的CSS代码，读模式下，cssText返回style属性CSS代码在浏览器内部的表示。写模式下，给cssText赋值会重写整个style属性的值。</li>\n<li>length属性跟item()方法一起使用迭代CSS属性</li>\n</ul>\n<pre><code class=\"language-js\">for(let i = 0; i &#x3C; myDiv.style.length; ++i){\n  console.log(myDiv.style[i]) // 取得css属性名为\"background-color\"而不是backgroundColor\n}\n</code></pre>\n<!--more-->\n<ul>\n<li>getPropertyValue返回CSS属性值的字符串表示，getPropertyCSSValue返回一个CSSValue对象，包含两个值：cssText和cssValueType。前者跟getPropertyValue返回值一样，后者是一个数值常量，表示当前值类型（0代表继承值，1代表原始值，2代表列表，3代表自定义值）</li>\n<li>removeProperty用于从元素样式中删除指定CSS属性，删除后会使用该属性的默认（从其他样式表继承）样式，不确定默认值是什么的情况下，从style属性中删除就会用默认值</li>\n</ul>\n<h2>计算样式</h2>\n<ul>\n<li>style样式包含支持style属性的元素为这个属性设置的样式信息，但是不包含从其他样式层叠表继承的同样影响该元素的样式信息。</li>\n<li>DOM2 Style在document.defaultView上增加了getComputedStyle()方法。该方法接受两个参数：要取得计算样式的元素和伪元素字符串（如\":after\"）。不需要查询伪元素，第二个参数可以为null</li>\n<li>getComputedStyle返回一个CSSStyleDeclaration对象，包含元素的计算样式</li>\n</ul>\n<pre><code class=\"language-js\">&#x3C;!DOCTYPE html>\n&#x3C;html lang=\"en\">\n&#x3C;head>\n  &#x3C;meta charset=\"UTF-8\">\n  &#x3C;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  &#x3C;title>Document&#x3C;/title>\n  &#x3C;style>\n    #myDiv{\n      background-color: blue;\n      width:100px;\n      height: 200px;\n    }\n  &#x3C;/style>\n&#x3C;/head>\n&#x3C;body>\n  &#x3C;div id=\"myDiv\" style=\"background-color: red;border:1px solid black\">&#x3C;/div>\n  &#x3C;script>\n    let div = document.getElementById('myDiv')\n    let computedStyle = document.defaultView.getComputedStyle(div, null)\n    console.log(div.style.backgroundColor) // \n    console.log(computedStyle.backgroundColor)\n    console.log(div.style.width)\n    console.log(computedStyle.width)\n    console.log(div.style.height)\n    console.log(computedStyle.height)\n    console.log(div.style.border)\n    console.log(computedStyle.border)\n  &#x3C;/script>\n&#x3C;/body>\n&#x3C;/html>\n// red\n// rgb(255, 0, 0)\n// \n// 100px\n//\n// 200px\n// 1px solid black\n// 1px solid rgb(0, 0, 0)\n</code></pre>\n<ul>\n<li>所有浏览器中，计算样式都是只读的，不可修改，计算样式还会包含默认值</li>\n<li>CSSStyleSheet类型表示CSS样式表，包括使用<link>元素和通过<style>元素定义的样式。这两个元素本身是HTMLLinkElement和HTMLStyleElement。CSSStyleSheet类型是通用样式表类型。CSSStyleSheet类型的实例是一个只读对象</li>\n<li>\n<p>CSSStyle继承StyleSheet，以下为继承的属性</p>\n<ul>\n<li>disabled:布尔值，样式表是否被禁用，设置为true会禁用样式表</li>\n<li>href:如果是link包含的样式表，返回样式表的URL，否则返回null</li>\n<li>media:样式表支持的媒体类型集合，集合有一个length属性和item()方法，如果样式表可用于所有媒体，就返回空列表</li>\n<li>ownerNode,指向拥有当前样式表的节点，在HTML中要么是link元素要么是style元素。如果当前样式表是@import被包含在另一个样式表中，则这个值是null</li>\n<li>parentStyleSheet，如果当前样式是通过@import被包含在另一个样式表中，这个属性指向导入它的样式表</li>\n<li>title,ownerNode的title属性</li>\n<li>type,字符串，表示样式表的类型，CSS样式表就是\"text/css\"</li>\n</ul>\n</li>\n<li>\n<p>以上属性除了disabled，其他都是只读的，除了以上继承属性，还支持下属性和方法</p>\n<ul>\n<li>cssRules，当前样式表包含的样式规则的集合</li>\n<li>ownerRule:如果样式表是使用@import导入，指向导入规则，否则指向null</li>\n<li>deleteRule(index)，在指定位置删除cssRules中的规则</li>\n<li>insertRule(rule, index),在指定位置向cssRules中插入规则</li>\n</ul>\n</li>\n<li>document.styleSheets表示文档中可用的样式表的集合</li>\n<li>\n<p>CSSRule类型表示样式表中的一条规则，很多类型都继承它，最常用的是表示样式信息的CSSStyleRule，以下是CSSStyleRule对线上可用的属性</p>\n<ul>\n<li>cssText，返回整个规则的文本。返回的文本可能跟实际的不一样，Safari始终会把所有字母转为小写</li>\n<li>parentRule,如果这条规则被其他规则包含，就指向包含规则，否则指向null</li>\n<li>parentStyleSheet,包含当前规则的样式表</li>\n<li>selectText，返回规则的选择符文本，可能与样式表中的文本不一样。在Opera中是可修改的</li>\n<li>style，返回CSSStyleDecalaration对象，可以设置和获取当前规则中的样式</li>\n<li>type,数值常量，表示规则类型，样式规则，始终为1</li>\n</ul>\n</li>\n<li>cssText与style.cssText类似，前者包含选择符文本和环绕样式的大括号，后者只包含样式生命，cssText是只读的，style.cssText是可以被重写的</li>\n<li>DOM中，可以使用insertRule来向样式表插入新规则，接受两个参数：规则的文本和表示插入未知的索引值</li>\n</ul>\n<pre><code class=\"language-js\">let sheet = document.styleSheets[0]\nsheet.insertRule(\"body{ background-color: silver }\", 0)\n</code></pre>\n<ul>\n<li>上面例子中这条规则作为样式表的第一条规则插入</li>\n<li>支持从样式表中删除规则的DOM方法deleteRule()，接受一个参数，要删除的索引</li>\n</ul>\n<h2>元素尺寸</h2>\n<ul>\n<li>这咯的属性和方法并不是DOM2 Style中定义的，但是与HTML元素样式有关。IE率先增加了一些属性，这些属性已经得到所有主流浏览器支持</li>\n<li>\n<p>偏移尺寸：包含元素在屏幕上占用的所有视觉空间。元素在页面山的视觉空间由高度与宽度决定，包括所有内边距、滚动条和边框</p>\n<ul>\n<li>offsetHeight: 元素在垂直方向上占用的像素尺寸，包括它的高度、水品滚动条高度（如果可见）和上下边框的高度</li>\n<li>offsetLeft: 元素左边框外侧距离包含元素左边框内侧的像素数</li>\n<li>offsetTop:元素上边框外侧距离包含元素上边框内侧的像素数</li>\n<li>offsetWidth:元素在水平方向上占用的像素尺寸，包含它的宽度、垂直滚动条宽度和左右边框宽度</li>\n</ul>\n</li>\n<li>offsetLeft和offsetTop是相对于包含元素的，包含元素保存在offsetParent属性中。offsetParent不一定是parentNode。比如<td>元素的offsetParent是table元素，因为table是节点中第一个提供尺寸的元素</li>\n<li>要确定一个元素在页面中的偏移量，可以将它的offsetLeft和offsetTop分别于offsetParent的相同属性相加，一直到更元素</li>\n</ul>\n<pre><code class=\"language-js\">function getElementLeft(element){\n  let actualLeft = element.offsetLeft\n  let current = element.offsetParent\n  while(current !== null) {\n    actualLeft += current.offsetLeft\n    current = offsetParent\n  }\n  return actualLeft\n}\n</code></pre>\n<ul>\n<li>对于CSS布局的页面，这个函数很精确，对使用表格和内嵌窗格的页面，返回值会不相同</li>\n<li>所有偏移尺寸都是只读的，每次访问都会重新计算</li>\n<li>\n<p>元素的客户端尺寸：客户端尺寸只有clientWidth和clientHeight</p>\n<ul>\n<li>clientWidth是内容区宽度加左右内边距的宽度</li>\n<li>clientHeight是内容区高度加上下内边距的高度</li>\n</ul>\n</li>\n<li>客户端尺寸实际上就是元素内部的空间，不包含滚动条占用的空间，最常用的是确定浏览器视口尺寸，及document.documentElement的clientWidth和clientHeight</li>\n<li>\n<p>滚动尺寸：提供了元素滚动距离的信息</p>\n<ul>\n<li>scrollHeight:没有滚动条出现时，元素内容的总高度</li>\n<li>scrollLeft:内容区左侧隐藏的像素数，设置这个属性可以改变元素的滚动位置</li>\n<li>scrollTop:内容区顶部隐藏的像素数，设置这个属性可以改变元素的滚动位置</li>\n<li>scrollWidth:没有滚动条出现时，元素内容的总宽度</li>\n</ul>\n</li>\n<li>scrollWidth和scrollHeight可以确定元素的实际尺寸</li>\n<li>scrollWidth和scrollHeight等于文档内容的宽度，而clientWidth和clientHeight等于视口的大小</li>\n<li>scrollLeft个scrollTop用于确定当前元素的滚动位置或者设置滚动位置，这两个属性表示已经滚动不可见的元素的高度</li>\n<li>浏览器在每个元素上暴露了getBoundingClientRect()方法，返回一个DOMRect对象，包含六个属性：left、top、right、bottom、height、width</li>\n</ul>\n<h2>遍历</h2>\n<ul>\n<li>DOM2 Traversal and Range定义了两个类型用于辅助遍历：NodeIterator和TreeWalker对DOM结构的深度遍历优先</li>\n<li>\n<p>NodeIterator通过document.createNodeIterator()，接受以下4个参数</p>\n<ul>\n<li>root，作为遍历根节点的节点</li>\n<li>whatToShow,数值代码，表示应该访问哪些节点</li>\n<li>filter，NodeFilter对象或函数，表示是否接收或跳过特定节点</li>\n<li>entityReferenceExpansion，布尔值，表示是否拓展实体引用。这个参数在HTML文档中没有效果</li>\n</ul>\n</li>\n<li>\n<p>whatToShow参数是一个位掩码，通过应用一个或多个过滤器来指定访问哪些节点。常量是在NodeFilter中定义的</p>\n<ul>\n<li>NodeFilter.SHOW_ALL，所有节点</li>\n<li>NodeFilter.SHOW_ELEMENT，元素节点</li>\n<li>NodeFilter.SHOW_ATTRIBUTE，属性节点，DOM结构中用不到</li>\n<li>NodeFilter.SHOW_TEXT,文本节点</li>\n<li>NodeFilter.SHOW<em>CDATA</em>SECTION,CData区块节点，不在HTML页面使用</li>\n<li>NodeFilter.SHOW<em>ENTITY</em>REFERENCE,实体引用节点，不在HTML页面使用</li>\n<li>NodeFilter.SHOW<em>PROCESSING</em>INSTRUCTION，处理指令节点，不在HTML页面使用</li>\n<li>NodeFilter.SHOW_COMMENT，注释节点</li>\n<li>NodeFilter.SHOW_DOCUMENT，文档节点</li>\n<li>NodeFilter.SHOW<em>DOCUMENT</em>TYPE,文档类型节点</li>\n<li>NodeFilter.SHOW<em>DOCUMENT</em>FRAGMENT，文档片段节点，不在HTML页面使用</li>\n<li>NodeFilter.SHOW_NOTATION,记号节点，不在HTML页面使用</li>\n</ul>\n</li>\n<li>除了NodeFilter.SHOW_ALL之外，都可以组合使用</li>\n</ul>\n<pre><code class=\"language-js\">let whatToShow = NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_TEXT\n</code></pre>\n<ul>\n<li>createNodeIterator()方法的filter参数可以用来指定自定义NodeFilter对象，或者一个作为节点过滤器的函数。NodeFilter对象只有一个方法acceptNode()，如果给定节点应该访问就返回NodeFilter.FILTER<em>ACCEPT，否则返回NodeFilter.FILTER</em>SKIP。因为NodeFilter是抽象类，不可创建势力</li>\n</ul>\n<pre><code class=\"language-js\">let filter = {\n  acceptNode(node) {\n    return node.tagName.toLowerCase() === 'p' ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP\n  }\n}\n\n// 或者直接用函数\nfunction filter(node){\n  return node.tagName.toLowerCase() === 'p' ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP\n}\nlet iterator = document.createNodeIterator(root, NodeFilter.SHOW_ELEMENT, filter, false)\n</code></pre>\n<ul>\n<li>filter参数也可以是一个函数，与acceptNode形式一样，返回对应的属性值</li>\n<li>如果不需要指定过滤器，可以直接传入null</li>\n<li>NodeIterator有两个主要方法是nextNode()跟previouseNode()。</li>\n<li>nextNode在DOM子树中以深度优先方法前进一步，而previousNode则是后退一步。创建NodeIterator对象时会有一个内部指针指向根节点，因此第一次调用时nextNode()返回根节点。当遍历到最后一个节点时，nextNode返回null，previousNode当遍历到最后一个节点时，调用previousNode返回遍历的根节点时，再次调用返回null</li>\n<li>\n<p>TreeWalker是NodeIterator的高级版，除了同样的NextNode和previousNode外，新增了在DOM中向不同方向遍历的方法</p>\n<ul>\n<li>parentNode():遍历到当前节点的父节点</li>\n<li>firstChild():遍历到当前节点的第一个子节点</li>\n<li>lastChild():遍历到当前节点的最后一个子节点</li>\n<li>nextSibling():遍历到当前节点的下一个同胞节点</li>\n<li>previousSibling():遍历到当前节点的上一个同胞节点</li>\n</ul>\n</li>\n<li>document.createTreeWalker方法来创建TreeWalker实例，接受与document.createNodeIterator一样的参数，两者很相似，所以经常会使用TreeWalker替代NodeIterator</li>\n<li>不同的是，节点过滤器（filter）除了可以返回NodeFilter.FILTER<em>ACCEPT跟NodeFilter.FILTER</em>SKIP，还可以返回NodeFilter.FILTER_REJECT。</li>\n<li>在使用NodeItertor时，NodeFilter.FILTER<em>SKIP与NodeFilter.FILTER</em>REJECT是一样的。在使用TreeWalker时，NodeFilter.FILTER<em>SKIP表示跳过该节点，访问子树中的下一个节点，而NodeFilter.FILTER</em>REJECT表示跳过该节点及节点的整个子树</li>\n</ul>","fields":{"slug":"/dom2-dom3-css/"},"frontmatter":{"title":"DOM2跟DOM3-CSS","tags":["JavaScript回顾"],"categories":"JavaScript"}}},{"node":{"html":"<h1>DOM2跟DOM3-DOM范围</h1>\n<ul>\n<li>DOM2 Traversal and Range 模块定义了范围接口。范围可用于在文档中选择内容，而不用考虑节点之间的接线。</li>\n<li>DOM2 在Document类型上定义了createRange()方法，暴露在document对象上。可用此方法创建一个DOM范围对象</li>\n</ul>\n<pre><code class=\"language-js\">let range = document.createRange()\n</code></pre>\n<ul>\n<li>这个创建的范围对象关联到创建它的文档，不能在其他文档使用。</li>\n<li>\n<p>每个范围都是Range类型的实例，拥有相应的方法与属性。</p>\n<ul>\n<li>startContainer，范围起点躲在的节点（选区中第一个子节点的父节点）</li>\n<li>startOffset，范围起点在startContainer中的偏移量。如果startContainer是文本节点、注释节点或CData节点，则startOffset指范围起点之前跳过的字符数；否则表示范围中第一个节点的索引</li>\n<li>endContainer，范围终点所在的节点（选区中最后一个子节点的父节点）</li>\n<li>endOffset，范围终点在startContainer中的偏移量</li>\n<li>commonAncestorContainer，文档中以startContainer和endContainer为后代的最深的节点</li>\n</ul>\n</li>\n<li>这些属性在范围放到文档中特定位置时获得相应的值</li>\n<li>\n<p>selectNode()与selectNodeContents()方法可用于选中文档中的某个部分，接收一个节点为参数，并将该节点信息添加到调用它的范围。selectNode选择整个节点，包括后代节点，selectNodeContents只选择节点的后代</p>\n<!--more-->\n<pre><code class=\"language-js\">&#x3C;!DOCTYPE html>\n&#x3C;html lang=\"en\">\n&#x3C;body>\n&#x3C;p id=\"p1\">&#x3C;b>Hello&#x3C;/b> world&#x3C;/p>\n&#x3C;/body>\n&#x3C;/html>\n</code></pre>\n</li>\n</ul>\n<p>let range1 = document.createRange()\nlet range2 = document.createRange()\nlet p1 = document.getElementById('p1')\nrange1.selectNode(p1)\nrange2.selectNodeContonts(p1)</p>\n<pre><code>- selectNode时，startContainer、endContainer和commonAncestorContainer都等于传入节点的父节点，startOffset等于传入接点在父节点childNodes集合中的索引（这里startOffset等于1，DOM合规把空格当成文本节点），而endOffset等于startOffset + 1\n- selectNodeContents是，startContainer、endContainer、commonAncestorContainer是传入的节点。startOffset始终为0，因为范围从传入节点的第一个子节点开始，而endOffset等于传入节点的子节点数量（node.childNodes.length），这里等于2\n- 像上面一样选中节点后，可以使用下方法实现更准确地控制\n  - setStartBefore(refNode)，把范围的起点设置到refNode之前，让refNode称为选区的第一个子节点。startContainer属性设置为refNode.parentNode，而startOffset设置为refNode在父元素中的索引\n  - setStartAfter(refNode)，把范围起点设置到refNode之后，让refNode排除在选区之外，让它的下一个同胞节点成为选区的第一个子节点。startContainer设置为refNode.parentNode，startOffset设置为refNode在其父节点childNode中的索引加一\n  - setEndBefore(refNode)，将范围终点设置到refNode之前，让refNode排除在选区外，让它上一个同胞节点变成选区最后一个子节点。endContainer设置为refNode.parentNode，endOffset设置为refNode在其父元素childNodes中的索引\n  - setEndAfter(refNode)，把范围的终点设置到refNode之后，让refNode称为选区的最后一个子节点。endContainer属性设置为refNode.parentNode，而startOffset设置为refNode在父元素中的索引+1\n- 调用这些方法，所有的属性都会自动重新赋值。\n- setStart()与setEnd()方法都接受两个参数：参照节点与偏移量。setStart，参照节点会成为startContainer，偏移量成为startOffset。setEnd中，参照节点成为endContainer，偏移量赋值给endOffset。可以使用这两个方法模拟selectNode与selectNodeContents方法\n\n```js\nlet range1 = document.createRange()\nlet range2 = document.createRange()\nlet p1 = document.getElementById('p1')\nlet p1Index = -1\nlet i\nlet len\nfor(let i = 0, len = p1.parentNode.childNodes.length; i &#x3C; len; ++i) {\n  if(p1.parentNode.childNode[i] === p1){\n    p1Index = i\n    break\n  }\n}\nrange1.setStart(p1.parentNode, p1Index)\nrange1.setEnd(p1.parentNode, pIndex + 1)\nrange2.setStart(p1, 0)\nrange2.setEnd(p1, p1.childNodes.length)\n</code></pre>\n<ul>\n<li>选中节点必须先确定节点在父元素中的索引。选择节点的内容就不许要这样计算了</li>\n<li>setStart与setEnd真正的能力还是选取节点中的某个部分，假设我们想从前面案例中选中\"Hello\"中的\"llo\"到\" world\"中的\"o\"部分。如下</li>\n</ul>\n<pre><code class=\"language-js\">let p1 = document.getElementById('p1')\nlet helloNode = p1.firstChild.firstChild\nlet worldNode = p1.lastChild\nlet range = document.createRange()\nrange.setStart(helloNode, 2)\nrange.setEnd(worldNode, 3)\n</code></pre>\n<ul>\n<li>因为起点在\"Hello\"中的字母\"e\"之后，所以给setStart传入helloNode跟偏移量2。设置选区终点，给setEnd传入worldNode和偏移量3</li>\n<li>因为helloNode与worldNode都是文本节点，所以会成为范围的startContainer与endContainer，这样startOffset与endOffset实际上表示每个节点中文本字符的位置，而不是子节点的位置（传入元素节点时的情形）。而commonAncestorContainer是<p>元素，包含这两个节点的第一个祖先节点</li>\n<li>创建范围后，浏览器在内部会创建一个文档片段节点，用于包含选区中的节点。为操作的内容，选区中的内容必须格式完好，前面的例子中，并不是完好的DOM结构，所以无法在DOM中表示。范围能够确认缺失的开始与结束标签，从而重构出有效的DOM结构</li>\n<li>上面的例子中，范围发现缺少开始<b>与结束<b>，就会自动补齐，就成了</li>\n</ul>\n<pre><code class=\"language-js\">&#x3C;p>&#x3C;b>He&#x3C;/b>&#x3C;b>llo&#x3C;/b> world&#x3C;/p>\n</code></pre>\n<ul>\n<li>并且world也会被拆成两个文本节点</li>\n<li>创建完范围，可以使用方法来操作范围内容（范围对应文档片段中的所有节点，都是文档中响应节点的指针）</li>\n<li>第一个方法deleteContents()，会从文档中删除范围包含的节点</li>\n</ul>\n<pre><code class=\"language-js\">let p1 = document.getElementById('p1')\nlet helloNode = p1.firstChild.firstChild\nlet worldNode = p1.lastChild\nlet range = document.createRange()\nrange.setStart(helloNode, 2)\nrange.setEnd(worldNode, 3)\nrange.deleteContents()\n\n// 执行后，页面变成\n&#x3C;p>&#x3C;b>He&#x3C;/b>rld&#x3C;/p>\n</code></pre>\n<ul>\n<li>extractContents()与deleteContents类似，也会从文档中移除范围选区，不同点是，extractContents()返回范围对应的文档片段，这样就可以将范围中的内容插入其他地方</li>\n</ul>\n<pre><code class=\"language-js\">let p1 = document.getElementById('p1')\nlet helloNode = p1.firstChild.firstChild\nlet worldNode = p1.lastChild\nlet range = document.createRange()\nrange.setStart(helloNode, 2)\nrange.setEnd(worldNode, 3)\n\nlet fragment = range.extractContents()\np1.parentNode.appendChilld(fragment)\n// 执行后，页面变成，因为文档片段传给appendChild时只会添加子树，不包含片段本身\n&#x3C;p>&#x3C;b>He&#x3C;/b>rld&#x3C;/p>\n&#x3C;b>llo&#x3C;/b> wo\n</code></pre>\n<ul>\n<li>不想把范围从文档删除，可以使用cloneContents()创建一个副本，然后再把副本插入</li>\n</ul>\n<pre><code class=\"language-js\">let p1 = document.getElementById('p1')\nlet helloNode = p1.firstChild.firstChild\nlet worldNode = p1.lastChild\nlet range = document.createRange()\nrange.setStart(helloNode, 2)\nrange.setEnd(worldNode, 3)\n\nlet fragment = range.cloneContents()\np1.parentNode.appendChilld(fragment)\n// 执行后，页面变成，因为文档片段传给appendChild时只会添加子树，不包含片段本身\n&#x3C;p>&#x3C;b>Hello&#x3C;/b> world&#x3C;/p>\n&#x3C;b>llo&#x3C;/b> wo\n</code></pre>\n<ul>\n<li>insertNode方法可以向范围选区的开始位置插入一个节点</li>\n</ul>\n<pre><code class=\"language-js\">let p1 = document.getElementById('p1')\nlet helloNode = p1.firstChild.firstChild\nlet worldNode = p1.lastChild\nlet range = document.createRange()\nrange.setStart(helloNode, 2)\nrange.setEnd(worldNode, 3)\n\nlet span = document.createElement(\"span\")\nspan.style.color = 'red'\nspan.appendChild(document.createTextNode('Inserted text'))\nrange.insertNode(span)\n\n// 运行得到，span刚好插入到\"llo\"之前\n&#x3C;p>&#x3C;b>He&#x3C;span style=\"color: red\">Inserted text&#x3C;/span>llo&#x3C;/b> world&#x3C;/p>\n</code></pre>\n<ul>\n<li>原始的HTML并没有添加或删除<b>元素，并没有使用之前提到的管理方法。利用这个方法可以插入有用的信息，比如在外链插入一个小图标</li>\n<li>\n<p>surroundContents()插入包含范围的内容，接受一个参数，既包含范围的节点，调用方法后，后台执行操作</p>\n<ul>\n<li>提取范围内容</li>\n<li>在原始文档中范围之前所在位置插入给定的节点</li>\n<li>将范围对应文档片段的内容添加到给定节点</li>\n</ul>\n</li>\n<li>这个适合在网页中高亮显示某些关键字，比如</li>\n</ul>\n<pre><code class=\"language-js\">let p1 = document.getElementById('p1')\nlet helloNode = p1.firstChild.firstChild\nlet worldNode = p1.lastChild\nlet range = document.createRange()\nrange.selectNode(helloNode)\nlet span = document.createElement(\"span\")\nspan.style.backgroundColor = \"yellow\"\nrange.surroundContents(span)\n\n// 运行后\n&#x3C;p>&#x3C;b>&#x3C;span style=\"background-color: yellow\">Hello&#x3C;/span>&#x3C;/b> world&#x3C;/p>\n</code></pre>\n<ul>\n<li>为了插入<span>元素，范围中必须包含完整DOM结构。如果范围中包含部分选择的非文节点，操作会失败并报错。如果给定的节点是Document、DocumentType或DocumentFragment类型，也会报错</li>\n<li>如果范围并没有选择文档的任何部分，则称为折叠。折叠范围类似于文本框：如果文本框有文本，那可以用鼠标选中以亮度显示全部文本。这时候再点击鼠标，选区会移除，光标落在两个字符中间。折叠范围时，位置会设置为范围与文档交界的地方，可能是范围选区的开始，也可能是结尾</li>\n<li>折叠范围可以用collapse()方法，接受一个参数：布尔值，表示折叠到哪一端。true表示折叠到起点，false表示折叠到终点。要确定是否被折叠，检测collapsed属性</li>\n</ul>\n<pre><code class=\"language-js\">range.collapse(true)\nconsole.log(range.collapsed) // true\n</code></pre>\n<ul>\n<li>测试范围是否能折叠，可以确定范围中的两个节点是否相邻</li>\n</ul>\n<pre><code class=\"language-js\">&#x3C;p id=\"p1\">&#x3C;/p>&#x3C;p id=\"p2\">&#x3C;/p>\n\n// 这里假如我们不知道标记的结构\nlet p1 = document.getElementById('p1')\nlet p2 = document.getElementById('p2')\nlet range = document.createRange()\nrange.setStartAfter(p1)\nrange.setStartBefore(p2)\nconsole.log(range.collapsed) // true\n</code></pre>\n<ul>\n<li>\n<p>如果有多个范围，可以用compareBoundarPoints()确定范围是否有公共边界。接收两个参数：要比较的范围和一个常量值，表示要比较的方式，常量值如下</p>\n<ul>\n<li>Range.START<em>TO</em>START(0),比较两个范围的起点</li>\n<li>Range.START<em>TO</em>END(1)，比较第一个范围的起点和第二个范围的终点</li>\n<li>Range.END<em>TO</em>END(2)，比较两个范围的终点</li>\n<li>Range.END<em>TO</em>START(3)，比较第一个范围的终点和第二个范围的起点</li>\n</ul>\n</li>\n<li>此方法在第一个范围的边界点位于第二个范围的边界点之前返回-1，在两个范围的边界点相等返回0，在第一个范围的边界点位于第一个边界点之后返回1</li>\n</ul>\n<pre><code class=\"language-js\">let range1 = document.createRange()\nlet range2 = document.createRange()\nlet p1 = document.getElementById('p1')\nrange1.selectNodeContents(p1)\nrange2.selectNodeContents(p1)\nrange2.setEndBefore(p1.lastChild)\nconsole.log(range1.compareBoundaryPoints(Range.START_TO_START, range2)) // 0\nconsole.log(range1.compareBoundaryPoints(Range.END_TO_END, range2)) // 1\n</code></pre>\n<ul>\n<li>调用范围的cloneRange()可以复制范围。这个方法会创建调用它的范围的副本</li>\n</ul>\n<pre><code class=\"language-js\">let newRange = range.cloneRange()\n</code></pre>\n<ul>\n<li>新范围包含与原始范围相同的属性，修改边界值不会影响原始范围</li>\n<li>使用完范围后，最好调用detach()方法将范围从创建它的文档中剥离。调用detach()后，就可以放心解除对范围的引用，以便垃圾回收程序释放它所占用的内存</li>\n</ul>\n<pre><code class=\"language-js\">range.detach()\nrange = null\n</code></pre>\n<ul>\n<li>这样就合理的结束了范围的使用</li>\n</ul>","fields":{"slug":"/dom2-dom3-range/"},"frontmatter":{"title":"DOM2跟DOM3-DOM范围","tags":["JavaScript回顾"],"categories":"JavaScript"}}},{"node":{"html":"<h1>JavaScript中的事件</h1>\n<ul>\n<li>JavaScript与HTML的交互是通过事件实现，事件代表文档或浏览器中某个有意义的时刻。可以使用仅在事件发生时执行的监听器（也叫处理程序）订阅事件。传统软件领域叫做“观察者模式”，能做到页面行为（JavaScript中定义）与页面展示（在HTML与CSS定义）的分离</li>\n<li>DOM2开始以符合逻辑的方式来标准化DOM事件API，目前所有现代浏览器都支持了DOM2 Events的核心部分。IE8是最后一个使用专有事件系统的主流浏览器</li>\n<li>在定义事件时有一个有趣的问题，当你点击按钮的时候，不光点击了按钮，而且点击了它的容器跟整个页面，所以为解决这个问题就有了事件流</li>\n<li>事件流描述了页面接收事件的顺序。结果就是，IE和Netscape提出了相反的事件流方案，IE支持事件冒泡，Netscape支持事件捕获流</li>\n</ul>\n<h2>事件冒泡</h2>\n<ul>\n<li>IE事件称为事件冒泡，事件被定义为从最基本的元素开始触发，然后向上传播至没那么具体的元素（文档）比如页面点击div，click触发顺序为： div -> body -> html -> document</li>\n<li>所有现代浏览器都支持事件冒泡，只是实现有点变化。IE5.5及更早会跳过html，从body直接到document，现代浏览器会一直到window对象</li>\n</ul>\n<h2>事件捕获</h2>\n<ul>\n<li>事件捕获是从最不具体的节点最先收到事件，最具体的最后收到事件。实际上就是为了在事件到达目标前拦截事件，前面的例子在事件捕获中为： document -> html -> body -> div</li>\n<li>事件捕获也得到所有现代浏览器的支持，所有浏览器都是从window开始捕获事件，而DOM2 Evenets规定的是从document开始</li>\n<li>\n<p>旧版本不支持，所以实际几乎不会使用事件捕获，建议使用事件冒泡，特殊情况下可以使用</p>\n<!--more-->\n<h2>DOM事件流</h2>\n</li>\n<li>DOM2 Events规范规定事件流分为三个阶段：事件捕获、到达目标和事件冒泡。事件捕获最先发生，提供了提前拦截事件的可能。然后实际目标接收到事件。最后一个阶段是冒泡，最迟要在这个阶段响应事件</li>\n<li>DOM事件流中，实际目标在捕获阶段不会接受到事件。然后在下一阶段触发事件的“到达目标”阶段，通常认为是冒泡的一部分。然后就开始冒泡阶段</li>\n<li>大多数DOM都进行了一个小拓展，虽然DOM2 Events规范明确捕获阶段不命中事件目标，但现代浏览器都会在捕获阶段在事件目标上触发事件。最终在事件目标上有两个机会来处理事件</li>\n<li>可以直接在元素标签上指定事件，但是注意不能在未转义的情况下使用HTML标签，这样指定的事件可以访问全局作用域中的一切</li>\n<li>这样指定的事件处理程序有一些特殊的地方，会创建一个函数来封装属性的值。函数有一个特殊的局部变量event，保存的就是event对象</li>\n<li>在这个函数中，this值相当于事件的目标元素</li>\n<li>动态创建的包装函数作用域链被拓展了，document和元素自身成员都可以当局部变量来访问，也就是可以更方便的访问自己的属性</li>\n<li>如果元素是一个表单输入框，作用域中还会包含表单元素，这样事件处理程序就能不必引用表单元素直接访问同一表单的其他成员</li>\n</ul>\n<pre><code class=\"language-js\">// 获取event对象\n&#x3C;input type=\"button\" value=\"click me\" onclick=\"console.log(event.type)\"/>\n// this就是自己，所以可以获取value\n&#x3C;input type=\"button\" value=\"click me\" onclick=\"console.log(this.value)\"/>\n// 这个与上面的功能一样，采用with实现的\n&#x3C;input type=\"button\" value=\"click me\" onclick=\"console.log(value)\"/>\n// 可以直接获取同意表单的其他成员\n&#x3C;form method=\"post\">\n  &#x3C;input type=\"text\" name=\"username\" value=\"\"/>\n  &#x3C;input type=\"button\" value=\"Echo Username\" onclick=\"console.log(username.value)\"/>\n&#x3C;/form>\n// 静默错误\n&#x3C;input type=\"button\" value=\"click me\" onclick=\"try{showMessage()}catch(ex){}\"/>\n</code></pre>\n<ul>\n<li>HTML直接处理事件会有一些时机问题，有可能元素展示了，但是事件处理程序的事件还没加载完成，所以需要加一个try/catch来进行静默错误</li>\n</ul>\n<h2>DOM0 事件处理程序</h2>\n<ul>\n<li>JavaScript中传统的事件处理程序就是讲一个函数赋值给DOM元素的事件处理程序，直到现在所有现代浏览器都支持此方法。</li>\n<li>每个元素（包括window与document）都有通常小写的事件处理程序属性</li>\n</ul>\n<pre><code class=\"language-js\">let btn = document.getElementById('myBtn')\nbtn.onclick = function(){\n  console.log('Clicked')\n}\n</code></pre>\n<ul>\n<li>这样实现如果代码出现在按钮之后，可能用户点击按钮无反应</li>\n<li>这样实现函数中的this等于元素本身</li>\n<li>这样注册的事件注册在事件流的冒泡阶段</li>\n<li>将事件处理程序属性的值设为null可以移除通过DOM0方式添加的事件处理程序</li>\n</ul>\n<h2>DOM2事件处理程序</h2>\n<ul>\n<li>DOM2 Events定义了两个方法来为事件处理程序赋值跟移除：addEventListener()和removeEventListener()。这两个方法暴露在所有DOM节点上。接收三个参数：事件名、事件处理函数和一个布尔值，true表示在捕获阶段调用事件处理程序，false（默认）表示在冒泡阶段调用</li>\n</ul>\n<pre><code class=\"language-js\">let btn = document.getElementById('myBtn')\nbtn.addEventListener('click', () => {\n  console.log(this.id)\n}, false)\n</code></pre>\n<ul>\n<li>上述代码添加了会在事件冒泡阶段触发的onclick事件处理程序。与DOM0方式，这个处理程序同样被附加到元素的作用域中运行</li>\n<li>DOM2 Events优势就是可以添加多个事件处理程序</li>\n</ul>\n<pre><code class=\"language-js\">let btn = document.getElementById('myBtn')\nbtn.addEvenetListener('click', () => {\n  console.log(this.id)\n})\nbtn.addEvenetListener('click', () => {\n  console.log('Hello world')\n})\n</code></pre>\n<ul>\n<li>多个事件处理程序以添加顺序来触发</li>\n<li>通过addEventListener添加的事件只能用removeEventListener()并传入与添加同样的参数来移除，所以添加匿名函数无法移除</li>\n</ul>\n<pre><code class=\"language-js\">let btn = document.getElementById('myBtn')\nbtn.addEvenetListener('click', () => {\n  console.log(this.id)\n}, false)\nbtn.removeEventListener('click', () => {\n  console.log(this.id)\n}, false)\n</code></pre>\n<ul>\n<li>大多数情况下，事件处理程序会添加到事件流的冒泡阶段，主要是跨浏览器兼容性好。捕获阶段通常用于拦截事件</li>\n<li>IE实现了与DOM类似的方法，attachEvent和detachEvent，两个方法接收两个同样的参数：事件处理程序的名称和事件处理函数</li>\n</ul>\n<pre><code class=\"language-js\">var btn = document.getElementById('myBtn')\nbtn.attachEvent('onclick', function(){\n  console.log('clicked')\n})\n</code></pre>\n<ul>\n<li>attachEvent第一个参数是\"onclick\"，而不是addEventListener中的click</li>\n<li>使用DOM0方式时，事件处理程序中的this为目标元素，使用attachEvent时，this等于window</li>\n<li>attachEvent也可以给元素添加多个事件处理程序</li>\n</ul>\n<pre><code class=\"language-js\">var btn = document.getElementById('myBtn')\nbtn.attachEvent('onclick', function(){\n  console.log('clicked')\n})\n\nbtn.attachEvent('onclick', function(){\n  console.log('Hello world')\n})\n</code></pre>\n<ul>\n<li>不过与DOM方法不同，这里的触发顺序会以它们添加的顺序反向触发</li>\n<li>可以使用detachEvent移除添加的处理程序</li>\n<li>结合上面的两种方法，我们编写一个兼容浏览器的方式处理，保证最大的兼容性，让代码在冒泡阶段运行即可</li>\n</ul>\n<pre><code class=\"language-js\">var EventUtil = {\n  addHandler: function(element, type, handler){\n    if(element.addEventListener){\n      element.addEventListener(type, handler, false)\n    } else if(element.attachEvent) {\n      element.attachEvent('on' + type, handler)\n    } else {\n      element['on' + type] = handler\n    }\n  },\n  removeHandler: function(element, type, handler){\n    if(element.removeEventListener){\n      element.removeEventListener(type, element, false)\n    } else if(element.detachEvent) {\n      element.detach('on' + type, handler)\n    } else {\n      element['on' + type] = null\n    }\n  }\n}\n</code></pre>\n<ul>\n<li>DOM事件发生时，所有先关信息都会收集并存储到event对象中，比如导致事件的元素、发生的事件类型等</li>\n<li>DOM合规的浏览器中，event对象是传给事件处理程序的唯一参数。DOM0跟DOM2形式添加的事件处理程序都一样</li>\n<li>\n<p>所有事件对象都包含下列公共属性与方法</p>\n<ul>\n<li>bubbles: 布尔值，事件是否冒泡</li>\n<li>canclable: 布尔值，表示是否可以取消事件的默认行为</li>\n<li>currentTarget: 元素，当前事件处理程序所在的元素</li>\n<li>defaultPrevented: 布尔值，true表示已经调用preventDefault方法（DOM3 Events新增）</li>\n<li>detail: 整数，事件相关的其他信息</li>\n<li>eventPhase: 整数，表示调用事件处理程序阶段，1代表捕获阶段，2代表到达阶段，3代表冒泡阶段</li>\n<li>preventDefault(): 函数，用于取消事件的默认行为。只有canclable为true才能调用</li>\n<li>stopImmediatePropagation(): 函数，用于取消后续事件捕获或事件冒泡，并阻止调用任何后续事件处理程序（DOM3 Events新增）</li>\n<li>stopPropagation(): 函数，用于取消后续事件冒泡或事件捕获，只有bubbles为true才能调用</li>\n<li>target: 元素，事件目标</li>\n<li>trusted: 布尔值，true表示由浏览器生成，false表示由开发者通过JavaScript创建（DOM3 Events新增）</li>\n<li>type: 字符串，触发的事件类型</li>\n<li>View: AbstractView.与事件相关的抽象视图，等于事件所发生的window对象</li>\n</ul>\n</li>\n<li>事件处理程序内部，this对象始终等于currentTarget的值，target只包含事件的实际目标。如果事件处理程序直接添加到了意图的目标，那this、currentTarget、target值一样</li>\n</ul>\n<pre><code class=\"language-js\">let btn = document.getElementById('myBtn')\nbtn.onclick = function(event) {\n  console.log(event.currentTarget === this) // true\n  console.log(event.target === this) // true\n}\n\n// 添加到父元素\ndocument.body.onclick = function(event){\n  console.log(event.currentTarget === document.body) // true\n  console.log(this === document.body) // true\n  console.log(event.target === document.getElementById('myBtn')) // true\n}\n</code></pre>\n<ul>\n<li>preventDefault用于阻止跳转链接等默认行为</li>\n<li>stopPropagation()用于阻止事件流在DOM结构中传播，取消后续的事件捕获或冒泡</li>\n</ul>\n<h2>IE事件对象</h2>\n<ul>\n<li>与DOM事件对象不同，IE事件对象可以基于事件处理程序被指定的方式以不同方式访问。如果以DOM0方式制定，event就是window的一个属性</li>\n</ul>\n<pre><code class=\"language-js\">let btn = document.getElementById('myBtn')\nbtn.onclick = function() {\n  const event = window.event\n  console.log(event.type)\n}\n</code></pre>\n<ul>\n<li>如果是以attachEvent()方式指定的，event对象会作为唯一参数传递给处理函数，但是event对象也仍然是window对象的属性</li>\n<li>\n<p>所有IE事件对象都会包含下列属性和方法</p>\n<ul>\n<li>cancelBubble: 布尔值，默认为false，设置为true可以取消冒泡（等同于DOM的stopPropagation）</li>\n<li>returnValue: 布尔值，默认为true，设置为false可以取消事件的默认行为（与DOM的preventDefault相同）</li>\n<li>srcElement: 元素，事件目标（与DOM的target属性相同）</li>\n<li>type: 字符串，触发的事件类型</li>\n</ul>\n</li>\n<li>由于事件处理程序的作用域取决于指定它的方式，因此this值不总等于事件目标，所以更好地方式是使用srcElement替代this</li>\n<li>returnValue等价于preventDefault()方法，只不过需要将returnValue设置为false才阻止默认行为</li>\n</ul>\n<pre><code class=\"language-js\">var link = document.getElementById('myLink')\nlink.onclick = function(){\n  window.event.returnValue = false\n}\n</code></pre>\n<ul>\n<li>与DOM不同，没有办法通过JavaScript确认事件是否可以被取消</li>\n<li>cancelBubble属性与DOMstopPropagation()方法用途一样，用于阻止事件冒泡。IE8及更早不支持捕获阶段，所以只会取消冒泡。stopPropagation()既取消捕获也取消冒泡</li>\n</ul>\n<pre><code class=\"language-js\">var btn = document.getElementById('myBtn')\nbtn.onclick = function(){\n  console.log('clicked')\n  window.event.cancelBubble = true\n}\ndocument.body.onclick = function(){\n  console.log('body click')\n}\n</code></pre>\n<ul>\n<li>有了上面特性，我们可以拓展一下EventUtil对象</li>\n</ul>\n<pre><code class=\"language-js\">var EventUtil = {\n  addHandler: function(element, type, handler){\n    if(element.addEventListener){\n      element.addEventListener(type, handler, false)\n    } else if(element.attachEvent) {\n      element.attachEvent('on' + type, handler)\n    } else {\n      element['on' + type] = handler\n    }\n  },\n  removeHandler: function(element, type, handler){\n    if(element.removeEventListener){\n      element.removeEventListener(type, element, false)\n    } else if(element.detachEvent) {\n      element.detach('on' + type, handler)\n    } else {\n      element['on' + type] = null\n    }\n  },\n  getEvent: function(event){\n    return event ? event : window.event\n  },\n  getTarget: function(event){\n    return event.target || event.srcElement\n  },\n  preventDefault: function(event){\n    if(event.preventDefault) {\n      event.preventDefault()\n    }else {\n      event.returnValue = false\n    }\n  },\n  stopPropagation: function(event){\n    if(event.stopPropagation) {\n      event.stopPropagation()\n    } else {\n      event.cancelBubble = true\n    }\n  }\n}\n</code></pre>","fields":{"slug":"/Events/"},"frontmatter":{"title":"JavaScript中的事件","tags":["JavaScript回顾"],"categories":"JavaScript"}}},{"node":{"html":"<h1>JavaScript中的事件-事件类型</h1>\n<ul>\n<li>\n<p>Web浏览器定义很多事件，所发生事件类型决定了事件对象会保存什么信息，DOM3 Events定义了如下事件类型</p>\n<ul>\n<li>用户界面事件（UIEvent）: 涉及与BOM交互的通用浏览器事件</li>\n<li>焦点事件（FocusEvent）: 在元素获得和失去焦点时触发</li>\n<li>鼠标事件（MouseEvent）: 使用鼠标执行操作时触发</li>\n<li>滚轮事件（WheelEveny）: 使用鼠标滚轮或类似设备触发</li>\n<li>输入事件（InputEvent）: 向文档中输入文本时触发</li>\n<li>键盘事件（KeyboardEvent）: 使用键盘执行操作时触发</li>\n<li>合成事件（CompositionEvent）: 在使用某种IME（Input Method Editor,输入法编辑器）输入字符时触发</li>\n</ul>\n</li>\n<li>所有主流浏览器都支持DOM2 Events 跟DOM3 Events</li>\n<li>\n<p>用户界面事件或UI事件，主要有以下几种</p>\n<ul>\n<li>DOMActivate: 元素被用户通过鼠标或键盘操作激活时触发(比click或keydown)更常用，在DOM3 Events飞起，因为浏览器实现有差异</li>\n<li>load: 在window上页面加载完成后触发，在窗套（<frameset>）上所有窗格(frame)加载完成后触发，img元素上当图片加载完成后触发，在<object>上对应对象加载完成后触发</li>\n<li>unload: window上页面完全卸载后触发，窗套上所有窗格卸载后触发，object上的对应对象卸载后触发</li>\n<li>abort: 在object元素上对应的对象加载完成前被用户提前终止时触发</li>\n<li>error: window上当JavaScript报错时触发，img元素当图片无法加载时触发，object元素无法加载相应对象时触发，窗套上当一个或多个窗格无法完成加载时触发</li>\n<li>select: 文本框（input或textarea）上用户选了一个或多个字符时触发</li>\n<li>resize: window或窗格上被缩放时触发</li>\n<li>scroll: 用户滚动包含滚动条的元素时在元素上触发。body包含已加载页面的滚动条</li>\n</ul>\n</li>\n<li>除DOMActivate，这些事件在DOM2 Events被称为HTML Events</li>\n<li>load在window对象上load事件会在整个页面（所有外部资源如图片、css、js）加载完成后触发</li>\n<li>使用addEventListener添加load事件时，事件处理程序会收到一个event对象，DOM合规的浏览器中，event.target会设置为document，但在IE8之前的版本中，不会设置这个对象的srcElement属性</li>\n<li>load用于图片时，可以按照下方式动态添加图片</li>\n</ul>\n<pre><code class=\"language-js\">window.addEventListener('load', () => {\n  let image = document.createElement('img')\n  image.addEventListener('load', (event) => {\n    console.log(event.target.src)\n  })\n  document.body.appendChild(image)\n  image.src = 'smile.jpg'\n})\n</code></pre>\n<!--more-->\n<ul>\n<li>这里注意，图片的下载不一定要把元素添加到页面，只要给他设置了src属性就开始下载</li>\n<li>可以使用这种形式来进行图片的预加载</li>\n</ul>\n<pre><code class=\"language-js\">window.addEventListener('load', () => {\n  let image = new Image()\n  image.addEventListener('load', (event) => {\n    console.log(event.target.src)\n  })\n  image.src = 'smile.jpg'\n})\n</code></pre>\n<ul>\n<li>IE8及早期版本，图片没有添加到DOM文档中，load事件发生时不会生成event对象，IE9修复了这个问题</li>\n<li>script元素也可以以非标准的方式支持load事件。script元素会在javascript元素加载完成后触发load，与图片不同，下载JavaScript文件必须要指定src并且添加到文档中才可以，IE8及以下不支持script触发load事件</li>\n<li>IE和Opera支持link元素触发load事件，跟script一样，指定href跟插入文档后才会下载样式表</li>\n</ul>\n<pre><code class=\"language-js\">window.addEventListener('load', () => {\n  let link = document.createElement('link')\n  link.type = 'text/css'\n  link.rel = 'stylesheet'\n  link.addEventListener('load', (event) => {\n    console.log('css load')\n  })\n  link.href = 'example.css'\n  document.getElementByTagName('head')[0].appendChild(link)\n})\n</code></pre>\n<ul>\n<li>load相对的是unload事件，会在文档卸载完成后触发，一般在一个页面导航到另一个页面时触发，常用语清理内存，避免内存泄漏</li>\n<li>resize事件，浏览器窗口被缩放到新高度或宽度就会触发resize事件，不同浏览器触发resize方法存在差异。IE、Safari、Chrome、Opera会在窗口缩放超过1像素时触发resize事件，然后随用户缩放浏览器窗口不断触发。Firefox早期只在用户停止缩放时触发resize事件。无论如何都应该避免在这个过程执行过多计算。否则可能导致浏览器明显变慢</li>\n<li>scrolls事件，虽然scroll事件发生在window上，但实际反应页面相应元素的变化。混杂模式下可以通过body来检测scrollLeft和scrollTop属性的变化。标准模式下，这些变化都发生在html元素上</li>\n</ul>\n<pre><code class=\"language-js\">window.addEventListener('scroll', (event) => {\n  if(document.compatMode == 'CSS1Compat') {\n    console.log(document.documentElement.scrollTop)\n  } else {\n    console.log(document.body.scrollTop)\n  }\n})\n</code></pre>\n<h2>鼠标事件</h2>\n<ul>\n<li>\n<p>焦点事件在元素获得或失去焦点时触发。可以与document.hasFocus跟document.activeElement一起给用户提供导航信息</p>\n<ul>\n<li>blur: 元素失去焦点时触发，事件不冒泡，所有浏览器支持</li>\n<li>DOMFocusIn: 当前元素获得焦点触发，是focus的冒泡版。DOM3 Events废弃了该事件，推荐focusin</li>\n<li>DOMFocusOut: 元素失去焦点时触发，是blur的通用版。DOM3 Events废弃了该事件，推荐focusout</li>\n<li>focus: 当元素获取焦点时触发，事件不冒泡，所有浏览器支持</li>\n<li>focusin: 元素获得焦点时触发。是事件focus的冒泡版</li>\n<li>focusout: 元素失去焦点时触发。是blur的冒泡版</li>\n</ul>\n</li>\n<li>\n<p>当焦点从一个元素移动到另一个元素时，会依次触发</p>\n<ul>\n<li>focusout在失去焦点的元素上触发</li>\n<li>focusin在获得焦点的元素上触发</li>\n<li>blur在失去焦点的元素触发</li>\n<li>DOMFocusOut在失去焦点的元素上触发</li>\n<li>focus在获取焦点的元素触发</li>\n<li>DOMFocusIn在获取焦点的元素上触发</li>\n</ul>\n</li>\n<li>blur、focusout、DOMFocusOut事件目标是失去焦点的元素，focus、focusin、DOMFocusIn目标是获得焦点元素</li>\n<li>\n<p>DOM3 Events定义了9种鼠标事件</p>\n<ul>\n<li>click: 用户单击鼠标主键或按键盘回车时触发，主要是考虑到无障碍访问</li>\n<li>dbclick: 用户双击鼠标主键触发，DOM3 Events进行了标准化</li>\n<li>mousedown: 用户按下任意鼠标键触发，不能通过键盘触发</li>\n<li>mouseenter: 用户把鼠标从元素外移到元素内触发。不冒泡，不会在光标经过后代元素时触发，DOM3 Events新增</li>\n<li>mouseleave: 用户把光标从元素内部移到元素外部时触发。事件不冒泡，也不会在经过后代元素时触发</li>\n<li>mousemove: 光标在元素上移动时反复触发，不可通过键盘触发</li>\n<li>mouseout: 用户把鼠标光标从一个元素移到另一个元素时触发。移到的元素可以是外部元素，也可以是元素的子元素，不能通过键盘触发</li>\n<li>mouseover: 用户把光标从元素外部移到元素内部时触发</li>\n<li>mouseup: 用户释放鼠标时触发</li>\n</ul>\n</li>\n<li>所有元素都支持鼠标事件。除mouseenter跟mouseleave之外的鼠标事件都会冒泡，都可以被取消</li>\n<li>\n<p>取消事件可能影响其他鼠标事件</p>\n<ul>\n<li>click触发前提是mousedown触发，然后同一个元素触发mouseup，如果这两个元素任意一个被取消，click就不会被触发。</li>\n<li>两次连续的click会触发dbclick，要是任何一个click事件被取消，dbclick就不会发生</li>\n</ul>\n</li>\n<li>\n<p>这四个事件的顺序永远如下</p>\n<ul>\n<li>mousedown -> mouseup -> click -> mousedown -> mouseup -> click ->dbclick</li>\n</ul>\n</li>\n<li>\n<p>IE8及更早版本实现有问题，会导致双击事件跳过第二次mousedown和click事件，顺序就成了下面</p>\n<ul>\n<li>mousedown -> mouseup -> click -> mouseup -> dbclick</li>\n</ul>\n</li>\n<li>鼠标事件在DOM3 Events中对应的类型是\"MouseEvent\"而不是\"MouseEvents\"</li>\n<li>鼠标事件还有一个滚轮事件的子类别，只有一个事件mousewheel，反应鼠标滚轮或类似设备滚轮的交互</li>\n<li>客户端坐标：鼠标事件都是在浏览器视口的某个位置发生，这些信息保存在事件对象的clientX和clientY属性中，表示事件发生时鼠标在视口中的坐标，所有浏览器支持</li>\n<li>客户端坐标不考虑页面滚动，所以不代表鼠标在页面中的位置</li>\n<li>页面坐标：页面坐标是事件发生时相对页面的坐标，可以通过pageX跟pageY获取</li>\n<li>IE8及更早没有在事件对象暴露页面坐标，所以需要通过客户端坐标跟滚动信息计算出来，计算方式如下</li>\n</ul>\n<pre><code class=\"language-js\">let div = document.getElementById('myDiv')\ndiv.addEventListener('click', (event) => {\n  let pageX = event.pageX,\n  pageY = event.pageY\n  if(pageX === undefined) {\n    pageX = event.clientX + (document.body.scrollLeft || document.documentElement.scrollLeft)\n  }\n  if(pageY === undefined) {\n    pageY = event.clientY + (document.body.scrollTop || document.documentElement.scrollTop)\n  }\n})\n</code></pre>\n<ul>\n<li>屏幕坐标：鼠标事件不光在浏览器发生，也在屏幕上发生，通过event的screenX和screenY可以获取鼠标在屏幕上的坐标</li>\n<li>\n<p>鼠标有时候会跟键盘按键一起触发，键盘的Shift、Ctrl、Alt和Meta经常用于修改鼠标事件的行为，DOM规定了四个属性来表示修饰键状态</p>\n<ul>\n<li>shiftKey、ctrlKey、altKey、metaKey</li>\n</ul>\n</li>\n<li>这几个属性会在各自的修饰键按下时包含布尔值true，没有被按下时包含false</li>\n</ul>\n<pre><code class=\"language-js\">div.addEventListener('click', (event) => {\n  let keys = new Array()\n  if(event.shiftKey) {\n    keys.push('shift')\n  }\n  if(event.ctrlKey) {\n    keys.push('ctrl')\n  }\n  ...\n})\n</code></pre>\n<ul>\n<li>这里每个对应属性为true的修饰键都会添加到keys，最后就能得到所有键名称</li>\n<li>IE8及更早不支持metaKey属性</li>\n<li>mouseover跟mouseout事件还涉及其他相关元素，都涉及从一个元素到另一个元素的边界内。mouseover事件主要关联元素时获得光标的元素，相关元素是失去光标的元素</li>\n<li>DOM通过event对象的relatedTarget提供了相关元素的信息，只有mouseover与mouseout事件时才能发生，其他事件都是null</li>\n<li>IE8及更早版本不支持relatedTarget属性，但是在mouseover时提供了fromElement属性，mouseout发生时提供了toElement元素来表示相关元素，可根据这个规则扩充相关方法</li>\n</ul>\n<pre><code class=\"language-js\">var EventUtil = {\n  getRelatedTarget: function(event){\n    if(event.relatedTarget) {\n      return event.relatedTarget\n    } else if(event.toElement) {\n      return event.toElement\n    } else if(event.fromElement) {\n      return event.fromElement\n    } else {\n      return null\n    }\n  }\n}\n</code></pre>\n<ul>\n<li>在元素上单击鼠标主键（或按下回车）时click才会触发，因此按键信息不是必须的。对mousedown跟mouseup事件，event对象有一个button属性表示按下哪个键。</li>\n<li>DOM 为button属性定义了3个值：0表示主键、1表示中键、2表示副键，通常主键是左键，副键是右键</li>\n<li>\n<p>IE8也提供了button属性，但是跟上面完全不一样</p>\n<ul>\n<li>0: 没有任何按键</li>\n<li>1: 鼠标主键</li>\n<li>2: 鼠标副键</li>\n<li>3: 同时按下主键副键</li>\n<li>4: 鼠标中键</li>\n<li>5: 同时按下鼠标中键跟主键</li>\n<li>6: 同时按下鼠标副键和中键</li>\n<li>7: 同时按下3个键</li>\n</ul>\n</li>\n<li>DOM2 Events在event对象提供了detail属性，给出事件的更多信息</li>\n<li>对鼠标而言，detail包含一个数值，表示给定位置发生了多少次单击，detail从1开始，每次单击加1，要是在mousedown跟mouseup之间移动了，detail重置为0</li>\n<li>\n<p>IE给鼠标事件提供了额外的信息</p>\n<ul>\n<li>altLeft，布尔值，是否按下左Alt()</li>\n<li>ctrlLeft，布尔值，是否按下左Ctrl</li>\n<li>offsetX，光标相对于元素边界的x坐标</li>\n<li>offsetY，光标相对于元素边界的y坐标</li>\n<li>shiftLeft，布尔值，表示是否按下了左shift键</li>\n</ul>\n</li>\n<li>mousewheel会在用户使用鼠标滚轮触发，可在任何元素触发，在（IE8）冒泡到document跟（所有现代浏览器）window，mousewheel的event对象包含鼠标事件的所有标准信息，还有wheelDelta的新属性，向前滚wheelDelta每次都是+120，向后滚，每次都是-120</li>\n<li>\n<p>触摸屏不支持鼠标操作，所以有以下注意事项</p>\n<ul>\n<li>不支持dbclick事件，双击窗口会放大浏览器窗口，并且这个行为无法覆盖</li>\n<li>单指点击屏幕上的可点击元素会触发mousemove事件。如果操作导致内容变化，则不会触发其他事件。如果屏幕没有变化，会相继触发mousedown、mouseup、click事件。点触不可点击的元素不会触发事件。可点击元素是指点击时有默认动作的元素（如链接）或指定了onclick事件处理程序的元素</li>\n<li>mousemove事件会触发mouseover和mouseout事件</li>\n<li>双指点触屏幕并滑动会导致页面滚动时会触发mousewheel和scroll事件</li>\n</ul>\n</li>\n<li>\n<p>如果网站考虑残障人士，特别是屏幕阅读器的用户，鼠标事件要小心使用。按回车可以触发click事件，其他鼠标事件无法通过键盘触发。所以不要使用click之外的鼠标事件向用户提示功能。下面是相应的建议</p>\n<ul>\n<li>使用click事件执行代码，因为mousedown无法在屏幕阅读器触发</li>\n<li>不要使用mouseover向用户展示新选项，建议使用对应的键盘快捷键</li>\n<li>不要使用dbclick事件，因为键盘无法触发</li>\n</ul>\n</li>\n</ul>\n<h2>键盘与输入事件</h2>\n<ul>\n<li>键盘事件是用户操作键盘触发的，DOM2 Events定义了键盘事件，但是最终在发布前删除了，所以大多数还是基于原始的DOM0 </li>\n<li>\n<p>键盘事件包含下面三个事件</p>\n<ul>\n<li>keydown: 用户按下键盘某个键，持续按住会重复触发</li>\n<li>keypress: 用户按下某个键并产生字符时触发，持续按住重复触发。Esc也会触发这个事件，DOM3 Events废弃该方法，推荐textInput事件</li>\n<li>keyup: 用户释放某个键时触发</li>\n</ul>\n</li>\n<li>输入事件只有textInput事件，是对keypress事件的拓展，用于在文本显示给用户之前更好地截获文本输入，textInput会在文本插入到文本框之前触发。</li>\n<li>用户按下键时会先触发keydown，然后是keypress，然后是keyup事件</li>\n<li>其中keydown跟keypress会在文本框出现变化之前触发，keyup在文本框出现变化后触发。一直按住某个键，则keydown跟keypress会一直重复触发</li>\n<li>对于非字符键，会先触发keydown事件，然后触发keyup事件。</li>\n<li>键盘事件与鼠标事件相同的修饰键。shiftKey、ctrlKey、altKey和metaKey在键盘事件中都是可用的</li>\n<li>\n<p>在keydown跟keyup事件中，event对象中的keyCode都会保存一个键嘛，对应键盘上的一个键。字母与数字键，keyCode键码与小写字母和数字的ASCII编码一致，例如数字7键码为55，字母A键keyCode为65，跟是否按了shift键无关。DOM和IE的event对象都支持keyCode属性，下面为非字符键的键码值</p>\n<ul>\n<li>BackSpace: 8</li>\n<li>Tab: 9</li>\n<li>Enter: 13</li>\n<li>Shift: 16</li>\n<li>Ctrl: 17</li>\n<li>Alt: 18</li>\n<li>Pause/Break: 19</li>\n<li>Caps Lock: 20</li>\n<li>Esc: 27</li>\n<li>Page Up: 33</li>\n<li>Page Down: 34</li>\n<li>End: 35</li>\n<li>Home: 36</li>\n<li>左箭头: 37</li>\n<li>上箭头: 38</li>\n<li>右箭头: 39</li>\n<li>下箭头: 40</li>\n<li>Ins: 45</li>\n<li>Del: 46</li>\n<li>左Windows: 91</li>\n<li>数字键8: 104</li>\n<li>数字键9: 105</li>\n<li>数字键盘+: 107</li>\n<li>减号(数字与非数字键盘): 109</li>\n<li>数字键盘.: 110</li>\n<li>数字键盘/: 111</li>\n<li>F1: 112</li>\n<li>F2: 113</li>\n<li>F3: 114</li>\n<li>F4: 115</li>\n<li>F5: 116</li>\n<li>F6: 117</li>\n<li>F7: 118</li>\n<li>F8: 119</li>\n<li>F9: 120</li>\n<li>F10: 121</li>\n<li>F11: 122</li>\n<li>F12: 123</li>\n<li>Num Lock: 144</li>\n<li>Scroll Lock: 145</li>\n<li>右Windows： 92</li>\n<li>Context Menu: 93</li>\n<li>数字键盘0: 96</li>\n<li>数字键盘1: 97</li>\n<li>数字键盘2: 98</li>\n<li>数字键盘3: 99</li>\n<li>数字键盘4: 100</li>\n<li>数字键盘5: 101</li>\n<li>数字键盘6: 102</li>\n<li>数字键盘7: 103</li>\n<li>分号(IE/Safari/Chrome): 186</li>\n<li>分号(Opera/FF): 59</li>\n<li>小于号: 188</li>\n<li>大于号: 190</li>\n<li>反斜杠: 191</li>\n<li>重音符(`): 192</li>\n<li>等于号: 61</li>\n<li>左中括号: 219</li>\n<li>反斜杠(\\): 220</li>\n<li>右中括号: 221</li>\n<li>单引号: 222</li>\n</ul>\n</li>\n<li>keypress事件发生时，意味着按键影响屏幕中显示的文本，插入与删除文本的键，所有浏览器都会触发keypress事件，其他键取决于浏览器</li>\n<li>浏览器在event对象上支持charCode属性，只有发生keypress事件时才会被设置值，通常，charCode值为0，keypress事件发生时则是对应键的键码。IE8及更早版本和Opera使用keyCode传达ASCII编码，要以跨浏览器的方法获取字符编码，首先检查charCode属性是否有值，没有再使用keyCode</li>\n</ul>\n<pre><code class=\"language-js\">function getCharCode(event){\n  if(typeof event.charCode === 'number') {\n    return event.charCode\n  } else {\n    return event.keyCode\n  }\n}\n</code></pre>\n<ul>\n<li>DOM3 Events做了一些调整，DOM3 Events并未规定charCode属性，而是定义了key和char属性</li>\n<li>key用于取代keyCode，且包含字符串，按下字符键时，key的值等于文本字符（如\"k\"）；在按下非字符键时，key值时键名（如\"Shift\"），char属性在按下字符键时与key类似，按下非字符时为null</li>\n<li>IE支持key属性，不支持char属性。Safari和Chrome支持keyIdentifier属性，按下非字符串时返回月key一样的值(\"Shift\")，对于字符键，返回以\"U+0000\"形式表示Unicode值的字符串形式的字符编码</li>\n<li>由于缺乏跨浏览器支持，不建议使用key、keyIdentifier、char</li>\n<li>DOM3 Events支持一个location属性，属性是一个数值，表示在哪里按得键：0为默认键，1是左边（如左边的alt），2是右边，3是数字键盘，4是移动设备，5是游戏手柄。IE9支持这些属性。Safari和Chrome支持等价的keyLocation，但由于实现有问题，这个值始终为0，除非是数字键盘（3），值永远不会是1、2、4、5</li>\n<li>最后给event增加了getModifierState()方法，这个方法接受一个参数，一个等于Shift、Control、Alt、AltGraph或Meta的字符串，表示要检测的修饰键，如果给定的修饰键处于激活状态，返回true，否则返回false</li>\n<li>DOM3 Events增加了一个textInput事件，在文本被输入到可编辑区域时触发，作为keypress的替代，textInput有下面的区别：</li>\n<li>keypress会在所有可以获得焦点的元素上触发，textInput只在可编辑区域触发。</li>\n<li>textInput只会在新字符插入时触发，keypress对任何影响文本的键都会触发</li>\n<li>textInput主要关注字符，所以在event对象上提供一个data属性，包含要插入的字符。data的值始终是要被插入的字符，因此按S没有按shift，data的值就是s，按了shift，data值就是S</li>\n<li>\n<p>event上还有一个inputMethod属性，表示向控件中输入文本的字段，值如下</p>\n<ul>\n<li>0: 不确定什么输入手段</li>\n<li>1: 表示键盘</li>\n<li>2: 表示粘贴</li>\n<li>3: 表示拖放操作</li>\n<li>4: 表示IME</li>\n<li>5: 表示表单选项</li>\n<li>6: 表示手写</li>\n<li>7: 表示语音</li>\n<li>8: 表示组合方式</li>\n<li>9: 表示脚本</li>\n</ul>\n</li>\n<li>这些属性可以确定用户如何输入文本的，从而辅助验证</li>\n</ul>\n<h2>合成事件</h2>\n<ul>\n<li>合成事件时DOM3 Events中新增事件，用于处理使用IME输入时的复杂输入序列。IME可以让用户输入物理键盘不存在的字符，比如可以使用拉丁文字母键盘输入日文</li>\n<li>\n<p>IME通常需要使用多个键才能输入一个字符。所以由合成事件检测与控制该输入</p>\n<ul>\n<li>compositionstart: IME文本合成系统打开触发</li>\n<li>compositionupdate: 新字段插入式触发</li>\n<li>compositionend: IME文本合成系统关闭时触发，恢复正常键盘输入</li>\n</ul>\n</li>\n<li>\n<p>合成事件与输入事件很像，合成事件触发时，事件目标是接收文本的输入字段。唯一增加的事件属性是data，包含的值如下</p>\n<ul>\n<li>compositionstart：包含正在编辑的文本</li>\n<li>compositionupdate: 包含要插入的新字符</li>\n<li>compositionend: 包含合成过程中输入的全部目标</li>\n</ul>\n</li>\n</ul>\n<h2>HTML5事件</h2>\n<ul>\n<li>DOM规范并没有涵盖浏览器都支持的所有事件，HTML5尽可能的列出了浏览器支持的所有事件，下面我们讨论html5中支持比较好的事件</li>\n<li>contextmenu事件: contextmenu用于表示合适显示默认右键鼠标触发的上下文菜单，从而用于开发者取消默认的上下文菜单并自定义</li>\n<li>contextmenu事件冒泡，所以只需要给document指定一个事件处理程序就可以处理页面上的所有同类事件。</li>\n<li>这个事件在所有浏览器都可以取消，DOM合规浏览器中使用event.preventDefault()，IE8及更早将event.returnValue设为false</li>\n<li>beforeunload事件：该事件会在window上触发，给开发者阻止页面被卸载的机会，该事件会在页面即将从浏览器被卸载时触发。该事件默认行为不可取消，会向用户展示一个确认框，并请用户确认是希望关闭页面还是继续停留</li>\n<li>DOMContentLoaded: window的load事件会在页面完全加载后触发，而DOMContentLoaded会在DOM树完全构建后即触发，不需要等待其他的js、css、图片资源等加载。DOMContentLoaded可以让开发者在资源下载期间就能指定事件处理程序，从而让用户更快的与页面交互</li>\n<li>处理DOMContentLoaded事件，需要给document或window添加事件处理程序（实际事件目标是document，但会冒泡到window）</li>\n<li>\n<p>readystatechange事件：IE首先在DOM文档定义了readystatechange事件，为了提供文档或元素加载的信息，行为不是很稳定。支持readystatechange事件的对象都由一个readyState属性，对应值如下</p>\n<ul>\n<li>uninitialized: 对象存在未初始化</li>\n<li>loading: 对象正在加载数据</li>\n<li>loaded: 对象加载数据完成</li>\n<li>interactive: 对象可以交互，但未加载完成</li>\n<li>complete: 对象加载完成</li>\n</ul>\n</li>\n<li>文档说有些对象会完全跳过某个阶段，但并未说明哪些阶段适用哪些对象，意味着readystatechangez经常会触发不到4次，readyState也未必会依次呈现上述值</li>\n<li>在document上使用时，值为\"interactive\"的readyState首先触发readystatechange，时机类似于DOMContentLoaded</li>\n<li>Firefox跟Opera开发了往返缓存的功能，用于使用浏览器前进和后退时加快页面的切换</li>\n<li>pageshow会在页面展示时触发，无论是否来自缓存，新页面会在load事件后触发。注意：虽然该事件目标是document，但是处理程序必须加到window</li>\n<li>pageshow的event对象中有一个persisted的属性，如果页面存在缓存该值就是true，否则就是false</li>\n<li>与pageshow类似的是pagehide，该方法会在页面从浏览器卸载，unload之前触发。同样，该事件处理程序必须被添加到window上，pagehide同样有persisted属性，但是用法不同，pagehide中persisted为true表示页面将会存在于缓存中</li>\n<li>第一次触发pageshow是persisted始终是false，第一次触发pagehide时persisted始终是true（除非页面不符合往返缓存）</li>\n<li>注册了onunload事件（哪怕是空函数）的页面自动排除在往返缓存之外。因为onunload就是用来撤销onload事件发生的事，如果使用往返缓存，那下次页面不会触发onload，可能导致页面无法使用</li>\n<li>hashchange事件：html5新增hashchange事件，用于在URL散列值发生变化时通知开发者。onhashchange必须添加给window，每次URL散列值发生变化都会触发它。event有两个新属性:oldUrl跟newUrl，分别保存变化前后的url值，而且是包含了散列值的完整URL</li>\n</ul>\n<h2>设备事件</h2>\n<ul>\n<li>手机平板的出现导致了新的交互事件，所以产生了新的事件。设备设备用于确定用户使用设备的方式</li>\n<li>\n<p>orientationchange事件：苹果公司在Safari浏览器创造了orientationchange事件，用于确认设备是垂直模式还是水平模式。在window上暴露了window.orientation属性，值如下</p>\n<ul>\n<li>0: 垂直模式</li>\n<li>90: 左转水平模式</li>\n<li>-90: 右转水平模式</li>\n</ul>\n</li>\n<li>用户设备发生变化会触发orientationchange事件，但是事件本身没有有用的信息，都需要从window.orientation上拿（所有ios设备都支持该事件）</li>\n<li>deviceorientation事件：该事件是DeviceOrientationEvent事件规范定义的事件。如果可以获取设备的加速计信息，并且数据发生了变化，该事件就会在window触发，该事件只反映设备在空间中的朝向，不涉及移动的信息</li>\n<li>\n<p>deviceorientation事件触发时，event对象包含各个轴相对于设备静置时的变化，主要是5个属性</p>\n<ul>\n<li>alpha: 0-360范屋内浮点数，表示围绕z轴旋转y轴的度数（左右转）</li>\n<li>beta: -180-180范围内的浮点数，表示围绕x轴旋转时z轴的度数（前后转）</li>\n<li>gamma: -90-90范围内的浮点数，表示围绕y轴旋转时z轴的度数（扭转）</li>\n<li>absolute: 布尔值表示设备是否返回绝对值</li>\n<li>compassCalibrated: 布尔值，表示设备的指南针是否正确校准</li>\n</ul>\n</li>\n<li>\n<p>devicemotion事件：这个事件用于提示设备实际上的移动，可用于确认设备正在掉落或正在一个行走的人手中，事件触发时event对象包含的额外属性</p>\n<ul>\n<li>acceleration: 对象，包含x,y和z属性，反应不考虑重力下各个维度的加速信息</li>\n<li>accelerationIncludingGravity: 对象，包含x,y和z属性，反应各个维度的加速信息，包含z轴重力加速度</li>\n<li>interval: 毫秒，距离下次devicemotion事件的事件。该值在事件中应该是常量</li>\n<li>rotationRate: 对象，包含alpha、beta和gamma属性，表示设备朝向</li>\n</ul>\n</li>\n<li>无法提供acceleration、accelerationIncludingGravity、rotationRate时为null，所以使用前先检测是否为null</li>\n</ul>\n<h2>触摸及手势事件</h2>\n<ul>\n<li>\n<p>触摸事件：手指放在屏幕上、在屏幕上滑动或从屏幕一开，触摸事件会触发</p>\n<ul>\n<li>touchstart: 手指放到屏幕上触发</li>\n<li>touchmove: 手指在屏幕上滑动时连续触发。在这个事件中调用preventDefault可以阻止滚动</li>\n<li>touchend: 手指从屏幕移开时触发</li>\n<li>touchcancel: 系统停止跟踪触摸时触发。文档并未明确什么情况下停止追踪</li>\n</ul>\n</li>\n<li>这些事件都可以冒泡，也都可以被取消</li>\n<li>触摸事件不属于DOM规范，但是浏览器还是以DOM兼容的方式实现。因此，每个触摸事件都提供了鼠标事件的公共属性：bubbles、cancelable、view、clientX、clientY、screenX、screenY、detail、altKey、shiftKey、ctrlKey、metaKey</li>\n<li>\n<p>除了上述的DOM属性，还新增了3个属性用于追踪触电</p>\n<ul>\n<li>touches: Touch对象的数组，表示当前屏幕上的每个触点</li>\n<li>targetTouches: Touch对象的数组，表示特定于事件目标的触点</li>\n<li>changedTouches: Touch对象的数组，表示自上次用户动作之后变化的触点</li>\n</ul>\n</li>\n<li>\n<p>每个Touch对象自动包含下属性</p>\n<ul>\n<li>clientX: 触点在视口中的x坐标</li>\n<li>clientY: 触点在视口中的y坐标</li>\n<li>identifier: 触点ID</li>\n<li>pageX: 触点在页面上的x坐标</li>\n<li>pageY: 触点在页面上的y坐标</li>\n<li>screenX: 触点在屏幕上的x坐标</li>\n<li>screenY: 触点在屏幕上的y坐标</li>\n<li>target: 触发事件的事件目标</li>\n</ul>\n</li>\n<li>\n<p>这些事件会在文档的所有元素上触发，手指点击屏幕会依次触发下事件</p>\n<ul>\n<li>touchstart</li>\n<li>mouseover</li>\n<li>mousemove</li>\n<li>mousedown</li>\n<li>mouseup</li>\n<li>click</li>\n<li>touchend</li>\n</ul>\n</li>\n<li>\n<p>手势事件会在两个手指触摸屏幕且相对距离或者旋转角度时触发，事件如下</p>\n<ul>\n<li>gesturestart: 一个手指已经在屏幕上，另一个手指放到屏幕上触发</li>\n<li>gesturechange: 任何一个手指在屏幕上的位置发生变化时触发</li>\n<li>gestureend: 其中一个手指离开屏幕触发</li>\n</ul>\n</li>\n<li>只有两个手指同接触事件接受者时才会触发，在一个元素设置就要保证两个手指都在元素内。该事件可以冒泡，所以可以在文档进行事件处理，此时，事件的目标就是两个手指均位于其边界内的元素</li>\n<li>与触摸事件类似，每个手势事件都有event包含的所有标准鼠标事件。新增了两个event属性rotation和scale。rotation表示手指旋转的度数，负数表示逆时针旋转，正数表示顺时针旋转（从0开始）。scale表示两指间距离变化的成都，开始为1，后续随距离增大或缩小</li>\n</ul>\n<h2>内存与性能</h2>\n<ul>\n<li>过多事件处理程序可以使用事件委托来进行优化。事件委托利用事件冒泡，只用一个事件处理程序就可以管理一种类型的事件</li>\n<li>\n<p>事件委托的优势如下</p>\n<ul>\n<li>document对象随时可用，任何时间都可以给他添加事件处理程序（不用等onload或DOMContentLoaded），只要元素渲染就可以起作用</li>\n<li>节省花在设置页面处理程序上的时间，只需要指定一个事件处理程序可以节省DOM一弄，也能节省时间</li>\n<li>减少整个页面所需的内存，提升整体性能</li>\n</ul>\n</li>\n<li>适合使用事件委托的事件有：click、mousedown、mouseup、keydown、keypress。mouseover跟mouseout经常冒泡，但是很难处理</li>\n<li>\n<p>事件处理程序指定给元素后，在浏览器代码和负责页面交互的JavaScript代码之间就建立了联系，联系越多，页面性能就越差。导致这个问题的原因主要有两个：</p>\n<ul>\n<li>一个是删除带有事件处理程序的元素，这个时候被删除元素上有事件处理程序，就不会被垃圾收集程序正常清理</li>\n<li>另一个就是页面卸载，如果页面卸载后事件处理程序没有被清理，则会存在与内存中，每次加载或卸载程序都会导致残留的数据，所以在onunload事件中要清理注册的事件处理程序</li>\n</ul>\n</li>\n</ul>\n<h2>模拟事件</h2>\n<ul>\n<li>\n<p>DOM3增加了自定义事件类型，自定义事件不会触发原生DOM事件，可以让开发者定义自己的事件，需要调用createEvent('CustomEvent')，返回的对象包含initCustomEvent()方法，该方法包含四个参数：</p>\n<ul>\n<li>type: 要触发的事件类型，如\"myEvent\"</li>\n<li>bubbles: 布尔值，表示是否冒泡</li>\n<li>cancelable: 布尔值，表示事件是否可取消</li>\n<li>detail: 对象，任意值，作为event对象的detail属性</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"language-js\">let div = document.getElementById('myDiv'), event;\ndiv.addEventListener('myEvent', (event) => {\n  console.log(`div:${ event.detail }`)\n})\ndocument.addEventListener('myEvent', (event) => {\n  console.log(`document:${ event.detail }`)\n})\nif(document.implementation.hasFeature('CustomEvents', \"3.0\")) {\n  event = document.createEvent(\"CustomEvent\")\n  event.initCustomEvent('myevent', true, false, 'Hello world')\n  div.dispatchEvent(event)\n}\n</code></pre>\n<ul>\n<li>IE8及更早版本中模拟事件过程与DOM相似，创建event对象，指定信息，然后使用对象触发。不过IE中的实现步骤不一样</li>\n<li>首先使用document的createEventObject()方法创建event对象。与DOM不同，该方法不接受参数，返回一个通用的event对象。</li>\n<li>然后可以手动的给返回的对象指定希望该对象具有的属性。</li>\n<li>最后在事件目标上调用fireEvent()方法，该方法接受两个参数：事件处理程序的名字和event对象。调用fireEvent时，srcElement和type属性会自动指派到event对象（其他属性需要手动指定）。</li>\n</ul>\n<pre><code class=\"language-js\">var div = document.getElementById('myBtn')\nvar event = document.createEventObject()\nevent.screenX = 100\nevent.screenY = 0\nevent.clientX = 0\nevent.clientY = 0\nevent.ctrlKey = false\nevent.altKey = false\nevent.shiftKey = false\nevent.button = 0\nbtn.fireEvent('onclick', event)\n</code></pre>","fields":{"slug":"/Events-type/"},"frontmatter":{"title":"JavaScript中的事件-事件类型","tags":["JavaScript回顾"],"categories":"JavaScript"}}},{"node":{"html":"<h1>从零搭建一个react-hooks项目（六）</h1>\n<ul>\n<li>最近项目比较忙，所以有段时间没有补充新内容了，直到github提示有人给我提了issue才抽时间补了一下这个内容</li>\n<li>之前已经完成了webpack的搭建与优化，可以完成项目的基本使用，这位热心的伙伴也是提出了一些关于eslint的建议，所以这次补充一下ESLint的引入</li>\n<li>我们的项目使用了react与typescript，有typescript的存在看起来应该使用TSLint，但是官方提出以后会弃用TSLint，转而使用ESLint，声明也说了ESLint对TS的支持很完善，所以我们就引入一下ESLint</li>\n</ul>\n<h2>在项目中安装ESLint</h2>\n<ul>\n<li>首先安装ESLint与TS的相关依赖</li>\n</ul>\n<pre><code class=\"language-js\">// yarn add eslint @typescript-eslint/eslint-plugin @typescript-eslint/parser\nnpm install eslint @typescript-eslint/eslint-plugin @typescript-eslint/parser --save-dev\n</code></pre>\n<ul>\n<li>\n<p>然后在项目的根目录创建 .eslintrc.json 文件，然后补充下面选项进入</p>\n<!--more-->\n<pre><code class=\"language-js\">// .eslintrc.json\n{\n\"parser\": \"@typescript-eslint/parser\",\n\"parserOptions\": {\n\"jsx\": true,\n\"useJSXTextNode\": true\n},\n\"extends\": [\n\"plugin:@typescript-eslint/recommended\"\n],\n\"plugins\": [\"@typescript-eslint\"]\n}\n</code></pre>\n</li>\n<li>parser告诉ESLint使用typescript模式解析，parserOpions告诉ESLint我们想要使用jsx语法</li>\n<li>extends是表明我们想要使用ESLint中typescript的推荐语法</li>\n<li>plugins中是我们要用到的ESLint包含的详细typescript的解析规则</li>\n</ul>\n<h2>使用prettier</h2>\n<ul>\n<li>使用prettier就是告诉ESLint我们已经在本地校验过代码格式了，你可以不用关心代码的格式怎么样，下面是安装的依赖</li>\n</ul>\n<pre><code class=\"language-js\">// yarn add prettier eslint-config-prettier\nnpm install prettier eslint-config-prettier --save-dev\n</code></pre>\n<ul>\n<li>然后就需要在ESLint的配置规则中进行拓展，拓展之后能给我们更好看的代码格式校验，修改 .eslintrc.json 文件如下</li>\n</ul>\n<pre><code class=\"language-js\">{\n  \"parser\": \"@typescript-eslint/parser\",\n  \"parserOptions\": {\n    \"jsx\": true,\n    \"useJSXTextNode\": true\n  },\n  \"extends\": [\n    \"plugin:@typescript-eslint/recommended\",\n    \"prettier\",\n    \"prettier/@typescript-eslint\"\n  ],\n  \"plugins\": [\"@typescript-eslint\"]\n}\n</code></pre>\n<h2>使用VSCode优化编码体验</h2>\n<ul>\n<li>上面添加了基本的校验规则，但是不会在我们编码的时候主动为我们执行检查，所以我们可以通过配置VSCode插件来让编辑器实时为我们检查</li>\n<li>先在VSCode的插件库里搜索ESlint，然后安装并重启</li>\n<li>之后在 文件 -> 首选项 -> 设置中搜索 setting.json ，然后在 setting.json 最外层补充</li>\n</ul>\n<pre><code class=\"language-js\">// setting.json\n{\n  // otherSetting\n  \"eslint.validate\": [\n    \"javascript\",\n    \"javascriptreact\",\n    {\n        \"language\": \"typescript\",\n        \"autoFix\": true\n    },\n    {\n        \"language\": \"typescriptreact\",\n        \"autoFix\": true\n    }\n  ],\n}\n</code></pre>\n<ul>\n<li>之后再打开我们的代码就发现可以在每个页面提醒我们代码中的格式问题</li>\n</ul>\n<h2>配置hooks</h2>\n<ul>\n<li>因为我们的项目使用了hooks，所以我们需要添加hooks的解析规则帮助我们修复hooks编写中的问题</li>\n<li>首先安装相关的依赖</li>\n</ul>\n<pre><code class=\"language-js\">// yarn add eslint-plugin-react-hooks\nnpm install eslint-plugin-react-hooks --save-dev\n</code></pre>\n<ul>\n<li>然后在 .eslintrc.json 中补充相关的配置，配置如下</li>\n</ul>\n<pre><code class=\"language-js\">// .eslintrc.json\n{\n  \"parser\": \"@typescript-eslint/parser\",\n  \"parserOptions\": {\n    \"jsx\": true,\n    \"useJSXTextNode\": true\n  },\n  \"extends\": [\n    \"plugin:@typescript-eslint/recommended\",\n    \"prettier\",\n    \"prettier/@typescript-eslint\"\n  ],\n  \"plugins\": [\"@typescript-eslint\", \"react-hooks\"],\n  \"rules\": {\n    \"@typescript-eslint/explicit-function-return-type\": \"off\",\n    \"react-hooks/rules-of-hooks\": \"error\",\n    \"react-hooks/exhaustive-deps\": \"warn\"\n  }\n}\n</code></pre>\n<ul>\n<li>这样引入了hooks的校验之后就会帮我们提示一些类似于在非react组件中使用hooks语法这样的语法错误</li>\n<li>好了，上面就是引入代码规范ESLint的步骤了，有什么问题也可以私我啊</li>\n</ul>","fields":{"slug":"/react_md_6/"},"frontmatter":{"title":"从零搭建一个react-hooks项目（六）","tags":["react","react hooks","redux","webpack","esLint"],"categories":"Webpack"}}}]}},"pageContext":{"limit":10,"skip":60,"currentIndex":6}},"staticQueryHashes":["2566592090"]}