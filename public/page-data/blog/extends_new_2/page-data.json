{"componentChunkName":"component---src-templates-blog-small-jsx","path":"/blog/extends_new_2/","result":{"data":{"markdownRemark":{"html":"<h1>js中的继承（二）</h1>\n<h2>原型式继承</h2>\n<ul>\n<li>原型式继承：原型式继承可以根据现有对象创建一个新的对象，并且不用显式的创建一个新的自定义类型对象（道格拉斯说的）。这也就是原型式继承的作用，创建一个继承某对象属性并可进行拓展的的新对象。</li>\n<li>原型式继承采用的其实还是类式继承的原理，只不过不会显式的构建一个对象子类，而是用一个空的构造函数类来做过渡类，然后把被继承的对象设置为过渡类的原型对象，然后返回一个过渡类的实例，这样这个返回的对象就有了被继承对象的属性与方法，具体实现见下代码</li>\n</ul>\n<!--more-->\n<pre><code class=\"language-js\">  function inheritObject(obj){\n    function F(){} // 过渡类，一般为空\n    F.prototype = obj // 设置过渡类原型对象\n    return new F() // 返回新的实例\n  }\n\n  let book = {\n    books: ['css', 'js', 'html'],\n    name: 'css book',\n    showBooks: function(){\n      console.log(this.books, this.name)\n    }\n  }\n\n  let b1 = inheritObject(book)\n  let b2 = inheritObject(book)\n  b1.name = 'js book'\n  b2.name = 'html book'\n  b2.showBooks() // [\"css\", \"js\", \"html\"]  \"html book\"\n  b1.books.push('php')\n  // 这里可以看到对b1的books属性进行操作会影响到b2的books属性\n  b2.showBooks() // [\"css\", \"js\", \"html\", \"php\"]  \"html book\"\n  b1.showBooks() // [\"css\", \"js\", \"html\", \"php\"]  \"js book\"\n</code></pre>\n<ul>\n<li>原型式继承其实就是对类式继承的另类使用，只不过使用一个空构造函数的过渡类来替代子类减少开销，用于创建对象是一个蛮不错的选择，也是后来Object.create()的实现思想来源。</li>\n</ul>\n<h2>寄生式继承</h2>\n<ul>\n<li>寄生式继承：就是对原型式继承的二次封装，并且在二次封装中对继承的对象进行了拓展，这样对象不仅拥有了父类中的对象与属性，也有了新的属性与方法</li>\n</ul>\n<pre><code class=\"language-js\">  function inheritObject(obj){\n    function F(){} // 过渡类，一般为空\n    F.prototype = obj // 设置过渡类原型对象\n    return new F() // 返回新的实例\n  }\n  function createBook(obj){\n    var o = inheritObject(obj) // 获取原型式继承的对象\n    // 对该对象进行拓展\n    o.getName = function(){ \n      console.log(this.name)\n    }\n    return o\n  }\n  let book = {\n    books: ['css', 'js', 'html'],\n    name: 'css book',\n    showBooks: function(){\n      console.log(this.books, this.name)\n    }\n  }\n\n  let b1 = createBook(book)\n  b1.getName() // css book\n</code></pre>\n<ul>\n<li>只是比原型式继承多了一个函数封装，使其拥有了自己的属性与方法，产生这个继承方式的目的也是为了寄生组合式继承模型的实现</li>\n</ul>\n<h2>完美的继承模式——寄生组合式继承</h2>\n<ul>\n<li>寄生组合式继承：是寄生式继承与构造函数继承的组合形式，取了两个继承的优点产生的目前最完美的继承形式</li>\n<li>构造函数继承使子类具有父类构造函数内的属性与方法，寄生式继承获取一个继承自父类原型对象的子对象，避免了父类原型对象的二次调用，因为该对象可获取父类原型对象上的属性与方法，设置该对象为子类原型对象继承父类原型对象上的属性与方法，最后对该对象进行属性增强修正其constructor不指向子类的错误</li>\n</ul>\n<pre><code class=\"language-js\">  function inheritObject(obj){\n    function F(){}\n    F.prototype = obj\n    return new F()\n  }\n\n  function inherit(Subclass, Superclass){\n    // 生成一个继承父类原型对象的子对象\n    let sup = inheritObject(Superclass.prototype) \n    // 该对象的constructor并不是指向子类，所以要对其进行属性拓展，修改其constructor属性至子类\n    sup.constructor = Subclass\n    // 将这个拓展过后的对象作为子类的原型对象\n    Subclass.prototype = sup\n  }\n\n  function SuperClass(name){\n    this.name = name\n    this.favite = ['吃饭', '喝酒', '打篮球']\n  }\n  // 原型对象方法\n  SuperClass.prototype.showFavite = function(){\n    console.log(this.favite)\n  }\n\n  function SubClass(name){\n    SuperClass.call(this, name)\n  }\n  // 实现继承\n  inherit(SubClass, SuperClass)\n\n  let s1 = new SubClass('张三')\n  let s2 = new SubClass('李四')\n  s2.showFavite() //  [\"吃饭\", \"喝酒\", \"打篮球\"]\n  s1.favite.push('打豆豆')\n  s2.showFavite() //  [\"吃饭\", \"喝酒\", \"打篮球\"]\n  s1.showFavite() //  [\"吃饭\", \"喝酒\", \"打篮球\", \"打豆豆\"]\n</code></pre>\n<ul>\n<li>原型链与构造函数的组合继承中子类的原型对象为父类的一个实例，也就导致在对子类实现继承的时候会执行两次父类的构造函数（一次子类构造函数调用父类构造函数，一次生成父类实例时调用）。</li>\n<li>而在寄生组合式继承中，每次继承都会由过渡类继承父类原型对象返回一个新的实例，而且由于过渡类的空构造函数并不会导致有太大的内存开销，就避免了父类构造函数的二次调用，所以这也是当下最完美的继承形式</li>\n</ul>","frontmatter":{"title":"JavaScript中的继承（二）","date":"2019-10-15","tags":["JavaScript回顾","设计模式","进修"],"categories":"JavaScript"},"fields":{"slug":"/extends_new_2/"}}},"pageContext":{"slug":"/extends_new_2/"}},"staticQueryHashes":["2566592090"]}