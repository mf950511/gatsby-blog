{"componentChunkName":"component---src-templates-index-jsx","path":"/blog/3","result":{"data":{"allMarkdownRemark":{"totalCount":27,"edges":[{"node":{"html":"<h1>react hooks 下使用redux</h1>\n<h2>redux</h2>\n<ul>\n<li>redux是近年来javascript中火热的状态管理容器，提供可预测的全局状态管理。在大型的应用中我们常采用redux来进行状态管理，redux的基本使用方式如下</li>\n<li>使用redux，我们先要进行action的编写，action一般由type与其他相关数据构成，下面就是简单的两个action</li>\n</ul>\n<pre><code class=\"language-js\">const INCREMENT = 'INCREMENT'\nconst DECREMENT = 'DECREMENT'\n\n// 数字增加action\n{ type: INCREMENT, payload: number }\n\n// 数字减少action\n{ type: DECREMENT, payload: number }\n</code></pre>\n<!--more-->\n<ul>\n<li>接下来，我们就要根据action来进行我们的reducer编写,reducer是一个函数，具有两个初始值，一个是当前的状态值state，一个是当前的操作模式action</li>\n<li>我们要根据当前的操作模式进行相应的逻辑处理，并返回新的state,这里我们为state设置一个初始值 0，对应INCREMENT与DECREMENT分别进行加减操作</li>\n</ul>\n<pre><code class=\"language-js\">const initialState = 0\n\nconst numberReducer = (state = initialState, action) => {\n  switch(action.type) {\n    case INCREMENT:\n      return state + action.payload\n    case DECREMENT:\n      return state - action.payload\n    default:\n      return state\n  }\n}\n</code></pre>\n<ul>\n<li>上面只是定义了操作形式与如何响应该操作，并没有实际的进行触发，触发状态改变需要redux提供的dispatch,dispatch接收一个action并将这个action传递给reducer，从而触发最后的状态改变，如下</li>\n</ul>\n<pre><code class=\"language-js\">dispatch({ type: DECREMENT, payload: number })\n</code></pre>\n<h2>react中使用redux</h2>\n<ul>\n<li>react hooks出来之前，redux几乎是所有react项目的不二只选，但是其复杂的使用方式让许多开发者都头疼，对萌新来说更是要命，上网查了都不知道是怎么回事</li>\n<li>hooks的出现，解放了一大批的react的开发者，易上手的开发模式让开发者使用极其简单，而react-redux自然也不会放过hooks的这波狂潮，下面就让我们对比一下hooks前后的两种redux使用形式</li>\n</ul>\n<h3>react中使用redux</h3>\n<ul>\n<li>react中使用redux需要借助三方库react-redux，react-redux提供了connect来让我们在组件中使用redux，如下使用</li>\n</ul>\n<pre><code class=\"language-js\">import React from 'react'\nimport { connect } from 'react-redux'\n\nclass Test extends React.Component {\n  constructor(){\n    super()\n  }\n  mapStateToProps(state) {\n    return {\n      number: state.number\n    }\n  }\n\n  mapDispatchToProps(dispatch) {\n    return {\n      increment: (number) => dispatch({ type: 'INCREMENT', payload: number }),\n      decrement: (number) => dispatch({ type: 'DECREMMENT', payload: number }),\n    }\n  }\n\n  render() {\n    return (\n      &#x3C;div>\n        &#x3C;div>{ this.props.number }&#x3C;/div>\n        &#x3C;button onClick={() => { this.props.increment(10) }}>增加10&#x3C;/button>\n        &#x3C;button onClick={() => { this.props.decrement(5) }}>减少5&#x3C;/button>\n      &#x3C;/div>\n    )\n  }\n\n}\n\nexport default connect(mapStateToProps, mapDispatchToProps)(Test)\n</code></pre>\n<h2>react hooks中使用redux</h2>\n<ul>\n<li>hooks中使用redux需要依靠react-redux提供的 useSelector 与 useDispatch进行state取值与dispatch执行修改操作</li>\n<li>useSelector会根据接受的函数返回需要的状态值，如下面的number</li>\n<li>useDispatch会返回一个操作函数，返回的操作函数可以接收一个action执行状态值的修改</li>\n</ul>\n<pre><code class=\"language-js\">import * as React from 'react'\nimport { useSelector, useDispatch } from 'react-redux'\n\nconst Test = () => {\n  const number = useSelector(state => state.number)\n  const dispatch = useDispatch()\n  return (\n      &#x3C;div>\n        &#x3C;div>{ this.props.number }&#x3C;/div>\n        &#x3C;button onClick={() => { dispatch({ type: 'INCREMENT', payload: 10 }) }}>增加10&#x3C;/button>\n        &#x3C;button onClick={() => { dispatch({ type: 'DECREMMENT', payload: 5 }) }}>减少5&#x3C;/button>\n      &#x3C;/div>\n    )\n}\n\nexport default Test\n</code></pre>","fields":{"slug":"/redux-hooks/"},"frontmatter":{"title":"react hooks下使用react-redux","tags":["react","react hooks","redux"],"categories":"React"}}},{"node":{"html":"<h1>从零搭建一个react-hooks项目（一）</h1>\n<ul>\n<li>最近有打算仿vue-admin项目构造一个react的项目，不引用官方脚手架，从webpack开始配置一套基于react,redux,typescript的项目，并实时记录一下项目中的一些配置情况</li>\n<li>首先搭建一个基本的webpack环境</li>\n</ul>\n<h2>webpack项目搭建</h2>\n<ul>\n<li>前置基础，电脑有安装node环境，可以使用npm工具</li>\n<li>新建文件夹，命名项目名称（react-admin）,进入文件夹，使用命令 npm init ，然后一路确定生成package.json文件</li>\n<li>webpack需要安装基本依赖 webpack webpack-cli webpack-dev-server, 命令为 npm i webpack webpack-cli webpack-dev-server -D</li>\n<li>安装依赖完成，则需要进行webpack的基本配置，我们在根目录构建 webpack.config.js 文件用于配置webpack</li>\n<li>然后在根目录创建一个index.js作为入口文件，我们先构造index.js这个入口文件，代码如下</li>\n</ul>\n<!--more-->\n<pre><code class=\"language-js\">function a(number){\n  console.log(number)\n}\na(12)\n</code></pre>\n<ul>\n<li>然后开始配置我们的webpack，webpack需要配置入口及输出位置，分别对应entry与output属性</li>\n<li>entry可以接收一个字符串作为主入口的文件路径，但只能用于单入口项目。也可以接收一个对象作为入口的文件路径，如下所示</li>\n<li>output用来描述打包后的文件应该放到哪，叫什么名字，也有两个基本属性，一个是打包后的文件名，一个是打包后的文件路径，这里我们通过[name].js来获取他在入口文件中的对应名称并生成文件名，如果是单入口并且直接用字符串指定的文件路径，比如entry: './index.js'，这样最后生成的文件名就是main.js，如果采用对象形式设定的entry属性，比如entry: { app: './index.js' }，则最后生成的文件就是对应的键值app.js。 路径使用path.resolve()来在根目录下生成dist文件夹并将打包文件放到其中</li>\n</ul>\n<pre><code class=\"language-js\">const path = require('path') // node环境自带，无需下载\n// 单入口文件\nmodule.exports = {\n  entry: './index.js', // 入口为index.js\n  output: {  // 输出就是 dist/main.js\n    filename: '[name].js',\n    path: path.resolve(__dirname, 'dist')\n  }\n}\n\n// 多入口文件\nmodule.exports = {\n  entry: { // 入口也是index.js\n    app: './index.js'\n  }, \n  output: {  // 输出为dist/app.js\n    filename: '[name].js',\n    path: path.resolve(__dirname, 'dist')\n  }\n}\n</code></pre>\n<ul>\n<li>配置到这就算完成了最基本的配置，我们可以来测试一下，先在package.json中的 scripts 下新建指令 \"start\": \"webpack --config webpack.config.js\"</li>\n<li>然后再执行npm run start 就可以看到执行了打包过程，生成了dist文件夹</li>\n<li>这里我们完成了基本的配置，但是这里还有一个问题，当我们修改entry对应的文件名时，重新执行打包，会发现之前的打包文件还存在，这样就会导致我们的dist文件夹会包含很多之前打包的跟当前代码无关的文件，这样其实对我们的项目并不友好，这里我们想要在每次打包的时候都把dist给移除了，并重新生成</li>\n<li>clean-webpack-plugin 插件可以帮助我们实现这个需求，先下载这个包  npm i clean-webpack-plugin -D</li>\n<li>然后在webpack.config.js中进行配置，如下，plugins用于我们配置我们想要的相关插件，接收一个数组值，这样我们的项目就可以在每次打包前都将dist清空了，就不会存在无用文件在内了</li>\n</ul>\n<pre><code class=\"language-js\">const path = require('path')\nconst { CleanWebpackPlugin } = require('clean-webpack-plugin');\n\nmodule.exports = {\n  entry: {\n    app: './index.js'\n  },\n  output: {\n    filename: '[name].js',\n    path: path.resolve(__dirname, 'dist'),\n    chunkFilename: '[name].bundle.js'\n  },\n  plugins: [\n    new CleanWebpackPlugin()\n  ]\n}\n</code></pre>\n<ul>\n<li>接下来就让我们开始配置react相关吧，react开发中我们会用到jsx或者es6的语法，而这些语法在低版本浏览器都是不兼容的，所以我们需要配置babel来实现低版本浏览器的兼容</li>\n<li>这里我们需要下载 babel-loader @babel/preset-env(根据环境转换代码) @babel/preset-react(react使用) @babel/preset-polyfill(Babel默认只转换新的JavaScript语法，但是不转换新的API，比如 <code>Iterator</code>、<code>Generator</code>、<code>Set</code>、<code>Maps</code>、<code>Proxy</code>、<code>Reflect</code>、<code>Symbol</code>、<code>Promise</code> 等全局对象，以及一些定义在全局对象上的方法（比如<code>Object.assign</code> ）都不会转码。而<code>@babel/preset-polyfill</code>可以转码。) @babel/proposal-object-rest-spread(处理react中对象的rest写法) @babel/proposal-object-rest-spread (处理类里面的箭头函数this绑定，static属性等 ), 依赖下载完成后就需要进行babel配置了</li>\n<li>我们在根目录构建 .babelrc 文件，内里配置如下</li>\n</ul>\n<pre><code class=\"language-js\">{\n  \"presets\": [\n    \"@babel/preset-env\",\n    \"@babel/preset-react\"\n  ],\n  \"plugins\": [\n    \"@babel/proposal-object-rest-spread\", // 处理对象的rest写法\n    \"@babel/proposal-class-properties\" // 处理类里面的箭头函数绑定，static属性等 \n  ]\n}\n</code></pre>\n<ul>\n<li>然后就需要在webpack里面配置编译规则了，还是在webpack.config.js里面，新增module模块，添加不同文件的解析规则，如下</li>\n</ul>\n<pre><code class=\"language-js\">module.exports = {\n  entry: {\n    app: './index.js'\n  },\n  output: {\n    filename: '[name].js',\n    path: path.resolve(__dirname, 'dist'),\n    chunkFilename: '[name].bundle.js'\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.(js)x?$/,\n        use: ['babel-loader'],\n        exclude: /node-modules/ // 不解析node_modules中的文件\n      }\n    ]\n  },\n  plugins: [\n    new CleanWebpackPlugin()\n  ]\n}\n</code></pre>\n<ul>\n<li>然后我们可以写代码来测试一下，react 要基于 dom 展示，所以我们新建一个index.html用于dom展示，index.jsx用于执行react挂载，新建一个文件夹src用于放置react相关的组件及内里逻辑，并在里面新建一个app.jsx用于做初始组件，代码分别如下</li>\n</ul>\n<pre><code class=\"language-js\">// index.html\n&#x3C;!DOCTYPE html>\n&#x3C;html lang=\"en\">\n&#x3C;head>\n  &#x3C;meta charset=\"UTF-8\">\n  &#x3C;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  &#x3C;title>Document&#x3C;/title>\n&#x3C;/head>\n&#x3C;body>\n  \n&#x3C;div id=\"app\">&#x3C;/div>\n&#x3C;script src=\"./dist/app.js\">&#x3C;/script>\n&#x3C;script src=\"./dist/test.js\">&#x3C;/script>\n&#x3C;/body>\n&#x3C;/html>\n</code></pre>\n<pre><code class=\"language-js\">// index.jsx\nimport * as React from 'react'\nimport * as ReactDOM from 'react-dom'\nimport App from './src/app.jsx'\nReactDOM.render(\n  &#x3C;App/>\n  ,document.querySelector('#app')\n)\n</code></pre>\n<pre><code class=\"language-js\">// app.jsx\nimport * as React from 'react'\nclass App extends React.Component{\n  render(){\n    return (\n      &#x3C;div>123&#x3C;/div>\n    )\n  }\n}\nexport default App\n</code></pre>\n<ul>\n<li>然后需要在我们的webpack配置中新增加一个入口文件，如我们在html中的引入一样，需要命名为test，配置如下</li>\n</ul>\n<pre><code class=\"language-js\">module.exports = {\n  entry: {\n    app: './index.js',\n    test: './index.jsx'\n  },\n  ...// 省略\n}\n</code></pre>\n<ul>\n<li>接下来执行npm run start 执行打包，打包完成后打开页面 index.html 查看就可以发现已经插入了123进去</li>\n<li>这里我们可以发现我们需要新建一个index.html然后再主动根据生成的文件路径将其引入进去，要是生成的文件比较多则会很麻烦，所以我们接下来使用插件让其自动生成</li>\n<li>首先下载插件 html-webpack-plugin，命令为 npm i html-webpack-plugin</li>\n<li>然后再webpack.config.js里进行相关配置，还是用在plugins模块中，如下所示</li>\n</ul>\n<pre><code class=\"language-js\">const path = require('path')\nconst webpack = require('webpack')\nconst { CleanWebpackPlugin } = require('clean-webpack-plugin');\nconst HTMLWebpackPlugin = require('html-webpack-plugin')\n\nmodule.exports = {\n  entry: {\n    app: './index.js',\n    test: './index.jsx'\n  },\n  output: {\n    filename: '[name].js',\n    path: path.resolve(__dirname, 'dist'),\n    chunkFilename: '[name].bundle.js'\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.(js)x?$/,\n        use: ['babel-loader'],\n        exclude: /node-modules/\n      }\n    ]\n  },\n  plugins: [\n    new HTMLWebpackPlugin({\n      inject: true, // 所有js脚本放于body之后\n      hash: true, // 为静态资源生成hash，用于清楚缓存\n      cache: true, // 仅在文件被更改时发出文件\n      title: 'react admin',\n      filename: 'index.html',\n      template: path.resolve(__dirname, 'index.html'),\n      minify: {\n        collapseWhitespace: true, // 折叠空白\n        removeComments: true, // 删除注释\n        removeRedundantAttributes: true,\n        removeScriptTypeAttributes: true,\n        removeStyleLinkTypeAttributes: true\n      }\n    }),\n    new CleanWebpackPlugin()\n  ]\n}\n</code></pre>\n<ul>\n<li>然后在根目录放置我们的模板index.html，不需要主动引入js文件了，内容如下</li>\n</ul>\n<pre><code class=\"language-js\">// index.html\n&#x3C;!DOCTYPE html>\n&#x3C;html lang=\"en\">\n&#x3C;head>\n  &#x3C;meta charset=\"UTF-8\">\n  &#x3C;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  &#x3C;title>react admin&#x3C;/title>\n&#x3C;/head>\n&#x3C;body>\n  \n&#x3C;div id=\"app\">&#x3C;/div>\n&#x3C;/body>\n&#x3C;/html>\n</code></pre>\n<ul>\n<li>之后再执行我们的npm run start 就可以在dist中自动生成我们的index.html文件了，直接打开就能发现已经有我们要渲染的内容了</li>\n<li>react相关的就配置完成了，接下来我们需要配置一下css部分，开发中以less作为示例配置一下</li>\n<li>首先安装相关的依赖 less-loader style-loader postcss-loader css-loader autoprefixer，命令为 npm i less-loader style-loader postcss-loader css-loader autoprefixer -D</li>\n<li>接下来进行webpack配置，用以处理less文件的解析及处理</li>\n<li>还是在 module 下面的 rules 中配置规则，如下</li>\n</ul>\n<pre><code class=\"language-js\">const path = require('path')\nconst webpack = require('webpack')\nconst { CleanWebpackPlugin } = require('clean-webpack-plugin');\nconst HTMLWebpackPlugin = require('html-webpack-plugin')\n\nmodule.exports = {\n  entry: {\n    app: './index.js',\n    test: './index.jsx'\n  },\n  output: {\n    filename: '[name].js',\n    path: path.resolve(__dirname, 'dist'),\n    chunkFilename: '[name].bundle.js'\n  },\n  module: {\n    rules: [\n      { \n        test: /\\.(le|c)ss$/,\n        use: [ // 解析规则为从右向左，即 less-loader, postcss-loader, css-loader, style-loader\n          'style-loader',\n          {\n            loader: 'css-loader',\n            options: {\n              sourceMap: true //是否打开样式查找\n            }\n          },\n          {\n            loader: 'postcss-loader', // 为浏览器加前缀\n            options: {\n              ident: 'postcss',\n              sourceMap: true,\n              plugins: loaders => [\n                require('autoprefixer')({\n                })\n              ]\n            }\n          },\n          {\n            loader: 'less-loader', // 解析样式文件\n            options: {\n              sourceMap: true\n            }\n          }\n        ]\n      },\n      {\n        test: /\\.(js)x?$/,\n        use: ['babel-loader'],\n        exclude: /node-modules/\n      }\n    ]\n  },\n  plugins: [\n    new HTMLWebpackPlugin({\n      inject: true, // 所有js脚本放于body之后\n      hash: true, // 为静态资源生成hash，用于清楚缓存\n      cache: true, // 仅在文件被更改时发出文件\n      title: 'react admin',\n      filename: 'index.html',\n      template: path.resolve(__dirname, 'index.html'),\n      minify: {\n        collapseWhitespace: true, // 折叠空白\n        removeComments: true, // 删除注释\n        removeRedundantAttributes: true,\n        removeScriptTypeAttributes: true,\n        removeStyleLinkTypeAttributes: true\n      }\n    }),\n    new CleanWebpackPlugin()\n  ]\n}\n</code></pre>\n<ul>\n<li>配置完成之后我们简单做个测试，在app.jsx目录下新建app.less文件，并简单书写样式</li>\n</ul>\n<pre><code class=\"language-css\">.red{\n  color: red;\n  .blue{\n    background: blue;\n  }\n  .orange{\n    background: orange;\n  }\n}\n</code></pre>\n<ul>\n<li>修改app.jsx中的渲染内容为</li>\n</ul>\n<pre><code class=\"language-js\">import * as React from 'react'\nimport './app.less'\n\nclass App extends React.Component{\n  render(){\n    return (\n      &#x3C;div className=\"red\">\n        &#x3C;div className=\"blue\">123&#x3C;/div>\n        &#x3C;div className=\"orange\">345&#x3C;/div>\n      &#x3C;/div>\n    )\n  }\n}\n\nexport default App\n</code></pre>\n<ul>\n<li>然后执行npm run start,之后打开dist中的index.html，就发现样式已经生效了，然后F12打开开发者工具调试，能查找到对应的div生效样式的所在位置</li>\n<li>上面就完成了一个简单的demo，接下来就是要针对项目做一些配置化了</li>\n</ul>","fields":{"slug":"/react_md_1/"},"frontmatter":{"title":"从零搭建一个react-hooks项目（一）","tags":["react","react hooks","redux","webpack"],"categories":"Webpack"}}},{"node":{"html":"<h1>从零搭建一个react-hooks项目（二）</h1>\n<ul>\n<li>上一篇搭建了基本的webpack项目，可以支持react，less的基本使用，但是没有考虑到项目中的实际情况，例如生产环境的代码混淆，代码压缩，开发环境的热启动等。</li>\n<li>下面我们就针对开发与生产环境的不同需求，对webpack进行下一步的配置</li>\n<li>生产环境的配置与开发环境的配置有很多的不同点，所以我们需要分别建对应的配置文件，在根目录下分别创建 webpack.prod.js（生产配置） 与webpack.dev.js（开发配置）</li>\n<li>然后在package.json中的scripts里新建两个命令，分别是 \"build\": \"webpack --config webpack.prod.js\", \"dev\": \"webpack --config webpack.dev.js\"</li>\n</ul>\n<h2>开发环境的配置</h2>\n<ul>\n<li>先将webpack.config.js中的配置复制到webpack.dev.js中，然后进行我们的基本配置修改</li>\n<li>首先开发中需要对错误进行一个精准定位，所以在配置中开启 devtool: \"inline-source-map\"，如下所示</li>\n<li>css的样式覆盖关系在我们之前的开发中就已经使用了source: map的属性，所以可以在开发环境中继续使用</li>\n</ul>\n<!--more-->\n<pre><code class=\"language-js\">const path = require('path')\nconst webpack = require('webpack')\nconst { CleanWebpackPlugin } = require('clean-webpack-plugin');\nconst HTMLWebpackPlugin = require('html-webpack-plugin')\n\nmodule.exports = {\n  entry: {\n    app: './index.js',\n    test: './index.jsx'\n  },\n  output: {\n    filename: '[name].js',\n    path: path.resolve(__dirname, 'dist'),\n    chunkFilename: '[name].bundle.js'\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.(le|c)ss$/,\n        use: [\n          'style-loader',\n          {\n            loader: 'css-loader',\n            options: {\n              sourceMap: true //是否打开样式查找\n            }\n          },\n          {\n            loader: 'postcss-loader', // 为浏览器加前缀\n            options: {\n              ident: 'postcss',\n              sourceMap: true,\n              plugins: loaders => [\n                require('autoprefixer')({\n                })\n              ]\n            }\n          },\n          {\n            loader: 'less-loader', // 解析样式文件\n            options: {\n              sourceMap: true\n            }\n          }\n        ]\n      },\n      {\n        test: /\\.(js)x?$/,\n        use: ['babel-loader'],\n        exclude: /node-modules/\n      }\n    ]\n  },\n  devtool: 'inline-source-map',\n  plugins: [\n    new HTMLWebpackPlugin({\n      inject: true, // 所有js脚本放于body之后\n      hash: true, // 为静态资源生成hash，用于清楚缓存\n      cache: true, // 仅在文件被更改时发出文件\n      title: 'react admin',\n      filename: 'index.html',\n      template: path.resolve(__dirname, 'index.html'),\n      minify: {\n        collapseWhitespace: true, // 折叠空白\n        removeComments: true, // 删除注释\n        removeRedundantAttributes: true,\n        removeScriptTypeAttributes: true,\n        removeStyleLinkTypeAttributes: true\n      }\n    }),\n    new CleanWebpackPlugin()\n  ]\n}\n</code></pre>\n<ul>\n<li>接着在我们的开发过程中我们不希望每做一次改动都需要手动的执行一次npm run dev，所以我们这里使用我们的webpack-dev-server来为我们提供node的静态服务，配合webpack的打包可以让我们实现实时更新，实时显示，不需要手动触发npm run dev命令来进行刷新</li>\n<li>首先我们修改package.json中的dev命令为:\"webpack-dev-server --open --config webpack.dev.js\"</li>\n<li>接下来就需要对该静态服务进行配置，配置项放在配置中的devServer下面，如下</li>\n</ul>\n<pre><code class=\"language-js\">const path = require('path')\nconst webpack = require('webpack')\nconst { CleanWebpackPlugin } = require('clean-webpack-plugin');\nconst HTMLWebpackPlugin = require('html-webpack-plugin')\n\nmodule.exports = {\n  entry: {\n    ...\n  },\n  output: {\n    ...\n  },\n  module: {\n    ...\n  },\n  devtool: 'inline-source-map',\n  plugins: [\n    ...\n  ],\n  devServer: {\n    contentBase: './dist', // 静态文件目录，用于浏览器显示\n    clientLogLevel: 'warning',  // 输出日志级别\n    hot: true, // 启动热更新\n    publicPath: '/', // 浏览器访问路径\n    compress: true, // 启用gzip压缩\n    port: 9998,\n    open: true, // 自动调起浏览器\n    overlay: { // 出现错误或警告是否覆盖页面线上错误信息\n      warnings: true,\n      errors: true\n    },\n    quiet: true,\n    proxy: { // 代理\n    },\n    watchOptions: { // 监控文件相关配置\n      poll: true,\n      ignored: /node_modules/,\n      aggregateTimeout: 300  // 默认值, 当你连续改动时候, webpack可以设置构建延迟时间(防抖)\n    }\n  }\n}\n</code></pre>\n<ul>\n<li>然后在执行我们的npm run dev就可以发现会自动帮我们打开浏览器，然后当我们修改主要文件的时候也会重新帮我们刷新页面</li>\n<li>上面的自动刷新在某些场景下会有一些问题，当依赖的模块发生改变时可能当前的页面绑定关系不能即时刷新，所以我们需要引入新的模块来进行问题修复</li>\n<li>webpack 自带模块热替换插件 HotModuleReplacementPlugin ，使用时只需要引入webpack，然后在plugin中添加 new webpack.HotModuleReplacementPlugin()即可解决部分依赖刷新不及时的问题，如下</li>\n</ul>\n<pre><code class=\"language-js\">...\nconst webpack = require('webpack')\n\nmodule.exports = {\n  entry: {\n    ...\n  },\n  output: {\n    ...\n  },\n  module: {\n    ...\n  },\n  devtool: 'inline-source-map',\n  plugins: [\n    new webpack.HotModuleReplacementPlugin(),\n    ...\n  ],\n  devServer: {\n    ...\n  }\n}\n</code></pre>\n<ul>\n<li>再次执行npm run dev就能实时的更改代码并实时刷新了，至此，开发环境的基本配置就完成了</li>\n</ul>\n<h2>生产环境的构建</h2>\n<ul>\n<li>生产环境为了客户的体验与代码的隐私性，我们一般都会对代码进行混淆压缩，包括css与js代码的压缩，下面我们就来进行相关的配置</li>\n<li>首先还是将我们之前的webpack.config.js中的基本配置复制到webpack.prod.js中，然后在此基础上进行相关的修改</li>\n<li>上一章中我们将output中的filename命名为[name].js与入口文件一致，在生产环境中，为了避免名称一致导致的缓存问题，我们要对其进行修改</li>\n<li>修改为[name].[chunkhash].js，这样在生成文件的时候会默认添加一个hash值，避免缓存问题的出现，修改如下</li>\n</ul>\n<pre><code class=\"language-js\">// 先贴一下上一章最后的配置内容，后续不再完整展示\nconst path = require('path')\nconst webpack = require('webpack')\nconst { CleanWebpackPlugin } = require('clean-webpack-plugin');\nconst HTMLWebpackPlugin = require('html-webpack-plugin')\n\nmodule.exports = {\n  entry: {\n    app: './index.js',\n    test: './index.jsx'\n  },\n  output: {\n    filename: '[name].[chunkhash].js',\n    path: path.resolve(__dirname, 'dist'),\n    chunkFilename: '[name].bundle.js'\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.(le|c)ss$/,\n        use: [\n          'style-loader',\n          {\n            loader: 'css-loader',\n            options: {\n              sourceMap: true //是否打开样式查找\n            }\n          },\n          {\n            loader: 'postcss-loader', // 为浏览器加前缀\n            options: {\n              ident: 'postcss',\n              sourceMap: true,\n              plugins: loaders => [\n                require('autoprefixer')({\n                })\n              ]\n            }\n          },\n          {\n            loader: 'less-loader', // 解析样式文件\n            options: {\n              sourceMap: true\n            }\n          }\n        ]\n      },\n      {\n        test: /\\.(js)x?$/,\n        use: ['babel-loader'],\n        exclude: /node-modules/\n      }\n    ]\n  },\n  plugins: [\n    new HTMLWebpackPlugin({\n      inject: true, // 所有js脚本放于body之后\n      hash: true, // 为静态资源生成hash，用于清楚缓存\n      cache: true, // 仅在文件被更改时发出文件\n      title: 'react admin',\n      filename: 'index.html',\n      template: path.resolve(__dirname, 'index.html'),\n      minify: {\n        collapseWhitespace: true, // 折叠空白\n        removeComments: true, // 删除注释\n        removeRedundantAttributes: true,\n        removeScriptTypeAttributes: true,\n        removeStyleLinkTypeAttributes: true\n      }\n    }),\n    new CleanWebpackPlugin()\n  ]\n}\n</code></pre>\n<ul>\n<li>执行npm run build之后打开dist文件夹发现生成的文件都会带一串乱码，这样就避免了线上缓存的问题</li>\n<li>接下来我们需要打开完整的错误调试，方便线上查找问题，还是修改devtool为source-map即可，如下</li>\n</ul>\n<pre><code class=\"language-js\">...\n\nmodule.exports = {\n  entry: {\n    ...\n  },\n  devtool: 'source-map',\n  output: {\n    ...\n  },\n  ...\n}\n</code></pre>\n<ul>\n<li>然后我们尝试在index.js中主动抛出错误，执行npm run build后在浏览器点击错误就可以定位到相关错误的地方，便于错误排查</li>\n<li>然后我们就需要进行代码的压缩混淆，减少代码体积，先对js进行代码压缩，这里我们需要引用插件 terser-webpack-plugin ，先进行下载，命令为： cnpm i terser-webpack-plugin -D ，然后在配置文件中进行相关配置，如下</li>\n</ul>\n<pre><code class=\"language-js\">const path = require('path')\nconst webpack = require('webpack')\nconst { CleanWebpackPlugin } = require('clean-webpack-plugin');\nconst HTMLWebpackPlugin = require('html-webpack-plugin')\nconst TerserWebpackPlugin = require('terser-webpack-plugin')\n\nmodule.exports = {\n  entry: {\n    ...\n  },\n  devtool: 'source-map',\n  output: {\n    ...\n  },\n  module: {\n    ...\n  },\n  plugins: [\n    ...\n  ],\n  optimization: {\n    minimizer: [\n      // js压缩\n      new TerserWebpackPlugin({\n        cache: true, // 启用文件缓存\n        parallel: true, // 多线程调用\n        sourceMap: true // 错误排查\n      }),\n    ]\n  }\n}\n</code></pre>\n<ul>\n<li>接下来就是对css文件的打包进行处理，首先我们要将css文件给单独打包出来，我们可以观察到之前打包出来的文件其实是没有css文件的，因为webpack把所有的文件都打到一个文件里面了，所以我们没办法看到它，这其实对最后的生成的项目并不友好，所以我们先要在打包中将css抽离出来，这里我们就需要一个新的包 mini-css-extract-plugin ，还是使用npm下载此包： npm i mini-css-extract-plugin -D，然后在loader中将其配置起来</li>\n<li>首先我们在页面中引用该插件，然后将style-loader替换为它提供的loader，然后在plugins中进行css抽离的命名规则配置，为避免缓存问题，我们还是采用hash值进行命名，配置如下</li>\n</ul>\n<pre><code class=\"language-js\">...\nconst MiniCssExtractPlugin = require('mini-css-extract-plugin')\n\nmodule.exports = {\n  entry: {\n    ...\n  },\n  devtool: 'source-map',\n  output: {\n    ...\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.(le|c)ss$/,\n        use: [\n          MiniCssExtractPlugin.loader, // 替换了原来的style-loader\n          {\n            loader: 'css-loader',\n            options: {\n              sourceMap: true //是否打开样式查找\n            }\n          },\n          {\n            loader: 'postcss-loader', // 为浏览器加前缀\n            options: {\n              ident: 'postcss',\n              sourceMap: true,\n              plugins: loaders => [\n                require('autoprefixer')({\n                })\n              ]\n            }\n          },\n          {\n            loader: 'less-loader', // 解析样式文件\n            options: {\n              sourceMap: true\n            }\n          }\n        ]\n      },\n      ...\n    ]\n  },\n  plugins: [\n    new MiniCssExtractPlugin({// 将css打包成单独的css文件\n      filename: '[name].[hash:5].css',\n      chunkFilename: '[id].[hash:5].css'\n    }),\n    ...\n  ]\n  \n}\n</code></pre>\n<ul>\n<li>然后在运行npm run build就可以发现我们打出来的文件中出现了app.xxxxx.css的文件</li>\n<li>接下来我们就要对css进行压缩了，css的压缩需要使用 optimize-css-assets-webpack-plugin 插件，还是npm下载该插件 npm i optimize-css-assets-webpack-plugin -D，然后在webpack中进行相关配置，跟js的配置一样，需要放置在optimization 下的 minimizer 中，如下</li>\n</ul>\n<pre><code class=\"language-js\">const path = require('path')\nconst webpack = require('webpack')\nconst { CleanWebpackPlugin } = require('clean-webpack-plugin');\nconst HTMLWebpackPlugin = require('html-webpack-plugin')\nconst TerserWebpackPlugin = require('terser-webpack-plugin')\nconst MiniCssExtractPlugin = require('mini-css-extract-plugin')\nconst OptimizeCssAssetsWebpackPlugin = require('optimize-css-assets-webpack-plugin')\n\nmodule.exports = {\n  entry: {\n    ...\n  },\n  devtool: 'source-map',\n  output: {\n    ...\n  },\n  module: {\n    ...\n  },\n  plugins: [\n    ...\n  ],\n  optimization: {\n    minimizer: [\n      // js压缩\n      new TerserWebpackPlugin({\n        cache: true, // 启用文件缓存\n        parallel: true, // 多线程调用\n        sourceMap: true // 错误排查\n      }),\n      new OptimizeCssAssetsWebpackPlugin({}) // css压缩\n    ]\n  }\n}\n</code></pre>\n<ul>\n<li>到这我们就基本完成了开发与生产环境的各自配置，接下来我们就继续对项目需要进行相应的处理</li>\n<li>观察上面的开发与生产配置，其实还是有一部分的公用配置可以抽离出来，这里我们采用webpack-merge包来将其公共配置分离出来</li>\n<li>还是先下载该包：npm i webpack-merge -D</li>\n<li>然后在根目录新建一个webpack.common.js用来放置我们的公共配置</li>\n<li>观察开发与生产配置，抽离公共的配置如下</li>\n</ul>\n<pre><code class=\"language-js\">// webpack.common.js\nconst path = require('path')\nconst HtmlWebpackPlugin = require('html-webpack-plugin')\nconst { CleanWebpackPlugin } = require('clean-webpack-plugin')\nmodule.exports = {\n  entry: {\n    app: './index.js',\n    test: './index.jsx'\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.(|js)x?$/,\n        use: ['babel-loader'],\n        exclude: /node-modules/\n      }\n    ]\n  },\n  plugins: [\n    new HtmlWebpackPlugin({\n      inject: true, // 所有js脚本放于body之后\n      hash: true, // 为静态资源生成hash，用于清楚缓存\n      cache: true, // 仅在文件被更改时发出文件\n      title: 'react admin',\n      filename: 'index.html',\n      template: path.resolve(__dirname, 'index.html'),\n      minify: {\n        collapseWhitespace: true, // 折叠空白\n        removeComments: true, // 删除注释\n        removeRedundantAttributes: true,\n        removeScriptTypeAttributes: true,\n        removeStyleLinkTypeAttributes: true\n      }\n    }),\n    new CleanWebpackPlugin(),\n  ]\n}\n</code></pre>\n<ul>\n<li>之前我们的配置中没有进行代码块的抽离，这里我们也简单的进行一下补充，加一组配置即可，这个是开发与生产公用的，所以我们也加到上面的配置中，如下</li>\n</ul>\n<pre><code class=\"language-js\">// webpack.common.js\nconst path = require('path')\nconst HtmlWebpackPlugin = require('html-webpack-plugin')\nconst { CleanWebpackPlugin } = require('clean-webpack-plugin')\nmodule.exports = {\n  entry: {\n    app: './index.js',\n    test: './index.jsx'\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.(|js)x?$/,\n        use: ['babel-loader'],\n        exclude: /node-modules/\n      }\n    ]\n  },\n  plugins: [\n    new HtmlWebpackPlugin({\n      inject: true, // 所有js脚本放于body之后\n      hash: true, // 为静态资源生成hash，用于清楚缓存\n      cache: true, // 仅在文件被更改时发出文件\n      title: 'react admin',\n      filename: 'index.html',\n      template: path.resolve(__dirname, 'index.html'),\n      minify: {\n        collapseWhitespace: true, // 折叠空白\n        removeComments: true, // 删除注释\n        removeRedundantAttributes: true,\n        removeScriptTypeAttributes: true,\n        removeStyleLinkTypeAttributes: true\n      }\n    }),\n    new CleanWebpackPlugin(),\n  ],\n  optimization: { // 公共代码抽离\n    splitChunks:{ //启动代码分割，有默认配置项\n      chunks: 'all'\n    }\n  }\n}\n</code></pre>\n<ul>\n<li>这样便配置了我们的代码分割功能，然后就开始继续配置我们的生产与开发配置了</li>\n<li>然后修改webpack.dev.js，先在webpack.dev.js中引入webpack-merge与webpack.common.js，然后进行合并，因为css中的loader与生产环境不一致所以没有抽离，现在的webpack还需要给配置指定mode，取值为production或者deveopment，我们这里为开发配置，所以新增一个字段mode: 'development',最终如下</li>\n</ul>\n<pre><code class=\"language-js\">// webpack.dev.js\nconst path = require('path')\nconst webpack = require('webpack')\nconst merge = require('webpack-merge')\nconst common = require('./webpack.common.js')\n\nmodule.exports = merge(common, {\n  mode: 'development',\n  output: {\n    filename: '[name].js',\n    path: path.resolve(__dirname, 'dist'),\n    chunkFilename: '[name].bundle.js'\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.(le|c)ss$/,\n        use: [\n          'style-loader',\n          {\n            loader: 'css-loader',\n            options: {\n              sourceMap: true //是否打开样式查找\n            }\n          },\n          {\n            loader: 'postcss-loader', // 为浏览器加前缀\n            options: {\n              ident: 'postcss',\n              sourceMap: true,\n              plugins: loaders => [\n                require('autoprefixer')({\n                })\n              ]\n            }\n          },\n          {\n            loader: 'less-loader', // 解析样式文件\n            options: {\n              sourceMap: true\n            }\n          }\n        ]\n      }\n    ]\n  },\n  devtool: 'inline-source-map',\n  plugins: [\n    new webpack.HotModuleReplacementPlugin(), // 模块热替换\n    new webpack.NamedModulesPlugin() // 热更新时返回文件名而不是文件id\n  ],\n  devServer: {\n    contentBase: './dist', // 静态文件目录，用于浏览器显示\n    clientLogLevel: 'warning',  // 输出日志级别\n    hot: true, // 启动热更新\n    publicPath: '/', // 浏览器访问路径\n    compress: true, // 启用gzip压缩\n    port: 8822,\n    open: true, // 自动调起浏览器\n    overlay: { // 出现错误或警告是否覆盖页面线上错误信息\n      warnings: true,\n      errors: true\n    },\n    quiet: true,\n    proxy: { // 代理\n    },\n    watchOptions: { // 监控文件相关配置\n      poll: true,\n      ignored: /node_modules/,\n      aggregateTimeout: 300  // 默认值, 当你连续改动时候, webpack可以设置构建延迟时间(防抖)\n    }\n  }\n})\n</code></pre>\n<ul>\n<li>再运行npm run dev能够发现跟抽离之前的配置是一样的，接下来我们对生产配置也进行一个合并，然后新增一个mode: production</li>\n<li>同样是引入webpack-merge与webpack.common.js，然后进行合并，如下</li>\n</ul>\n<pre><code class=\"language-js\">// webpack.prod.js\nconst path = require('path')\nconst TerserWebpackPlugin = require('terser-webpack-plugin')\nconst MiniCssExtractPlugin = require('mini-css-extract-plugin')\nconst OptimizeCssAssetsWebpackPlugin = require('optimize-css-assets-webpack-plugin')\nconst merge = require('webpack-merge')\nconst common = require('./webpack.common.js')\n\nmodule.exports = merge(common, {\n  mode: 'production',\n  devtool: 'source-map',\n  output: {\n    filename: '[name].[chunkhash].js',\n    path: path.resolve(__dirname, 'dist'),\n    chunkFilename: '[name].bundle.js'\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.(le|c)ss$/,\n        use: [\n          MiniCssExtractPlugin.loader,\n          {\n            loader: 'css-loader',\n            options: {\n              sourceMap: true //是否打开样式查找\n            }\n          },\n          {\n            loader: 'postcss-loader', // 为浏览器加前缀\n            options: {\n              ident: 'postcss',\n              sourceMap: true,\n              plugins: loaders => [\n                require('autoprefixer')({\n                })\n              ]\n            }\n          },\n          {\n            loader: 'less-loader', // 解析样式文件\n            options: {\n              sourceMap: true\n            }\n          }\n        ]\n      }\n    ]\n  },\n  plugins: [\n    new MiniCssExtractPlugin({// 将css打包成单独的css文件\n      filename: '[name].[hash:5].css',\n      chunkFilename: '[id].[hash:5].css'\n    }),\n  ],\n  optimization: {\n    minimizer: [\n      // js压缩\n      new TerserWebpackPlugin({\n        cache: true, // 启用文件缓存\n        parallel: true, // 多线程调用\n        sourceMap: true // 错误排查\n      }),\n      new OptimizeCssAssetsWebpackPlugin({}) // css压缩\n    ]\n  }\n})\n</code></pre>\n<ul>\n<li>上面就完成了生产与开发环境的配置，但是之前的配置还有部分遗漏，一个是在开发环境没有配置css的抽离规则，一个是没有配置react开发中的图片资源加载跟字体库与icon</li>\n<li>下面我们就先针对开发环境的css进行一个处理，之前我们在运行webpack的时候是没办法区分开发与生产环境的，所以我们现在在webpack的命令中设置环境变量，用以区分开发还是生产环境，我们先引用cross-env的包，用于各平台设置环境变量的兼容，命令为 npm i cross-env -D</li>\n<li>然后修改package.json中的启动命令为 \"dev\": \"cross-env NODE<em>ENV=development webpack-dev-server --open --config webpack.dev.js\",  \"build\": \"cross-env NODE</em>ENV=production webpack --config webpack.prod.js\" 然后在webpack.common.js中打印process.env.NODE<em>ENV，然后可以观察到在npm run dev的命令下process.env.NODE</em>ENV是'development'， npm run build 的命令下 process.env.NODE_ENV是'production'，由此，我们来配置css的抽离规则，先将之前配置在webpack.prod.js中的css打包配置删除，然后在webpack.common.js中新增如下配置</li>\n</ul>\n<pre><code class=\"language-js\">// webpack.common.js\nconst path = require('path')\nconst HtmlWebpackPlugin = require('html-webpack-plugin')\nconst { CleanWebpackPlugin } = require('clean-webpack-plugin')\nconst MiniCssExtractPlugin = require('mini-css-extract-plugin')\nconst devMode = process.env.NODE_ENV === 'development' // 命令行设置的值\nconsole.log(devMode)\nmodule.exports = {\n  entry: {\n    ...\n  },\n  module: {\n    ...\n  },\n  plugins: [\n    new MiniCssExtractPlugin({// 将css打包成单独的css文件，在开发与生成生成不同的css\n      filename: devMode ? '[name].css' : '[name].[hash:5].css',\n      chunkFilename: devMode ? '[id].css' : '[id].[hash:5].css'\n    }),\n    ...\n  ]\n}\n</code></pre>\n<ul>\n<li>接下来我们要对图片进行处理，在开发中我们会经常根据当前文件的相对路径来引入图片资源，但是我们的打包又是基于入口文件的，所以经常会导致最后的图片引用路径错误，这里我们就要使用url-loader来帮我们进行图片路径处理，会将我们的引用路径替换为打包后的文件路径。</li>\n<li>url-loader还对我们提供了图片转dataUrl的功能，这样就可以将图片转为dataUrl的路径直接引入，避免了网络请求，但是图片过大的时候会影响我们的编码速率，这种时候还是应该使用网络图片请求。url-loader中的limit就是控制多大的图片以内转为dataUrl，大于该限制的就引用图片地址访问。</li>\n<li>同样，我们还是先下载url-loader的相关包， npm i url-loader file-loader -D</li>\n<li>下面我们就对各格式的图片进行配置，这部分配置生产与开发都要使用，因此在webpack.common.js下配置，配置如下</li>\n</ul>\n<pre><code class=\"language-js\">// webpack.common.js\n...\nmodule.exports = {\n  entry: {\n    ...\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.(jpg|png|gif|svg)$/,\n        use: [\n          {\n            loader: 'url-loader',\n            options: {\n              limit: 10000,\n              name: '[name]-[hash:5].[ext]',\n              outputPath: 'img/'\n            }\n          }\n        ]\n      }\n      ...\n    ]\n  },\n  plugins: [\n    ...\n  ]\n}\n</code></pre>\n<ul>\n<li>这样当图片在10k以内的时候我们就会将其转为dataUrl的路径引入，并且将图片统一放到img文件夹下</li>\n<li>webpack还为我们提供了图片的压缩功能，方便缩小我们的项目体积，需要使用 image-webpack-loader 来进行配置，还是先下载该包 npm i image-webpack-loader -D</li>\n<li>然后在开发与生产都需要进行相关的配置，所以还是在 webpack.common.js 进行配置，配置如下</li>\n</ul>\n<pre><code class=\"language-js\">// webpack.common.js\n...\nmodule.exports = {\n  entry: {\n    ...\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.(jpg|png|gif|svg)$/,\n        use: [\n          {\n            loader: 'url-loader',\n            options: {\n              limit: 10000,\n              name: '[name]-[hash:5].[ext]',\n              outputPath: 'img/'\n            }\n          },\n          {\n            loader: 'image-webpack-loader',\n            options: {\n              mozjpeg: {\n                progressive: true,\n                quality: 65\n              },\n              optipng: {\n                enabled: false\n              },\n              pngquant: {\n                quality: [0.65, 0.9],\n                speed: 4\n              },\n              gifsicle: {\n                interlaced: false\n              },\n              webp: {\n                quality: 75\n              }\n            }\n          }\n        ]\n      }\n    ]\n  },\n  plugins: [\n    ...\n  ]\n}\n</code></pre>\n<ul>\n<li>上面就完成了开发中图片的相关配置，接下来配置一下字体库，还是使用url-loader，配置规则跟图片的一致，如下</li>\n</ul>\n<pre><code class=\"language-js\">...\nmodule.exports = {\n  entry: {\n    ...\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.(woff2?|eot|ttf|otf)(\\?.*)?$/,\n        use: [\n          {\n            loader: 'url-loader',\n            options: {\n              // 文件大小小于limit参数，url-loader将会把文件转为DataUR\n              limit: 10000,\n              name: '[name]-[hash:5].[ext]',\n              ourput: 'fonts/'\n            }\n          }\n        ],\n      },\n    ]\n  },\n  plugins: [\n    ...\n  ]\n}\n</code></pre>\n<ul>\n<li>如上就完成了咱们项目的前期配置，单纯使用react已经没有什么问题了，这一章的配置就到这吧，下面把各个配置文件都贴一下，当然也可以选择源码查看，地址是 <a href=\"https://github.com/mf950511/react-admin\">react-admin</a></li>\n<li>下一章我们进行typeScript的配置，之后就开始正式进行项目开发</li>\n</ul>\n<pre><code class=\"language-js\">// webpack.common.js\nconst path = require('path')\nconst HtmlWebpackPlugin = require('html-webpack-plugin')\nconst { CleanWebpackPlugin } = require('clean-webpack-plugin')\nconst MiniCssExtractPlugin = require('mini-css-extract-plugin')\nconst devMode = process.env.NODE_ENV === 'development'\nconsole.log(devMode)\nmodule.exports = {\n  entry: {\n    app: './index.js',\n    test: './index.jsx'\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.(jpg|png|gif|svg)$/,\n        use: [\n          {\n            loader: 'url-loader',\n            options: {\n              limit: 10000,\n              name: '[name]-[hash:5].[ext]',\n              outputPath: 'img/'\n            }\n          },\n          {\n            loader: 'image-webpack-loader',\n            options: {\n              mozjpeg: {\n                progressive: true,\n                quality: 65\n              },\n              optipng: {\n                enabled: false\n              },\n              pngquant: {\n                quality: [0.65, 0.9],\n                speed: 4\n              },\n              gifsicle: {\n                interlaced: false\n              },\n              webp: {\n                quality: 75\n              }\n            }\n          }\n        ]\n      },\n      {\n        test: /\\.(woff2?|eot|ttf|otf)(\\?.*)?$/,\n        use: [\n          {\n            loader: 'url-loader',\n            options: {\n              // 文件大小小于limit参数，url-loader将会把文件转为DataUR\n              limit: 10000,\n              name: '[name]-[hash:5].[ext]',\n              ourput: 'fonts/'\n            }\n          }\n        ],\n      },\n      {\n        test: /\\.(js)x?$/,\n        use: ['babel-loader'],\n        exclude: /node-modules/\n      }\n    ]\n  },\n  plugins: [\n    new MiniCssExtractPlugin({// 将css打包成单独的css文件\n      filename: devMode ? '[name].css' : '[name].[hash:5].css',\n      chunkFilename: devMode ? '[id].css' : '[id].[hash:5].css'\n    }),\n    new HtmlWebpackPlugin({\n      inject: true, // 所有js脚本放于body之后\n      hash: true, // 为静态资源生成hash，用于清楚缓存\n      cache: true, // 仅在文件被更改时发出文件\n      title: 'react admin',\n      filename: 'index.html',\n      template: path.resolve(__dirname, 'index.html'),\n      minify: {\n        collapseWhitespace: true, // 折叠空白\n        removeComments: true, // 删除注释\n        removeRedundantAttributes: true,\n        removeScriptTypeAttributes: true,\n        removeStyleLinkTypeAttributes: true\n      }\n    }),\n    new CleanWebpackPlugin(),\n  ],\n  optimization: { // 公共代码抽离\n    splitChunks:{ //启动代码分割，有默认配置项\n      chunks: 'all'\n    }\n  }\n}\n\n// webpack.dev.js\nconst path = require('path')\nconst webpack = require('webpack')\nconst merge = require('webpack-merge')\nconst common = require('./webpack.common.js')\n\nmodule.exports = merge(common, {\n  output: {\n    filename: '[name].js',\n    path: path.resolve(__dirname, 'dist'),\n    chunkFilename: '[name].bundle.js'\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.(le|c)ss$/,\n        use: [\n          'style-loader',\n          {\n            loader: 'css-loader',\n            options: {\n              sourceMap: true //是否打开样式查找\n            }\n          },\n          {\n            loader: 'postcss-loader', // 为浏览器加前缀\n            options: {\n              ident: 'postcss',\n              sourceMap: true,\n              plugins: loaders => [\n                require('autoprefixer')({\n                })\n              ]\n            }\n          },\n          {\n            loader: 'less-loader', // 解析样式文件\n            options: {\n              sourceMap: true\n            }\n          }\n        ]\n      }\n    ]\n  },\n  devtool: 'inline-source-map',\n  plugins: [\n    new webpack.HotModuleReplacementPlugin(),\n    new webpack.NamedModulesPlugin()\n  ],\n  devServer: {\n    contentBase: './dist', // 静态文件目录，用于浏览器显示\n    // clientLogLevel: 'warning',  // 输出日志级别\n    hot: true, // 启动热更新\n    publicPath: '/', // 浏览器访问路径\n    compress: true, // 启用gzip压缩\n    port: 8822,\n    open: true, // 自动调起浏览器\n    overlay: { // 出现错误或警告是否覆盖页面线上错误信息\n      warnings: true,\n      errors: true\n    },\n    quiet: true,\n    proxy: { // 代理\n    },\n    watchOptions: { // 监控文件相关配置\n      poll: true,\n      ignored: /node_modules/,\n      aggregateTimeout: 300  // 默认值, 当你连续改动时候, webpack可以设置构建延迟时间(防抖)\n    }\n  }\n})\n\n// webpack.prod.js\nconst path = require('path')\nconst TerserWebpackPlugin = require('terser-webpack-plugin')\nconst OptimizeCssAssetsWebpackPlugin = require('optimize-css-assets-webpack-plugin')\nconst merge = require('webpack-merge')\nconst common = require('./webpack.common.js')\nconst BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin;\nconst MiniCssExtractPlugin = require('mini-css-extract-plugin')\n\nmodule.exports = merge(common, {\n  devtool: 'source-map',\n  output: {\n    filename: '[name].[chunkhash].js',\n    path: path.resolve(__dirname, 'dist'),\n    chunkFilename: '[name].bundle.js'\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.(le|c)ss$/,\n        use: [\n          MiniCssExtractPlugin.loader,\n          {\n            loader: 'css-loader',\n            options: {\n              sourceMap: true //是否打开样式查找\n            }\n          },\n          {\n            loader: 'postcss-loader', // 为浏览器加前缀\n            options: {\n              ident: 'postcss',\n              sourceMap: true,\n              plugins: loaders => [\n                require('autoprefixer')({\n                })\n              ]\n            }\n          },\n          {\n            loader: 'less-loader', // 解析样式文件\n            options: {\n              sourceMap: true\n            }\n          }\n        ]\n      }\n    ]\n  },\n  plugins: [\n    new BundleAnalyzerPlugin({\n      analyzerMode: 'server',\n      analyzerHost: '127.0.0.1',\n      analyzerPort: 7778,\n      reportFilename: 'report.html',\n      defaultSizes: 'parsed',\n      openAnalyzer: true,\n      generateStatsFile: false,\n      statsFilename: 'stats.json',\n      statsOptions: null,\n      logLevel: 'info'\n    }),\n  ],\n  optimization: {\n    minimizer: [\n      // js压缩\n      new TerserWebpackPlugin({\n        cache: true, // 启用文件缓存\n        parallel: true, // 多线程调用\n        sourceMap: true // 错误排查\n      }),\n      new OptimizeCssAssetsWebpackPlugin({}) // css压缩\n    ]\n  }\n})\n</code></pre>","fields":{"slug":"/react_md_2/"},"frontmatter":{"title":"从零搭建一个react-hooks项目（二）","tags":["react","react hooks","redux","webpack"],"categories":"Webpack"}}},{"node":{"html":"<h1>从零搭建一个react-hooks项目（三）</h1>\n<ul>\n<li>上一篇我们配置了项目相关，包括代码压缩混淆，开发生产配置抽离，图片与文字的引入使用等</li>\n<li>接下来我们就配置一下react-router，react-redux与typescript</li>\n<li>配置之前我们先补充一下webpack的部分配置，用于方便我们的开发</li>\n<li>在webpack.common.js中配置webpack的查找规则，也就是resolve，如下</li>\n</ul>\n<!--more-->\n<pre><code class=\"language-js\">...\nmodule.exports = {\n  entry: {\n    ...\n  },\n  module: {\n    ...\n  },\n  resolve: {\n    extensions: ['.jsx', '.js', '.json'],\n    alias: {\n      \"@\": path.resolve(__dirname, 'src')\n    }\n  },\n  plugins: [\n    ...\n  ],\n  optimization: { // 公共代码抽离\n    ...\n  }\n}\n</code></pre>\n<ul>\n<li>上面新增了一个resolve的解析规则，使webpack方便查找，第一个extensions中的配置表示我们在引入后缀为.jsx,.js,.json的文件时，可以直接写文件名而不用加后缀，比如引入'./index.jsx'，我们就可以直接写为'./index'</li>\n<li>下面的alias就是别名配置，用于在引入路径时方便使用，比如我们在项目中有如下的代码结构</li>\n</ul>\n<pre><code class=\"language-js\">src \n├── lib \n│ └── utils.js \n└── pages \n└── demo \n└── index.js\n</code></pre>\n<ul>\n<li>在 src/pages/demo/index.js 中如果要引用 src/lib/utils.js 那么可以通过：import utils from '../../lib/utils' ，如果目录更深一些，会越来越难看，这时可以通过设置 alias 来缩短这种写法，例如：</li>\n</ul>\n<pre><code class=\"language-js\">module.exports = {\n  resolve: {\n      '@': path.resolve(__dirname, 'src'),\n      '@lib': path.resolve(__dirname, 'src/lib')\n  }\n}\n</code></pre>\n<ul>\n<li>这样我们就可以直接使用 '@lib/utils'来进行文件的引入了</li>\n</ul>\n<h2>react-router的使用</h2>\n<ul>\n<li>配置完resolve之后我们就开始进行react-router的配置了，还是先下载react-router-dom模块，命令为： npm i react-router-dom -S</li>\n<li>然后在src下新建两个页面，pages/login.jsx与pages/home.jsx作为我们的路由页面</li>\n</ul>\n<pre><code class=\"language-js\">// pages/home.jsx\nimport React from 'react'\nconst Home = () => {\n  return (\n    &#x3C;div>我是首页&#x3C;/div>\n  )\n}\nexport default Home\n\n// pages/login.jsx\nimport React from 'react'\nconst Login = () => {\n  return (\n    &#x3C;div>我是登录页&#x3C;/div>\n  )\n}\nexport default Login\n</code></pre>\n<ul>\n<li>接着在src下新建routes/index.jsx文件作为我们的路由管理页面</li>\n<li>在文件内引入react与react-router-dom,然后引入新建的login页面与home页面</li>\n<li>页面代码如下</li>\n</ul>\n<pre><code class=\"language-js\">// routes/index.jsx\nimport React from 'react'\nimport { HashRouter as Router, Route, Switch, Redirect } from 'react-router-dom'\nimport Login from '@/pages/login'\nimport Home from '@/pages/home'\nconst RouteConfig = () => {\n  return (\n    &#x3C;Router>\n      &#x3C;Switch>\n        &#x3C;Route path=\"/home\" component={ Home }>&#x3C;/Route>\n        &#x3C;Route path=\"/login\" component={ Login }>&#x3C;/Route>\n        &#x3C;Redirect to=\"/home\" from=\"/\">&#x3C;/Redirect>\n      &#x3C;/Switch>\n    &#x3C;/Router>\n  )\n}\nexport default RouteConfig\n</code></pre>\n<ul>\n<li>然后在app.jsx里面以组件的形式引入我们的路由即可，如下</li>\n</ul>\n<pre><code class=\"language-js\">// app.jsx\nimport * as React from 'react'\nimport './app.less'\nimport RouteConfig from '@/route/index'\nclass App extends React.Component{\n  render(){\n    return (\n      &#x3C;RouteConfig>&#x3C;/RouteConfig>\n    )\n  }\n}\nexport default App\n</code></pre>\n<ul>\n<li>然后运行npm run dev就能发现自动帮我们定位到/home页面，我们手动修改路由为/login就可以发现页面跳转到了login页面</li>\n<li>至此，我们的react-router就配置完成了</li>\n</ul>\n<h2>react-redux的使用</h2>\n<ul>\n<li>redux是常用的状态管理组件，用于维护全局的数据变量，react项目中自然也需要它的存在，下面我们就配置一下redux</li>\n<li>在react中使用redux需要引入redux与react-redux，还是先安装包： npm i redux react-redux -S</li>\n<li>然后在src下新建文件夹store用于放置我们的redux相关文件</li>\n<li>redux在数据比较复杂的时候会按照模块来放置文件，最后再用redux提供的api组合起来，方便后续的维护，这里我们创立数字模块number与聊天模块chat，分别在store下面建立两个文件夹store/chat与store/number</li>\n<li>在每个文件夹下面建立我们会用到的操作该数据的操作类型与该操作类型下的数据变化情况，分别对应types.js与reducers.js</li>\n<li>先构建store/number下的types与reducers，对外提供加减两个方法，先在types下构建常量用于标识对应的方法</li>\n</ul>\n<pre><code class=\"language-js\">// store/number/types\nexport const INCREMENT = 'INCREMENT'\nexport const DECREMENT = 'DECREMENT'\n</code></pre>\n<ul>\n<li>然后再编写该方法下的数据变化情况reducers，并为这个数字模块设立初始值0，当执行方法为加减的时候就在原基础上加减对应的值，否则就原样返回</li>\n</ul>\n<pre><code class=\"language-js\">// store/number/reducers.js\nimport { INCREMENT, DECREMENT } from './types'\nconst initialState = 0\nconst numberReducer = (state = initialState, action) => {\n  switch(action.type) {\n    case INCREMENT:\n      return state + action.payload\n    case DECREMENT:\n      return state - action.payload\n    default:\n      return state\n  }\n}\nexport default numberReducer\n</code></pre>\n<ul>\n<li>上面就是简单的数字模块的两个方法了，然后我们同样实现一下chat模块的方法</li>\n</ul>\n<pre><code class=\"language-js\">// store/chat/types\nexport const SEND = 'SEND'\nexport const DELETE = 'DELETE'\n\n// store/chat/reducers\nimport { SEND, DELETE } from './types'\n\nconst initialState = []\nconst chatReducer = (state = initialState, action) => {\n  switch(action.type) {\n    case SEND:\n      return [...state, action.payload]\n    case DELETE:\n      return state.length ? state.slice(0, state.length - 1) : []\n    default:\n      return state\n  }\n}\nexport default chatReducer\n</code></pre>\n<ul>\n<li>chat模块提供了一个发送方法与删除方法用于操作聊天列表</li>\n<li>接下来我们就要使用redux提供的combineReducers方法将其合并起来</li>\n<li>在store下新建index.js文件用于最后的导出</li>\n<li>在index.js中引入combineReducers，chat模块，number模块，然后合并并导出，如下</li>\n</ul>\n<pre><code class=\"language-js\">// store/index.js\nimport { combineReducers } from 'redux'\nimport ChatReducer from './chat/reducers'\nimport NumberReducer from './number/reducer'\n\nconst rootReducer = combineReducers({\n  number: NumberReducer,\n  chat: ChatReducer\n})\n\nexport default rootReducer\n</code></pre>\n<ul>\n<li>上面就完成了redux的编写，接下来就要在react根组件上将其使用</li>\n<li>在index.jsx中引入store/index.js，引入redux提供的方法createStore创建全局状态，引入react-redux中的Provider包装根组件，如下</li>\n</ul>\n<pre><code class=\"language-js\">// index.jsx\nimport * as React from 'react'\nimport * as ReactDOM from 'react-dom'\nimport App from './src/app.jsx'\nimport { createStore } from 'redux'\nimport { Provider } from 'react-redux'\nimport RootReducer from '@/store/index'\nconst store = createStore(RootReducer)\nReactDOM.render(\n  &#x3C;Provider store={ store }>\n    &#x3C;App/>\n  &#x3C;/Provider>\n  ,document.querySelector('#app')\n)\n</code></pre>\n<ul>\n<li>上面就在我们的项目中引入了redux，接下来就是使用，我们在login组件中尝试使用number并修改</li>\n<li>在login组件中引入对应的操作方法与react-redux提供的connect方法，然后修改我们的login组件如下</li>\n</ul>\n<pre><code class=\"language-js\">// src/pages/login.jsx\nimport React from 'react'\nimport { connect } from 'react-redux'\nimport { INCREMENT, DECREMENT } from '@/store/number/types'\nconst Login = (props) => {\n  const { number, increment, decrement } = props\n  return (\n    &#x3C;div>\n      &#x3C;button>我是数字{ number }&#x3C;/button>\n      &#x3C;button onClick={() => { increment() } }>点我加10&#x3C;/button>\n      &#x3C;button onClick={() => { decrement() } }>点我减10&#x3C;/button>\n    &#x3C;/div>\n  )\n}\nfunction mapStateToProps(state){ // 将redux中的state整合到props中\n  return {\n    number: state.number \n  }\n}\n\nfunction mapDispatchToProps(dispatch){ // 将操作state的函数整合到props中\n  return {\n    increment: () => dispatch({ type: INCREMENT, payload: 10 }),\n    decrement: () => dispatch({ type: DECREMENT, payload: 10 })\n  }\n}\nexport default connect(mapStateToProps, mapDispatchToProps)(Login)\n</code></pre>\n<ul>\n<li>connect中的第一个参数接受两个函数，分别用于整合state到props中跟整合操作方法到props中，这样我们就可以在页面中使用该方法与该值了</li>\n<li>修改之后我们点击两个按钮就可以看到对应值的变化了</li>\n</ul>\n<h2>react中引入typescript</h2>\n<ul>\n<li>typescript当下如此潮流我们自然也要接入一下啦，下面就是简单的接入过程</li>\n<li>得益于我们强大的babel-7，我们不再需要去单独的使用ts-loader或者awesome-typescript-loader解析ts文件，只需要在babel中进行typescript的相关配置即可</li>\n<li>首先还是先安装我们的typescript与@babel/preset-typescript，命令为： npm i typescript @babel/preset-typescript -D</li>\n<li>然后再.babelrc文件中进行typescript的配置，如下</li>\n</ul>\n<pre><code class=\"language-js\">// .babelrc\n{\n  \"presets\": [\n    \"@babel/preset-env\",\n    \"@babel/preset-react\",\n    \"@babel/preset-rtpescript\", // 处理typescript\n  ],\n  \"plugins\": [\n    \"@babel/proposal-object-rest-spread\", // 处理对象的rest写法\n    \"@babel/proposal-class-properties\" // 处理类里面的箭头函数绑定，static属性等 \n  ]\n}\n</code></pre>\n<ul>\n<li>然后在webpack中对typescript文件配置babel解析即可，这是一个通用配置，所以还是在webpack.common.js上修改，如下</li>\n</ul>\n<pre><code class=\"language-js\">// webpack.common.js\nmodule.exports = {\n  entry: {\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.(js|ts)x?$/, // tsx或者ts文件也使用babel解析\n        use: ['babel-loader'],\n        exclude: /node-modules/\n      }\n    ]\n  },\n  resolve: {\n    extensions: ['.tsx', '.ts', '.jsx', '.js', '.json'], // 添加.tsx与.ts后缀解析\n    alias: {\n      \"@\": path.resolve(__dirname, 'src')\n    }\n  },\n  plugins: [\n    ...\n  ],\n  optimization: { // 公共代码抽离\n    ...\n  }\n}\n</code></pre>\n<ul>\n<li>然后就要配置typescript中的编译规则，在根目录下新建tsconfig.json文件，然后添加如下配置</li>\n</ul>\n<pre><code class=\"language-js\">{\n  \"compilerOptions\": {\n    \"allowSyntheticDefaultImports\": true, // 允许从没有设置默认导出的模块中默认导入。这并不影响代码的输出，仅为了类型检查。\n    \"outDir\": \"./dist/\", // 重定向输出目录\n    \"noImplicitAny\": true,// 在表达式和声明上有隐含的 any类型时报错。（默认为false，个人建议也为false，可以兼容之前的js代码，这里改为true是为了我自己检测哪些类型需要处理）\n    \"module\": \"es6\", // 模块引入方式\n    \"target\": \"esnext\",// 指定ECMAScript目标版本\n    \"jsx\": \"react\", // 在 .tsx文件里支持JSX\n    \"allowJs\": true,\n    \"sourceMap\": true, // 生成相应的 .map文件\n    \"lib\": [\n      \"es2015\",\n      \"dom.iterable\",\n      \"es2016.array.include\",\n      \"es2017.object\",\n      \"dom\"\n    ], // 编译过程中需要引入的库文件的列表。\n    \"moduleResolution\": \"node\",// 用于解析一些加载器，如css-type, source-map \n    \"baseUrl\": \"./src\", // typescript的模块解析基础路径\n    \"paths\": { // 对应的模块解析路径\n      \"store/*\": [\"store/*\"],\n    },\n  },\n  \"include\": [\n    \"src\"\n  ],\n  \"exclude\": [\n    \"./node_modules\"\n  ]\n}\n</code></pre>\n<ul>\n<li>因为我们之前配置了别名，所以需要加上后面的配置中的baseUrl与paths保证typescript能够找到对应的配置，其他的都是typescript的基本配置</li>\n<li>接下来我们尝试将入口文件修改为tsx尝试一下，在webpack.common.js中将入口文件改为app:'index.tsx'，然后再将index.jsx后缀改为tsx，之后运行npm run dev发现报错 can not find module 'react'，就说明我们的typescript已经配置完成了，可以正常检查错误</li>\n<li>上述错误是因为我们在TS中进行的开发，TS并不知道我们的react是什么类型，导出了什么，所以就报错了，这里我们就需要安装react相关的类型文件</li>\n<li>项目中我们使用了react,react-dom,react-redux,react-router-dom这四个依赖，所以我们就需要安装依赖包，命令为：npm i @types/react @types/react-dom @types/react-redux @types/react-router-dom -S</li>\n<li>之后我们再次编译，就发现项目可以正常运行了。</li>\n<li>但是使用上面的配置之后发现，在我们编译过程中类型出错webpack并不会提示我们出错，这是因为babel7中在编译过程会移除typescript，完全以javascript的形式进行打包，详见<a href=\"https://iamturns.com/typescript-babel\">(https://iamturns.com/typescript-babel)</a>。因为，要把babel跟typescript同时编译，两个编译器会导致过程十分缓慢，这可是开发者不能容忍的。针对这种情况，我们可以新建一个命令 \"check\": \"tsc -watch\"，然后使用vscode带给我们的终端启用两个终端，一个运行命令 npm run check，另一个运行命令npm run dev，这样就发现我们在开发中出现的类型错误都会在check的终端对我们进行提示。</li>\n<li>接下来我们只需要将所有的jsx文件转为tsx文件就可以进行typescript的开发了，项目地址<a href=\"https://github.com/mf950511/react-admin\">react-admin</a>，可以自行获取配置进行修改</li>\n</ul>","fields":{"slug":"/react_md_3/"},"frontmatter":{"title":"从零搭建一个react-hooks项目（三）","tags":["react","react hooks","redux","webpack"],"categories":"Webpack"}}},{"node":{"html":"<h1>从零搭建一个react-hooks项目（四）</h1>\n<ul>\n<li>前面我们搭建了基于react与typescript的开发环境，接下来就是我们项目开发中遇到的一些问题处理了</li>\n</ul>\n<h2>图片引入申明报错问题处理</h2>\n<ul>\n<li>之前我们配置了图片引入并且在页面中进行了图片引入，当我们把页面变为ts之后会发现图片引入的地方被标红了，报错为 Cannot find module './image/img.png' or its corresponding type declarations，这里是因为图片类型我们没有为其设定类型文件，所以报错，这种情况下，我们可以在src目录下新建image.d.ts文件来为其进行声名，声明文件如下</li>\n</ul>\n<pre><code class=\"language-js\">// image.d.ts\ndeclare module '*.svg'\ndeclare module '*.png'\ndeclare module '*.jpg'\ndeclare module '*.jpeg'\ndeclare module '*.gif'\ndeclare module '*.bmp'\ndeclare module '*.tiff'\n</code></pre>\n<!--more-->\n<ul>\n<li>这样就能发现我们的ts类型错误消失了</li>\n</ul>\n<h2>非组件页面进行页面跳转</h2>\n<ul>\n<li>传统中使用react-router-dom进行页面跳转需要在页面中获取props，然后props中获取history，然后采用history.push('/home')的形式进行页面跳转</li>\n<li>要是想在别的非组件页面，如request文件或者入口index.tsx中进行页面跳转就需要依赖三方库如history进行页面路由跳转，如下</li>\n</ul>\n<pre><code class=\"language-js\">// index.tsx 这样就实现了在非组件页面中的跳转，页面打开后两秒自动跳转登录\n// 需安装依赖history：npm i history -S\nimport { createHashHistory  } from 'history'\nconst history = createHashHistory() \nsetTimeout(() =>{\n  history.push('/login')\n}, 2000)\n</code></pre>\n<ul>\n<li>我们简单的将该方法封装一下，方便后续的使用，在src文件夹下创建lib/untils.ts文件用于我们的工具函数封装，如下</li>\n</ul>\n<pre><code class=\"language-js\">// src/lib/untils.js\nimport { createHashHistory  } from 'history'\nconst history = createHashHistory() \nexport {\n  history\n}\n\n// index.tsx\nimport { history } from './src/lib/untils'\nsetTimeout(() =>{\n  history.push('/home')\n}, 2000)\n</code></pre>\n<ul>\n<li>这样就可以实现在其他工具页面进行页面跳转了</li>\n</ul>\n<h2>ant4使用icon与动态渲染问题</h2>\n<ul>\n<li>ant4中icon的引用方式发生了变化，需要我们单独引入 @ant-design/icons 包，然后获取Icon名以组件的形式进行引入，这样就存在了一个问题，如何动态的引入icon，比如在后台配置icon名称，在前端进行对应的展示，如首页菜单栏，权限不一，展现不一致</li>\n<li>这种情况我们就只能全量引入icon，如下</li>\n</ul>\n<pre><code class=\"language-js\">import * as Icons from '@ant-design/icons';\n</code></pre>\n<ul>\n<li>然后再指定返回reactNode的方法</li>\n</ul>\n<pre><code class=\"language-js\">interface Icons { // 处理icon的类型\n  [PropName: string]: any\n}\nconst getIcons = (str: string, Icons: Icons) => {\n  const TestBankOutlined = Icons[str]\n  return &#x3C;TestBankOutlined />\n}\n</code></pre>\n<ul>\n<li>之后就是我们的菜单渲染函数</li>\n</ul>\n<pre><code class=\"language-js\">interface SideBar{ // 菜单栏\n  name: string;\n  children?: Array&#x3C;SideBar>,\n  [propName: string]: any;\n}\nconst sideBarTree = (menuArr: SideBar[]) => {\n  if(menuArr &#x26;&#x26; menuArr.length) {\n    return menuArr.map((item, index) => {\n      return (\n        item.children \n        ? \n        &#x3C;SubMenu className=\"home-menu\" popupClassName=\"home-sider\" key={ item.path } icon={ item.icon ? getIcons(item.icon, Icons) : '' } title={ item.name }>\n          { sideBarTree(item.children) }\n        &#x3C;/SubMenu> : &#x3C;Menu.Item className=\"home-menu-item\" icon={ item.icon ? getIcons(item.icon, Icons) : '' } key={ item.path }>{ item.name }&#x3C;/Menu.Item>\n      )\n    })\n  } else {\n    return null\n  }\n}\n</code></pre>\n<ul>\n<li>这样就完成了我们菜单与icon的可配置化</li>\n</ul>","fields":{"slug":"/react_md_4/"},"frontmatter":{"title":"从零搭建一个react-hooks项目（四）","tags":["react","react hooks","redux","webpack"],"categories":"Webpack"}}},{"node":{"html":"<h1>react hooks下封装通用redux</h1>\n<p>redux我们常用来做全局状态管理，一般我们都会按功能模块来新建相关的action，reducer然后再使用combineReducers来将其组合导出，这样的话就实现了模块的划分，让我们更方便项目的管理。但是在某些情况下，我们想要一个通用的redux管理，比如一些特别小，但是又必须要用到的场景，比如我们现在新建了一个chat模块用来管理聊天相关的redux，新建了一个menu模块来管理我们的菜单模块，新建了一个number模块用来管理我们的数据状态，但是这时候我想要对顶部导航栏的显示与隐藏添加一个reducer用来与其他组件交互，这种情况下还要单独再开一个nav模块吗？肯定是不愿意的，所以针对我们这些比较小的功能模块，我们想封装一个通用的reducer，这个通用的reducer共享一个normal数据，dispatch时接受一组数据key,value用于进行数据的改变，下面就是我们的封装过程</p>\n<!--more-->\n<ul>\n<li>首先我们需要创建一个normalReducer，如下</li>\n</ul>\n<pre><code class=\"language-js\">// store/normal/reducer.js\n\nexport const normalReducer = (state = {}, action) => {\n  if(action.type === 'normal') { // 用于标识走通用的reducer\n    const { payload: { key, value } } = action\n    return {\n      ...state,\n      [key]: value\n    }\n  } else {\n    return state\n  }\n}\n\n// store/index.js\n\nimport { normalReducer } from './normal/reducer.js'\n\nconst rootReducer = combineReducer({\n  normal: normalReducer,\n  ...\n})\n</code></pre>\n<ul>\n<li>这样我们就简单实现了一个通用的normal模块，在页面中我们可以这样使用</li>\n</ul>\n<pre><code class=\"language-js\">import * as React from 'react'\nimport { useSelector, useDispatch } from 'react-redux'\n\nconst Home = () => {\n  const normalState = useSelector((state) => state.normal) // 获取到了相应的normal状态值\n  const dispatch = useDispatch() // 获取dispatch函数\n\n  const changeOk = () => {\n    dispatch({\n      type: 'normal',\n      payload: {\n        key: 'isOk',\n        value: !normalState.isOk\n      }\n    })\n  }\n\n  return (\n    &#x3C;div className=\"home\">\n      &#x3C;div>{ normalState.isOk }&#x3C;/div>\n      &#x3C;button onClick={ changeOk }>点我切换状态&#x3C;/button>\n    &#x3C;/div>\n  )\n}\n</code></pre>\n<ul>\n<li>这样就更新了我们的数据状态，这样我们每次都需要写dispatch相关部分，还是有点繁琐，所以我们可以参考useState的写法，接收一个键值，返回数据值与数据操作函数，如下</li>\n</ul>\n<pre><code class=\"language-js\">// src/effect/reducer\nimport * as React from 'react'\nimport { useSelector, useDispatch } from 'react-redux'\n\nexport const normalReducerDispatch = (key) => {\n  const dispatch = useDispatch()\n  const normalInfo = useSelector(state => state.normal)\n  const stateValue = normalInfo[key]\n  const setNormalInfo = (value) => {\n    dispatch({\n      type: 'normal',\n      payload: {\n        key,\n        value\n      }\n    })\n  }\n  return [stateValue, setNormalInfo]\n}\n</code></pre>\n<p>// 上面封装之后我们就可以像使用useState一样来使用我们的normal模块了，在需要使用的页面引入使用即可，如下</p>\n<pre><code class=\"language-js\">// src/home.jsx\nimport * as React from 'react'\nimport { normalReducerDispatch } from 'src/effect/reducer'\n\nconst Home = () => {\n  const [isOk, setIsOk] = normalReducerDispatch('isOk')\n\n  return (\n    &#x3C;div className=\"home\">\n      &#x3C;div>{ isOk }&#x3C;/div>\n      &#x3C;button onClick={ setIsOk(!isOk) }>点我切换状态&#x3C;/button>\n    &#x3C;/div>\n  )\n}\n</code></pre>\n<ul>\n<li>这样就实现了我们上面代码同样的功能，其他需要使用redux的小模块也可以同样使用了</li>\n</ul>","fields":{"slug":"/react_hooks/"},"frontmatter":{"title":"react hooks下封装通用redux","tags":["react","react hooks","redux"],"categories":"React"}}},{"node":{"html":"<h1>从零搭建一个react-hooks项目（五）</h1>\n<ul>\n<li>项目完成大概建起来了，但是当我打个生产包的时候都快哭了，一开始使用的devtool: \"source-map\"，用时高达 34 s，这当然是不可容忍的</li>\n<li>然后我们先将devtool改为\"none\"，然后发现变为了29s</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1075px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/0cf0800b8cd1b8010f7ea92caf0742f3/38a65/webpack.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 22.6%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAIAAADKYVtkAAAACXBIWXMAAAsSAAALEgHS3X78AAAA4klEQVQY03WO227DIBBE/TOJL8G3AIY1wQJjgh2HWFWdPKWN2v//iBK1UvtS6Wi00u7MbDT5l2FZ+skzaQlXjTAgjwc1CjWpwTNhUkSSf4hO8zr763y5Hd2CShbvcFBU8TSnQbOyiRFO8udpSAnbwK/5od2nPd+4fBw0A1MQucn2acHymm8zvE32cRoUP+cdCXGogpD7Yy4qXmFAJaWEL/Mou5430GvDhaVdR1UbACdpy6EBZb2yl7yG7/6oPUn1qvSqxzczv2sYBG8Na1WcNXZ108fg7oO56pqxomQE9N+3vwD8i0Hf7uZxMwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"图片\"\n        title=\"图片\"\n        src=\"/static/0cf0800b8cd1b8010f7ea92caf0742f3/38a65/webpack.png\"\n        srcset=\"/static/0cf0800b8cd1b8010f7ea92caf0742f3/0b533/webpack.png 500w,\n/static/0cf0800b8cd1b8010f7ea92caf0742f3/00d43/webpack.png 1000w,\n/static/0cf0800b8cd1b8010f7ea92caf0742f3/38a65/webpack.png 1075w\"\n        sizes=\"(max-width: 1075px) 100vw, 1075px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<h2>分析打包速度</h2>\n<ul>\n<li>通过 <code>speed-measure-webpack-plugin</code> 分析 <code>webpack</code> 构建期间各个阶段花费的时间，使用方法如下</li>\n</ul>\n<pre><code class=\"language-js\">const SpeedMeasurePlugin = require(\"speed-measure-webpack-plugin\");\nconst smp = new SpeedMeasurePlugin();\nmodule.exports = smp.wrap(webpackConfig)\n</code></pre>\n<ul>\n<li>然后在打包时就会显示打包中各阶段花费的时间，显示如下</li>\n</ul>\n<!--more-->\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 846px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/9d1709d15c5d6c27b8da868781ebfb3f/5b481/speed_measure.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 77.8%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAYAAAAWGF8bAAAACXBIWXMAABJ0AAASdAHeZh94AAAB4ElEQVQ4y5WUWW/aQBSF+S9VE4Lx7rE93vCGgUCBAKEli9pEVbe3/v+HrwNUTdpKiXm4Gmt0/emec66mYzoxtsjoWyGWl2CockRKYAZktkTXBWeaS7fvcf77fKk6ZhASlSVZcYkb5hiGj9EXGJqHtm9SkLc99w/sNWgnq2fcPX7n9uM33q1vGVcz5oOaRZbjOCF9Q2BZAk1vOWE1uuLx609291+4f/jB9e1nxsst0+2catkQSEno+ZjWk/QXgVE2Zr19YLrYsX7/icl8i5vkpMuMdJ6iC583Xae1jx07lqSjgqJRHsoS25RYmqCvHX++eNbcSnJQDJjfbZhcLxR4RFlVDGSKa8njVFp72AEoiojhjZpwo2SOS7w8QQ8lPTNUDSrdE2BHYB7TfGioNjVJ1ZDKAZnvoxteqxD+A+puSL24JBkOiZIRaRQRB8Ffa7I/z9sC3SxidDOkXFdERY2uvNtLPcjVnha6+/y7teS6ochzCpX8fu/2CV/oJ3poSRXKakpcqwlVwuEwZX9nugmRHyBVdU+R7CRK8q6hXNUHoB3Jg2zLFAhb0PvHy1eBXhYz2c2oVyOqKxVMMzg8EmEekZYxuoKe9U6QrNkBwUDtX5whkkw9XyE99eJo7rG6J3r4C5XEAqIGpU5aAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"图片\"\n        title=\"图片\"\n        src=\"/static/9d1709d15c5d6c27b8da868781ebfb3f/5b481/speed_measure.png\"\n        srcset=\"/static/9d1709d15c5d6c27b8da868781ebfb3f/0b533/speed_measure.png 500w,\n/static/9d1709d15c5d6c27b8da868781ebfb3f/5b481/speed_measure.png 846w\"\n        sizes=\"(max-width: 846px) 100vw, 846px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<ul>\n<li>不要在开发模式下使用这个分析插件，否则每次对代码进行修改都会导致webpack异常退出，报错 <code>Running webpack throws 'Callback was already called' error</code></li>\n</ul>\n<h2>优化一 优化解析速度 - 多进程打包</h2>\n<ul>\n<li>正常的webpack打包是单线程的，文件只能挨个处理，针对大量文件就会很慢，所以官方推荐了 thread_loader ，这个loader放在其他loader之前，，那么它后面的loader就会在单独的worker进程（node.js process）中进行</li>\n<li>thread_loader使用很简单，将它引入并放到其他loader之前即可</li>\n<li>注意：thread-loader 需要 style-loader 之后，这是因为 thread-loader 后的 loader 没法存取文件也没法获取 webpack 的选项设置。</li>\n</ul>\n<pre><code class=\"language-js\">module.exports = {\n  ...\n  module: {\n    rules: [\n      {\n        test: /\\.(ts|js)x?$/,\n        use: [\n          'thread-loader',\n          'babel-loader'\n        ],\n        exclude: /node-modules/\n      }\n    ]\n  }\n}\n</code></pre>\n<ul>\n<li>由于每个worker启动要600ms，为了防止worker启动的高延迟，我们可以进行预热</li>\n</ul>\n<pre><code class=\"language-js\">const threadLoader = require('thread-loader');\nconst jsWorkerPool = {\n  // options\n  \n  // 产生的 worker 的数量，默认是 (cpu 核心数 - 1)\n  // 当 require('os').cpus() 是 undefined 时，则为 1\n  workers: 2,\n  \n  // 闲置时定时删除 worker 进程\n  // 默认为 500ms\n  // 可以设置为无穷大， 这样在监视模式(--watch)下可以保持 worker 持续存在\n  poolTimeout: 2000\n};\nthreadLoader.warmup(jsWorkerPool, ['babel-loader']);\n\nmodule.exports = {\n  ...\n  module: {\n    rules: [\n      {\n        test: /\\.(ts|js)x?$/,\n        use: [\n          {\n            loader: 'thread-loader',\n            options: jsWorkerPool\n          },\n          'babel-loader'\n        ],\n        exclude: /node-modules/\n      }\n    ]\n  }\n}\n</code></pre>\n<ul>\n<li>然后我们再尝试打包，分析一下babel-loader的时间</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 846px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/9d1709d15c5d6c27b8da868781ebfb3f/5b481/speed_measure.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 77.8%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAYAAAAWGF8bAAAACXBIWXMAABJ0AAASdAHeZh94AAAB4ElEQVQ4y5WUWW/aQBSF+S9VE4Lx7rE93vCGgUCBAKEli9pEVbe3/v+HrwNUTdpKiXm4Gmt0/emec66mYzoxtsjoWyGWl2CockRKYAZktkTXBWeaS7fvcf77fKk6ZhASlSVZcYkb5hiGj9EXGJqHtm9SkLc99w/sNWgnq2fcPX7n9uM33q1vGVcz5oOaRZbjOCF9Q2BZAk1vOWE1uuLx609291+4f/jB9e1nxsst0+2catkQSEno+ZjWk/QXgVE2Zr19YLrYsX7/icl8i5vkpMuMdJ6iC583Xae1jx07lqSjgqJRHsoS25RYmqCvHX++eNbcSnJQDJjfbZhcLxR4RFlVDGSKa8njVFp72AEoiojhjZpwo2SOS7w8QQ8lPTNUDSrdE2BHYB7TfGioNjVJ1ZDKAZnvoxteqxD+A+puSL24JBkOiZIRaRQRB8Ffa7I/z9sC3SxidDOkXFdERY2uvNtLPcjVnha6+/y7teS6ochzCpX8fu/2CV/oJ3poSRXKakpcqwlVwuEwZX9nugmRHyBVdU+R7CRK8q6hXNUHoB3Jg2zLFAhb0PvHy1eBXhYz2c2oVyOqKxVMMzg8EmEekZYxuoKe9U6QrNkBwUDtX5whkkw9XyE99eJo7rG6J3r4C5XEAqIGpU5aAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"图片\"\n        title=\"图片\"\n        src=\"/static/9d1709d15c5d6c27b8da868781ebfb3f/5b481/speed_measure.png\"\n        srcset=\"/static/9d1709d15c5d6c27b8da868781ebfb3f/0b533/speed_measure.png 500w,\n/static/9d1709d15c5d6c27b8da868781ebfb3f/5b481/speed_measure.png 846w\"\n        sizes=\"(max-width: 846px) 100vw, 846px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<ul>\n<li>我们可以看到优化了将近 9 s</li>\n</ul>\n<h2>优化二 添加公用包的缓存</h2>\n<ul>\n<li>之前我们通过将不会发生变化的三方库进行抽离为dll文件，然后二次打包的时候不再对这些文件进行打包，以此来进行打包优化</li>\n<li>不过由于webpack的升级，已经有了不差于dll的打包性能，所以我们不再考虑dll形式的打包</li>\n<li>DLL不明显了，但是有了更好的替代品 hard-source-webpack-plugin ，只需要简单引入，之后第一次打包的时候可能会慢一点，但是从第二次开始就可以看到明显的差别</li>\n<li>使用方法如下</li>\n</ul>\n<pre><code class=\"language-js\">const HardSourceWebpackPlugin = require('hard-source-webpack-plugin');\n\nmodule.exports = {\n  ...\n  plugins: [\n    new HardSourceWebpackPlugin(),\n  ],\n}\n</code></pre>\n<ul>\n<li>之后我们再来对比一下，第一次打包</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 905px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/0a5a839f48d274f53f61f79181e56bb4/65d79/optimize_hard_source.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 59.599999999999994%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAABJ0AAASdAHeZh94AAABZ0lEQVQoz5WTwXKbMBRF+ZkmDRhsgwQSAhuBcUPjxMRtmCRtPVl0Ml32/zcnctpOvYTFmyeNNGfuvXrygmVKogvChebjTOBHKX4o8d06OO1dXQbJ+9mY8iKpyKsGqSxRbAhcLRcK6cDK9WyecTmbAExLy83hgZv9I5vunlXZIkSBnitMlDGbST74f4BjlHqresfw7SeH4cht/8Swf+JwfU9VbcmUoUgzkjjlYqRtr97ueXn9zfPxle8vv6i7A+XtBvvFslDqPUM/HJ+jlxUb+ocju/0zu/4RYztEVWI+Fw6YceHs/oONsiysZvO1pum3yNw9TJAyDwRXp9zC/xdHK0xKQ91/onI2TdNS25pCGMLoPLdkPFCsc5rBsr6r0HVFvMrxY8VVmE6avzOFOe3QUt01aDcyRWaQ8ZnFiVBPVobux7XLcYtetySJJpo74F+rkxUutcb2LWXXuB/jelkgYukUismwU70BXw2BEYpWaiQAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"图片\"\n        title=\"图片\"\n        src=\"/static/0a5a839f48d274f53f61f79181e56bb4/65d79/optimize_hard_source.png\"\n        srcset=\"/static/0a5a839f48d274f53f61f79181e56bb4/0b533/optimize_hard_source.png 500w,\n/static/0a5a839f48d274f53f61f79181e56bb4/65d79/optimize_hard_source.png 905w\"\n        sizes=\"(max-width: 905px) 100vw, 905px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<ul>\n<li>可以看到第一次的打包长中HardSourceWebpackPlugin 占了 30多s，几乎跟打包时常一样了</li>\n<li>但是当我们第二次打包的时候</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 902px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/9a5670f6b11f7999300161919faddbd7/58213/optimize_hard_source_after.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 52.2%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAABJ0AAASdAHeZh94AAABW0lEQVQoz5WSWU+DQBSF+TEtZSswwLDKFFroYukiiVVbbYzG5cH4/9+Ow9i4Jg19+HInmZsz59w7kmK6MEgARffQ012BzOkcqmJ4gt6P8zEkJ07AigkIZeiTGIaTgNohGMc1fXQPj7QVlWiaYVKtkZdLeGGGwI8Q+TFMw4dhUOimB/UUh/P1DR6e37Hdv+D67gmbzQ6L1QXS8xLRIEFEfZgW/RX/qOCk2mD/+Ibd/Suubp8wmtXIVgWyOoNzFn7NtXXkQVFhfblHxZ0u6i1iNkY8ZUiXDFYQQNbc05Yiaw66qo2OYvNKBLLqiq0r/UNj47KFmBBsNuuFOZLBVMCGc9hewp2RVgL/BMN0jJLPbVHvhNhwvAJNCmhWKBbR1dzv/6n+Qfu8b1I2ND2Swf9bn0QCzQpgkhB5XmI6W0LnkVnK3bNSzNbwKEzKe/xAzNd0KAihYKM5cm6E0BQfMxBBrC7aUMYAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"图片\"\n        title=\"图片\"\n        src=\"/static/9a5670f6b11f7999300161919faddbd7/58213/optimize_hard_source_after.png\"\n        srcset=\"/static/9a5670f6b11f7999300161919faddbd7/0b533/optimize_hard_source_after.png 500w,\n/static/9a5670f6b11f7999300161919faddbd7/58213/optimize_hard_source_after.png 902w\"\n        sizes=\"(max-width: 902px) 100vw, 902px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<ul>\n<li>这时神奇的事发生了，我们的打包时间变得只有13s了，缩短了60%</li>\n</ul>\n<h2>优化三 vendor代码分离</h2>\n<ul>\n<li>我们发现打出来的三方库的包vendor只有一个，体积达到了 2.6 M，这样对我们的首次加载是极其不友好的</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 905px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/f53ab1dd0530c86e20fa622a15fc0605/65d79/vendor_size.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 33.4%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAABJ0AAASdAHeZh94AAAA7klEQVQoz51Rf3ODIAz1+3/FnT13tlVBQBwqSOEtYW3Xs39tucvlF3l5IVWMETlnHGXfd/RCwYedogxtLAL5/DbGGzYfkFK69+YnRnU61WjbFsuyFBBWFh4kxQCtNbz3EEOPpmkgpSx1v22w1hafwZ6AXXeFEBITFe08F5syCgulFGbKhRDg3IJpmqBoQEo/LJd1fQf8qGt8the0lw6DVHBbwOr3oudrDzFquNVD0crdIEscYoKlAdp+4Y74C8i0efI4jjDGwJDPbPh/nHPYaDVen+1KjB6NN8ox8zeG+I+8HPF40OqB/ic9sHr1vwHj0CMVGwf3sgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"图片\"\n        title=\"图片\"\n        src=\"/static/f53ab1dd0530c86e20fa622a15fc0605/65d79/vendor_size.png\"\n        srcset=\"/static/f53ab1dd0530c86e20fa622a15fc0605/0b533/vendor_size.png 500w,\n/static/f53ab1dd0530c86e20fa622a15fc0605/65d79/vendor_size.png 905w\"\n        sizes=\"(max-width: 905px) 100vw, 905px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<ul>\n<li>导致vendor包过大的原因主要是我们的react组件都是同步引入的，导致webpack打包时认为是首页就需要的全部组件，从而将所有的依赖与文件都打到了一起</li>\n<li>解决这个问题我们就需要react的按需引入功能，配合webpack本身的异步分离打包实现vendor包的优化</li>\n<li>react本身支持异步导入，但是因为我们的项目使用了babel，所以我们需要确保babel可以解析异步导入语句，并能正确解析，所以引入 'babel-plugin-syntax-dynamic-import' ,使用方法如下</li>\n</ul>\n<pre><code class=\"language-js\">// 首先引入\nyarn add babel-plugin-syntax-dynamic-import -D -S\n// 然后修改 .babelrc 文件\n\"plugins\": [\n  \"syntax-dynamic-import\",\n  ...\n]\n</code></pre>\n<ul>\n<li>这样就保证我们可以正常使用react的异步导入方法了</li>\n<li>然后因为我们使用了typescript，并且配置项中的module是 es6 ，但是该模式下不支持异步导入，所以将其修改为 commonjs，如下</li>\n</ul>\n<pre><code class=\"language-js\">// tsconfig.json\n{\n  \"compilerOptions\": {\n    ...\n    \"module\": \"commonjs\", // 模块引入方式\n  }\n}\n</code></pre>\n<ul>\n<li>然后就完成了webpack基本项的配置，接下来就要修改我们的react代码</li>\n<li>我们使用react提供的 lazy 方法对组件页面进行异步引入</li>\n</ul>\n<pre><code class=\"language-js\">// 原代码\nimport * as React from 'react'\nimport Home from 'pages/home'\n\n// 异步导入\nimport * as React from 'react'\nconst { lazy } = React\nconst Home = lazy(() => import('pages/home'))\n</code></pre>\n<ul>\n<li>按这种形式将我们的所有页面引入都修改了，然后再进行打包尝试，打包后的结果如下</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 877px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/8c16623f3cc19666704e5d027dcf4353/4b446/vendor_list.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 73.4%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAABJ0AAASdAHeZh94AAAB80lEQVQ4y22TC2+bQBCE/f9/VSu1TZO0lZo2TnFjqDE2YDhe5mXzmO5cjEUMJ50SuNvhm93xwvd95HkOrr7v9eY6n89I0xR5keN0OqEsS/2cZZm+0zSNfndbt3h5WSIIgslBJZdd10UYhiiKAvZmA9O0EEXR23lVIUmSa92wFiyaJRSqOI5xPB41IYtDpTQhFz+Sy54QGoahSSaEQuB5HpSIFEWpXTiOo4kHwVlCFvHLwxoOSUV7JKrrWtNSlH0czsfOroIbe4P9hXB8WNeVFqAQaZUKtZNxDwf77wRp43A4TCyTioK0xWIKMxHq4oaEs4LbrQPP9yaCJxFkMS1SkPbYvyhS6LoeXdvOWzYtC7v9fnYoJKJF5o00vnyY77quQ9s284S8MEzuNja0y9jU8j+nStt818kdio6DfRV8Xa91HKaEl2Crt2DTOp89z0WrCdvrxCeEQRjgdukwX4LNAZEmGQilhxQs54L9Vwi3ux1q+e0WjII0upVDPnsyfSUihQimIuzL1EPpaSeFvJPODcX7eof950+wP36Af/cF8Y/vqJbPqGUHD/dI5Ln4/QvHp58IH+9lP6BZGXJniezbI3uDfiS6MFcW1n9MrJ4N/HvdwF7b8B3JmxfBsRy4tvTRVfovdxykSFUG5cdQjsSta98J/gdmnITTfyFT7QAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"图片\"\n        title=\"图片\"\n        src=\"/static/8c16623f3cc19666704e5d027dcf4353/4b446/vendor_list.png\"\n        srcset=\"/static/8c16623f3cc19666704e5d027dcf4353/0b533/vendor_list.png 500w,\n/static/8c16623f3cc19666704e5d027dcf4353/4b446/vendor_list.png 877w\"\n        sizes=\"(max-width: 877px) 100vw, 877px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<ul>\n<li>可以看到我们的vendor变成了 160 多k，并且将原来的大文件拆分为很多小的bundle文件，这对我们的首屏加载有很大的帮助</li>\n</ul>","fields":{"slug":"/react_md_5/"},"frontmatter":{"title":"从零搭建一个react-hooks项目（五）","tags":["react","react hooks","redux","webpack"],"categories":"Webpack"}}}]}},"pageContext":{"limit":10,"skip":20,"currentIndex":2}},"staticQueryHashes":["2566592090"]}