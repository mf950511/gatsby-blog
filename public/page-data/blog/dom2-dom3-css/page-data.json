{"componentChunkName":"component---src-templates-blog-small-jsx","path":"/blog/dom2-dom3-css/","result":{"data":{"markdownRemark":{"html":"<h1>DOM2跟DOM3-CSS</h1>\n<ul>\n<li>支持style属性的HTML元素在JavaScript中都有一个style属性，该属性是CSSStyleDeclaration属性的实例，包含通过HTML style属性为元素设置的所有样式信息，不包含通过层叠样式机制从文档样式和外部样式中继承来的样式</li>\n<li>HTML style属性中的CSS属性在JavaScript style对象中都有对应的属性（JavaScript中会把连字符分割的单词转为驼峰）</li>\n<li>大多数属性都可以直接转换，但是float不可以，因为它在JavaScript中是保留字，所以不能用做属性名。DOM2 Style规定它为cssFloat</li>\n<li>\n<p>DOM2 Style规范在style对象上加了一些属性和方法</p>\n<ul>\n<li>cssText:包含style属性中的CSS代码</li>\n<li>length，应用给元素的css属性数量</li>\n<li>parentRule，表示CSS信息的CSSRule对象</li>\n<li>getPropertyCSSValue(propertyName)，返回包含CSS属性值propertyName值的CSSValue对象（已废弃）</li>\n<li>getPropertyPriority(propertyeName)，如果CSS属性PropertyName使用了!important则返回\"important\"，否则返回空字符串</li>\n<li>getPropertyValue(propertyName),返回属性propertyName的字符串值</li>\n<li>item(index)，返回索引index的CSS属性名</li>\n<li>removeProperty(propertyName)，从样式中删除CSS属性</li>\n<li>setProperty(propertyName, value, priority)，设置CSS属性propertyName值为value，priority是\"important\"或空字符串</li>\n</ul>\n</li>\n<li>cssText可以存取样式的CSS代码，读模式下，cssText返回style属性CSS代码在浏览器内部的表示。写模式下，给cssText赋值会重写整个style属性的值。</li>\n<li>length属性跟item()方法一起使用迭代CSS属性</li>\n</ul>\n<pre><code class=\"language-js\">for(let i = 0; i &#x3C; myDiv.style.length; ++i){\n  console.log(myDiv.style[i]) // 取得css属性名为\"background-color\"而不是backgroundColor\n}\n</code></pre>\n<!--more-->\n<ul>\n<li>getPropertyValue返回CSS属性值的字符串表示，getPropertyCSSValue返回一个CSSValue对象，包含两个值：cssText和cssValueType。前者跟getPropertyValue返回值一样，后者是一个数值常量，表示当前值类型（0代表继承值，1代表原始值，2代表列表，3代表自定义值）</li>\n<li>removeProperty用于从元素样式中删除指定CSS属性，删除后会使用该属性的默认（从其他样式表继承）样式，不确定默认值是什么的情况下，从style属性中删除就会用默认值</li>\n</ul>\n<h2>计算样式</h2>\n<ul>\n<li>style样式包含支持style属性的元素为这个属性设置的样式信息，但是不包含从其他样式层叠表继承的同样影响该元素的样式信息。</li>\n<li>DOM2 Style在document.defaultView上增加了getComputedStyle()方法。该方法接受两个参数：要取得计算样式的元素和伪元素字符串（如\":after\"）。不需要查询伪元素，第二个参数可以为null</li>\n<li>getComputedStyle返回一个CSSStyleDeclaration对象，包含元素的计算样式</li>\n</ul>\n<pre><code class=\"language-js\">&#x3C;!DOCTYPE html>\n&#x3C;html lang=\"en\">\n&#x3C;head>\n  &#x3C;meta charset=\"UTF-8\">\n  &#x3C;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  &#x3C;title>Document&#x3C;/title>\n  &#x3C;style>\n    #myDiv{\n      background-color: blue;\n      width:100px;\n      height: 200px;\n    }\n  &#x3C;/style>\n&#x3C;/head>\n&#x3C;body>\n  &#x3C;div id=\"myDiv\" style=\"background-color: red;border:1px solid black\">&#x3C;/div>\n  &#x3C;script>\n    let div = document.getElementById('myDiv')\n    let computedStyle = document.defaultView.getComputedStyle(div, null)\n    console.log(div.style.backgroundColor) // \n    console.log(computedStyle.backgroundColor)\n    console.log(div.style.width)\n    console.log(computedStyle.width)\n    console.log(div.style.height)\n    console.log(computedStyle.height)\n    console.log(div.style.border)\n    console.log(computedStyle.border)\n  &#x3C;/script>\n&#x3C;/body>\n&#x3C;/html>\n// red\n// rgb(255, 0, 0)\n// \n// 100px\n//\n// 200px\n// 1px solid black\n// 1px solid rgb(0, 0, 0)\n</code></pre>\n<ul>\n<li>所有浏览器中，计算样式都是只读的，不可修改，计算样式还会包含默认值</li>\n<li>CSSStyleSheet类型表示CSS样式表，包括使用<link>元素和通过<style>元素定义的样式。这两个元素本身是HTMLLinkElement和HTMLStyleElement。CSSStyleSheet类型是通用样式表类型。CSSStyleSheet类型的实例是一个只读对象</li>\n<li>\n<p>CSSStyle继承StyleSheet，以下为继承的属性</p>\n<ul>\n<li>disabled:布尔值，样式表是否被禁用，设置为true会禁用样式表</li>\n<li>href:如果是link包含的样式表，返回样式表的URL，否则返回null</li>\n<li>media:样式表支持的媒体类型集合，集合有一个length属性和item()方法，如果样式表可用于所有媒体，就返回空列表</li>\n<li>ownerNode,指向拥有当前样式表的节点，在HTML中要么是link元素要么是style元素。如果当前样式表是@import被包含在另一个样式表中，则这个值是null</li>\n<li>parentStyleSheet，如果当前样式是通过@import被包含在另一个样式表中，这个属性指向导入它的样式表</li>\n<li>title,ownerNode的title属性</li>\n<li>type,字符串，表示样式表的类型，CSS样式表就是\"text/css\"</li>\n</ul>\n</li>\n<li>\n<p>以上属性除了disabled，其他都是只读的，除了以上继承属性，还支持下属性和方法</p>\n<ul>\n<li>cssRules，当前样式表包含的样式规则的集合</li>\n<li>ownerRule:如果样式表是使用@import导入，指向导入规则，否则指向null</li>\n<li>deleteRule(index)，在指定位置删除cssRules中的规则</li>\n<li>insertRule(rule, index),在指定位置向cssRules中插入规则</li>\n</ul>\n</li>\n<li>document.styleSheets表示文档中可用的样式表的集合</li>\n<li>\n<p>CSSRule类型表示样式表中的一条规则，很多类型都继承它，最常用的是表示样式信息的CSSStyleRule，以下是CSSStyleRule对线上可用的属性</p>\n<ul>\n<li>cssText，返回整个规则的文本。返回的文本可能跟实际的不一样，Safari始终会把所有字母转为小写</li>\n<li>parentRule,如果这条规则被其他规则包含，就指向包含规则，否则指向null</li>\n<li>parentStyleSheet,包含当前规则的样式表</li>\n<li>selectText，返回规则的选择符文本，可能与样式表中的文本不一样。在Opera中是可修改的</li>\n<li>style，返回CSSStyleDecalaration对象，可以设置和获取当前规则中的样式</li>\n<li>type,数值常量，表示规则类型，样式规则，始终为1</li>\n</ul>\n</li>\n<li>cssText与style.cssText类似，前者包含选择符文本和环绕样式的大括号，后者只包含样式生命，cssText是只读的，style.cssText是可以被重写的</li>\n<li>DOM中，可以使用insertRule来向样式表插入新规则，接受两个参数：规则的文本和表示插入未知的索引值</li>\n</ul>\n<pre><code class=\"language-js\">let sheet = document.styleSheets[0]\nsheet.insertRule(\"body{ background-color: silver }\", 0)\n</code></pre>\n<ul>\n<li>上面例子中这条规则作为样式表的第一条规则插入</li>\n<li>支持从样式表中删除规则的DOM方法deleteRule()，接受一个参数，要删除的索引</li>\n</ul>\n<h2>元素尺寸</h2>\n<ul>\n<li>这咯的属性和方法并不是DOM2 Style中定义的，但是与HTML元素样式有关。IE率先增加了一些属性，这些属性已经得到所有主流浏览器支持</li>\n<li>\n<p>偏移尺寸：包含元素在屏幕上占用的所有视觉空间。元素在页面山的视觉空间由高度与宽度决定，包括所有内边距、滚动条和边框</p>\n<ul>\n<li>offsetHeight: 元素在垂直方向上占用的像素尺寸，包括它的高度、水品滚动条高度（如果可见）和上下边框的高度</li>\n<li>offsetLeft: 元素左边框外侧距离包含元素左边框内侧的像素数</li>\n<li>offsetTop:元素上边框外侧距离包含元素上边框内侧的像素数</li>\n<li>offsetWidth:元素在水平方向上占用的像素尺寸，包含它的宽度、垂直滚动条宽度和左右边框宽度</li>\n</ul>\n</li>\n<li>offsetLeft和offsetTop是相对于包含元素的，包含元素保存在offsetParent属性中。offsetParent不一定是parentNode。比如<td>元素的offsetParent是table元素，因为table是节点中第一个提供尺寸的元素</li>\n<li>要确定一个元素在页面中的偏移量，可以将它的offsetLeft和offsetTop分别于offsetParent的相同属性相加，一直到更元素</li>\n</ul>\n<pre><code class=\"language-js\">function getElementLeft(element){\n  let actualLeft = element.offsetLeft\n  let current = element.offsetParent\n  while(current !== null) {\n    actualLeft += current.offsetLeft\n    current = offsetParent\n  }\n  return actualLeft\n}\n</code></pre>\n<ul>\n<li>对于CSS布局的页面，这个函数很精确，对使用表格和内嵌窗格的页面，返回值会不相同</li>\n<li>所有偏移尺寸都是只读的，每次访问都会重新计算</li>\n<li>\n<p>元素的客户端尺寸：客户端尺寸只有clientWidth和clientHeight</p>\n<ul>\n<li>clientWidth是内容区宽度加左右内边距的宽度</li>\n<li>clientHeight是内容区高度加上下内边距的高度</li>\n</ul>\n</li>\n<li>客户端尺寸实际上就是元素内部的空间，不包含滚动条占用的空间，最常用的是确定浏览器视口尺寸，及document.documentElement的clientWidth和clientHeight</li>\n<li>\n<p>滚动尺寸：提供了元素滚动距离的信息</p>\n<ul>\n<li>scrollHeight:没有滚动条出现时，元素内容的总高度</li>\n<li>scrollLeft:内容区左侧隐藏的像素数，设置这个属性可以改变元素的滚动位置</li>\n<li>scrollTop:内容区顶部隐藏的像素数，设置这个属性可以改变元素的滚动位置</li>\n<li>scrollWidth:没有滚动条出现时，元素内容的总宽度</li>\n</ul>\n</li>\n<li>scrollWidth和scrollHeight可以确定元素的实际尺寸</li>\n<li>scrollWidth和scrollHeight等于文档内容的宽度，而clientWidth和clientHeight等于视口的大小</li>\n<li>scrollLeft个scrollTop用于确定当前元素的滚动位置或者设置滚动位置，这两个属性表示已经滚动不可见的元素的高度</li>\n<li>浏览器在每个元素上暴露了getBoundingClientRect()方法，返回一个DOMRect对象，包含六个属性：left、top、right、bottom、height、width</li>\n</ul>\n<h2>遍历</h2>\n<ul>\n<li>DOM2 Traversal and Range定义了两个类型用于辅助遍历：NodeIterator和TreeWalker对DOM结构的深度遍历优先</li>\n<li>\n<p>NodeIterator通过document.createNodeIterator()，接受以下4个参数</p>\n<ul>\n<li>root，作为遍历根节点的节点</li>\n<li>whatToShow,数值代码，表示应该访问哪些节点</li>\n<li>filter，NodeFilter对象或函数，表示是否接收或跳过特定节点</li>\n<li>entityReferenceExpansion，布尔值，表示是否拓展实体引用。这个参数在HTML文档中没有效果</li>\n</ul>\n</li>\n<li>\n<p>whatToShow参数是一个位掩码，通过应用一个或多个过滤器来指定访问哪些节点。常量是在NodeFilter中定义的</p>\n<ul>\n<li>NodeFilter.SHOW_ALL，所有节点</li>\n<li>NodeFilter.SHOW_ELEMENT，元素节点</li>\n<li>NodeFilter.SHOW_ATTRIBUTE，属性节点，DOM结构中用不到</li>\n<li>NodeFilter.SHOW_TEXT,文本节点</li>\n<li>NodeFilter.SHOW<em>CDATA</em>SECTION,CData区块节点，不在HTML页面使用</li>\n<li>NodeFilter.SHOW<em>ENTITY</em>REFERENCE,实体引用节点，不在HTML页面使用</li>\n<li>NodeFilter.SHOW<em>PROCESSING</em>INSTRUCTION，处理指令节点，不在HTML页面使用</li>\n<li>NodeFilter.SHOW_COMMENT，注释节点</li>\n<li>NodeFilter.SHOW_DOCUMENT，文档节点</li>\n<li>NodeFilter.SHOW<em>DOCUMENT</em>TYPE,文档类型节点</li>\n<li>NodeFilter.SHOW<em>DOCUMENT</em>FRAGMENT，文档片段节点，不在HTML页面使用</li>\n<li>NodeFilter.SHOW_NOTATION,记号节点，不在HTML页面使用</li>\n</ul>\n</li>\n<li>除了NodeFilter.SHOW_ALL之外，都可以组合使用</li>\n</ul>\n<pre><code class=\"language-js\">let whatToShow = NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_TEXT\n</code></pre>\n<ul>\n<li>createNodeIterator()方法的filter参数可以用来指定自定义NodeFilter对象，或者一个作为节点过滤器的函数。NodeFilter对象只有一个方法acceptNode()，如果给定节点应该访问就返回NodeFilter.FILTER<em>ACCEPT，否则返回NodeFilter.FILTER</em>SKIP。因为NodeFilter是抽象类，不可创建势力</li>\n</ul>\n<pre><code class=\"language-js\">let filter = {\n  acceptNode(node) {\n    return node.tagName.toLowerCase() === 'p' ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP\n  }\n}\n\n// 或者直接用函数\nfunction filter(node){\n  return node.tagName.toLowerCase() === 'p' ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP\n}\nlet iterator = document.createNodeIterator(root, NodeFilter.SHOW_ELEMENT, filter, false)\n</code></pre>\n<ul>\n<li>filter参数也可以是一个函数，与acceptNode形式一样，返回对应的属性值</li>\n<li>如果不需要指定过滤器，可以直接传入null</li>\n<li>NodeIterator有两个主要方法是nextNode()跟previouseNode()。</li>\n<li>nextNode在DOM子树中以深度优先方法前进一步，而previousNode则是后退一步。创建NodeIterator对象时会有一个内部指针指向根节点，因此第一次调用时nextNode()返回根节点。当遍历到最后一个节点时，nextNode返回null，previousNode当遍历到最后一个节点时，调用previousNode返回遍历的根节点时，再次调用返回null</li>\n<li>\n<p>TreeWalker是NodeIterator的高级版，除了同样的NextNode和previousNode外，新增了在DOM中向不同方向遍历的方法</p>\n<ul>\n<li>parentNode():遍历到当前节点的父节点</li>\n<li>firstChild():遍历到当前节点的第一个子节点</li>\n<li>lastChild():遍历到当前节点的最后一个子节点</li>\n<li>nextSibling():遍历到当前节点的下一个同胞节点</li>\n<li>previousSibling():遍历到当前节点的上一个同胞节点</li>\n</ul>\n</li>\n<li>document.createTreeWalker方法来创建TreeWalker实例，接受与document.createNodeIterator一样的参数，两者很相似，所以经常会使用TreeWalker替代NodeIterator</li>\n<li>不同的是，节点过滤器（filter）除了可以返回NodeFilter.FILTER<em>ACCEPT跟NodeFilter.FILTER</em>SKIP，还可以返回NodeFilter.FILTER_REJECT。</li>\n<li>在使用NodeItertor时，NodeFilter.FILTER<em>SKIP与NodeFilter.FILTER</em>REJECT是一样的。在使用TreeWalker时，NodeFilter.FILTER<em>SKIP表示跳过该节点，访问子树中的下一个节点，而NodeFilter.FILTER</em>REJECT表示跳过该节点及节点的整个子树</li>\n</ul>","frontmatter":{"title":"DOM2跟DOM3-CSS","date":"2021-01-16","tags":["JavaScript回顾"],"categories":"JavaScript"},"fields":{"slug":"/dom2-dom3-css/"}}},"pageContext":{"slug":"/dom2-dom3-css/"}},"staticQueryHashes":["2566592090"]}