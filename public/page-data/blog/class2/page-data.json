{"componentChunkName":"component---src-templates-blog-small-jsx","path":"/blog/class2/","result":{"data":{"markdownRemark":{"html":"<h1>类</h1>\n<ul>\n<li>ECMAScript 6 引入了class关键字来实现正式定义类的能力</li>\n<li>类定义也是两种方法：声明类与类表达式</li>\n</ul>\n<pre><code class=\"language-js\">// 类声明\nclass Person {}\n\n// 类表达式\nconst Person = class {}\n</code></pre>\n<ul>\n<li>类定义不可变量提升，声明前不可使用</li>\n<li>函数受函数作用域限制，类受块作用域限制</li>\n<li>\n<p>类可以包含构造函数方法、实例方法、获取函数、设置函数与静态类方法</p>\n<!--more-->\n<h2>构造函数</h2>\n</li>\n<li>构造函数非必须，不定义则默认为空</li>\n<li>默认情况下，构造函数会在执行后返回this对象。构造函数返回的对象会被用作实例化对象，如果没有引用新创建的this对象，则对象会被销毁</li>\n<li>如果返回的不是this对象，而是其他对象，那么这个对象不回通过instanceof操作符检测出与类有关联，因为对象的原型指针没有被修改</li>\n</ul>\n<pre><code class=\"language-js\">class Person{\n  constructor(override){\n    this.foo = 'foo'\n    if(override) {\n      return { bar: 'bar' }\n    }\n  }\n}\n\nlet p1 = new Person()\nlet p2 = new Person(true)\nconsole.log(p1) // Person {foo: \"foo\"}\nconsole.log(p1 instanceof Person) // true\n\nconsole.log(p2) // {bar: \"bar\"}\nconsole.log(p2 instanceof Person) // false\n</code></pre>\n<ul>\n<li>类中定义的constructor不会被当做构造函数，对它使用instanceof会返回false</li>\n</ul>\n<pre><code class=\"language-js\">class Person{\n  constructor(){\n    this.foo = 'foo'\n  }\n}\n\nlet p1 = new Person()\nconsole.log(p1 instanceof Person) // true\nconsole.log(p1 instanceof Person.constructor) // false\n</code></pre>\n<ul>\n<li>类也可以立即被实例化</li>\n</ul>\n<pre><code class=\"language-js\">let p = new class Foo{\n  constructor(x){\n    console.log(x)\n  }\n}('foo') // 'foo'\n</code></pre>\n<h2>实例、原型和类成员</h2>\n<ul>\n<li>定义在构造函数内的属性为实例属性，实例独享</li>\n<li>定义在类块中的方法为原型方法，所有实例共享，可以在类块中定义方法，但不能定义属性</li>\n</ul>\n<pre><code class=\"language-js\">class Person {\n  name: 'Jack' // Uncaught SyntaxError: Unexpected token\n}\n</code></pre>\n<ul>\n<li>类上定义静态方法，一般用于执行不特定于市里的操作，不要求存在类的实例，使用static修饰</li>\n</ul>\n<h2>super</h2>\n<ul>\n<li>派生类可以通过super关键字引用他们的原型。只能在派生类中使用，而且仅限于类构造函数、实例方法、静态方法内部。</li>\n<li>构造函数中使用super可以调用父类构造函数（这种情况下super之前不允许出现this）</li>\n<li>ES6给类构造函数与静态方法添加了内部特征[[HomeObject]]，是一个指针，指向定义该方法的对象。只能在javascript引擎内部访问。</li>\n<li>super始终会定义为[[HomeObject]]的原型</li>\n<li>super不可单独使用，要么用它调用构造函数，要么引用静态方法</li>\n</ul>\n<pre><code class=\"language-js\">class Vehicle {\n\n}\nclass Bus extends Vehicle{\n  constructor(){\n    console.log(super)  // SyntaxError: 'super' keyword unexpected here\n  }\n}\n</code></pre>\n<ul>\n<li>调用super会调用父类构造函数，并将返回的实例赋值给this</li>\n<li>如果没有定义类构造函数，实例化派生类时会调用super，并传入所有给派生类的参数</li>\n<li>如果派生类定义了构造函数，那么要么在其中调用super，要么必须在其中返回一个对象</li>\n</ul>\n<h2>抽象基类</h2>\n<ul>\n<li>基类就是可供继承但不可被实例化的类，ECMAScript没有单独实现，但是可以使用new.target来实现，new.target保存了通过new调用的类或者函数。所以可以如下实现</li>\n</ul>\n<pre><code class=\"language-js\">class Vehicle {\n  constructor(){\n    if(new.target === Vehicle) {\n      throw new Error('Vehicle cannot be directly instantiated')\n    }\n  }\n}\nnew Vehicle() // Error: Vehicle cannot be directly instantiated\n</code></pre>\n<h2>类混入</h2>\n<ul>\n<li>将不同类集中到一个类中</li>\n</ul>\n<pre><code class=\"language-js\">class Vehicle {}\nlet FooMixin = (Superclass) => class extends Superclass {\n    foo() {\n      console.log('foo')\n    }\n  }\n\n  let BarMixin = (Superclass) => class extends Superclass {\n    bar() {\n      console.log('bar')\n    }\n  }\n\n  let BazMixin = (Superclass) => class extends Superclass {\n    baz() {\n      console.log('baz')\n    }\n  }\n\n  class Bus extends FooMixin(BarMixin(BazMixin(Vehicle))) {}\n  let b = new Bus()\n  b.foo()  // 'foo'\n  b.bar()  // 'bar'\n  b.baz()  // 'baz'\n</code></pre>\n<ul>\n<li>很多javascript已经放弃混入模式，转为组合模式，也就是著名的“组合胜过继承”</li>\n</ul>","frontmatter":{"title":"类--高程4","date":"2020-12-08","tags":["JavaScript回顾"],"categories":"JavaScript"},"fields":{"slug":"/class2/"}}},"pageContext":{"slug":"/class2/"}},"staticQueryHashes":["2566592090"]}