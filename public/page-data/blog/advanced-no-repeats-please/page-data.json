{"componentChunkName":"component---src-templates-blog-small-jsx","path":"/blog/advanced-no-repeats-please/","result":{"data":{"markdownRemark":{"html":"<h1>字符串排列 (No repeats please)</h1>\n<h2>题目链接</h2>\n<ul>\n<li><a href=\"https://freecodecamp.cn/challenges/no-repeats-please\">中文链接</a></li>\n<li><a href=\"https://freecodecamp.com/challenges/no-repeats-please\">英文链接</a></li>\n</ul>\n<h2>问题解释</h2>\n<ul>\n<li>这个 <code>function</code> 接收一个字符串参数 <code>str</code>。返回值为参数 <code>str</code> 没有连续重复字符串的排列个数</li>\n<li>如果 <code>str</code> 为 <code>\"aab\"</code>，则返回值应为 <code>2</code>，因为全排列后，会出现两个 <code>\"aba\"</code>，不含连续重复字符串 (排除 <code>\"aab\"</code> 和 <code>\"baa\"</code>)</li>\n</ul>\n<!--more-->\n<h1>解题思路</h1>\n<ul>\n<li>这道题应该是高级算法题目中难度稍大的一道题。题目的难点在于获取字符串的全排列。我觉得这里有必要先说一下，如何获取全排列</li>\n<li>只要我们可以获取字符串的全排列，那就至少有两种方式判断字符串是否含有连续重复的字符。可以遍历，也可以用正则</li>\n<li><a href=\"https://zh.wikipedia.org/wiki/%E7%BD%AE%E6%8F%9B\">排列 (也叫置换)，Permutation</a> 与 <a href=\"https://zh.wikipedia.org/wiki/%E7%B5%84%E5%90%88\">组合，Combination</a>，高中数学就已经涉及到。比如，对于 <code>123</code>，从中取出两个数有三种组合，分别是 <code>12</code>、<code>13</code> 和 <code>23</code>。同样是取出两个数，有六种排列，分别是 <code>12</code>、<code>21</code>、<code>13</code>、<code>31</code>、<code>23</code> 和 <code>32</code></li>\n<li>再说一下什么是全排列 (Full Permutation)，全排列的意思是，从 <code>n</code> 个中取出 <code>n</code> 个的排列。对于 <code>123</code>，取出三个数的排列，就是 <code>123</code> 的全排列。<code>123</code> 的全排列总共有六种，分别是 <code>123</code>、<code>132</code>、<code>213</code>、<code>231</code>、<code>312</code> 和 <code>321</code>。计算数量方式很简单，就是 <code>n!</code>，<code>n</code> 的阶乘。对于 <code>123</code> 来说，也就是 <code>3!</code>，得 <code>6</code></li>\n</ul>\n<h2>全排列的实现 - 封装，循环</h2>\n<ul>\n<li>\n<p>我们可以先根据这个实际的例子想想，怎样才能无遗漏的输出全排列</p>\n<ul>\n<li>两个数就不用说了，对于 <code>12</code>，只有 <code>12</code> 和 <code>21</code> 两种</li>\n<li>\n<p>三个数，比如 <code>123</code>，我们先分为三种情况，就是 <code>1</code> 开头，<code>2</code> 开头和 <code>3</code> 开头</p>\n<ul>\n<li>对于 <code>1</code> 开头的情况，剩下 <code>2</code> 和 <code>3</code>，这就回到了两个数的排列</li>\n<li>对于 <code>2</code> 开头的情况，剩下 <code>1</code> 和 <code>3</code>，这也回到了两个数的排列</li>\n<li><code>3</code> 开头的情况同理</li>\n</ul>\n</li>\n<li>四个数，先按照开头分为四种情况，然后按照三个数的排列去处理</li>\n<li>......</li>\n<li>以此类推</li>\n</ul>\n</li>\n<li>你可能已经看出来了，这就是一个递归。就好像求斐波那契数列的某一个元素，我们要先求出前面的；要想求出前面的，我们就要求出更前面的。记 \"斐波那契数列的第 <code>n</code> 位\" 这件事为 <code>F(n)</code>，则有 <code>F(n) = F(n - 1) + F(n - 2)</code></li>\n<li>类似地，记 \"求出 <code>n</code> 个字符串的全排列\" 这件事为 <code>P(n)</code>，则有 <code>P(n) = 分别以这n个字符之一开头 + P(n - 1)</code>。其中，<code>P(n - 1)</code> 表示去掉那个开头字符的剩余字符串的全排列。哪怕只有两个字符，比如对于上面例子中的 <code>12</code>，同样符合这一条结论</li>\n<li>以 <code>'abc'</code> 为例，执行步骤如下：</li>\n</ul>\n<pre><code>给出 abc\n\n1. a 作为开头 -> 求 bc 全排列 -> 得到 bc 和 cb -> 与 a 合并 -> 得到 abc 和 acb\n2. b 作为开头 -> 求 ac 全排列 -> 得到 ac 和 ca -> 与 b 合并 -> 得到 bac 和 bca\n3. c 作为开头 -> 求 ab 全排列 -> 得到 ab 和 ba -> 与 c 合并 -> 得到 cab 和 cba\n</code></pre>\n<ul>\n<li>注意，这只是其中一种实现方式。后面我们还会看到另一种实现</li>\n<li>首先我们来想一下公共逻辑是什么。对于一个字符串，我们取出一个字符作为开头，然后对去掉这个开头字符的剩余字符串继续求全排列。求出来之后，与取到的字符合并起来就行</li>\n<li>对于 <code>P(n)</code> 来说，我们要取出一个字符作为开头，而且原始的字符串可能本身就含有重复的字符。在代码中，我们可以通过开头字符在原字符串中的索引来区分</li>\n<li>对于我们封装的函数，可以直接使用字符串作为参数。这是因为，在获取剩余字符串全排列，即 <code>P(n - 1)</code> 时，我们并不关心去掉的那个，用作开头的字符是什么，只需要关心现在我们要生成谁的全排列就好</li>\n<li>因此，我们需要在递归调用时，传入去掉那个用作开头的字符之后的，剩余字符串。这个很容易实现，如果我们知道了去掉的那个字符的索引，那我们就可以用 <code>str.slice(0, i)</code> 来获取这个字符之前的字符串，用 <code>str.slice(i + 1, str.length)</code> 来获取这个字符之后的字符串 (注意，<code>slice</code> 方法的第一个参数是包含的，第二个不包含。如果 <code>i</code> 本身就是 <code>0</code>，那么取到的是 <strong>空字符串</strong>)，拼接在一起就可以作为递归调用的参数</li>\n<li>跳出条件也不难想，只要传入的参数长度为 <code>1</code> 或 <code>0</code>，直接返回即可</li>\n<li>另外，每次调用，我们都需要一个数组来保存根据当前参数生成的全排列。代码如下</li>\n</ul>\n<pre><code class=\"language-js\">function permAlone(string) {\n    function _perm(str) {\n        // 跳出条件\n        if (str.length &#x3C; 2) return str;\n        var permutations = [];\n\n        for (var i = 0; i &#x3C; str.length; i++) {\n            // 获取开头的字符串和剩余字符串\n            var start = str[i];\n            var remaining = str.slice(0, i) + str.slice(i + 1, str.length);\n\n            // 根据通过剩余字符串的全排列，生成前一次的全排列。注意 _perm(remaining) 是一个数组\n            for (var permutation of _perm(remaining)) {\n                permutations.push(start + permutation);\n            }\n        }\n        return permutations;\n    }\n}\n</code></pre>\n<h2>判断连续重复字符</h2>\n<h3>遍历</h3>\n<ul>\n<li>判断是否有连续重复的字符，最简单的方式是遍历。只需要在外面用一个变量记录上一个字符就可以</li>\n<li>只要当前的和上一个相同，直接跳出就可以，不需要继续判断。代码如下：</li>\n</ul>\n<pre><code class=\"language-js\">function hasRepeatChar(str) {\n    var previous = '';\n    for (var i = 0; i &#x3C; str.length; i++) {\n        if (previous === str[i]) {\n            return true;\n        } else {\n            // 赋值，用于下次判断\n            previous = str[i];\n        }\n    }\n    // 不存在连续重复字符\n    return false;\n}\n</code></pre>\n<h3>递归</h3>\n<ul>\n<li>递归也是很容易写的。跟上面的思路一样，调用的时候传入两个参数，分别是上一个字符，和剩余字符串。其中，剩余字符串可以通过 <code>str.slice(1)</code> 获取</li>\n<li>为避免 <code>str</code> 本身就是空字符串，需要多一次判断，即如果 <code>prevChar</code> 不是空的 (这说明 <code>prevChar</code> 被赋过值，而并非初始的空值)，我们才可以认为 <code>str</code> 不含连续重复字符，则返回 <code>false</code>。因此，跳出条件是 <code>str</code> 为空且 <code>prevChar</code> 有值。如果这时候 <code>prevChar</code> 也是空的，那就证明传入的 <code>str</code> 本身就是空的。为了防止混淆，我们直接给它返回 <code>\"Empty string\"</code>。事实上，这种 corner case 在这道题目中不会遇到。代码如下：</li>\n</ul>\n<pre><code class=\"language-js\">function hasRepeatChar(str, prevChar) {\n    if (str.length === 0) return prevChar ? false : 'Empty string';\n    if (prevChar === str[0]) return true;\n\n    return hasRepeatChar(str.slice(1), str[0]);\n}\n</code></pre>\n<h3>正则表达式</h3>\n<ul>\n<li>正则是个好东西。在正则里，有一中写法叫做 <code>back reference</code>，就是 <code>\\\\</code> 后面加一个正整数。请参考 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions\">文档</a> 中 <code>\\\\n</code> 的那一行</li>\n<li>简单来说，<code>\\\\x</code> 就是匹配之前，正数第 <code>x</code> 个 matched group (匹配组，也叫捕获组，其实就是小括号包含的内容)</li>\n<li>对于判断一个字符串是否含有连续重复字符，我们并不关注它重复了几次，也不需要关注它有几组重复的。因此，这里不需要 <code>global</code> flag <code>/g</code></li>\n<li>那么，对于字符串中的任意字符，只要这个字符右边的字符和它相同，那就匹配到，并且返回 <code>false</code>。听起来像是句废话，只是，如果你看不懂后面的正则，记得回来再读读这句话。代码如下：</li>\n</ul>\n<pre><code class=\"language-js\">function hasRepeatChar(str) {\n    return !/(\\w)\\1/.test(str);\n}\n</code></pre>\n<h1>基本解法</h1>\n<h2>思路提示</h2>\n<ul>\n<li>思路上面已经说得很清楚。通过上面的递归调用，我们可以得到了一个包含字符串全排列的数组，只需要通过上面的正则过滤一下，保留不含连续重复字符的字符串，并返回它的 <code>length</code></li>\n</ul>\n<h2>代码</h2>\n<pre><code class=\"language-js\">function permAlone(string) {\n    function _perm(str) {\n        if (str.length &#x3C; 2) return str;\n        var permutations = [];\n\n        for (var i = 0; i &#x3C; str.length; i++) {\n            var start = str[i];\n            var remaining = str.slice(0, i) + str.slice(i + 1, str.length);\n\n            for (var permutation of _perm(remaining)) {\n                permutations.push(start + permutation);\n            }\n        }\n        return permutations;\n    }\n    return _perm(string).filter(function(str) {\n        return !/(\\w)\\1/.test(str);\n    }).length;\n}\n</code></pre>\n<h1>数组方法 - 思路的优化</h1>\n<h2>思路提示</h2>\n<ul>\n<li>上面的方式是把子问题 (剩余字符串的全排列) 添加到之前取出的开头字符后面，这也就意味着，对于长度为 <code>n</code> 的字符串 <code>string</code>，开头的字符我们要获取 <code>n</code> 次。每一次取了开头，我们又要再对子问题进行 <code>n - 1</code> 次取开头的操作，因此这时候的时间复杂度会是 <code>n!</code>。效率很低</li>\n<li>如果我们换一个思路，采用 \"插值\" 的方法，会让整体操作变少一些。注意，这个思路并不一定需要用数组去实现。确切的说，如果不用数组去实现，效率会更高。只是个人觉得，用数组会比较容易写，也比较容易理解</li>\n<li>之前的方式，如果我们说它是 \"从前往后\" 实现的，那现在我们来试试从后往前实现</li>\n<li>对于字符串 <code>'abc'</code>，给出子串 <code>'bc'</code>，剩余 <code>'a'</code>。我们可以通过把 <code>'a'</code> 放到 <code>'bc'</code> 里面，不同的位置来实现排列。注意到 <code>'bc'</code> 有三个位置可以插入 <code>'a'</code>，分别是：</li>\n</ul>\n<pre><code> b c\n↑ ↑ ↑\n1 2 3\n</code></pre>\n<ul>\n<li>如果把 <code>'a'</code> 分别插入上面说的位置 <code>1</code>、<code>2</code> 和 <code>3</code>，我们就可以得到 <code>'abc'</code>、<code>'bac'</code> 和 <code>'bca</code></li>\n<li><code>'bc'</code> 排列还有一种情况 <code>'cb'</code>。再把 <code>'a'</code> 插入到 <code>'cb'</code> 的三个位置，我们就可以得到另外三种排列</li>\n<li>注意到，<code>'bc'</code> 和 <code>'cb'</code>，其实就是在子串 <code>'c'</code> 中插入 <code>'b'</code> 产生的。因为 <code>'c'</code> 只有两个位置可以插入 <code>'b'</code>：</li>\n</ul>\n<pre><code> c\n↑ ↑\n1 2\n</code></pre>\n<ul>\n<li>这样，我们就得到了一个新的递归思路，如下 (左边的竖线只是为了方便看清递归弹出的时候对应上面的哪一步，弹出步骤中的插入值与上面取出的第一个字符相对应)：</li>\n</ul>\n<pre><code>给出 'abc'\n\n|- 取出第一个字符 a，剩余 bc\n|  |- 取出第一个字符 b，剩余 c\n|  |  |- 取出第一个字符 c，剩余空字符串 (划重点，这个就是弹出的条件)\n|  |  |- 在上次剩余值中插入 c，只能得到一种情况 c\n|  |- 在上次剩余值 (c) 中插入 b，得到 bc 和 cb\n|- 在上次剩余值 (bc 和 cb) 中插入 a，得到 abc, bac, bca 和 acb, cab, cba\n</code></pre>\n<ul>\n<li>这个思路很像是，先一直走到底 (即长度为 0 的时候)，弹出的过程中，我们再来生成需要的结果</li>\n<li>这段代码加注释不太方便，详细解释还是写到代码之后吧</li>\n<li>如果你还是不知道如何写代码，不要怕麻烦，试着写出来 <code>'abcd'</code> 的详细过程，写完你就能理解了</li>\n</ul>\n<h2>代码</h2>\n<pre><code class=\"language-js\">function permAlone(string) {\n    return _perm(string.split('')).filter(function(str) {\n        return !/(\\w)\\1/.test(str);\n    }).length;\n\n    function _perm(arr) {\n        return arr.length === 0 ? [[]] : _perm(arr.slice(1)).reduce(function(accum, curr) {\n            // 插值的实现\n            for (var i = 0; i &#x3C; arr.length; i++) {\n                accum.push([curr.slice(0, i), arr[0], curr.slice(i)].join(''));\n            }\n            return accum;\n        }, []);\n    }\n}\n</code></pre>\n<h2>解释</h2>\n<ul>\n<li>先说一句，上面的代码，尽管思路优化了，但速度理论上会比之前的慢，因为咱们用了数组</li>\n<li>外面那层应该没啥疑问，既然决定了用数组去处理，那就干脆直接传入数组，一个 <code>split</code> 的事儿而已</li>\n<li>封装的 <code>_perm</code>，其实还是要进行递归调用的。当外面的 <code>string</code> 是空字符串时，返回值是 <code>[[]]</code>，而不可以是 <code>[]</code>。原因很简单，如果是 <code>[]</code>，那么 <code>reduce</code> 就不会执行了，因为没有元素。你可以试试以下的代码片段，就理解了：</li>\n</ul>\n<pre><code class=\"language-js\">// 不会输出 '执行了'，返回值是 []\n[].reduce((accum, curr) => {\n    console.log('执行了');\n    return accum;\n}, []);\n\n// 会输出 '执行了'，返回值也是 []\n[[]].reduce((accum, curr) => {\n    console.log('执行了');\n    return accum;\n}, []);\n</code></pre>\n<ul>\n<li>只要 <code>arr</code> 长度不为 <code>0</code>，那我们就递归调用 <code>_perm(arr.slice(1))</code>，直到遇到传入的 <code>arr</code> 长度为 <code>0</code>，才开始执行 <code>reduce</code> 弹出的过程。详情请看上面的思路分析</li>\n<li>里面的 <code>for</code> 循环很重要，\"插值\" 这个核心步骤就是在这里实现的。如果看不懂这个过程，请去了解一下 <code>slice</code> 方法是怎么回事，然后举几个例子带进去试一试就明白了</li>\n</ul>\n<h1>算法优化 - Heap's algorithm</h1>\n<h2>思路提示</h2>\n<ul>\n<li>注意，这里的 Heap 不是指数据结构的 \"堆\"，而是发明者的名字。如果你从来没听说过这个算法，那只靠自己想可能有些困难</li>\n<li>\n<p>给出字符串 <code>'abc'</code>，我们可以按照先确定结尾字符的思路来这样推一下：</p>\n<ul>\n<li>\n<p><code>'c'</code> 作为结尾：</p>\n<ul>\n<li>我们得到第一个排列 <code>'abc'</code></li>\n<li>通过交换 <code>'a'</code> 和 <code>'b'</code>，我们可以得到另一种排列 <code>'bac'</code></li>\n</ul>\n</li>\n<li>\n<p>交换开头结尾，这时候 <code>'b'</code> 作为结尾：</p>\n<ul>\n<li>得到 <code>'cab'</code></li>\n<li>通过交换 <code>'c'</code> 和 <code>'a'</code>，得到 <code>'acb'</code></li>\n</ul>\n</li>\n<li>\n<p>交换开头结尾，这时候 <code>'a'</code> 作为结尾：</p>\n<ul>\n<li>得到 <code>'bca'</code></li>\n<li>通过交换 <code>'b'</code> 和 <code>'c'</code>，得到 <code>'cba'</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>思路大致上是这样，通过交换去实现。交换的好处在于，我们不需要额外的空间去存储。值得注意的是，在 JavaScript 中，字符串可以通过 index 访问某一个位置的字符，但不可以修改它的值。因此，想要换位，我们还是要通过数组来实现的</li>\n<li>事实上，真正实现起来还与上面的例子有区别。在 <code>Heap's Algorithm</code> 的 <a href=\"https://en.wikipedia.org/wiki/Heap%27s_algorithm\">维基百科页面</a> 有详细的解释，也有四个元素的详细步骤示例。其实，并不是 \"交换开头结尾\" 这么简单的</li>\n<li>实现数组中元素交换的方式也非常多。有朋友可能首先想到的是用 <code>splice</code>，但这样做效率会很低，我会比较推荐用变量缓存一个值的做法，很容易写。比如，我们需要交换 index 为 <code>2</code> 和 <code>4</code> 的元素：</li>\n</ul>\n<pre><code class=\"language-js\">var arr = [1, 2, 3, 4, 5, 6];\n\nvar temp = arr[2];\narr[2] = arr[4];\narr[4] = temp;\n\nconsole.log(arr);  // [1, 2, 5, 4, 3, 6]\n</code></pre>\n<ul>\n<li>当然，还有一种比较好玩儿的黑科技：</li>\n</ul>\n<pre><code class=\"language-js\">var arr = [1, 2, 3, 4, 5, 6];\narr[2] = [arr[4], arr[4] = arr[2]][0]\n\nconsole.log(arr);  // [1, 2, 5, 4, 3, 6]\n</code></pre>\n<ul>\n<li>如果你听说过 ES6 的解构赋值，也可以这么写。注意这个在不支持 ES6 的浏览器里是不行的：</li>\n</ul>\n<pre><code class=\"language-js\">var arr = [1, 2, 3, 4, 5, 6];\n[arr[2], arr[4]] = [arr[4], arr[2]]\n\nconsole.log(arr);  // [1, 2, 5, 4, 3, 6]\n</code></pre>\n<ul>\n<li>维基百科页面也提供了伪代码，而且提供了递归和非递归的两个版本。两个版本都用到了两个参数，但我们只需要一个 <code>n</code> 就够了，不需要第二个 <code>A</code>，因为我们的数组可以通过 <code>var arr = str.split('');</code> 将它定义到函数 <code>generate</code> 外面。这样，伪代码如下：</li>\n</ul>\n<pre><code class=\"language-js\">函数 generate\n参数 num\n\n如果 num 等于 1:\n    arr.join('')，并添加到结果数组\n否则:\n    循环，0 至 num:\n        递归调用 generate(num - 1)\n        如果 num 为偶数:\n            交换 strArr[i] 与 strArr[num - 1]\n        如果 num 为奇数:\n            交换 strArr[0] 与 strArr[num - 1]\n</code></pre>\n<h2>代码</h2>\n<pre><code class=\"language-js\">function permAlone(str) {\n    var arr = str.split('');\n    var result = [];\n    // 声明需要放在这里，因为赋值是在弹出的时候执行的\n    var tempIndex;\n\n    function generate(num) {\n        if (num === 1) {\n            result.push(arr.join(''));\n        } else {\n            for (var i = 0; i &#x3C; num; i++) {\n                generate(num - 1);\n                tempIndex = num % 2 ? 0 : i;\n                arr[tempIndex] = [arr[num - 1], arr[num - 1] = arr[tempIndex]][0];\n            }\n        }\n    }\n    \n    generate(arr.length);\n    \n    return result.filter(function(str) {\n        return !/(\\w)\\1/.test(str);\n    }).length;\n}\n</code></pre>","frontmatter":{"title":"FreeCodeCamp 高级算法题 - 字符串排列","date":"2017-09-06 22:32:17","tags":["FreeCodeCamp","高级","算法"],"categories":"FCC"},"fields":{"slug":"/advanced-no-repeats-please/"}}},"pageContext":{"slug":"/advanced-no-repeats-please/"}},"staticQueryHashes":["2566592090"]}