{"componentChunkName":"component---src-templates-index-jsx","path":"/blog/5","result":{"data":{"allMarkdownRemark":{"totalCount":52,"edges":[{"node":{"html":"<h1>Array对象</h1>\n<h2>Array的创建</h2>\n<ul>\n<li>Array构建函数创建</li>\n<li>无参数创建会生成一个空的数组</li>\n<li>当传入一个数值时，会生成一个数组，并且长度设为该数值</li>\n<li>当传入一个非数值时，会生成一个数组，并且数组第一项位该值</li>\n<li>如果传入多个值时，会生成一个数组，并且这几个值都会依次存在于数组中</li>\n</ul>\n<pre><code class=\"language-js\">let arr1 = new Array()\nlet arr2 = new Array(3)\nlet arr3 = new Array('张三')\nlet arr4 = new Array({ name: '张三' })\nlet arr5 = new Array(5, '张三', 24)\nconsole.log(arr1, arr2, arr3, arr4, arr5)\n// []\n// [empty × 3]\n// [\"张三\"]\n// [{…}]\n// [5, \"张三\", 24]\n</code></pre>\n<h2>Array.from、Array.of</h2>\n<ul>\n<li>这两个都是Array构造函数的静态方法，属于ES6新增范畴</li>\n<li>Array.from用于将类数组结构转为数组</li>\n<li>Array.from方法接收的第一个参数是一个类数组对象（任何可迭代的结构）或者有length属性与可索引元素的结构</li>\n</ul>\n<!--more-->\n<pre><code class=\"language-js\">// 字符串转为数组\nconsole.log(Array.from(\"Matt\"))\n// [\"M\", \"a\", \"t\", \"t\"]\nconst m = new Map().set(1,2).set(3,4)\nconst s = new Set().add(1).add(2).add(3).add(4)\nconsole.log(Array.from(m)) // [[1, 2], [3, 4]]\nconsole.log(Array.from(s)) // [1, 2, 3, 4]\nconst iter = {\n  *[Symbol.iterator](){\n    yield 1;\n    yield 2;\n    yield 3;\n    yield 4;\n    yield 5;\n  }\n}\nconsole.log(Array.from(iter)) // [1, 2, 3, 4, 5]\n\nfunction getArgsArray(){\n  return Array.from(arguments)\n}\nconsole.log(getArgsArray(1,2,3,4)) // [1, 2, 3, 4]\n\nconst arrayLikeObject = {\n  0: 1,\n  1: 2,\n  3: 3,\n  4: 4,\n  length:4\n}\nconsole.log(Array.from(arrayLikeObject)) // [1, 2, 3, 4]\n</code></pre>\n<ul>\n<li>Array.from的第二个参数（可选）接收的是一个对新数组操作的函数，会对新数组的每一项都执行该函数</li>\n<li>第三个参数（可选）接收的是操作函数的this的值，当第二个参数是箭头函数时，这个值无效</li>\n</ul>\n<pre><code class=\"language-js\">const array = [1,2,3,4]\nconst a2 = Array.from(array, x => x ** 2)\nconst a3 = Array.from(array, function(x) { return x ** this.exponent}, { exponent: 2 })\nconsole.log(a2) // [1, 4, 9, 16]\nconsole.log(a3) // [1, 4, 9, 16]\n</code></pre>\n<ul>\n<li>Array.of可以把一组参数专为数组，用于替代之前的Array.prototype.slice.call(arguments)</li>\n</ul>\n<pre><code class=\"language-js\">console.log(Array.of(1, 2, 3, 4)) // [1, 2, 3, 4]\nconsole.log(Array.of(undefined))  // [undefined]\n</code></pre>\n<h2>数组检测</h2>\n<ul>\n<li>在只有一个全局上下文时只用 instanceof 就够用了，但是要是有两个全局上下文，那么对应的Array构造函数可能不同，这种情况下可能不合适</li>\n<li>所以针对这种情况就提供了 Array.isArray()方法，该方法只用于确定一个值是否是数组，跟上下文环境无关</li>\n</ul>\n<pre><code class=\"language-js\">let array = [1, 2, 3, 4]\nlet arrayLike = {\n  0: 1,\n  1: 2,\n  2: 3,\n  length: 3\n}\nconsole.log(array instanceof Array)     // true\nconsole.log(arrayLike instanceof Array) // false\n\nconsole.log(Array.isArray(array))       // true\nconsole.log(Array.isArray(arrayLike))   // false\n</code></pre>\n<h2>迭代器方法</h2>\n<ul>\n<li>Array原型暴露了3个检索数组内容的方法，keys()，values()，entries()</li>\n<li>keys返回数组索引的迭代器</li>\n<li>values返回数组元素的迭代器</li>\n<li>entries返回索引/元素的迭代器</li>\n</ul>\n<pre><code class=\"language-js\">// 都是迭代器，所以可以直接使用Array.from转为数组\nconst a = ['foo', 'bar', 'baz', 'qux']\nconsole.log(Array.from(a.keys()))     //  [0, 1, 2, 3]\nconsole.log(Array.from(a.values()))   // [\"foo\", \"bar\", \"baz\", \"qux\"]\nconsole.log(Array.from(a.entries()))  // [[0, \"foo\"], [1, \"bar\"], [2, \"baz\"], [3, \"qux\"]]\n</code></pre>\n<h2>填充方法copyWithin、fill</h2>\n<ul>\n<li>数组填充方法 fill() 可以向一个已有的数组中插入全部或部分相同的值。</li>\n<li>第一个参数为填充值</li>\n<li>第二个参数为开始索引，指定开始填充的位置（可选），</li>\n<li>第三个参数为结束索引位置（填充不包含该位置），不提供结束索引就一直填充到数组末尾</li>\n<li>负值索引从数组末尾开始计算（也可以理解为数组长度加上它得到的正值索引）</li>\n</ul>\n<pre><code class=\"language-js\">const zeroes = [0, 0, 0, 0, 0]\nzeroes.fill(5) // [5, 5, 5, 5, 5]\nzeroes.fill(0) // 重置为 0 [0, 0, 0, 0, 0]\n\nzeroes.fill(6, 3) // [0, 0, 0, 6, 6]\nzeroes.fill(0)\n\nzeroes.fill(7, 1, 3) // [0, 7, 7, 0, 0]\nzeroes.fill(0)\n\n// -4 + 5 = 1, -1 + 5 = 4,等价于zeroes.fill(1, 4)\nzeroes.fill(8, -4, -1) // [0, 8, 8, 8, 0]\n</code></pre>\n<ul>\n<li>fill()静默忽略超出数组边界，零长度以及相反索引</li>\n</ul>\n<pre><code class=\"language-js\">const zeroes = [0, 0, 0, 0, 0]\nzeroes.fill(1, -10, -6) // 索引过低 [0, 0, 0, 0, 0]\nzeroes.fill(0)\n\nzeroes.fill(1, 10 ,15) // 索引过高 [0, 0, 0, 0, 0]\nzeroes.fill(0)\n\nzeroes.fill(7, 4, 2) // 索引相反，忽略 [0, 0, 0, 0, 0]\nzeroes.fill(0)\n\n// -4 + 5 = 1, -1 + 5 = 4,等价于zeroes.fill(1, 4)\nzeroes.fill(8, 3, 10) // [0, 0, 0, 8, 8]\n</code></pre>\n<ul>\n<li>copyWithin会浅复制数组中的部分内容，然后再插入到指定索引的位置，开始索引与结束索引与fill计算方式一直</li>\n<li>第一个参数为插入元素的开始位置</li>\n<li>第二个参数为复制数组的开始位置（可选），默认为0</li>\n<li>第三个参数为复制数组的结束位置（可选），不指定则会一直复制到数组结束</li>\n</ul>\n<pre><code class=\"language-js\">let ints, reset = () => ints = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nreset()\n\n// 未指定开始位置表示从数组的第0个位置开始复制，然后插入到第5个位置\nints.copyWithin(5) // [0, 1, 2, 3, 4, 0, 1, 2, 3, 4]\nreset()\n\n// 第二个参数为5，表示从数组的第5个位置开始复制，然后从3的位置开始插入\nints.copyWithin(3, 5) // [0, 1, 2, 5, 6, 7, 8, 9, 8, 9]\nreset()\n\n// 第二个参数为0，表示从数组的第0个位置开始复制，复制到第3的位置，然后从第4个位置插入\nints.copyWithin(4, 0, 3) // [0, 1, 2, 3, 0, 1, 2, 7, 8, 9]\nreset()\n\n// 负值的算法与fill一致， -4 + 10 = 6， -7 + 10 = 3，-3  + 10 = 7,等价于 ints.copyWithin(6, 3, 7)\nints.copyWithin(-4, -7, -3) // [0, 1, 2, 3, 4, 5, 3, 4, 5, 6]\n</code></pre>\n<ul>\n<li>copyWithin()也会静默忽略超出数组边界，零长度以及相反索引</li>\n</ul>\n<pre><code class=\"language-js\">let ints, reset = () => ints = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nreset()\n\n// 索引过低，忽略\nints.copyWithin(1, -15, -12) // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nreset()\n\n// 索引过高，忽略\nints.copyWithin(1, 12, 15) // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nreset()\n\n// 索引反向，忽略\nints.copyWithin(4, 3, 1) // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nreset()\n\n// 部分索引可用\nints.copyWithin(4, 7, 10) // [0, 1, 2, 3, 7, 8, 9, 7, 8, 9]\n</code></pre>\n<h2>转换方法</h2>\n<ul>\n<li>所有对象都有toLocalString、toString、valueOf方法。</li>\n<li>数组中valueOf返回数组本身</li>\n<li>toString返回数组每一项调用toString返回的字符串用逗号拼接的一个字符串</li>\n<li>toLocalString返回数组每一项调用toLocalString返回的字符串用逗号拼接的一个字符串</li>\n</ul>\n<pre><code class=\"language-js\">let a = [1,2,3,4]\nconsole.log(a.valueOf())  // [1, 2, 3, 4]\nconsole.log(a.toString()) // 1,2,3,4\n</code></pre>\n<h2>reverse与sort</h2>\n<ul>\n<li>reverse就是简单地将数组翻转</li>\n<li>sort默认会将数组的每一项调用String方法，然后再按照升序排列元素，所以对数字的排序会有问题</li>\n<li>所以sort可以接收一个比较函数，如果第一个值要在第二个值前面，返回-1，两个参数相等，返回0，第一个值在第二个值后面，返回1</li>\n</ul>\n<pre><code class=\"language-js\">let arr = [0, 1, 5, 10, 15]\nconsole.log(arr.sort()) // [0, 1, 10, 15, 5]\n\nfunction compare(x, y){\n  if(x > y) {\n    return 1\n  } else if(x &#x3C; y) {\n    return -1\n  } else {\n    return 0\n  }\n}\nconsole.log(arr.sort(compare)) // [0, 1, 5, 10, 15]\n</code></pre>\n<ul>\n<li>上面直接对数字数组调用出错是因为对数字排序时也会转为字符串在比较，'10' 对应的字符串要小于 '5'的字符串</li>\n<li>下面进行了值比较后就正常了，单看这个比较，其实简单地 arr.sort((a, b) => a - b) 也可以实现</li>\n</ul>\n<h2>concat方法</h2>\n<ul>\n<li>concat是数组拼接方法，会创建一个数组的副本，然后把它的参数拼接到副本末尾，然后返回这个副本</li>\n<li>如果参数是数组，会把数组的每一项都加到结果数组，如果是非数组，则直接加到结果数组中</li>\n</ul>\n<pre><code class=\"language-js\">let colors = ['red', 'green', 'blue']\nlet colors1 = colors.concat('yellow', ['black', 'brown'])\nconsole.log(colors)   // [\"red\", \"green\", \"blue\"]\nconsole.log(colors1)  // [\"red\", \"green\", \"blue\", \"yellow\", \"black\", \"brown\"]\n</code></pre>\n<ul>\n<li>参数中的数组是否被展开拼接可以通过符号 Symbol.isConcatSpreadable 控制，为false不再展开，为true强制展开</li>\n</ul>\n<pre><code class=\"language-js\">let colors = ['red', 'green', 'blue']\nlet newColors = ['black', 'brown']\nnewColors[Symbol.isConcatSpreadable] = false\nlet moreNewColors = {\n  [Symbol.isConcatSpreadable]: true,\n  length: 2,\n  0: 'pink',\n  1: 'cyan'\n}\nconsole.log(colors.concat(newColors))     // [\"red\", \"green\", \"blue\", Array(2)]\nconsole.log(colors.concat(moreNewColors)) // [\"red\", \"green\", \"blue\", \"pink\", \"cyan\"]\n</code></pre>\n<h2>slice与splice</h2>\n<ul>\n<li>slice就是简单地创建一个包含原数组一个或多个元素的数组</li>\n<li>参数有两个，第一个为开始位置，第二个为结束位置（可选）</li>\n<li>不设置结束位置则一直到数组尾的全部元素</li>\n<li>如果结束位置小于开始位置，返回空数组</li>\n<li>如果参数为负值，则认为值为该负值加数组长度后的值</li>\n<li>splice用于向数组删除与插入元素</li>\n<li>第一个参数表示删除元素的位置</li>\n<li>第二个参数表示删除的数量</li>\n<li>第三个及以后的参数表示在删除位置要插入的元素</li>\n<li>该方法返回值为删除后的元素</li>\n</ul>\n<h2>find与findIndex</h2>\n<ul>\n<li>都用于查找元素，find返回第一个匹配的元素，findIndex返回第一个匹配元素的索引</li>\n<li>没找到find返回undefined，findIndex返回-1</li>\n<li>找到元素后两个方法都不会继续执行</li>\n</ul>\n<pre><code class=\"language-js\">let arr1 = [2, 4, 6]\nconsole.log(arr1.find(x => x === 4)) // 4\nconsole.log(arr1.findIndex(x => x === 4)) // 1\n</code></pre>\n<h2>迭代方法</h2>\n<ul>\n<li>every()，数组每一项都执行传入的函数，都返回true则结果返回true</li>\n<li>filter()，数组每一项都运行该函数，函数返回true则会将返回true的项拼接为数组后返回</li>\n<li>forEach()，数组每一项都执行该函数，无返回值</li>\n<li>map()，数组每一项都执行该值，返回由函数调用结果够成的数组</li>\n<li>some()，数组每一项都执行该值，有一项返回true，则方法返回true</li>\n</ul>\n<h2>reduce与reduceRight</h2>\n<ul>\n<li>两个方法都会迭代数组所有项，然后构建一个最终值并返回</li>\n<li>区别是reduce从数组第一项开始迭代，reduceRight从数组最后一项开始迭代</li>\n<li>两个方法都接受两个参数，第一个为归并函数，第二个为初始值（可选）</li>\n<li>归并函数接收4个参数，上一个归并值，当前项，当前索引，数组本身</li>\n<li>当方法的第二个参数不存在时，归并函数从第二个值开始，第一个值作为初始值</li>\n<li>以此可以做数组求和</li>\n</ul>\n<pre><code class=\"language-js\">let values = [1, 2, 3, 4, 5]\n// 可以无初始值\nlet sum = values.reduce((prev, cur, index, array) => prev + cur)\nconsole.log(sum) // 15\n// 有初始值\nsum = values.reduce((prev, cur, index, array) => prev + cur, 0)\nconsole.log(sum) // 15\n\n// 使用reduceRight\n// 有初始值\nsum = values.reduceRight((prev, cur, index, array) => prev + cur, 0)\nconsole.log(sum) // 15\n</code></pre>","fields":{"slug":"/ObjectArray/"},"frontmatter":{"title":"Array对象","tags":["JavaScript回顾"],"categories":"JavaScript"}}},{"node":{"html":"<h1>定型数组</h1>\n<ul>\n<li>WebGL的出现导致了定型数组的出现，WebGL的API不需要javascript默认的双精度浮点格式的数值，但是这种数值恰好是javascript数组在内存中的格式。</li>\n<li>因此每次WebGL与javascript运行时传递数组WebGL都需要在目标环境分配新数组，以其当前形式迭代数组，然后将数值类型转为新数组中的适当格式，但是这一过程太过耗时</li>\n<li>所以产生了CanvasFloatArray(现在的Float32Array)。javascript可以分配、读取和写入这个数组。这个数组可以直接传给底层的图形驱动API，也可以直接从底层API获取到</li>\n<li>Float32Array是定型数组的一种</li>\n</ul>\n<h2>ArrayBuffer</h2>\n<ul>\n<li>Float32Array其实是一种“视图”，允许jiavascript访问一块名为ArrayBuffer的预分配内存。ArrayBuffer是所有定型数组以及视图引用的基本单位</li>\n<li>ArrayBuffer是普通的javascript构造函数，用于在内存中分配特定数量的字节空间</li>\n<li>\n<p>ArrayBuffer一经创建就不可更改大小，但是可以使用slice复制到一个新实例中</p>\n<!--more-->\n<pre><code class=\"language-js\">const buf1 = new ArrayBuffer(16)\nconsole.log(buf1.byteLength)    // 16\nconst buf2 = buf1.slice(4, 12)\nconsole.log(buf2.byteLength)    // 8\n</code></pre>\n</li>\n<li>ArrayBuffer分配失败会抛错，分配的内存不可超过Number.MAX<em>SAFE</em>INTEGER(2 ** 53 - 1)字节</li>\n<li>ArrayBuffer初始化会将所有二进制位初始化位0</li>\n<li>不可直接对ArrayBuffer进行读取或写入内容，需要借助视图。视图有不同的类型，但是引用的都是ArrayBuffer中的二进制数据</li>\n</ul>\n<h2>DataView</h2>\n<ul>\n<li>允许读写ArrayBuffer的一种视图。位文件I/O与网络I/O设计，API支持对缓冲数据的高度控制，但是性能会比其他视图差，对缓冲内容没有预设，也不能迭代</li>\n<li>必须在有ArrayBuffer的情况下才能创建DataView实例。该实例可以使用全部或部分ArrayBuffer，还有对缓冲实例的引用以及在缓冲中的开始位置</li>\n</ul>\n<pre><code class=\"language-js\">const buf = new ArrayBuffer(16)\nconst fullDataView = new DataView(buf)\nconsole.log(fullDataView.byteOffset)      // 0\nconsole.log(fullDataView.byteLength)      // 16\nconsole.log(fullDataView.buffer === buf)  // true\n</code></pre>\n<ul>\n<li>构造函数可以接收可选的偏移量与字节长度，第二个参数为偏移量，第三个参数为字节长度</li>\n<li>不指定字节长度则默认从偏移量到缓冲区域结束</li>\n</ul>\n<pre><code class=\"language-js\">const buf = new ArrayBuffer(16)\nconst dataView = new DataView(buf, 6, 3)\nconsole.log(dataView.byteOffset)      // 6\nconsole.log(dataView.byteLength)      // 3\nconsole.log(dataView.buffer === buf)  // true\n\nconst dataView2 = new DataView(buf, 9)\nconsole.log(dataView2.byteOffset)      // 9\nconsole.log(dataView2.byteLength)      // 7\nconsole.log(dataView2.buffer === buf)  // true\n</code></pre>\n<ul>\n<li>DataView读写组件还需要读写的字节偏移量</li>\n<li>要使用ElementType来实现JavaScript的Number类型到缓冲内二进制的转换</li>\n</ul>\n<h3>ElementType</h3>\n<ul>\n<li>DataView对存储在缓冲的数据类型没有预设，强制要求开发者在读写时指定ElementType</li>\n<li>\n<p>常见的ElementType类型如下</p>\n<ul>\n<li>Int8，1个字节，8位有符号整数，范围 -128 - 127</li>\n<li>Uint8，1个字节，8位无符号整数，范围 0 - 255</li>\n<li>Int16，2个字节，16位有符号整数，范围 -32768 - 32767</li>\n<li>Uint16，2个字节，16位无符号整数，范围 0 - 65535</li>\n<li>Int32，4个字节，32位有符号整数，范围 -2147483648 - 2147483647</li>\n<li>Uint32，4个字节，32位无符号整数，范围 0 - 42949967295</li>\n<li>Float32，4个字节，32位IEEE-754浮点数，范围 -3.4e+38 - 3.4e+38</li>\n<li>Float64，8个字节，64位IEEE-754浮点数，范围 -1.7e+308 - 1.7e+308</li>\n</ul>\n</li>\n<li>DataView给上面的每个类型都暴露了get与set方法，使用byteOffset定位要读写的值</li>\n</ul>\n<pre><code class=\"language-js\">const buf = new ArrayBuffer(2)\nconst view = new DataView(buf)\n// 因为ArrayBuffer的初始值都是0\nconsole.log(view.getInt8(0)) // 0\nconsole.log(view.getInt8(1)) // 0\nconsole.log(view.getInt16(0)) // 0\n\n// 采用8位有符号数设置\nview.setInt8(0, 255)  // 将第一个字节用255填充，也就是二进制的 11111111\nview.setInt8(1, 0xFF) // 第二个字节也用16进制的255填充，仍然是8位的1\n\nview.getInt16(0)  // -1 获取有符号的16位整数，第一位为符号位表示负数，然后转为10进制数为 -1\nview.getUint16(0) // 65535 无符号的16位整数，转为10进制数为65535\n</code></pre>\n<h3>字节序</h3>\n<ul>\n<li>字节序是指计算机维护的字节顺序的约定，DataView支持大端字节序和小端字节序。</li>\n<li>大端字节序意思是最高有效位保存在第一个字节，最低有效位保存在最后一个字节</li>\n<li>小端字节序就相反，最低有效位保存在第一个字节，最高有效位保存在最后一个字节</li>\n<li>Javascript运行时所在系统的原生字节序决定如何读写字节，但是DataView不受该影响，DataView所有的API方法都是大端字节序，可以接受一个可选的布尔值设置为true启用小端字节序</li>\n</ul>\n<pre><code class=\"language-js\">const buf2 = new ArrayBuffer(16)\nconst view2 = new DataView(buf2)\nview.setInt8(0, 0x80)   // 二进制表示 10000000\nview.setInt8(1, 0x01)   // 二进制表示 00000001\n\n// 获取16位整型，因为包含两个字节，第一个字节为 10000000，第二个字节为 00000001 \n// 采用大端字节序，从左往右读，就是 10000000 00000001，转为10进制就是 2 ** 15 + 2 ** 0 = 32769\nconsole.log(view.getUint16(0)) // 32769\n\n// 采用小端字节序，从右往左读，就是 00000001 10000000， 转为10进制就是 2 ** 8 + 2 ** 7 = 384\nconsole.log(view.getUint16(0, true)) // 384\n\n// 按大端字节序写入Uint16的 0x0004，此时字节为 00000000 00000100\nview.setUint16(0, 0x0004)\n\n// 此时按Uint8读取值为\nconsole.log(view.getUint8(0)) // 0\nconsole.log(view.getUint8(1)) // 4\n\n// 按小端字节序写入Uint16的 0x0002，此时字节为 00000010 00000000\nview.setUint16(0, 0x0002)\n\n// 此时按Uint8读取值为\nconsole.log(view.getUint8(0)) // 0\nconsole.log(view.getUint8(1)) // 2\n</code></pre>\n<h2>边界值</h2>\n<ul>\n<li>DataView的读写操作都要在足够的缓冲内进行，否则抛出RangeError</li>\n</ul>\n<pre><code class=\"language-js\">const buf3 = new ArrayBuffer(6)\nconst view3 = new DataView(buf3)\n// 读取部分超出缓冲范围  因为Int32占4个字节，缓冲区总长度为6个字节，然后从第4个字节读取，读到第7个就没有值了，所以抛出错误\nview.getInt32(4)  //VM4353:3 Uncaught RangeError: Offset is outside the bounds of the DataView\n\n// 尝试读取超出范围的值\nview.getInt32(8)  //VM4353:3 Uncaught RangeError: Offset is outside the bounds of the DataView\nview.getInt32(-1)  //VM4353:3 Uncaught RangeError: Offset is outside the bounds of the DataView\n\n// 尝试写入超出范围的值\nview.setInt32(4, 123)  //VM4353:3 Uncaught RangeError: Offset is outside the bounds of the DataView\n</code></pre>\n<ul>\n<li>DataView会尽可能地把一个值转为适当的类型，后备值为0。如果无法转换，抛出错误</li>\n</ul>\n<pre><code class=\"language-js\">const buf4 = new ArrayBuffer(1)\nconst view4 = new DataView(buf4)\n\nview4.setInt8(0, 1.5)\nconsole.log(view4.getInt8(0)) // 1\n\nview4.setInt8(0, [4])\nconsole.log(view4.getInt8(0)) // 4\n\nview4.setInt8(0, 'f')\nconsole.log(view4.getInt8(0)) // 0\n\nview4.setInt8(0, Symbol())\nconsole.log(view4.getInt8(0)) // VM4674:13 Uncaught TypeError: Cannot convert a Symbol value to a number\n</code></pre>\n<h2>定型数组</h2>\n<ul>\n<li>定型数组是另一种形式的ArrayBuffer，特定于一种ElementType并遵循原生的字节序，因此，它提供了适用面更广的Api和更好的性能</li>\n<li>创建定型数组的方式有：读取已有缓冲、使用自有缓冲、填充可迭代结构，以及填充基于任意类型的定型数组</li>\n<li>通过<ElementType>.from()和<ElementType>.of()也可以创建定型数组</li>\n</ul>\n<pre><code class=\"language-js\">// 通过缓冲区创建\nconst buf5 = new ArrayBuffer(12)\nconst ints = new Int32Array(buf5)\n// 因为我们的ArrayBuffer确定了字节数，Int32的字节数也是知道的，所以可以自动得出定型数组长度\nconsole.log(ints.length) // 3\n\n// 指定长度自己创建\nconst int1 = new Int32Array(6)\nconsole.log(int1.length)              // 6\n// 定型数组有一个关联缓冲的引用，可以根据自身的长度与字节数确定缓冲区的长度\nconsole.log(int1.buffer.byteLength)   // 24\n\n// 创建包含元素的定型数组\nconst int2 = new Int32Array([2, 4, 6, 8])\nconsole.log(int2.length) // 4\nconsole.log(int2.buffer.byteLength) // 16\nconsole.log(int2[2]) // 6\n\nconst ints3 = new Int16Array(int2)\n// 这里从int2生成了新的定型数组，元素位置都没有发生变化，只是将对应的 Int32 位数转为 Int16 位数，这样变化的只有缓冲区的大小\nconsole.log(ints3.length) // 4\nconsole.log(ints3.buffer.byteLength) // 8\nconsole.log(ints3[2]) // 6\n\n// const float = Float32Array.from([3.14, 2.718, 1.618]) 这两种方式都可以\nconst float = Float32Array.of(3.14, 2.718, 1.618)\nconsole.log(float.length) // 3\nconsole.log(float.buffer.byteLength) // 12\nconsole.log(float[2]) // 1.6180000305175781\n</code></pre>\n<ul>\n<li>定型数组的构造函数跟实例都有一个BYTES<em>PER</em>ELEMENT来表示当前定型数组每个元素的大小</li>\n</ul>\n<pre><code class=\"language-js\">console.log(Int16Array.BYTES_PER_ELEMENT) // 2\nconsole.log(Int32Array.BYTES_PER_ELEMENT) // 4\n</code></pre>\n<ul>\n<li>定型数组没有初始化，那么对应的缓冲会以0填充</li>\n<li>定型数组可以使用常用的数组方法，如some、map、every这些，并且返回的数组拥有相同元素类型的新定型数组</li>\n<li>定型数组无法改变长度，所以concat、pop、push、shift、splice、unshift方法不可用</li>\n<li>定型数组提供了set与subarray方法来复制数组元素以生成新的定型数组</li>\n<li>set方法从提供的数组中或者定性数组中把值复制到当前定型数组指定的索引位置</li>\n<li>第一个参数为被复制的数组，第二个参数为复制到定型数组的索引</li>\n<li>溢出会抛错</li>\n</ul>\n<pre><code class=\"language-js\">const container = new Int16Array(8)\ncontainer.set(Int8Array.of(1, 2, 3, 4))\nconsole.log(container) // [1, 2, 3, 4, 0, 0, 0, 0]\n\ncontainer.set([5, 6, 7, 8], 4)\nconsole.log(container) // [1, 2, 3, 4, 5, 6, 7, 8]\n\n// 剩余空间不够，溢出\ncontainer.set([5, 6, 7, 8], 7) // Uncaught RangeError: Source is too large\n</code></pre>\n<ul>\n<li>subarray方法与set相反，从指定的定型数组中复制一部分并返回这一部分组成的新定型数组</li>\n<li>接收2个参数，都可选，对应开始位置与结束位置</li>\n</ul>\n<pre><code class=\"language-js\">const source = Int32Array.of(2, 4, 6, 8)\nconst sub = source.subarray()\nconsole.log(sub)  // [2, 4, 6, 8]\n\nconst sub1 = source.subarray(2)\nconsole.log(sub1) //  [6, 8]\n\nconst sub2 = source.subarray(1,3)\nconsole.log(sub2) // [4, 6]\n</code></pre>\n<ul>\n<li>利用set手动实现一个拼接方法</li>\n</ul>\n<pre><code class=\"language-js\">function concatTypeArray(typeArrayConstructor, ...typeArrays) {\n  const totalLength = typeArrays.reduce((x, y) => (x.length || x) + y.length)\n  const resultArray = new typeArrayConstructor(totalLength)\n  let currentNum = 0\n  typeArrays.map(array => {\n    resultArray.set(array, currentNum)\n    currentNum += array.length\n  })\n  return resultArray\n}\n\nconst result = concatTypeArray(Int16Array, Int16Array.of(1, 2, 3), new Int16Array([4, 5, 6]), Int16Array.from([7, 8, 9]))\nconsole.log(result) // [1, 2, 3, 4, 5, 6, 7, 8, 9]\nconsole.log(result instanceof Int16Array) // true\n</code></pre>\n<h2>上溢与下溢</h2>\n<ul>\n<li>定型数组中元素的上溢与下溢不会影响其他索引的元素，但是要考虑自身的数据类型，如下所示</li>\n</ul>\n<pre><code class=\"language-js\">// Int8的范围为 -128 - 127\nconst ints = new Int8Array(2)\n// 上溢\nints[1] = 128 \n// 128用二进制表示为 10000000 ，因为是有符号 8 位，所以第一个 1 被当作负号的标识，所以会根据符号把它当作二补码来求原来的值\n// 首先减一得 00000001，然后再取反得 10000000 是二进制的 128，再加上判定的负数，所以为 -128\nconsole.log(ints[1]) // -128\n\n// 下溢\nints[1] = -129\n// 因为-129是负数形式，所以我们得到的 -129 得二进制表示为 129得二进制 10000001 ，然后各位取反得 01111110，然后再加 1 得 01111111，再补上符号位 1 ，因为要截取8位，所以得到的就是 01111111，转为我们的有符号数就是 127\nconsole.log(ints[1]) // 127\n\n// Uint8范围为 0 - 255\nconst unsignInts = new Uint8Array(2)\n// 上溢\nunsignInts[1] = 256\n// 256用二进制表示为 100000000，然后这里截取后面 8 位就是 00000000，转为十进制就是0\nconsole.log(unsignInts[1]) // 0\n\nunsignInts[1] = 511\n// 511 用二进制表示位 111111111，然后截取后面 8 位就是 11111111，转十进制就是255\nconsole.log(unsignInts[1]) // 255\n\n// 下溢\nunsignInts[1] = -1\n// -1 用二进制表示是 1 得二进制 00000001 ，然后各位取反 11111110，然后再加 1 得 11111111，这个用无符号数表示就是 255\nconsole.log(unsignInts[1]) // 255\n</code></pre>\n<ul>\n<li>得出结论，无符号数上溢取最低有效位的 8 位，下溢的位被转为其无符号数的等价值</li>\n<li>有符号数的上溢变成该值二补数形式，下溢也变成该值二补数形式</li>\n</ul>\n<h2>Uint8ClampedArray</h2>\n<ul>\n<li>夹板数组，不允许任何方向的溢出，大于255的变为255，小于0的变为0</li>\n</ul>\n<pre><code class=\"language-js\">const clampedInts = new Uint8ClampedArray([-1, 0, 255, 256])\nconsole.log(clampedInts) // [0, 0, 255, 255]\n</code></pre>\n<ul>\n<li>Uint8ClampedArray是canvas的历史残留，如果不是做canvas开发就不要用它</li>\n</ul>","fields":{"slug":"/ArrayBuffer/"},"frontmatter":{"title":"定型数组","tags":["JavaScript回顾"],"categories":"JavaScript"}}},{"node":{"html":"<h1>Set与WeakSet</h1>\n<h2>Set</h2>\n<ul>\n<li>Set是ES6新增的集合类型，带来了集合数据结构</li>\n<li>创建方式为 new 关键字加 Set 构造函数</li>\n<li>可以通过在构造函数内传入可迭代对象来初始化该实例，如下</li>\n</ul>\n<pre><code class=\"language-js\">const s = new Set()\nconst s1 = new Set(['val1', 'val2', 'val3'])\nconst s2 = new Set({\n  [Symbol.iterator]: function*(){\n    yield 'val1'\n    yield 'val2'\n  }\n})\nconsole.log(s1) // {\"val1\", \"val2\", \"val3\"}\nconsole.log(s2) // {\"val1\", \"val2\"}\n</code></pre>\n<ul>\n<li>add()方法可以给Set添加新的键值对，has可以判断该Set是否有对应的值</li>\n<li>\n<p>size可以获取Set的元素数量，delete()用于删除元素，clear()用于清空元素，如下</p>\n<!--more-->\n<pre><code class=\"language-js\">const s3 = new Set()\nconsole.log(s3.has('first'))  // false\nconsole.log(s3.size)          // 0\n</code></pre>\n</li>\n</ul>\n<p>// add方法会返回它自身，所以可以连续add\ns3.\nadd('first').\nadd('last')\nconsole.log(s3.has('first'))  // true</p>\n<p>s3.delete('first')\nconsole.log(s3.has('first'))  // false<br>\nconsole.log(s3.has('last'))   // true\nconsole.log(s3.size)          // 1</p>\n<p>s3.clear()</p>\n<p>console.log(s3.has('last'))   // false\nconsole.log(s3.size)          // 0</p>\n<pre><code>- Set可以使用任何类型作为键，has使用严格相等来判定该值是否存在\n\n```js\nconst s4 = new Set()\nconst funcVal = function(){}\nconst objectVal = {}\nconst symbolVal = Symbol()\n\ns4.\nadd(funcVal).\nadd(objectVal).\nadd(symbolVal)\n\nconsole.log(s4.has(funcVal))    // true\nconsole.log(s4.has(objectVal))  // true\nconsole.log(s4.has(symbolVal))  // true\n\n// 全等判断，所以独立实例不冲突\nconsole.log(s4.has(function(){})) // false\n</code></pre>\n<ul>\n<li>全等判断，所以用作值的对象在自己的内容或属性变更时仍然保持不变</li>\n</ul>\n<pre><code class=\"language-js\">const s5 = new Set()\nconst objVal = {}\n\ns5.\nadd(objVal)\n\nobjVal.m2 = 'm2'\n\nconsole.log(s5.has(objVal))    // true\n</code></pre>\n<ul>\n<li>add()跟delete()是幂等的，delete()返回一个boolean，表示是否存在要删除的值</li>\n</ul>\n<pre><code class=\"language-js\">const s6 = new Set()\n\ns6.\nadd('foo')\nconsole.log(s6.size)  // 1\ns6.\nadd('foo')\nconsole.log(s6.size)  // 1\n\nconsole.log(s6.delete('foo'))    // true\nconsole.log(s6.delete('foo'))    // false\n</code></pre>\n<h2>Set顺序与迭代</h2>\n<ul>\n<li>Set维护值插入的顺序，所以是可迭代的，实例提供了一个迭代器，以插入顺序生成集合内容。</li>\n<li>通过values()方法及其别名keys()(或者Symbol.iterator属性（引用的就是values()）)获取迭代器</li>\n</ul>\n<pre><code class=\"language-js\">const s8 = new Set(['val1', 'val2', 'val3'])\nconsole.log(s8.values === s8[Symbol.iterator]) // true\nconsole.log(s8.keys === s8[Symbol.iterator]) // true\n\nfor(let value of s8[Symbol.iterator]()) {\n  console.log(value)\n}\n// 'val1'\n// 'val2'\n// 'val3'\n</code></pre>\n<ul>\n<li>values()是默认迭代器，所以可以对实例使用拓展操作</li>\n</ul>\n<pre><code class=\"language-js\">const s8 = new Set(['val1', 'val2', 'val3'])\n\nconsole.log([...s8]) // ['val1', 'val2', 'val3']\n</code></pre>\n<ul>\n<li>也可以不用迭代器，使用回调方法，用映射的forEach方法并传入回调，依次接受每个键/值对（键跟值都是值）。回调可接受可选的第二个参数，用于重写内部的this值</li>\n<li>forEach中的两个参数都是对应的值。</li>\n</ul>\n<pre><code class=\"language-js\">const s8 = new Set(['val1', 'val2', 'val3'])\n\ns8.forEach((val, key) => { console.log(`${ key } -> ${ val }`) })\n// val1 -> val1\n// val2 -> val2\n// val3 -> val3\n\ns8.forEach(function(val, key){ console.log(`${ key } -> ${ this.name } -> ${ val}`) }, { name: 's8' })\n// val1 -> s8 -> val1\n// val2 -> s8 -> val2\n// val3 -> s8 -> val3\n</code></pre>\n<h2>WeakSet</h2>\n<ul>\n<li>WeakSet 是 Set 的兄弟类型，API也是 Set 的自己，“weak”描述的时Javascrip垃圾回收程序对待“弱映射”中键的形式</li>\n<li>WeakMap中的键只能是Object或者继承自Object的类型，使用非对象设置键会抛出TypeError，值类型无限制</li>\n<li>初始化时只要有一个键无效就会抛错，其他的初始化全部失败</li>\n</ul>\n<pre><code class=\"language-js\">const key1 = { id: 1 }\n\nconst ws = new WeakSet([key1, 'BADKEY']) // Uncaught TypeError: Invalid value used in weak set\n\n// 要使用非对象的值可以使用构造函数包装再使用\nconst ws1 = new WeakSet([key1,new String('BADKEY')]) \n</code></pre>\n<ul>\n<li>其他的基本方法add、has、delete与Set保持一致</li>\n<li>“weak”表示键不属于正式引用，可以被回收，当键被回收后，键值对消失</li>\n</ul>\n<pre><code class=\"language-js\">const ws2 = new WeakSet()\nconst container = {\n  key:{}\n}\nws2.add(container.key)\nfunction removeReference(){\n  container.key = null\n}\nremoveReference()\n</code></pre>\n<ul>\n<li>上例中container对象维护着弱集合值的引用，所以不会被回收，但是要是执行了removeReference方法，那么值的引用就消失了，那么值就会消失</li>\n<li>WeakSet中的键值随时可能消失，所以没有迭代能力，也没有提供clear()清空的方法</li>\n<li>WeakSet之所以限制只能使用对象，是为了保证只有通过键对象的引用才能取到值。要是允许原始值就无法区分初始化时的字符串字面量跟初始化之后使用一个相同的字符串了</li>\n</ul>\n<h3>WeakSet的应用</h3>\n<ul>\n<li>WeakSet不会阻止垃圾回收，所以适合给对象打标签</li>\n</ul>\n<pre><code class=\"language-js\">const disabledElements = new Set()\nconst loginButton = document.querySelector('#login')\ndisabledElements.add(loginButton)\n</code></pre>\n<ul>\n<li>这样我们查询元素在不在disabledElements就可以知道是否被禁用了。不过上面的实现在登录按钮被DOM树删除了，但因为Set中存在着按钮的引用，垃圾回收不能回收它</li>\n</ul>\n<pre><code class=\"language-js\">const disabledElements = new WeakSet()\nconst loginButton = document.querySelector('#login')\ndisabledElements.add(loginButton)\n</code></pre>\n<ul>\n<li>使用WeakMap后当节点被删除后这里的引用也会消失，内存可直接被回收</li>\n</ul>","fields":{"slug":"/Set/"},"frontmatter":{"title":"Set与WeakSet","tags":["JavaScript回顾"],"categories":"JavaScript"}}},{"node":{"html":"<h1>Map与WeakMap</h1>\n<h2>Map</h2>\n<ul>\n<li>Map是ES6新增的键值存储类型</li>\n<li>创建方式为 new 关键字加 Map构造函数</li>\n<li>可以通过在构造函数内传入可迭代对象来初始化该实例，可迭代对象的每一项需要包含键/值对数组，如下</li>\n</ul>\n<pre><code class=\"language-js\">const m = new Map()\nconst m1 = new Map([['key1', 'value1'], ['key2', 'value2'], ['key3', 'value3']])\nconst m2 = new Map({\n  [Symbol.iterator]: function*(){\n    yield ['key1', 'value1']\n    yield ['key2', 'value2']\n  }\n})\nconsole.log(m1) // {\"key1\" => \"value1\", \"key2\" => \"value2\", \"key3\" => \"value3\"}\nconsole.log(m2) // {\"key1\" => \"value1\", \"key2\" => \"value2\"}\n\n// Map会映射它期待的键值对，无论你提供不提供，如下，因为没有提供对应的键值，Map会自动以undefined填充\nconst m3 = new Map([[]])\nconsole.log(m3) // {undefined => undefined}\n</code></pre>\n<ul>\n<li>set()方法可以给Map添加新的键值对，get可以查询对应键下面的值，has可以判断该Map是否有对应的键</li>\n<li>\n<p>size可以获取Map的键值对数量，delete()用于删除指定值，clear()用于清空Map，如下</p>\n<!--more-->\n<pre><code class=\"language-js\">const m4 = new Map()\nconsole.log(m4.has('first'))  // false\nconsole.log(m4.get('first'))  // undefined\nconsole.log(m4.size)          // 0\n</code></pre>\n</li>\n</ul>\n<p>// set方法会返回它自身，所以可以连续set\nm4.\nset('first', 'matt').\nset('last', 'kuni')\nconsole.log(m4.has('first'))  // true\nconsole.log(m4.get('first'))  // 'matt'</p>\n<p>m4.delete('first')\nconsole.log(m4.has('first'))  // false<br>\nconsole.log(m4.has('last'))   // true\nconsole.log(m4.get('first'))  // undefined\nconsole.log(m4.get('last'))   // 'last'\nconsole.log(m4.size)          // 1</p>\n<p>m4.clear()</p>\n<p>console.log(m4.has('last'))   // false\nconsole.log(m4.size)          // 0</p>\n<pre><code>- Map可以使用任何类型作为键，has与get使用严格相等来判定该键是否存在\n\n```js\nconst m5 = new Map()\nconst funcKey = function(){}\nconst objectKey = {}\nconst symbolKey = Symbol()\n\nm5.\nset(funcKey, 'function').\nset(objectKey, 'object').\nset(symbolKey, 'symbol')\n\nconsole.log(m5.get(funcKey))    // function\nconsole.log(m5.get(objectKey))  // object\nconsole.log(m5.get(symbolKey))  // symbol\n\n// 全等判断，所以独立实例不冲突\nconsole.log(m5.get(function(){})) // undefined\n</code></pre>\n<ul>\n<li>全等判断，所以用作键和值的对象在自己的内容或属性变更时仍然保持不变</li>\n</ul>\n<pre><code class=\"language-js\">const m6 = new Map()\nconst objKey = {}\nconst objVal = {}\n\nm6.\nset(objKey, objVal)\n\nobjKey.m1 = 'm1'\nobjVal.m2 = 'm2'\n\nconsole.log(m6.get(objKey))    // {m2: \"m2\"}\n\n\n// 全等判断，所以独立实例不冲突\nconsole.log(m6.get({})) // undefined\n</code></pre>\n<ul>\n<li>全等判断，所以下面情况可能出问题</li>\n</ul>\n<pre><code class=\"language-js\">const m7 = new Map()\nconst a = 0/'', b = 0/'',pz = +0, nz = -0;\nconsole.log(a === b)\nconsole.log(pz === nz)\n\nm7.set(a, 'foo')  // false\nm7.set(pz, 'bar') // true\n\nconsole.log(m7.get(b))  // 'foo'\nconsole.log(m7.get(nz)) // 'bar'\n</code></pre>\n<h2>Map顺序与迭代</h2>\n<ul>\n<li>Map维护键值插入的顺序，所以是可迭代的，实例提供了一个迭代器，以插入顺序生成[key, value]形式的数组。</li>\n<li>通过entries()方法或者Symbol.iterator属性（引用的就是entries()）获取迭代器</li>\n</ul>\n<pre><code class=\"language-js\">const m8 = new Map([['key1', 'value1'], ['key2', 'value2'], ['key3', 'value3']])\nconsole.log(m8.entries === m8[Symbol.iterator]) // true\n\nfor(let pairs of m8[Symbol.iterator]()) {\n  console.log(pairs)\n}\n// [\"key1\", \"value1\"]\n// [\"key2\", \"value2\"]\n// [\"key3\", \"value3\"]\n</code></pre>\n<ul>\n<li>entries()是默认迭代器，所以可以对实例使用拓展操作</li>\n</ul>\n<pre><code class=\"language-js\">const m8 = new Map([['key1', 'value1'], ['key2', 'value2'], ['key3', 'value3']])\n\nconsole.log([...m8]) // [[\"key1\", \"value1\"], [\"key2\", \"value2\"], [\"key3\", \"value3\"]]\n</code></pre>\n<ul>\n<li>也可以不用迭代器，使用回调方法，用映射的forEach方法并传入回调，依次接受每个键/值对。回调可接受可选的第二个参数，用于重写内部的this值</li>\n<li>forEach中的第一个参数是对应的值，第二个为对应的键。</li>\n</ul>\n<pre><code class=\"language-js\">const m8 = new Map([['key1', 'value1'], ['key2', 'value2'], ['key3', 'value3']])\n\nm8.forEach((val, key) => { console.log(`${ key } -> ${ val }`) })\n// key1 -> value1\n// key2 -> value2\n// key3 -> value3\n\nm8.forEach(function(val, key){ console.log(`${ key } -> ${ this.name } -> ${ val}`) }, { name: 'm8' })\n// key1 -> m8 -> value1\n// key2 -> m8 -> value2\n// key3 -> m8 -> value3\n</code></pre>\n<ul>\n<li>keys()跟values()分别返回以插入顺序生成的键跟值</li>\n</ul>\n<pre><code class=\"language-js\">const m8 = new Map([['key1', 'value1'], ['key2', 'value2'], ['key3', 'value3']])\n\nfor(let key of m8.keys()) {\n  console.log(key)\n}\n// key1\n// key2\n// key3\n\nfor(let val of m8.values()) {\n  console.log(val)\n}\n\n// value1\n// value2\n// value3\n</code></pre>\n<ul>\n<li>\n<p>Object与Map的对比</p>\n<ul>\n<li>内存情况，Object与Map占用的内存都会随键的数量线性增加。在给定固定大小内存的情况下，Map可以比Object多存储 50% 的键值对</li>\n<li>插入性能，Object与Map对插入的消耗差不多，但是Map要快一点，所以大量的插入操作使用Map</li>\n<li>查找速度，包含少量的键值时，Object的速度更快，涉及大量的查找操作使用Object更好</li>\n<li>删除性能，Object的delete性能很差，Map的delete()比插入和查找更快。所以涉及大量删除使用Map</li>\n</ul>\n</li>\n</ul>\n<h2>WeakMap</h2>\n<ul>\n<li>WeakMap是Map的兄弟类型，API也是Map的子集，“weak”描述的时Javascrip垃圾回收程序对待“弱映射”中键的形式</li>\n<li>WeakMap中的键只能是Object或者继承自Object的类型，使用非对象设置键会抛出TypeError，值类型无限制</li>\n<li>初始化时只要有一个键无效就会抛错，其他的初始化全部失败</li>\n</ul>\n<pre><code class=\"language-js\">const key1 = { id: 1 }\nconst key2 = { id: 2 }\nconst key3 = { id: 3 }\n\nconst wm = new WeakMap([[key1, 'val1'], ['BADKEY', 'val2']]) // VM648:5 Uncaught TypeError: Invalid value used as weak map key\n\n// 要使用非对象的值可以使用构造函数包装再使用\nconst wm = new WeakMap([[key1, 'val1'], [new String('BADKEY'), 'val2']]) // {String => \"val2\", {…} => \"val1\"}\n</code></pre>\n<ul>\n<li>其他的基本方法set、get、has与Map保持一致</li>\n<li>“weak”表示键不属于正式引用，可以被回收，当键被回收后，键值对消失</li>\n</ul>\n<pre><code class=\"language-js\">const wm2 = new WeakMap()\nconst container = {\n  key:{}\n}\nwm2.set(container.key, 'val')\nfunction removeReference(){\n  container.key = null\n}\nremoveReference()\n</code></pre>\n<ul>\n<li>上例中container对象维护着弱映射键的引用，所以不会被回收，但是要是执行了removeReference方法，那么键的引用就消失了，那么键值对就会消失</li>\n<li>WeakMap中的键值随时可能消失，所以没有迭代能力，也没有提供clear()清空的方法</li>\n<li>WeabMap之所以限制只能使用对象，是为了保证只有通过键对象的引用才能取到值。要是允许原始值就无法区分初始化时的字符串字面量跟初始化之后使用一个相同的字符串了</li>\n</ul>\n<h3>WeakMap的应用</h3>\n<ul>\n<li>私有变量</li>\n</ul>\n<pre><code class=\"language-js\">const User = (() => {\n  const wm = new WeakMap()\n  class User {\n    constructor(id) {\n      this.idProperty = Symbol('id')\n      this.setId(id)\n    }\n    setPrivate(property, value) {\n      const propertyMembers = wm.get(this) || {}\n      propertyMembers[property] = value\n      wm.set(this, propertyMembers)\n    }\n    getPrivate(property) {\n      return wm.get(this)[property]\n    }\n    setId(id) {\n      this.setPrivate(this.idProperty, id)\n    }\n    getId(){\n      return this.getPrivate(this.idProperty)\n    }\n  }\n  return User\n})()\n\nconst user = new User(123)\nconsole.log(user.getId()) // 123\nuser.setId(456)\nconsole.log(user.getId()) // 456\n</code></pre>\n<ul>\n<li>DOM节点元数据</li>\n<li>WeakMap不会阻止垃圾回收，适合保存元数据</li>\n</ul>\n<pre><code class=\"language-js\">const m = new Map()\nconst loginButton = document.querySelector('#login')\nm.set(loginButton, { disabled: true })\n</code></pre>\n<ul>\n<li>上面的实现在登录按钮被DOM树删除了，但因为Map中存在着按钮的引用，所以DOM节点还会在内存中存在</li>\n</ul>\n<pre><code class=\"language-js\">const m = new WeakMap()\nconst loginButton = document.querySelector('#login')\nm.set(loginButton, { disabled: true })\n</code></pre>\n<ul>\n<li>使用WeakMap后当节点被删除后这里的引用也会消失，内存可直接被回收</li>\n</ul>","fields":{"slug":"/Map/"},"frontmatter":{"title":"Map与WeakMap","tags":["JavaScript回顾"],"categories":"JavaScript"}}},{"node":{"html":"<h1>初识webGl</h1>\n<ul>\n<li>webGl是在web端实现3d效果的Api，是OpenGl的裁剪版，适用于web端的3d效果实现</li>\n<li>webGl在浏览器端的支持情况不一致，所以我们使用时注意兼容此种情况</li>\n</ul>\n<h2>着色器</h2>\n<ul>\n<li>在使用webGl的时候我们要准备两个着色器，</li>\n<li>一个顶点着色器，用来确定我们的渲染物体的各个顶点的位置，由这些顶点可以确定画面的渲染位置</li>\n<li>一个片段着色器，用来确定顶点决定的图形的各个像素的颜色值</li>\n<li>下面我们分别定义这两个着色器</li>\n</ul>\n<pre><code class=\"language-js\">// 顶点着色器\nprecision lowp float; // 指定一下我们着色器的数据精度\nattribute vec4 inColor; // 定义一个包含4个浮点数的浮点型向量，一个属性值，将会从缓冲中获取数据，用于颜色值\nattribute vec3 v3Position; // 定义一个包含3个浮点数的浮点型向量，一个属性值，将会从缓冲中获取数据，用于表示该顶点的位置\nvarying vec4 outColor; // 可变量，是顶点着色器向片段着色器传值的方式\nvoid main() {\n  outColor = inColor; // 将获取到的顶点的值赋给可变量从而传递给片段着色器\n  gl_Position = vec4(v3Position, 1.0); // gl_Position是webgl提供的内置变量，用来表示顶点位置\n}\n\n// 片段着色器\nprecision lowp float; // 指定一下我们着色器的数据精度\nvarying vec4 outColor; // 可变量，获取顶点着色器的传值\nvoid main() {\n  gl_FragColor = outColor; // gl_fragColor也是webgl提供的内置变量，用来表示像素点的颜色\n}\n</code></pre>\n<!--more-->\n<h2>第一个实例</h2>\n<ul>\n<li>接下来我们就用一个实例来看看wenGl的编写过程</li>\n<li>首先我们需要准备一个canvas作为webGl的宿主环境</li>\n</ul>\n<pre><code class=\"language-js\">&#x3C;canvas id=\"canvas\" width='500' height='500'>&#x3C;/canvas>\n</code></pre>\n<ul>\n<li>然后开始我买的呢js代码实现，首先我们获取创建的canvas的Dom元素</li>\n<li>然后获取webGl的运行环境</li>\n</ul>\n<pre><code class=\"language-js\">// 定义着色器语句\nlet shaderVsJs = `\nprecision lowp float;  \nattribute vec3 v3Position;\nattribute vec4 inColor;\nvarying   vec4 outColor;\nvoid main(){\n  outColor = inColor;\n  gl_Position = vec4(v3Position, 1.0);\n}\n`\nlet shaderFsJs = `\nprecision lowp float;\nvarying vec4 outColor;\nvoid main(){\n  gl_FragColor = outColor;\n}\n`\n// 获取canvas环境\nlet canvas = document.querySelector('#canvas')\nwebgl = canvas.getContext('webgl')\nif(!webgl) {\n  alert('浏览器暂不支持webGl，请更换浏览器')\n  return\n}\n</code></pre>\n<ul>\n<li>接着设置webgl的视口大小，这个视口需要在canvas的范围内，所以我们先设为整个canvas的大小</li>\n</ul>\n<pre><code class=\"language-js\">// 视口的设置参数为 左上角顶点位置x，左上角顶点位置y，视口的宽度，视口的高度\nwebgl.viewport(0, 0, canvas.clientWidth, canvas.clientHeight)\n</code></pre>\n<ul>\n<li>接着需要创建我们顶点着色器与片段着色器</li>\n</ul>\n<pre><code class=\"language-js\">// 着色器的创建函数以及错误警告\nfunction initShaderSouce(webgl, shader, shaderScript){\n  webgl.shaderSource(shader, shaderScript)  // 提供数据源\n  webgl.compileShader(shader) // 编译，生成着色器\n  const success = webgl.getShaderParameter(shader, webgl.COMPILE_STATUS) // 查看着色器的编译状态\n  if(success) {\n    return shader\n  }\n  console.log(webgl.getShaderInfoLog(shader)) // 出错时打印着色器的出错日志\n  webgl.deleteShader(shader) // 着色器失败时删除对应着色器\n}\n\nconst ertexShaderObject = webgl.createShader(webgl.VERTEX_SHADER) // 创建着色器对象\nconst fragmentShaderObject = webgl.createShader(webgl.FRAGMENT_SHADER)  \n\ninitShaderSouce(webgl, vertexShaderObject, shaderVsJs)\ninitShaderSouce(webgl, fragmentShaderObject, shaderFsJs)\n</code></pre>\n<ul>\n<li>然后就要创建我们的着色程序，然后把着色器也要链接到着色程序以让他们生效</li>\n<li>然后将我们在着色器语句中创建的两个attribute变量v3Position关联到我们的属性索引</li>\n</ul>\n<pre><code class=\"language-js\">let inColorIndex = 1, v3PositionIndex = 0 // 创建对应的属性索引\nprogramObject = webgl.createProgram() // 创建着色程序\n\nwebgl.attachShader(programObject, vertexShaderObject)   // 将着色器附加到着色程序中\nwebgl.attachShader(programObject, fragmentShaderObject)\n\nwebgl.bindAttribLocation(programObject, inColor, 'inColor') // 将着色器中的变量（必须是attribute变量）关联到一个属性索引\nwebgl.bindAttribLocation(programObject, v3PositionIndex, 'v3Position') \n\nwebgl.linkProgram(programObject) // 链接我们的着色程序\nif(!webgl.getProgramParameter(programObject, webgl.LINK_STATUS)) { // 查看着色程序是否正确链接\n  console.log(webgl.getProgramInfoLog(programObject)) // 链接失败打印打印错误信息\n  return\n}\nwebgl.useProgram(programObject) // 启用我们的链接程序\n</code></pre>\n<ul>\n<li>接下来我们就要创建我们的顶点数据与索引数据了</li>\n<li>顶点数据确定了我们所有的可能使用的顶点的元素的集合</li>\n<li>索引数据确定了我们顶点的绘制顺序的集合</li>\n<li>数据集合都以buffer（缓冲）的形式保存，所以需要创建对应的缓冲变量</li>\n</ul>\n<pre><code class=\"language-js\">// 顶点数据集合\nlet triangleArrayData = [\n  // 每一行的前三个数据为顶点位置， 后4个位置为对应的颜色 rgba 值，所以一个顶点对应7个数据\n  // x,  y,   z,   r,   g,   b,  a\n  -0.5, 0.5, 0.0, 1.0, 0.0, 0.0, 1.0, // 左上\n  0.5, 0.5, 0.0, 0.0, 1.0, 0.0, 1.0, // 右上\n  0.5, -0.5, 0.0, 0.0, 0.0, 1.0, 1.0, // 右下\n  -0.5, -0.5, 0.0, 1.0, 1.0, 0.0, 1.0 // 左下\n// 索引数据集合\nlet indexArrayData = [\n  0, 1, 2,\n  0, 2, 3\n]\n\nconst triangleBuffer = webgl.createBuffer() // 缓冲区创建\nconst indexBuffer = webgl.createBuffer()\n</code></pre>\n<ul>\n<li>然后将创建的存储区设置为对应存储区类型的操作对象 （也就是说绑定了这个存储区类型要用来操作这个缓冲区了）</li>\n<li>然后给这个缓冲区确定数据、数据类型与数据的变动状况</li>\n</ul>\n<pre><code class=\"language-js\">// 绑定ARRAY_BUFFER存储区类型操作 triangleBuffer\nwebgl.bindBuffer(webgl.ARRAY_BUFFER, triangleBuffer)  \n// 给缓冲区绑定数据与确定数据的变动情况  Float32Array 表示32位浮点数， webgl.STATIC_DRAW表示这个数据我以后不会经常改\nwebgl.bufferData(webgl.ARRAY_BUFFER, new Float32Array(triangleArrayData), webgl.STATIC_DRAW) //\n\nwebgl.bindBuffer(webgl.ELEMENT_ARRAY_BUFFER, indexBuffer)\nwebgl.bufferData(webgl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indexArrayData), webgl.STATIC_DRAW)\n</code></pre>\n<ul>\n<li>然后准备清空我们的画布开始绘制我们的图形</li>\n</ul>\n<pre><code class=\"language-js\">// 清空画布的颜色 \nwebgl.clearColor(0.0, 0.0, 0.0, 1.0)\n// 执行清空操作\nwebgl.clear(webgl.COLOR_BUFFER_BIT) \n</code></pre>\n<ul>\n<li>然后我们启用之前绑定的变量索引，方便在后续更改变量值进行绘画</li>\n</ul>\n<pre><code class=\"language-js\">webgl.enableVertexAttribArray(v3PositionIndex) // 启用对应关联索引上的数组数据或元素数组数据\nwebgl.enableVertexAttribArray(inColor)\n</code></pre>\n<ul>\n<li>然后为我们的变量索引分配数据</li>\n</ul>\n<pre><code class=\"language-js\">// 为变量分配数据，参数对应为  第一个：数据绑定的变量， 第二个参数表示需要的元素个数（3表示需要3个数据，4表示需要4个数据，与定义时的 vec 后面跟的3或4相关），\n// 第三个参数为元素的数据类型， 第四个参数为是否归一化， 第五个参数为第二个数据与上一个数据的偏移量，以字节为单位（这里因为我们定义的是Float32位，所以一个数据为4个字节，偏移量就是每一组数据的个数7 * 字节数4），第六个参数是数据的偏移量（前三个数据为顶点的坐标位置，后4个为顶点的rgba值）\nwebgl.vertexAttribPointer(v3PositionIndex, 3, webgl.FLOAT, false, 7 * 4, 0) // 位置需要3个值， 第一行第一个开始就是要用的数据了，所以偏移量为0\nwebgl.vertexAttribPointer(inColor, 4, webgl.FLOAT, false, 7 * 4, 3 * 4)  // 位置需要4个值， 第一行第4个开始才是要用的数据了，所以偏移量为数据个数 3 * 字节数 4\n</code></pre>\n<ul>\n<li>之后我们的全部流程就完成了，然后再执行我们的绘画操作就可以了</li>\n</ul>\n<pre><code class=\"language-js\">// 绘制方法，第一个参数表示我们要画三角形， 第二个表示我们的顶点的绘制顺序总共有几个，第三个表示顶点绘制顺序的数据的元素类型是短整型，第四个参数是表示从数据列表的第几个开始绘制\nwebgl.drawElements(webgl.TRIANGLES, 6, webgl.UNSIGNED_SHORT, 0)\n</code></pre>\n<ul>\n<li>之后我们就绘制了出了一个渐变色正方形</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 626px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/e842cb1620e9a10679824522a6d46a82/af590/webgl_rect.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 99.6%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAACXBIWXMAABJ0AAASdAHeZh94AAACR0lEQVQ4y8XUzUtUURjH8TM5c73eq3MdX8a5WZA4F7u5aUwLTMeaWpQlIWEjOAVlWBlpCkNhICVkmTCEvSxmk4ShSC0i0jYZWCszokUULSuI/opvT2BZkTZQ5OK3uud8eM55nntUQNdRSv27/BfQ80N+u8mzkBWr0JIEshR+nyI3W2HkKHRDoeUqfH5FVr5UXyBrs5YBvx3PkDz0aswV5DJZaXJju0l/3OR4l0nzRZOtaZPwA5O8pybK8SxewVKguUrxqsjgs17GsxKHu5vCjDQ5nD3mcOiCw850mA1TDtZcGFWhZQDKMZ5X5vC+tJwZXy3jxQ2kIlGSu6O0tUeJnYvi3mzAmqxHlRkZgF7F/DaDj1vKeWLXM6HtJxVsJRmJk2iME2uP4/a3Yl1rQa21MgClEfMtAjYLWF3HhH2AlHaKZLCXRKSHWGMP7tFerL4uVKgwA1ATsFPAkwLulQprWkjZp0lqgySCw8QiQ7h7hrEOD6KKQguQZxlQxmT+vICDAnYI2CQV1nSTtIdIaKPEgmO4VXewdo2i8tcsAy6UberSlOsGH25JU/rrGO+QCpsErL5Mm32bmO8RbnAGa+M0ylyXAShD/PKewafH5cym65kciHP1RA9n9l3h4OYxdqyewdXeYBW/RmU7fwYN+SNmp3N4O1fG1EQtoyPNXOrrpPvIAPHGNA1V96kIvcCvvZNmrF8a/P4wCByyPZSWeikpyaZIhjwQyMPvz8c0C9H1IF6fLeu+3p9vpZ4vz89Z/Ob5JSv1fP1NvgAUEgYu3FVrWQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"图片\"\n        title=\"图片\"\n        src=\"/static/e842cb1620e9a10679824522a6d46a82/af590/webgl_rect.png\"\n        srcset=\"/static/e842cb1620e9a10679824522a6d46a82/0b533/webgl_rect.png 500w,\n/static/e842cb1620e9a10679824522a6d46a82/af590/webgl_rect.png 626w\"\n        sizes=\"(max-width: 626px) 100vw, 626px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>","fields":{"slug":"/webgl_shader_buffer/"},"frontmatter":{"title":"初识webGl（1）","tags":["WebGl"],"categories":"WebGl"}}},{"node":{"html":"<h1>迭代器</h1>\n<ul>\n<li>迭代器模式描述了一个方案，将某些结构称为“可迭代对象”，因为它们都实现了正式的Iterable接口，而且可以通过迭代器Iterator消费</li>\n<li>可迭代对象：数组或集合这样的集合类型的对象。特点：包含元素有限，具有无歧义的遍历顺序</li>\n<li>任何实现Iterable接口的数据结构都可以被实现Iterator接口的结构“消费”</li>\n<li>迭代器是按需生成的一次性对象。每个迭代器都会关联一个可迭代对象，迭代器暴露了与之关联的可迭代对象的api</li>\n<li>迭代器不关心与它关联的可迭代对象数据结构，只关心如何取得连续的值</li>\n</ul>\n<h2>可迭代协议</h2>\n<ul>\n<li>实现Iterable(可迭代协议)要求两种能力：支持迭代的自我识别能力与创建实现Iterator接口的对象的能力。</li>\n<li>ECMAScript中暴露一个属性值作为“默认迭代器”，而且该属性用特殊的Symbol.iterator作为键。</li>\n<li>这个默认迭代器必须引用一个迭代器工厂函数，调用工厂函数必须返回一个新迭代器</li>\n<li>\n<p>实现Iteratable的内置类型</p>\n<ul>\n<li>字符串</li>\n<li>数组</li>\n<li>映射</li>\n<li>集合</li>\n<li>arguments对象</li>\n<li>NodeList等DOM集合</li>\n</ul>\n</li>\n<li>可以通过检查是否存在默认迭代器属性来暴露工厂函数</li>\n<li>\n<p>调用工厂函数可以生成一个迭代器</p>\n<!--more-->\n<pre><code class=\"language-js\">let num = 1\nlet str = 'abc'\nlet arr = [1, 2, 3]\nconsole.log(num[Symbol.iterator]) // undefined\nconsole.log(str[Symbol.iterator]) // [Symbol.iterator]() { [native code] }\nconsole.log(arr[Symbol.iterator]) // values() { [native code] }\n</code></pre>\n</li>\n</ul>\n<p>console.log(str<a href=\"\">Symbol.iterator</a>) // StringIterator {}\nconsole.log(arr<a href=\"\">Symbol.iterator</a>) // Array Iterator {}</p>\n<pre><code>- 实际代码中不需要显式调用工厂函数来生成迭代器。实现可迭代协议的所有类型会自动兼容接收可迭代对象的任何语言特性。\n- 接收可迭代对象的原生语言特性有：\n  - for-of循环\n  - 数组解构\n  - 拓展操作符\n  - Array.from()\n  - 创建集合\n  - 创建映射\n  - Promise.all()接收由期约组成的可迭代对象\n  - Promise.race()接收由期约组成的可迭代对象\n  - yield* 操作符，在生成器中使用\n- 这些语言结构会在后台调用提供的可迭代对象的工厂函数，从而创建迭代器\n\n```js\nlet arr = ['a', 'b', 'c']\nfor(let el of arr) {\n  console.log(el) // a, b, c\n}\n\nlet [a, b, c] = arr\nconsole.log(a, b, c) // a, b, c\n\nlet arr2 = [...arr]\nconsole.log(arr2) // [\"a\", \"b\", \"c\"]\n\nlet arr3 = Array.from(arr)\nconsole.log(arr3) // [\"a\", \"b\", \"c\"]\n\nlet set = new Set(arr)\nconsole.log(set) // Set(3) {\"a\", \"b\", \"c\"}\n\nlet pairs = arr.map((x, i) => [x, i])\nlet map = new Map(pairs)\nconsole.log(map) // Map(3) {\"a\" => 0, \"b\" => 1, \"c\" => 2}\n</code></pre>\n<h2>迭代器协议</h2>\n<ul>\n<li>迭代器是一次性使用的对象，用于迭代与其关联的可迭代对象。</li>\n<li>迭代器api使用next()方法可以遍历迭代器中的数据。</li>\n<li>每次调用next都会返回一个IteratorResult对象，其中包含迭代器返回的下一个值</li>\n<li>不调用next无法知道迭代器的当前位置</li>\n<li>IteratorResult包含两个属性，done跟value，done为布尔值，表示是否可以调用next获取下一个值，value包含可迭代对象的下一个值（done为false），或者undefined（done为true）</li>\n</ul>\n<pre><code class=\"language-js\">// 可迭代对象\nlet arr = ['foo', 'bar']\n\n// 迭代器工厂函数\nconsole.log(arr[Symbol.iterator]) // ƒ values() { [native code] }\n\n// 迭代器\nlet iter = arr[Symbol.iterator]() // Array Iterator {}\n\n// 执行迭代\nconsole.log(iter.next()) // {value: \"foo\", done: false}\nconsole.log(iter.next()) // {value: \"bar\", done: false}\nconsole.log(iter.next()) // {value: undefined, done: true}\nconsole.log(iter.next()) // {value: undefined, done: true}\n</code></pre>\n<ul>\n<li>迭代器并不知道怎么从可迭代对象取下一个值，也不知道可迭代对象多大，只要迭代器到达done:true的状态，后续调用netx()就一直返回同样的值</li>\n<li>每个迭代器都表示对可迭代对象的一次遍历，不同迭代器实例没有联系，只会独立的遍历</li>\n</ul>\n<pre><code class=\"language-js\">let arr2 = ['foo', 'bar']\nlet iter1 = arr2[Symbol.iterator]()\nlet iter2 = arr2[Symbol.iterator]()\n\nconsole.log(iter1.next()) // {value: \"foo\", done: false}\nconsole.log(iter2.next()) // {value: \"foo\", done: false}\nconsole.log(iter1.next()) // {value: \"bar\", done: false}\nconsole.log(iter2.next()) // {value: \"bar\", done: false}\n</code></pre>\n<ul>\n<li>迭代器不会与可迭代对象的某个时刻绑定，而是记录遍历可迭代对象的过程，如果遍历中可迭代对象变了，那迭代器会反应相应的变化</li>\n</ul>\n<pre><code class=\"language-js\">let arr = ['foo', 'bar']\nlet iter = arr[Symbol.iterator]() // Array Iterator {}\nconsole.log(iter.next()) // {value: \"foo\", done: false}\narr.splice(1, 0, 'baz')\nconsole.log(iter.next()) // {value: \"baz\", done: false}\nconsole.log(iter.next()) // {value: \"bar\", done: false}\nconsole.log(iter.next()) // {value: undefined, done: true}\n</code></pre>\n<ul>\n<li>迭代器维护着可迭代对象的引用，所以迭代器会阻止垃圾回收程序回收可迭代对象</li>\n</ul>\n<h2>自定义迭代器</h2>\n<ul>\n<li>与Iterable接口类似，实现了Iterator接口的对象都可以作为迭代器使用。</li>\n</ul>\n<pre><code class=\"language-js\">class Counter{\n  constructor(limit){\n    this.count = 1\n    this.limit = limit\n  }\n  next(){\n    if(this.count &#x3C;= this.limit) {\n      return {\n        done: false,\n        value: this.count++\n      }\n    } else {\n      return {\n        done: true,\n        value: undefined\n      }\n    }\n  }\n  [Symbol.iterator](){\n    return this\n  }\n}\n\nlet counter = new Counter(3)\nfor(let i of counter) {\n  console.log(i) // 1, 2, 3\n}\n\nfor(let i of counter) {\n  console.log(i) // 没有值\n}\n</code></pre>\n<ul>\n<li>这样实现了Iterator接口，但是每个实例只能被迭代一次，所以我们把计数器变量放到闭包中</li>\n</ul>\n<pre><code class=\"language-js\">class Counter{\n  constructor(limit) {\n    this.limit = limit\n  }\n\n  [Symbol.iterator](){\n    let count = 1,limit = this.limit\n    return {\n      next(){\n        if(count &#x3C;= limit) {\n          return {\n            done: false,\n            value: count++\n          }\n        } else {\n          return {\n            done: true,\n            value: undefined\n          }\n        }\n      }\n    }\n  }\n}\n\nlet counter = new Counter(3)\nfor(let i of counter) {\n  console.log(i) // 1, 2, 3\n}\n\nfor(let i of counter) {\n  console.log(i) // 1, 2, 3\n}\n</code></pre>\n<ul>\n<li>每个以这种方式创建的迭代器都实现了Iterator接口。Symbol.iterator属性引用的工厂函数会返回相同的迭代器</li>\n<li>因为每个迭代器也实现了Iterable接口，所以可以再任何期待可迭代对象的地方使用，比如for-of循环</li>\n</ul>\n<pre><code class=\"language-js\">let arr = [3, 1, 4]\nlet iter = arr[Symbol.iterator]()\nfor(let item of arr) {\n  console.log(item) // 3, 1, 4\n}\n\nfor(let item of iter) {\n  console.log(item) // 3, 1, 4\n}\n</code></pre>\n<h2>提前终止迭代器</h2>\n<ul>\n<li>\n<p>可选的return方法用于指定在迭代器提前关闭时执行的逻辑。执行迭代的结构在想让迭代器知道它不想遍历到可迭代对象耗尽时，可以关闭迭代器。情况有：</p>\n<ul>\n<li>for-of循环通过break、continue、return、或者throw提前退出</li>\n<li>结构操作并未消费所有值</li>\n</ul>\n</li>\n<li>return方法必须返回一个幼小的IteratorResult对象，可以只返回{done: true}</li>\n<li>下面代码所示，内置语言结构发现还有值可以迭代，但不会消费这些值时，会自动调用return</li>\n</ul>\n<pre><code class=\"language-js\">class Counter{\n  constructor(limit) {\n    this.limit = limit\n  }\n\n  [Symbol.iterator](){\n    let count = 1,limit = this.limit\n    return {\n      next(){\n        if(count &#x3C;= limit) {\n          return {\n            done: false,\n            value: count++\n          }\n        } else {\n          return {\n            done: true,\n            value: undefined\n          }\n        }\n      },\n      return (){\n        console.log('exit early')\n        return { done: true }\n      }\n    }\n  }\n}\n\nlet counter1 = new Counter(5)\nfor(let i of counter1) {\n  if(i > 2) {\n    break\n  }\n  console.log(i)\n}\n// 1\n// 2\n// exit early\n\nlet counter2 = new Counter(5)\ntry {\n  for(let i of counter1) {\n    if(i > 2) {\n      throw 'err'\n    }\n    console.log(i)\n  }\n} catch(e) {}\n// 1\n// 2\n// exit early\n\nlet counter3 = new Counter(5)\nlet [a, b] = counter3\n// exit early\n</code></pre>\n<ul>\n<li>如果迭代器没有关闭，就可以从上次离开的地方继续迭代，比如数组的迭代不可关闭</li>\n</ul>\n<pre><code class=\"language-js\">let arr3 = [1, 2, 3, 4, 5]\nlet iter1 = arr3[Symbol.iterator]()\nfor(let i of iter1) {\n  console.log(i)\n  if(i > 2) {\n    break\n  }\n}\n// 1\n// 2\n// 3\n\n\nfor(let i of iter1) {\n  console.log(i)\n}\n// 4\n// 5\n</code></pre>\n<ul>\n<li>return方法是可选的，所以并非所有迭代都可以关闭，可以通过测试迭代器的return属性是不是方法确定是否可关闭。</li>\n<li>仅仅给给不可关闭的迭代器加return方法并不能使其变成可关闭的。这是因为调用return并不会强制迭代器进入关闭状态。但是return方法仍然会调用</li>\n</ul>\n<pre><code class=\"language-js\">let arr4 = [1, 2, 3, 4, 5]\nlet iter4 = arr4[Symbol.iterator]()\niter4.return = function(){\n  console.log('exit early')\n  return { done: true }\n}\n\nfor(let i of iter4) {\n  console.log(i)\n  if(i > 2) {\n    break\n  }\n}\n// 1\n// 2\n// 3\n// exit early\n\n\nfor(let i of iter4) {\n  console.log(i)\n}\n// 4\n// 5\n</code></pre>\n<h2>小结</h2>\n<ul>\n<li>迭代器是一个由任意对象实现的接口，支持连续获取对象产出的每一个值。任何实现Iterable接口的对象都有一个Symbol.iterator属性，这个属性引用默认迭代器。默认迭代器就像一个迭代器工厂，也就是一个函数，调用之后会产生一个实现Iterator接口的对象</li>\n<li>迭代器必须通过next方法才能连续取到值，这个方法返回IteratorObject。包含一个done属性跟value属性。这个借口可以通过手动反复调用next消费，也可以通过for-of这样的原生消费者消费</li>\n</ul>","fields":{"slug":"/iterator2/"},"frontmatter":{"title":"再读迭代器","tags":["JavaScript回顾"],"categories":"JavaScript"}}},{"node":{"html":"<h1>生成器</h1>\n<ul>\n<li>生成器是ECMAScript 6新增的拥有在一个函数块内暂停和恢复代码执行的能力</li>\n<li>使用该能力可以自定义迭代器和实现协称</li>\n<li>生成器是一个函数，函数名前加一个 * 表示它是一个生成器</li>\n<li>可以定义函数的地方都可以定义生成器</li>\n<li>箭头函数不可以定义生成器函数</li>\n</ul>\n<pre><code class=\"language-js\">function *generatorFn(){}\nlet generatorFn = function* () {}\nlet foo = {\n  *generatorFn(){}\n}\nclass Foo{\n  *generatorFn(){}\n}\nclass Bar{\n  static *generatorFn(){}\n}\n</code></pre>\n<ul>\n<li>生成器函数的 * 不受两侧空格影响</li>\n</ul>\n<pre><code class=\"language-js\">// 等价的生成方式\nfunction *generatorFn(){}\nfunction* generatorFn(){}\nfunction * generatorFn(){}\n</code></pre>\n<!--more-->\n<ul>\n<li>调用生成器函数会生成一个生成器对象。</li>\n<li>生成器对象开始处于暂停状态</li>\n<li>与迭代器相似，生成器对象也实现了Iterator接口，因此也有next方法。调用这个方法可以开始或恢复执行</li>\n</ul>\n<pre><code class=\"language-js\">const generatorFn = function* (){}\nconst g = generatorFn()\nconsole.log(g) // generatorFn {&#x3C;suspended>}\nconsole.log(g.next) // ƒ next() { [native code] }\nconsole.log(g.next()) // {value: undefined, done: true}\n</code></pre>\n<ul>\n<li>next返回的值类似于迭代器，有一个done跟value属性。函数体为空的生成器函数中间不会停留，调用一次就会让生成器到达done: true的状态</li>\n<li>value属性是生成器函数的返回值，默认为undefined，可以通过生成器函数的返回值指定</li>\n</ul>\n<pre><code class=\"language-js\">const generatorFn1 = function* (){\n  return 'bar'\n}\nconst g1 = generatorFn1()\nconsole.log(g1.next()) // {value: \"bar\", done: true}\n</code></pre>\n<ul>\n<li>生成器函数只会在初次调用next方法后开始执行，如下所示</li>\n</ul>\n<pre><code class=\"language-js\">const generatorFn2 = function* (){\n  console.log('foobar')\n}\nconst generatorObject2 = generatorFn2()\ngeneratorObject2.next() // 'foobar'\n</code></pre>\n<ul>\n<li>生成器对象实现了Iterator接口，它们默认的迭代器是自引用的</li>\n</ul>\n<pre><code class=\"language-js\">const generatorFn3 = function* (){\n}\nconsole.log(generatorFn3)  // ƒ* (){}\nconsole.log(generatorFn3()) // generatorFn3 {&#x3C;suspended>}\nconsole.log(generatorFn3()[Symbol.iterator]) // ƒ [Symbol.iterator]() { [native code] }\nconsole.log(generatorFn3()[Symbol.iterator]()) // generatorFn3 {&#x3C;suspended>}\n\nconst g3 = generatorFn3()\nconsole.log(g3 === g3[Symbol.iterator]()) // true\n</code></pre>\n<h2>yield</h2>\n<ul>\n<li>yield关键字可以让生成器停止和开始执行</li>\n<li>生成器函数再遇到yield之前正常执行，遇到这个关键字会停止执行，函数作用域状态保留</li>\n<li>停止执行的生成器函数只能通过在生成器对象上调用next方法恢复执行</li>\n</ul>\n<pre><code class=\"language-js\">const generatorFn4 = function* (){\n  yield\n}\nconst generatorObject4 = generatorFn4()\nconsole.log(generatorObject4.next()) // {value: undefined, done: false}\nconsole.log(generatorObject4.next()) // {value: undefined, done: true}\n</code></pre>\n<ul>\n<li>yield关键字类似于函数中的中间返回语句，生成的值会在next方法返回的对象里，通过yield退出的生成器函数会处在done: false的状态，通过return方法退出的生成器函数会处在 done: true的状态</li>\n</ul>\n<pre><code class=\"language-js\">const generatorFn5 = function* (){\n  yield 'foo'\n  yield 'bar'\n  return 'baz'\n}\nconst generatorObject5 = generatorFn5()\nconsole.log(generatorObject5.next()) // {value: \"foo\", done: false}\nconsole.log(generatorObject5.next()) // {value: \"bar\", done: false}\nconsole.log(generatorObject5.next()) // {value: \"baz\", done: true}\n</code></pre>\n<ul>\n<li>生成器函数内部的执行流程会对每个生成器对象区分作用域。在一个生成器上调用next不会影响其他生成器</li>\n</ul>\n<pre><code class=\"language-js\">const generatorFn6 = function* (){\n  yield 'foo'\n  yield 'bar'\n  return 'baz'\n}\nconst generatorObject6 = generatorFn6()\nconst generatorObject61 = generatorFn6()\nconsole.log(generatorObject6.next()) // {value: \"foo\", done: false}\nconsole.log(generatorObject61.next()) // {value: \"foo\", done: false}\nconsole.log(generatorObject6.next()) // {value: \"bar\", done: false}\nconsole.log(generatorObject61.next()) // {value: \"bar\", done: false}\n</code></pre>\n<ul>\n<li>yield关键字只能在生成器函数内部使用，其他地方会报错。类似return语句，yield必须直接位于生成器函数定义中，出现在嵌套的非生成器函数会抛错</li>\n</ul>\n<pre><code class=\"language-js\">// 有效\nfunction* validGeneratorFn(){\n  yield\n}\n\n// 无效\nfunction* invalidGeneratorFn(){\n  function a(){\n    yield\n  }\n}\n\n// 无效\nfunction* invalidGeneratorFn(){\n  const b = () => {\n    yield\n  }\n}\n\n// 无效\nfunction* invalidGeneratorFn(){\n  (() => {\n    yield\n  })()\n}\n</code></pre>\n<h2>生成器作为可迭代对象</h2>\n<ul>\n<li>可以把生成器当做可迭代对象使用</li>\n</ul>\n<pre><code class=\"language-js\">function* generatorFn7(){\n  yield 1\n  yield 2\n  yield 3\n}\nfor(const x of generatorFn7()) {\n  console.log(x) // 1, 2, 3\n}\n</code></pre>\n<ul>\n<li>在需要自定义迭代对象时我们可以使用生成器对象。比如，当我们需要定义一个可迭代对象，它会产生一个迭代器，迭代器会执行指定的次数</li>\n<li>使用生成器可以用一个简单地循环实现</li>\n</ul>\n<pre><code class=\"language-js\">function* generatorFn8(n){\n  while(n--) {\n    yield\n  }\n}\nfor(let _ of generatorFn8(3)) {\n  console.log('foo') // 'foo', 'foo', 'foo'\n}\n</code></pre>\n<h2>yield实现输入输出</h2>\n<ul>\n<li>除了作为函数的中间返回语句，yield还可以作为函数的中间参数使用。上一次让生成器函数暂停的yield关键字会接收到传给next的第一个值。</li>\n<li>第一次调用next方法传入的值不会被使用，因为第一次是为了开始执行生成器函数</li>\n</ul>\n<pre><code class=\"language-js\">function* generatorFn9(initial){\n  console.log(initial)\n  console.log(yield)\n  console.log(yield)\n}\nlet generatorObject9 = generatorFn9('foo')\n\ngeneratorObject9.next('bar') // foo\ngeneratorObject9.next('baz') // baz\ngeneratorObject9.next('qux') // qux\n</code></pre>\n<ul>\n<li>yield还可以同时用于输入输出</li>\n</ul>\n<pre><code class=\"language-js\">function* generatorFn10(){\n  return yield 'foo'\n}\nlet generatorObject10 = generatorFn10()\n\nconsole.log(generatorObject10.next()) // {value: \"foo\", done: false}\nconsole.log(generatorObject10.next('bar')) // {value: 'bar', done: true}\n</code></pre>\n<ul>\n<li>因为函数必须要对整个表达式求值才可以返回，再遇到yield时暂停并计算返回的值'foo'。下一次调用next()传入了'bar'，作为交给同一个yield的值。然后这个值被定为生成器函数要返回的值</li>\n<li>yield关键字可以多次使用</li>\n<li>如果我们定义一个生成器函数，根据配制的值迭代相应次数，并产生迭代索引。初始化一个数组可以实现，不用数组也可以</li>\n</ul>\n<pre><code class=\"language-js\">function* nTimes(n){\n  for(let i = 0; i &#x3C; n; ++i) {\n    yield i\n  }\n}\n\n// 或者用while实现\nfunction* nTimes(n){\n  let i = 0\n  while(n--) {\n    yield i++\n  }\n}\n</code></pre>\n<ul>\n<li>使用生成器可以填充范围数组</li>\n</ul>\n<pre><code class=\"language-js\">function* range(start, end) {\n  while(end > start) {\n    yield start++\n  }\n}\nfor(let x of range(4, 7)) {\n  console.log(x) // 4, 5, 6\n}\n\nfunction* zeroes(n) {\n  while(n--) {\n    yield 0\n  }\n}\nconsole.log(Array.from(zeroes(8))) // [0, 0, 0, 0, 0, 0, 0, 0]\n</code></pre>\n<h2>产生可迭代对象</h2>\n<ul>\n<li>可以使用 * 加强yield的行为，让它迭代一个可迭代对象，从而一次产出一个值</li>\n</ul>\n<pre><code class=\"language-js\">function* generatorFn11(){\n  yield* [1, 2, 3]\n}\nfor(let x of generatorFn11()) {\n  console.log(x)\n}\n\n// 等价于\nfunction* generatorFn11(){\n  for(const x of [1, 2, 3]) {\n    yield x\n  }\n}\n</code></pre>\n<ul>\n<li>yield星号两侧也不受空格影响</li>\n<li>yield* 其实只是将一个可迭代对象序列化为一串可以单独产出的值，跟放在循环里没有什么不同</li>\n<li>yield* 的值是关联迭代器返回done:true时的value属性。对于普通迭代器来说，这个值是undefined</li>\n</ul>\n<pre><code class=\"language-js\">function* generatorFn12(){\n  console.log('iter value:', yield* [1, 2, 3])\n}\nfor(const x of generatorFn12()) {\n  console.log('value: ', x)\n}\n// value:  1\n// value:  2\n// value:  3\n// iter value: undefined\n</code></pre>\n<ul>\n<li>对于生成器函数产生的迭代器来说，这个值就是生成器函数返回的值</li>\n</ul>\n<pre><code class=\"language-js\">function* generatorFn13(){\n  yield 'foo'\n  return 'bar'\n}\nfunction* othergeneratorFn13(genObj){\n  console.log('iter value:', yield* generatorFn13())\n}\nfor(const x of othergeneratorFn13()) {\n  console.log('value: ', x)\n}\n\n// value:  foo\n// iter value: bar\n</code></pre>\n<h2>yield*实现递归</h2>\n<ul>\n<li>这也是yield*最有用的地方</li>\n</ul>\n<pre><code class=\"language-js\">function* nTimes(n) {\n  if(n > 0) {\n    yield* nTimes(n - 1)\n    yield n - 1\n  }\n}\nfor(const x of nTimes(3)) {\n  console.log(z)\n}\n// 0\n// 1\n// 2\n</code></pre>\n<ul>\n<li>这里每个生成器都会从新创建的生成器对象产出值，然后再产生一个整数。</li>\n<li>下面是一个图的实现，生成一个随机的双向图</li>\n</ul>\n<pre><code class=\"language-js\">class Node {\n  constructor(id){\n    this.id = id\n    this.neighbors = new Set()\n  }\n  connect(node){\n    if(node !== this) {\n      this.neighbors.add(node)\n      node.neighbors.add(this)\n    }\n  }\n}\nclass RandomGraph {\n  constructor(size) {\n    this.nodes = new Set()\n    for(let i = 0; i &#x3C; size; ++i) {\n      this.nodes.add(new Node(i))\n    }\n    const threshold = 1 / size\n    for(const x of this.nodes) {\n      for(const y of this.nodes) {\n        if(Math.random() &#x3C; threshold) {\n          x.connect(y)\n        }\n      }\n    }\n  }\n\n  print(){\n    for(const node of this.nodes) {\n      // console.log([...node.neighbors])\n      const ids = [...node.neighbors].map((n) => n.id).join(',')\n      console.log(`${ node.id }: ${ ids }`)\n    }\n  }\n}\n\nconst gra = new RandomGraph(6)\ngra.print()\n// 0: 1,5\n// 1: 0,2,5\n// 2: 1,3,5\n// 3: 2\n// 4: 5\n// 5: 0,2,1,4\n</code></pre>\n<ul>\n<li>图结构数据适合递归遍历，而递归生成器可以实现这个需求。生成器函数必须包含一个可迭代对象，产出该对象的每个值，并对值进行递归。如此可以测试是否有某个点不可到达。</li>\n</ul>\n<pre><code class=\"language-js\">class Node {\n  constructor(id){\n    this.id = id\n    this.neighbors = new Set()\n  }\n  connect(node){\n    if(node !== this) {\n      this.neighbors.add(node)\n      node.neighbors.add(this)\n    }\n  }\n}\nclass RandomGraph {\n  constructor(size) {\n    this.nodes = new Set()\n    for(let i = 0; i &#x3C; size; ++i) {\n      this.nodes.add(new Node(i))\n    }\n    const threshold = 1 / size\n    for(const x of this.nodes) {\n      for(const y of this.nodes) {\n        if(Math.random() &#x3C; threshold) {\n          x.connect(y)\n        }\n      }\n    }\n  }\n\n  print(){\n    for(const node of this.nodes) {\n      // console.log([...node.neighbors])\n      const ids = [...node.neighbors].map((n) => n.id).join(',')\n      console.log(`${ node.id }: ${ ids }`)\n    }\n  }\n\n  isConnect(){\n    let visitedNode = new Set()\n    function* traverse(nodes){\n      for(let node of nodes) {\n        if(!visitedNode.has(node)) {\n          yield node\n          yield* traverse(node.neighbors)\n        }\n      }\n    }\n    const firstNode = this.nodes[Symbol.iterator]().next().value\n    for(const node of traverse([firstNode])) {\n      visitedNode.add(node)\n    }\n    return visitedNode.size === this.nodes.size\n  }\n}\n</code></pre>\n<ul>\n<li>因为生成器对象实现了Iterable接口，而且生成器函数和默认迭代器对象调用之后都会产生迭代器，所以生成器格外适合做为默认迭代器，下面是一个简单地例子</li>\n</ul>\n<pre><code class=\"language-js\">class Foo{\n  constructor(){\n    this.values = [1, 2, 3]\n  }\n  * [Symbol.iterator]() {\n    yield* this.values\n  }\n}\n\nconst f = new Foo()\nfor(const x of f) {\n  console.log(x)\n}\n// 1, 2, 3\n</code></pre>\n<ul>\n<li>for-of循环调用默认迭代器（刚好也是一个生成器函数）并产生一个生成器对象，生成器对象是可迭代的，所以可以在迭代中使用</li>\n</ul>\n<h2>提前终止生成器</h2>\n<ul>\n<li>生成器支持“可关闭”的概念。一个实现Iterator接口的对象一定有next方法，还有一个可选的return方法用于提前终止迭代器。生成器对象除了这两个方法，还有第三个方法： throw</li>\n</ul>\n<pre><code class=\"language-js\">function* generatorF(){}\nconst ge = generatorF()\nconsole.log(ge) // generatorF {&#x3C;suspended>}\nconsole.log(ge.next) // ƒ next() { [native code] }\nconsole.log(ge.return) // ƒ return() { [native code] }\nconsole.log(ge.throw) // ƒ throw() { [native code] }\n</code></pre>\n<ul>\n<li>return与throw都可以强制生成器进入关闭状态</li>\n<li>return 方法强制生成器进入关闭状态，提供给return的值就是终止迭代器对象的值</li>\n</ul>\n<pre><code class=\"language-js\">function* generatorF1(){\n  for(const x of [1,2,3]) {\n    yield x\n  }\n}\nconst ge1 = generatorF1()\nconsole.log(ge1) // generatorF1 {&#x3C;suspended>}\nconsole.log(ge1.return(3)) // {value: 3, done: true}\nconsole.log(ge1) // generatorF1 {&#x3C;closed>}\n</code></pre>\n<ul>\n<li>跟迭代器不一样，生成器对象一旦进入关闭状态就无法恢复了。后续调用next会显示done: true的状态，而且这个值不会被存储或传播</li>\n</ul>\n<pre><code class=\"language-js\">function* generatorF2(){\n  for(const x of [1,2,3]) {\n    yield x\n\nconst ge2 = generatorF2()\nconsole.log(ge2.next()) // {value: 1, done: false}\nconsole.log(ge2.return(4)) // {value: 4, done: true}\nconsole.log(ge2.next()) // {value: undefined, done: true}\nconsole.log(ge2.next()) // {value: undefined, done: true}  }\n}\n</code></pre>\n<ul>\n<li>for-of循环等内置语言结构会忽略状态为done: true的IteratorObject内部的值</li>\n</ul>\n<pre><code class=\"language-js\">function* generatorF3(){\n  for(const x of [1,2,3]) {\n    yield x\n  }\n}\nconst ge3 = generatorF3()\nfor(const x of ge3) {\n  if(x > 1) {\n    ge3.return(4)\n  }\n  console.log(x)\n}\n// 1\n// 2\n</code></pre>\n<ul>\n<li>throw方法会在暂停时讲一个提供的错误注入到生成器对象中，要是错误没有被处理，生成器就会关闭</li>\n</ul>\n<pre><code class=\"language-js\">function* generatorF4(){\n  for(const x of [1,2,3]) {\n    yield x\n  }\n}\nconst ge4 = generatorF4()\nconsole.log(ge4) // generatorF4 {&#x3C;suspended>}\ntry {\n  ge4.throw('foo')\n} catch(e) {\n  console.log(e) // foo\n}\nconsole.log(ge4) // generatorF4 {&#x3C;closed>}\n</code></pre>\n<ul>\n<li>要是生成器内部处理了这个值，那生成器就不会关闭，而且可以恢复执行。错误处理会跳过对应的yield，因此下例中会跳过一个值</li>\n</ul>\n<pre><code class=\"language-js\">function* generatorF5(){\n  for(const x of [1,2,3]) {\n    try {\n      yield x\n    } catch (e) {\n      console.log(e)\n    }\n  }\n}\nconst ge5 = generatorF5()\nge5.throw('foo') // 'foo'\nconsole.log(ge5.next()) // {value: 3, done: false}\n</code></pre>\n<ul>\n<li>上面生成器在try/catch块中的yield关键字暂停执行。暂停期间throw向生成器对象内部注入了一个错误：字符串\"foo\"。因为错误是在生成器的try/catch抛出，仍然在生成器内部捕获。</li>\n<li>由于yield抛出了错误，生成器不会产出2.此时，生成器函数继续执行，下一次迭代再次遇到yield关键字时产出了3</li>\n<li>如果生成器还没有开始执行，那么调用throw抛出的错误不会在函数内部被捕获，因为这相当于在函数外部抛出了错误</li>\n</ul>\n<h2>小结</h2>\n<ul>\n<li>生成器是一种特殊的函数，调用返回一个生成器对象。生成器对象实现了Iterable接口，因此能用在任何消费可迭代对象的地方。</li>\n<li>生成器支持yield关键字，该关键字可以暂停执行生成器函数。yield关键字可以通过next接收输入和输出。</li>\n<li>yield加上 * 后可以将后面的可迭代对象序列化为一串值</li>\n</ul>","fields":{"slug":"/generator2/"},"frontmatter":{"title":"再读生成器","tags":["JavaScript回顾"],"categories":"JavaScript"}}},{"node":{"html":"<h1>对象基本概念</h1>\n<ul>\n<li>ECMA-262定义的对象是一组属性的无序集合。就是说对象是一组没有顺序的值</li>\n<li>可以将对象想象为散列表，内容就是一组名/值对</li>\n<li>对象实例通常都有属性跟方法</li>\n</ul>\n<h2>属性类型</h2>\n<ul>\n<li>ECMA-262使用内部特性来描述属性的特质。这些特性都由javascript实现引擎的规范定义的。</li>\n<li>因此开发者不能在javascript中直接访问这些特性。为了将某个特性标志为内部特征，规范会用两个中括号包裹，比如[[Enumerable]]</li>\n<li>属性分为数据属性和访问器属性</li>\n</ul>\n<h3>数据属性</h3>\n<ul>\n<li>\n<p>数据属性包含一个保存数据值得位置。值会从这个位置读取，也会写到这个位置，有4个特性描述它的行为</p>\n<ul>\n<li>[[Configurable]]: 表示属性是否可以通过delete删除并重新定义，是否可以修改它的特性，以及是否可以把它改为访问器属性。默认情况下，直接定义在对象上的属性，这个值都是true</li>\n<li>[[Enumberable]]: 表示属性是否可以通过for-in循环返回。默认情况下，直接定义在对象上的属性，这个值都是true</li>\n<li>[[Writable]]: 表示属性的值是否可以被修改。默认情况下，直接定义在对象上的属性，这个值都是true</li>\n<li>[[Value]]: 包含属性实际的值，读取和写入属性值的位置。默认值为undefined</li>\n</ul>\n</li>\n<li>\n<p>当我们显式的将属性添加到对象之后，[[Configurable]],[[Enumberable]],[[Writable]]都被设为true，[[Value]]被设为指定值</p>\n<!--more-->\n<pre><code class=\"language-js\">let person = {\nname: 'Nicholas'\n}\n</code></pre>\n</li>\n<li>这里我们创建该属性后， [[Value]]会被设置为'Nicholas'，之后对这个name的修改都会放到这个位置</li>\n<li>修改属性的默认特性，要使用Object.defineProperty()方法。接收三个参数：添加属性的对象，属性名称和描述符对象。最后一个参数描述符对象属性包括：configurable、writable、enumerable、value，跟特性名称一一对应。根据要修改的特性，设置一个或多个值。</li>\n</ul>\n<pre><code class=\"language-js\">let person = {}\nObject.defineProperty(person, \"name\", {\n  value: 'Nicholas',\n  writable: false\n})\nconsole.log(person.name) // Nicholas\nperson.name = 'zhangsan'\nconsole.log(person.name)// Nicholas\n</code></pre>\n<ul>\n<li>这里我们设置了writable为false就是表明它制度，就不可以修改，非严格模式下赋值会被忽略，严格模式下报错</li>\n</ul>\n<pre><code class=\"language-js\">let person = {}\nObject.defineProperty(person, \"name\", {\n  value: 'Nicholas',\n  configurable: false\n})\ndelete person.name\nconsole.log(person.name) // Nicholas\n\n// 尝试再次修改\nObject.defineProperty(person, \"name\", {\n  value: 'Nicholas',\n  configurable: true\n})\n// VM68586:8 Uncaught TypeError: Cannot redefine property: name\n</code></pre>\n<ul>\n<li>设置configurable之后删除该属性无效，在严格模式下删除该属性会报错</li>\n<li>设置configurable之后这个属性就被改为不可再配置得了，再次调用Object.defineProperty()并修改非writable的属性会导致报错</li>\n<li>在调用Object.defineProperty时，configurable、enumerable、writable如果不指定则都默认为false</li>\n</ul>\n<h3>访问器属性</h3>\n<ul>\n<li>访问器属性不包含数据值。相反，它包含一个获取（getter）函数和一个设置（setter）函数，这两个函数都是非必须的。</li>\n<li>在读取访问器属性时，会调用获取函数，该函数的责任是返回一个有效的值。在写入访问器属性时，会调用设置函数并传入新值，这个函数必须决定对数据做出什么修改。</li>\n<li>\n<p>访问器属性也有4个特性描述它们的行为</p>\n<ul>\n<li>[[Configurable]]: 表示属性是否可以通过delete删除并重新定义，是否可以修改它的特性，是否可以把它改为数据属性。默认情况下，直接定义在对象上的属性的这个特性值都是true</li>\n<li>[[Enumerable]]: 表示属性是否可以通过for-in循环返回。默认情况下，直接定义在对象上的属性的这个特性值都是true</li>\n<li>[[Get]]: 获取函数，读取属性时调用。默认值为undefined</li>\n<li>[[Set]]: 设置函数，写入属性时调用。默认值为undefined</li>\n</ul>\n</li>\n<li>访问器属性也需要使用defineProperty来定义</li>\n</ul>\n<pre><code class=\"language-js\">let book = {\n  year_: 2017,\n  edition: 1\n}\nObject.defineProperty(book, 'year', {\n  get(){\n    return this.year_\n  },\n  set(newValue){\n    if(newValue > 2017) {\n      this.year_ = newValue\n      this.edition += newValue - 2017\n    }\n  }\n})\nconsole.log(book.year) // 2017\nbook.year = 2018\nconsole.log(book.edition) // 2\n</code></pre>\n<ul>\n<li>这个例子中book有两个默认属性year<em>跟edition。year</em>中的下划线表示该属性不想在对象方法的外面被访问。</li>\n<li>另一个属性year被定义为访问器属性，其中获取函数简单地返回year<em>的值，而设置函数会计算决定正确的版本。因此把year变为2018会导致year</em>变为2018，edition变为2。</li>\n<li>获取属性跟设置属性不一定都要定义。只定义获取属性意味属性是只读的，尝试修改会忽略。严格模式下会报错</li>\n<li>只有一个设置函数的属性是不可读取的，非严格模式返回undefined，严格模式报错</li>\n<li>在不支持Object.defineProperty()的浏览器中没法修改[[Configurable]]或[[Enumerable]]</li>\n<li>ECMAScript5之前，开发者通过非标准的访问器属性访问创建访问器属性：<strong>defineGetter</strong>()和<strong>defineSetter</strong>()。</li>\n</ul>\n<h3>定义多个属性</h3>\n<ul>\n<li>ECMAScript提供了Object.defineProperties()方法。该方法可以通过多个描述符一次性定义多个属性。</li>\n<li>接收两个参数：要为之添加或修改属性的对象和另一个描述符对象，属性与要添加或修改的属性一一对应。</li>\n</ul>\n<pre><code class=\"language-js\">let book = {}\nObject.defineProperties(book, {\n  year_: {\n    value: 2017\n  },\n  edition: {\n    value: 1,\n  },\n  year: {\n    get(){\n      return this.year_\n    },\n    set(newValue){\n      if(newValue > 2017) {\n        this.year_ = newValue\n        this.deition += newValue - 2017\n      }\n    }\n  }\n})\n</code></pre>\n<ul>\n<li>这段代码定义了两个数据属性year_跟edition，还有一个访问器属性year。最终的效果跟之前实现的效果一样。</li>\n<li>区别就是所有属性都是同时定义的，并且数据属性configurable、enumerable、和writable特性值都是false</li>\n</ul>\n<h3>读取属性特性</h3>\n<ul>\n<li>使用Object.getOwnPropertyDescriptor()方法可以读取指定属性的属性描述符。</li>\n<li>该方法接收两个参数：属性所在的对象和要取得的属性名。</li>\n<li>返回值是一个对象，对于数据属性包含configurable、enumerable、writable、value属性。对于访问器属性包含configurable、enumerable、get和set属性</li>\n</ul>\n<pre><code class=\"language-js\">let book = {}\nObject.defineProperties(book, {\n  year_: {\n    value: 2017\n  },\n  edition: {\n    value: 1,\n  },\n  year: {\n    get(){\n      return this.year_\n    },\n    set(newValue){\n      if(newValue > 2017) {\n        this.year_ = newValue\n        this.edition += newValue - 2017\n      }\n    }\n  }\n})\nlet descriptor = Object.getOwnPropertyDescriptor(book, \"year_\")\nconsole.log(descriptor)\n// {\n//   configurable: false\n//   enumerable: false\n//   value: 2017\n//   writable: false\n// }\nlet descriptor1 = Object.getOwnPropertyDescriptor(book, \"year\")\nconsole.log(descriptor1)\n// {\n//   configurable: false\n//   enumerable: false\n//   get: ƒ get()\n//   set: ƒ set(newValue)\n// }\n</code></pre>\n<ul>\n<li>ECMAScript2017中新增了Object.getOwnPropertyDescriptors()静态方法。该方法会在每个自有属性上调用Object.getOwnPropertyDescriptor()方法，并在一个新对象中返回。</li>\n</ul>\n<pre><code class=\"language-js\">let book = {}\nObject.defineProperties(book, {\n  year_: {\n    value: 2017\n  },\n  edition: {\n    value: 1,\n  },\n  year: {\n    get(){\n      return this.year_\n    },\n    set(newValue){\n      if(newValue > 2017) {\n        this.year_ = newValue\n        this.edition += newValue - 2017\n      }\n    }\n  }\n})\nconsole.log(Object.getOwnPropertyDescriptors(books))\n// {\n//     \"year_\":{\n//         \"value\":2017,\n//         \"writable\":false,\n//         \"enumerable\":false,\n//         \"configurable\":false\n//     },\n//     \"edition\":{\n//         \"value\":1,\n//         \"writable\":false,\n//         \"enumerable\":false,\n//         \"configurable\":false\n//     },\n//     \"year\":{\n//         \"enumerable\":false,\n//         \"configurable\":false,\n//         \"get\": ƒ get(),\n//         \"set\": ƒ set(newValue)\n//     }\n// }\n</code></pre>\n<ul>\n<li>ES6新增了Object.assign方法来实现对象的合并。这个方法接收一个目标对象和多个源对象作为参数，然后将每个源对象中可枚举（Object.propertyIsEnumerable()返回true）和自有（Object.hasOwnProperty()返回true）的属性复制到目标对象.</li>\n<li>以字符串跟符号为键的属性会被复制。对符合条件的属性，这个方法会使用源对象上的[[Get]]取得属性的值，然后使用目标对象上的[[Set]]设置属性的值</li>\n</ul>\n<pre><code class=\"language-js\">let dest = {\n  set a(val) {\n    console.log(`Invoke dest setter with param ${val}`)\n  }\n}\nlet src = {\n  get a(){\n    console.log('Invoke src getter')\n    return 'foo'\n  }\n}\nObject.assign(dest, src)\n// 调用src的获取方法  Invoke src getter\n// 调用dest的设置方法并传入参数‘foo’   Invoke dest setter with param foo\nconsole.log(dest)\n// 因为dest的设置函数并没有执行赋值操作，所以值并没有过来\n// { ser a()}\n</code></pre>\n<ul>\n<li>该方法采用的是浅复制。如果多个源对象有相同的属性，则以最后一次为准。</li>\n<li>从源对象访问器属性获取的值，比如获取函数会作为一个静态值赋给目标对象。也就是说，不能在两个对象之间转移获取函数和设置函数</li>\n<li>如果赋值期间出错，操作会终止并退出，同时抛出错误。但是并不能回滚之前的操作，因此它是一个尽力而为、可能只完成部分复制的方法</li>\n</ul>\n<pre><code class=\"language-js\">let desc,src,result\ndesc = {}\nsrc = {\n  a: 'foo',\n  get b(){\n    throw new Error()\n  },\n  c: 'bar'\n}\ntry {\n  Object.assign(desc, src)\n} catch(e) {}\n// 出错了，但无法回滚\nconsole.log(desc) // {a: \"foo\"}\n</code></pre>\n<h3>对象标识与相等判断</h3>\n<ul>\n<li>ES6之前，有些特殊情况 === 也无法判断大小，如下</li>\n</ul>\n<pre><code class=\"language-js\">console.log(+0 === -0) // true\nconsole.log(+0 === 0) // true\nconsole.log(-0 === 0) // true\nconsole.log(NaN === NaN) // false\n// 判断NaN必须使用isNaN\nconsole.log(isNaN(NaN)) // true\n</code></pre>\n<ul>\n<li>ES6新增了Object.is()方法，接收两个值，作用跟 === 相似</li>\n</ul>\n<pre><code class=\"language-js\">console.log(Object.is(+0, -0)) // false\nconsole.log(Object.is(+0, 0)) // true\nconsole.log(Object.is(-0, 0)) // false\nconsole.log(Object.is(NaN, NaN)) // true\n</code></pre>\n<ul>\n<li>递归调用可以检查多个值</li>\n</ul>\n<pre><code class=\"language-js\">function recursivelyCheckEqual(x, ...rest) {\n  return x === rest[0] &#x26;&#x26; (rest.length &#x3C; 2 || recursivelyCheckEqual(...rest))\n}\nrecursivelyCheckEqual(1, 1, 1) // true\nrecursivelyCheckEqual(1, 1, 2) // false\n</code></pre>","fields":{"slug":"/Object2/"},"frontmatter":{"title":"对象基本概念","tags":["JavaScript回顾"],"categories":"JavaScript"}}},{"node":{"html":"<h1>创建对象与原型</h1>\n<ul>\n<li>创建普通对象我们使用Object构造函数或者字面量，但是针对多个具有同样接口的对象我们再使用构造函数或者字面量会产生很多重复代码</li>\n<li>ECMAScript5.1并没有正式支持面向对象结构。ES6开始正式支持类和继承。但也仅仅是封装了ES5.1构造函数加原型继承语法糖</li>\n</ul>\n<h2>工厂模式</h2>\n<ul>\n<li>工厂模式就是抽象用于创建特定类型对象的过程，如下</li>\n</ul>\n<pre><code class=\"language-js\">function createPerson(name, age, job) {\n  let o = {\n    name,\n    age,\n    job,\n    sayName: function(){\n      console.log(this.name)\n    }\n  }\n  return o\n}\n\nlet person1 = createPerson('张三', 24, 'teacher')\nperson1.sayName() // 张三\nlet person2 = createPerson('李四', 24, 'doctor')\n</code></pre>\n<!--more-->\n<ul>\n<li>这就是一个简单工厂模式，帮我们简化了每一步赋值对象的过程</li>\n</ul>\n<h2>构造函数模式</h2>\n<ul>\n<li>我们可以自定义构造函数来为对象定义属性和方法</li>\n</ul>\n<pre><code class=\"language-js\">function Person(name, age, job) {\n  this.name = name\n  this.age = age\n  this.job = job\n  this.sayName = function(){\n    console.log(this.name)\n  }\n}\nlet person3 = new Person('张三', 24, 'teacher')\nperson3.sayName() // 张三\nlet person4 = new Person('李四', 24, 'doctor')\n\nconsole.log(person3.constructor === Person) // true\nconsole.log(person4.constructor === Person) // true\n</code></pre>\n<ul>\n<li>\n<p>这里我们看到其实就是讲属性和方法给了this，然后使用new关键字创建就可以了。其实这段语句内里的操作是：</p>\n<ul>\n<li>在内存中创建一个新对象</li>\n<li>将新对象的[[Prototype]]特性赋值为构造函数的prototype属性</li>\n<li>构造函数内部的this被赋值为这个新对象</li>\n<li>执行构造函数内部的代码（给新对象添加属性）</li>\n<li>如果构造函数返回非空对象，就返回该对象；否则返回刚创建的新对象</li>\n</ul>\n</li>\n<li>用该方式创建的实例都有一个constructor属性指向Person</li>\n<li>constructor本来是用于标识对象类型的。不过一般用instanceof来确定对象类型更加可靠。</li>\n</ul>\n<h3>构造函数创建的问题</h3>\n<ul>\n<li>定义的方法会在每个实例上都创建一遍，意味着两个实例都是对应的方法属性，而且不是同一个Function实例。</li>\n<li>我们的实例中的函数属性是做一样的事，所以没必要用两个Function实例。this对象可以吧函数与对象的绑定推迟到运行时</li>\n</ul>\n<pre><code class=\"language-js\">function Person(name, age, job){\n  this.name = name\n  this.age = age\n  this.job = job\n  this.sayName = sayName\n}\nfunction sayName(){\n  console.log(this.name)\n}\n</code></pre>\n<ul>\n<li>这样的实现就让所有的实例都共享了定义在外面的sayName函数。</li>\n<li>这样虽然解决了问题，但是污染了全局作用域，要是有多个方法属性就要在外面定义多个函数</li>\n</ul>\n<h2>原型模式</h2>\n<ul>\n<li>每个函数都会创建一个prototype属性，这个属性是一个对象，包含应该由特定引用类型的实例共享的属性与方法。</li>\n<li>这个对象就是通过调用构造函数创建的对象的原型。</li>\n<li>原型对象上定义的属性和方法可以被对象的实例共享。</li>\n</ul>\n<pre><code class=\"language-js\">function Person(){}\nPerson.prototype.name = '张三'\nPerson.prototype.age = 24\nPerson.prototype.sayName = function(){\n  console.log(this.name)\n}\n\nlet person1 = new Person()\nlet person2 = new Person()\nconsole.log(person1.sayName === person2.sayName) // true\n</code></pre>\n<ul>\n<li>使用这样的模式定义的属性与方法都由实例共享</li>\n</ul>\n<h2>原型</h2>\n<ul>\n<li>无论何时，只要创建函数，就会按照一定规则给函数创建一个prototype属性（指向原型对象）。默认情况下，所有原型对象获得一个名为constructor的属性，指回与之关联的构造函数</li>\n<li>然后就有了 Person.prototype.constructor === Person。</li>\n<li>在自定义构造函数时，原型对象默认只有constructor属性，其他的所有方法都继承自Object。</li>\n<li>每次调用构造函数都会创建一个新实例，这个实例内部[[Prototype]]会被赋值为构造函数的原型对象。脚本中没有标准的访问[[Prototype]]的犯法，但是一般浏览器会在对象上暴露<strong>proto</strong>属性来访问对象的原型。</li>\n<li>实例与构造函数原型有直接联系，但实例与构造函数之间没有，如下代码</li>\n</ul>\n<pre><code class=\"language-js\">function Person(){}\nconsole.log(typeof Person.prototype) // object\nconsole.log(Person.prototype) // \n// {\n//   constructor: ƒ Person()\n// __proto__: Object\n// }\n\nconsole.log(Person.prototype.constructor === Person) // true\n\n// 正常的原型链都会终止于Object的原型对象，Object的原型的原型是null\nconsole.log(Person.prototype.__proto__ === Object.prototype)   // true\nconsole.log(Person.prototype.__proto__.constructor === Object) // true\nconsole.log(Person.prototype.__proto__.__proto__ === null)     // true\nconsole.log(Person.prototype.__proto__)                        \n// {\n//   constructor: ƒ Object()\n// hasOwnProperty: ƒ hasOwnProperty()\n// isPrototypeOf: ƒ isPrototypeOf()\n// propertyIsEnumerable: ƒ propertyIsEnumerable()\n// toLocaleString: ƒ toLocaleString()\n// toString: ƒ toString()\n// valueOf: ƒ valueOf()\n// __defineGetter__: ƒ __defineGetter__()\n// __defineSetter__: ƒ __defineSetter__()\n// __lookupGetter__: ƒ __lookupGetter__()\n// __lookupSetter__: ƒ __lookupSetter__()\n// get __proto__: ƒ __proto__()\n// set __proto__: ƒ __proto__()\n// }\n\n// 实例与构造函数没有直接联系，与原型对象有直接联系\nlet person1 = new Person()\nconsole.log(person1.__proto__ === Person.prototype)  //true\nconsole.log(person1.__proto__.constructor === Person) // true\n</code></pre>\n<ul>\n<li>Person.prototype指向原型对象，而Person.prototype.constructor指回Person构造函数。</li>\n<li>虽然不是所有实现都暴露[[Prototype]]，但可以使用isPrototypeOf()确定两个对象之间的关系。本质上，isPrototypeOf()会在传入参数的[[Prototype]]指向调用它的对象时返回true</li>\n</ul>\n<pre><code class=\"language-js\">console.log(Person.prototype.isPrototypeOf(person1)) // true\n</code></pre>\n<ul>\n<li>ECMAScript的Object类型有一个方法Object.getPrototypeOf()，返回参数内部的特性[[Protptype]]的值</li>\n</ul>\n<pre><code class=\"language-js\">console.log(Object.getPrototypeOf(person1) === Person.prototype) // true\n</code></pre>\n<ul>\n<li>该方法可以方便的取得一个对象的原型</li>\n<li>Object还有一个setPrototypeOf()方法，可以向实例的私有属性[[Prototype]]写入一个新值。</li>\n</ul>\n<pre><code class=\"language-js\">let biped = {\n  numLegs: 2\n}\nlet person = {\n  name: 'Matt'\n}\nObject.setPrototypeOf(person, biped)\nconsole.log(person.name) // Matt\nconsole.log(person.numLegs) // 2\nconsole.log(Object.getPrototypeOf(person) === biped) // true\n</code></pre>\n<ul>\n<li>Object.setPrototypeOf()可能会严重影响代码性能。在所有的JavaScript引擎中，修改继承关系的影响都微妙而深远。这种影响不仅仅是执行Object.setPrototypeOf()语句那么简单，而是涉及所有修改过[[Prototype]]的对象的代码</li>\n<li>为避免使用Object.setPrototypeOf()导致的性能下降，可以使用Object.create()来创建对象，并指定原型</li>\n</ul>\n<pre><code class=\"language-js\">let biped = {\n  numLegs: 2\n}\nlet person = Object.create(biped)\nperson.name = 'Matt'\nconsole.log(person.numLegs) // 2\nconsole.log(person.name) // Matt\nconsole.log(Object.getPrototypeOf(person) === biped) // true\n</code></pre>\n<ul>\n<li>hasOwnProperty()用于确定某个属性存在于实例还是原型对象上。该方法继承自Object，会在属性存在于调用它的对象时返回true</li>\n<li>ECMAScript中的Object.getOwnPropertyDescriptor()只对实例属性有效。要取原型属性的描述符，就要在原型对象上调用Object.getOwnPropertyDescriptor()</li>\n</ul>\n<h3>原型和in操作符</h3>\n<ul>\n<li>in操作符有两种使用，一种是直接使用，一种配合for-in循环使用。</li>\n<li>单独使用时，in会在可以访问对象指定属性时返回true，无论该属性在实例上还是原型上</li>\n</ul>\n<pre><code class=\"language-js\">function Person(){}\nPerson.prototype.name = '张三'\nlet person = new Person()\nperson.age = 24\nconsole.log(\"name\" in person) // true\nconsole.log(\"age\" in person)  // true\n</code></pre>\n<ul>\n<li>in配合hasOwnProperty()可以实现判断某个属性是否在原型上</li>\n</ul>\n<pre><code class=\"language-js\">function hasPrototypeProperty(object, name){\n  return !object.hasOwnProperty(name) &#x26;&#x26; (name in object)\n}\n</code></pre>\n<ul>\n<li>在for-in使用in操作符可以通过对象访问可以被枚举的属性，包括实例属性和原型属性。屏蔽原型中不可枚举（[[Enumerable]]特性设置为false）也会在for-in循环中返回。因为默认情况下开发者定义的属性都是可枚举的</li>\n<li>可以通过Object.keys()获取对象上的所有可枚举的实例属性。不包含原型上的属性</li>\n<li>Object.getOwnPropertyNames()返回所有的实例属性，无论是否可以枚举。</li>\n<li>ES6新增符号类型后新增方法Object.getOwnPropertyNames()，因为以符号为键的属性没有名称概念。该方法与Object.getOwnPropertyNames()类似，只是针对符号而已</li>\n</ul>\n<h3>属性的枚举顺序</h3>\n<ul>\n<li>for-in与Object.keys()枚举顺序不确定，取决于JavaScript引擎</li>\n<li>Object.getOwnPropertyNames()、Object.getOwnPropertySymbols()和Object.assign()的枚举顺序是确定的，先以升序枚举数值键，然后以插入顺序枚举字符串和符号键</li>\n</ul>\n<pre><code class=\"language-js\">let k1 = Symbol('k1'), k2 = Symbol('k2')\nlet o = {\n  1: 1,\n  first: 'first',\n  [k1]:'sym1',\n  second: 'second',\n  0: 0\n}\no[k2] = 'sym2'\no[3] = 3\no.third = 'third'\no[2] = 2\nconsole.log(Object.getOwnPropertyNames(o))  //  [\"0\", \"1\", \"2\", \"3\", \"first\", \"second\", \"third\"]\nconsole.log(Object.getOwnPropertySymbols(o))  // [Symbol(k1), Symbol(k2)]\n</code></pre>\n<h3>对象迭代</h3>\n<ul>\n<li>ECMAScript2017新增了两个静态方法Object.values()、Object.entries()</li>\n<li>Object.values()返回对象值的数组，Object.entries()返回键/值的数组</li>\n</ul>\n<pre><code class=\"language-js\">const o = {\n  foo: 'bar',\n  baz: 1,\n  qux: {}\n}\nconsole.log(Object.entries(o)) //  [[\"foo\", \"bar\"],  [\"baz\", 1], [\"qux\", {…}]]\nconsole.log(Object.values(o)) //  [\"bar\", 1, {…}]\n</code></pre>\n<ul>\n<li>符号属性会被忽略</li>\n</ul>\n<pre><code class=\"language-js\">const sym = Symbol()\nconst o1 = {\n  [sym]: 'foo'\n}\nconsole.log(Object.entries(o1)) //  []\nconsole.log(Object.values(o1)) //  []\n</code></pre>\n<ul>\n<li>之前我们看到的原型上定义一个属性或方法都要把Person.prototype重写一遍，所以我们可以通过一个包含所有属性和方法的对象字面量重写原型</li>\n</ul>\n<pre><code class=\"language-js\">function Person(){}\nPerson.prototype = {\n  name: '张三',\n  age: 28,\n  sayName(){\n    console.log(this.name)\n  }\n}\n</code></pre>\n<ul>\n<li>这里Person.prototype被设置为跟前面一样的新对象，但是这样有一个问题，Person.prototype的constructor属性就指向Person了。</li>\n<li>之前创建函数时，也会创建它的prototype对象，并自动为这个原型的constructor属性赋值。</li>\n<li>字面量方式创建就完全重写了默认的prototype对象，因此其constructor属性也就指向了完全不同的新对象（Object构造函数），不再是原来的构造函数。</li>\n<li>虽然instanceof依然可以可靠地返回值，但是不能靠constructor属性来识别类型了</li>\n</ul>\n<pre><code class=\"language-js\">function Person(){}\nPerson.prototype = {\n  name: '张三',\n  age: 28,\n  sayName(){\n    console.log(this.name)\n  }\n}\nlet person2 = new Person()\nconsole.log(person2 instanceof Person) // true\nconsole.log(person2 instanceof Object) // true\nconsole.log(person2.constructor === Person) // false\nconsole.log(person2.constructor === Object) // true\n</code></pre>\n<ul>\n<li>如果还是决定要使用constructor，可以专门设置一下它的值</li>\n</ul>\n<pre><code class=\"language-js\">function Person(){}\nPerson.prototype = {\n  constructor: Person,\n  name: '张三',\n  age: 28,\n  sayName(){\n    console.log(this.name)\n  }\n}\n</code></pre>\n<ul>\n<li>但是要注意，这种方式恢复的constructor属性会创建一个[[Enumerable]]为true的属性。而原生的constructor属性默认不可枚举，所以需要使用Object.defineProperty来进行设置</li>\n</ul>","fields":{"slug":"/createObject/"},"frontmatter":{"title":"对象创建与原型","tags":["JavaScript回顾"],"categories":"JavaScript"}}},{"node":{"html":"<h1>类</h1>\n<ul>\n<li>ECMAScript 6 引入了class关键字来实现正式定义类的能力</li>\n<li>类定义也是两种方法：声明类与类表达式</li>\n</ul>\n<pre><code class=\"language-js\">// 类声明\nclass Person {}\n\n// 类表达式\nconst Person = class {}\n</code></pre>\n<ul>\n<li>类定义不可变量提升，声明前不可使用</li>\n<li>函数受函数作用域限制，类受块作用域限制</li>\n<li>\n<p>类可以包含构造函数方法、实例方法、获取函数、设置函数与静态类方法</p>\n<!--more-->\n<h2>构造函数</h2>\n</li>\n<li>构造函数非必须，不定义则默认为空</li>\n<li>默认情况下，构造函数会在执行后返回this对象。构造函数返回的对象会被用作实例化对象，如果没有引用新创建的this对象，则对象会被销毁</li>\n<li>如果返回的不是this对象，而是其他对象，那么这个对象不回通过instanceof操作符检测出与类有关联，因为对象的原型指针没有被修改</li>\n</ul>\n<pre><code class=\"language-js\">class Person{\n  constructor(override){\n    this.foo = 'foo'\n    if(override) {\n      return { bar: 'bar' }\n    }\n  }\n}\n\nlet p1 = new Person()\nlet p2 = new Person(true)\nconsole.log(p1) // Person {foo: \"foo\"}\nconsole.log(p1 instanceof Person) // true\n\nconsole.log(p2) // {bar: \"bar\"}\nconsole.log(p2 instanceof Person) // false\n</code></pre>\n<ul>\n<li>类中定义的constructor不会被当做构造函数，对它使用instanceof会返回false</li>\n</ul>\n<pre><code class=\"language-js\">class Person{\n  constructor(){\n    this.foo = 'foo'\n  }\n}\n\nlet p1 = new Person()\nconsole.log(p1 instanceof Person) // true\nconsole.log(p1 instanceof Person.constructor) // false\n</code></pre>\n<ul>\n<li>类也可以立即被实例化</li>\n</ul>\n<pre><code class=\"language-js\">let p = new class Foo{\n  constructor(x){\n    console.log(x)\n  }\n}('foo') // 'foo'\n</code></pre>\n<h2>实例、原型和类成员</h2>\n<ul>\n<li>定义在构造函数内的属性为实例属性，实例独享</li>\n<li>定义在类块中的方法为原型方法，所有实例共享，可以在类块中定义方法，但不能定义属性</li>\n</ul>\n<pre><code class=\"language-js\">class Person {\n  name: 'Jack' // Uncaught SyntaxError: Unexpected token\n}\n</code></pre>\n<ul>\n<li>类上定义静态方法，一般用于执行不特定于市里的操作，不要求存在类的实例，使用static修饰</li>\n</ul>\n<h2>super</h2>\n<ul>\n<li>派生类可以通过super关键字引用他们的原型。只能在派生类中使用，而且仅限于类构造函数、实例方法、静态方法内部。</li>\n<li>构造函数中使用super可以调用父类构造函数（这种情况下super之前不允许出现this）</li>\n<li>ES6给类构造函数与静态方法添加了内部特征[[HomeObject]]，是一个指针，指向定义该方法的对象。只能在javascript引擎内部访问。</li>\n<li>super始终会定义为[[HomeObject]]的原型</li>\n<li>super不可单独使用，要么用它调用构造函数，要么引用静态方法</li>\n</ul>\n<pre><code class=\"language-js\">class Vehicle {\n\n}\nclass Bus extends Vehicle{\n  constructor(){\n    console.log(super)  // SyntaxError: 'super' keyword unexpected here\n  }\n}\n</code></pre>\n<ul>\n<li>调用super会调用父类构造函数，并将返回的实例赋值给this</li>\n<li>如果没有定义类构造函数，实例化派生类时会调用super，并传入所有给派生类的参数</li>\n<li>如果派生类定义了构造函数，那么要么在其中调用super，要么必须在其中返回一个对象</li>\n</ul>\n<h2>抽象基类</h2>\n<ul>\n<li>基类就是可供继承但不可被实例化的类，ECMAScript没有单独实现，但是可以使用new.target来实现，new.target保存了通过new调用的类或者函数。所以可以如下实现</li>\n</ul>\n<pre><code class=\"language-js\">class Vehicle {\n  constructor(){\n    if(new.target === Vehicle) {\n      throw new Error('Vehicle cannot be directly instantiated')\n    }\n  }\n}\nnew Vehicle() // Error: Vehicle cannot be directly instantiated\n</code></pre>\n<h2>类混入</h2>\n<ul>\n<li>将不同类集中到一个类中</li>\n</ul>\n<pre><code class=\"language-js\">class Vehicle {}\nlet FooMixin = (Superclass) => class extends Superclass {\n    foo() {\n      console.log('foo')\n    }\n  }\n\n  let BarMixin = (Superclass) => class extends Superclass {\n    bar() {\n      console.log('bar')\n    }\n  }\n\n  let BazMixin = (Superclass) => class extends Superclass {\n    baz() {\n      console.log('baz')\n    }\n  }\n\n  class Bus extends FooMixin(BarMixin(BazMixin(Vehicle))) {}\n  let b = new Bus()\n  b.foo()  // 'foo'\n  b.bar()  // 'bar'\n  b.baz()  // 'baz'\n</code></pre>\n<ul>\n<li>很多javascript已经放弃混入模式，转为组合模式，也就是著名的“组合胜过继承”</li>\n</ul>","fields":{"slug":"/class2/"},"frontmatter":{"title":"类--高程4","tags":["JavaScript回顾"],"categories":"JavaScript"}}}]}},"pageContext":{"limit":10,"skip":40,"currentIndex":4}},"staticQueryHashes":["2566592090"]}