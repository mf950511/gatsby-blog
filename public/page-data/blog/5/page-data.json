{"componentChunkName":"component---src-templates-index-jsx","path":"/blog/5","result":{"data":{"allMarkdownRemark":{"totalCount":45,"edges":[{"node":{"html":"<h1>Array对象</h1>\n<h2>Array的创建</h2>\n<ul>\n<li>Array构建函数创建</li>\n<li>无参数创建会生成一个空的数组</li>\n<li>当传入一个数值时，会生成一个数组，并且长度设为该数值</li>\n<li>当传入一个非数值时，会生成一个数组，并且数组第一项位该值</li>\n<li>如果传入多个值时，会生成一个数组，并且这几个值都会依次存在于数组中</li>\n</ul>\n<pre><code class=\"language-js\">let arr1 = new Array()\nlet arr2 = new Array(3)\nlet arr3 = new Array('张三')\nlet arr4 = new Array({ name: '张三' })\nlet arr5 = new Array(5, '张三', 24)\nconsole.log(arr1, arr2, arr3, arr4, arr5)\n// []\n// [empty × 3]\n// [\"张三\"]\n// [{…}]\n// [5, \"张三\", 24]\n</code></pre>\n<h2>Array.from、Array.of</h2>\n<ul>\n<li>这两个都是Array构造函数的静态方法，属于ES6新增范畴</li>\n<li>Array.from用于将类数组结构转为数组</li>\n<li>Array.from方法接收的第一个参数是一个类数组对象（任何可迭代的结构）或者有length属性与可索引元素的结构</li>\n</ul>\n<!--more-->\n<pre><code class=\"language-js\">// 字符串转为数组\nconsole.log(Array.from(\"Matt\"))\n// [\"M\", \"a\", \"t\", \"t\"]\nconst m = new Map().set(1,2).set(3,4)\nconst s = new Set().add(1).add(2).add(3).add(4)\nconsole.log(Array.from(m)) // [[1, 2], [3, 4]]\nconsole.log(Array.from(s)) // [1, 2, 3, 4]\nconst iter = {\n  *[Symbol.iterator](){\n    yield 1;\n    yield 2;\n    yield 3;\n    yield 4;\n    yield 5;\n  }\n}\nconsole.log(Array.from(iter)) // [1, 2, 3, 4, 5]\n\nfunction getArgsArray(){\n  return Array.from(arguments)\n}\nconsole.log(getArgsArray(1,2,3,4)) // [1, 2, 3, 4]\n\nconst arrayLikeObject = {\n  0: 1,\n  1: 2,\n  3: 3,\n  4: 4,\n  length:4\n}\nconsole.log(Array.from(arrayLikeObject)) // [1, 2, 3, 4]\n</code></pre>\n<ul>\n<li>Array.from的第二个参数（可选）接收的是一个对新数组操作的函数，会对新数组的每一项都执行该函数</li>\n<li>第三个参数（可选）接收的是操作函数的this的值，当第二个参数是箭头函数时，这个值无效</li>\n</ul>\n<pre><code class=\"language-js\">const array = [1,2,3,4]\nconst a2 = Array.from(array, x => x ** 2)\nconst a3 = Array.from(array, function(x) { return x ** this.exponent}, { exponent: 2 })\nconsole.log(a2) // [1, 4, 9, 16]\nconsole.log(a3) // [1, 4, 9, 16]\n</code></pre>\n<ul>\n<li>Array.of可以把一组参数专为数组，用于替代之前的Array.prototype.slice.call(arguments)</li>\n</ul>\n<pre><code class=\"language-js\">console.log(Array.of(1, 2, 3, 4)) // [1, 2, 3, 4]\nconsole.log(Array.of(undefined))  // [undefined]\n</code></pre>\n<h2>数组检测</h2>\n<ul>\n<li>在只有一个全局上下文时只用 instanceof 就够用了，但是要是有两个全局上下文，那么对应的Array构造函数可能不同，这种情况下可能不合适</li>\n<li>所以针对这种情况就提供了 Array.isArray()方法，该方法只用于确定一个值是否是数组，跟上下文环境无关</li>\n</ul>\n<pre><code class=\"language-js\">let array = [1, 2, 3, 4]\nlet arrayLike = {\n  0: 1,\n  1: 2,\n  2: 3,\n  length: 3\n}\nconsole.log(array instanceof Array)     // true\nconsole.log(arrayLike instanceof Array) // false\n\nconsole.log(Array.isArray(array))       // true\nconsole.log(Array.isArray(arrayLike))   // false\n</code></pre>\n<h2>迭代器方法</h2>\n<ul>\n<li>Array原型暴露了3个检索数组内容的方法，keys()，values()，entries()</li>\n<li>keys返回数组索引的迭代器</li>\n<li>values返回数组元素的迭代器</li>\n<li>entries返回索引/元素的迭代器</li>\n</ul>\n<pre><code class=\"language-js\">// 都是迭代器，所以可以直接使用Array.from转为数组\nconst a = ['foo', 'bar', 'baz', 'qux']\nconsole.log(Array.from(a.keys()))     //  [0, 1, 2, 3]\nconsole.log(Array.from(a.values()))   // [\"foo\", \"bar\", \"baz\", \"qux\"]\nconsole.log(Array.from(a.entries()))  // [[0, \"foo\"], [1, \"bar\"], [2, \"baz\"], [3, \"qux\"]]\n</code></pre>\n<h2>填充方法copyWithin、fill</h2>\n<ul>\n<li>数组填充方法 fill() 可以向一个已有的数组中插入全部或部分相同的值。</li>\n<li>第一个参数为填充值</li>\n<li>第二个参数为开始索引，指定开始填充的位置（可选），</li>\n<li>第三个参数为结束索引位置（填充不包含该位置），不提供结束索引就一直填充到数组末尾</li>\n<li>负值索引从数组末尾开始计算（也可以理解为数组长度加上它得到的正值索引）</li>\n</ul>\n<pre><code class=\"language-js\">const zeroes = [0, 0, 0, 0, 0]\nzeroes.fill(5) // [5, 5, 5, 5, 5]\nzeroes.fill(0) // 重置为 0 [0, 0, 0, 0, 0]\n\nzeroes.fill(6, 3) // [0, 0, 0, 6, 6]\nzeroes.fill(0)\n\nzeroes.fill(7, 1, 3) // [0, 7, 7, 0, 0]\nzeroes.fill(0)\n\n// -4 + 5 = 1, -1 + 5 = 4,等价于zeroes.fill(1, 4)\nzeroes.fill(8, -4, -1) // [0, 8, 8, 8, 0]\n</code></pre>\n<ul>\n<li>fill()静默忽略超出数组边界，零长度以及相反索引</li>\n</ul>\n<pre><code class=\"language-js\">const zeroes = [0, 0, 0, 0, 0]\nzeroes.fill(1, -10, -6) // 索引过低 [0, 0, 0, 0, 0]\nzeroes.fill(0)\n\nzeroes.fill(1, 10 ,15) // 索引过高 [0, 0, 0, 0, 0]\nzeroes.fill(0)\n\nzeroes.fill(7, 4, 2) // 索引相反，忽略 [0, 0, 0, 0, 0]\nzeroes.fill(0)\n\n// -4 + 5 = 1, -1 + 5 = 4,等价于zeroes.fill(1, 4)\nzeroes.fill(8, 3, 10) // [0, 0, 0, 8, 8]\n</code></pre>\n<ul>\n<li>copyWithin会浅复制数组中的部分内容，然后再插入到指定索引的位置，开始索引与结束索引与fill计算方式一直</li>\n<li>第一个参数为插入元素的开始位置</li>\n<li>第二个参数为复制数组的开始位置（可选），默认为0</li>\n<li>第三个参数为复制数组的结束位置（可选），不指定则会一直复制到数组结束</li>\n</ul>\n<pre><code class=\"language-js\">let ints, reset = () => ints = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nreset()\n\n// 未指定开始位置表示从数组的第0个位置开始复制，然后插入到第5个位置\nints.copyWithin(5) // [0, 1, 2, 3, 4, 0, 1, 2, 3, 4]\nreset()\n\n// 第二个参数为5，表示从数组的第5个位置开始复制，然后从3的位置开始插入\nints.copyWithin(3, 5) // [0, 1, 2, 5, 6, 7, 8, 9, 8, 9]\nreset()\n\n// 第二个参数为0，表示从数组的第0个位置开始复制，复制到第3的位置，然后从第4个位置插入\nints.copyWithin(4, 0, 3) // [0, 1, 2, 3, 0, 1, 2, 7, 8, 9]\nreset()\n\n// 负值的算法与fill一致， -4 + 10 = 6， -7 + 10 = 3，-3  + 10 = 7,等价于 ints.copyWithin(6, 3, 7)\nints.copyWithin(-4, -7, -3) // [0, 1, 2, 3, 4, 5, 3, 4, 5, 6]\n</code></pre>\n<ul>\n<li>copyWithin()也会静默忽略超出数组边界，零长度以及相反索引</li>\n</ul>\n<pre><code class=\"language-js\">let ints, reset = () => ints = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nreset()\n\n// 索引过低，忽略\nints.copyWithin(1, -15, -12) // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nreset()\n\n// 索引过高，忽略\nints.copyWithin(1, 12, 15) // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nreset()\n\n// 索引反向，忽略\nints.copyWithin(4, 3, 1) // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nreset()\n\n// 部分索引可用\nints.copyWithin(4, 7, 10) // [0, 1, 2, 3, 7, 8, 9, 7, 8, 9]\n</code></pre>\n<h2>转换方法</h2>\n<ul>\n<li>所有对象都有toLocalString、toString、valueOf方法。</li>\n<li>数组中valueOf返回数组本身</li>\n<li>toString返回数组每一项调用toString返回的字符串用逗号拼接的一个字符串</li>\n<li>toLocalString返回数组每一项调用toLocalString返回的字符串用逗号拼接的一个字符串</li>\n</ul>\n<pre><code class=\"language-js\">let a = [1,2,3,4]\nconsole.log(a.valueOf())  // [1, 2, 3, 4]\nconsole.log(a.toString()) // 1,2,3,4\n</code></pre>\n<h2>reverse与sort</h2>\n<ul>\n<li>reverse就是简单地将数组翻转</li>\n<li>sort默认会将数组的每一项调用String方法，然后再按照升序排列元素，所以对数字的排序会有问题</li>\n<li>所以sort可以接收一个比较函数，如果第一个值要在第二个值前面，返回-1，两个参数相等，返回0，第一个值在第二个值后面，返回1</li>\n</ul>\n<pre><code class=\"language-js\">let arr = [0, 1, 5, 10, 15]\nconsole.log(arr.sort()) // [0, 1, 10, 15, 5]\n\nfunction compare(x, y){\n  if(x > y) {\n    return 1\n  } else if(x &#x3C; y) {\n    return -1\n  } else {\n    return 0\n  }\n}\nconsole.log(arr.sort(compare)) // [0, 1, 5, 10, 15]\n</code></pre>\n<ul>\n<li>上面直接对数字数组调用出错是因为对数字排序时也会转为字符串在比较，'10' 对应的字符串要小于 '5'的字符串</li>\n<li>下面进行了值比较后就正常了，单看这个比较，其实简单地 arr.sort((a, b) => a - b) 也可以实现</li>\n</ul>\n<h2>concat方法</h2>\n<ul>\n<li>concat是数组拼接方法，会创建一个数组的副本，然后把它的参数拼接到副本末尾，然后返回这个副本</li>\n<li>如果参数是数组，会把数组的每一项都加到结果数组，如果是非数组，则直接加到结果数组中</li>\n</ul>\n<pre><code class=\"language-js\">let colors = ['red', 'green', 'blue']\nlet colors1 = colors.concat('yellow', ['black', 'brown'])\nconsole.log(colors)   // [\"red\", \"green\", \"blue\"]\nconsole.log(colors1)  // [\"red\", \"green\", \"blue\", \"yellow\", \"black\", \"brown\"]\n</code></pre>\n<ul>\n<li>参数中的数组是否被展开拼接可以通过符号 Symbol.isConcatSpreadable 控制，为false不再展开，为true强制展开</li>\n</ul>\n<pre><code class=\"language-js\">let colors = ['red', 'green', 'blue']\nlet newColors = ['black', 'brown']\nnewColors[Symbol.isConcatSpreadable] = false\nlet moreNewColors = {\n  [Symbol.isConcatSpreadable]: true,\n  length: 2,\n  0: 'pink',\n  1: 'cyan'\n}\nconsole.log(colors.concat(newColors))     // [\"red\", \"green\", \"blue\", Array(2)]\nconsole.log(colors.concat(moreNewColors)) // [\"red\", \"green\", \"blue\", \"pink\", \"cyan\"]\n</code></pre>\n<h2>slice与splice</h2>\n<ul>\n<li>slice就是简单地创建一个包含原数组一个或多个元素的数组</li>\n<li>参数有两个，第一个为开始位置，第二个为结束位置（可选）</li>\n<li>不设置结束位置则一直到数组尾的全部元素</li>\n<li>如果结束位置小于开始位置，返回空数组</li>\n<li>如果参数为负值，则认为值为该负值加数组长度后的值</li>\n<li>splice用于向数组删除与插入元素</li>\n<li>第一个参数表示删除元素的位置</li>\n<li>第二个参数表示删除的数量</li>\n<li>第三个及以后的参数表示在删除位置要插入的元素</li>\n<li>该方法返回值为删除后的元素</li>\n</ul>\n<h2>find与findIndex</h2>\n<ul>\n<li>都用于查找元素，find返回第一个匹配的元素，findIndex返回第一个匹配元素的索引</li>\n<li>没找到find返回undefined，findIndex返回-1</li>\n<li>找到元素后两个方法都不会继续执行</li>\n</ul>\n<pre><code class=\"language-js\">let arr1 = [2, 4, 6]\nconsole.log(arr1.find(x => x === 4)) // 4\nconsole.log(arr1.findIndex(x => x === 4)) // 1\n</code></pre>\n<h2>迭代方法</h2>\n<ul>\n<li>every()，数组每一项都执行传入的函数，都返回true则结果返回true</li>\n<li>filter()，数组每一项都运行该函数，函数返回true则会将返回true的项拼接为数组后返回</li>\n<li>forEach()，数组每一项都执行该函数，无返回值</li>\n<li>map()，数组每一项都执行该值，返回由函数调用结果够成的数组</li>\n<li>some()，数组每一项都执行该值，有一项返回true，则方法返回true</li>\n</ul>\n<h2>reduce与reduceRight</h2>\n<ul>\n<li>两个方法都会迭代数组所有项，然后构建一个最终值并返回</li>\n<li>区别是reduce从数组第一项开始迭代，reduceRight从数组最后一项开始迭代</li>\n<li>两个方法都接受两个参数，第一个为归并函数，第二个为初始值（可选）</li>\n<li>归并函数接收4个参数，上一个归并值，当前项，当前索引，数组本身</li>\n<li>当方法的第二个参数不存在时，归并函数从第二个值开始，第一个值作为初始值</li>\n<li>以此可以做数组求和</li>\n</ul>\n<pre><code class=\"language-js\">let values = [1, 2, 3, 4, 5]\n// 可以无初始值\nlet sum = values.reduce((prev, cur, index, array) => prev + cur)\nconsole.log(sum) // 15\n// 有初始值\nsum = values.reduce((prev, cur, index, array) => prev + cur, 0)\nconsole.log(sum) // 15\n\n// 使用reduceRight\n// 有初始值\nsum = values.reduceRight((prev, cur, index, array) => prev + cur, 0)\nconsole.log(sum) // 15\n</code></pre>","fields":{"slug":"/ObjectArray/"},"frontmatter":{"title":"Array对象","tags":["JavaScript回顾"],"categories":"JavaScript"}}},{"node":{"html":"<h1>定型数组</h1>\n<ul>\n<li>WebGL的出现导致了定型数组的出现，WebGL的API不需要javascript默认的双精度浮点格式的数值，但是这种数值恰好是javascript数组在内存中的格式。</li>\n<li>因此每次WebGL与javascript运行时传递数组WebGL都需要在目标环境分配新数组，以其当前形式迭代数组，然后将数值类型转为新数组中的适当格式，但是这一过程太过耗时</li>\n<li>所以产生了CanvasFloatArray(现在的Float32Array)。javascript可以分配、读取和写入这个数组。这个数组可以直接传给底层的图形驱动API，也可以直接从底层API获取到</li>\n<li>Float32Array是定型数组的一种</li>\n</ul>\n<h2>ArrayBuffer</h2>\n<ul>\n<li>Float32Array其实是一种“视图”，允许jiavascript访问一块名为ArrayBuffer的预分配内存。ArrayBuffer是所有定型数组以及视图引用的基本单位</li>\n<li>ArrayBuffer是普通的javascript构造函数，用于在内存中分配特定数量的字节空间</li>\n<li>\n<p>ArrayBuffer一经创建就不可更改大小，但是可以使用slice复制到一个新实例中</p>\n<!--more-->\n<pre><code class=\"language-js\">const buf1 = new ArrayBuffer(16)\nconsole.log(buf1.byteLength)    // 16\nconst buf2 = buf1.slice(4, 12)\nconsole.log(buf2.byteLength)    // 8\n</code></pre>\n</li>\n<li>ArrayBuffer分配失败会抛错，分配的内存不可超过Number.MAX<em>SAFE</em>INTEGER(2 ** 53 - 1)字节</li>\n<li>ArrayBuffer初始化会将所有二进制位初始化位0</li>\n<li>不可直接对ArrayBuffer进行读取或写入内容，需要借助视图。视图有不同的类型，但是引用的都是ArrayBuffer中的二进制数据</li>\n</ul>\n<h2>DataView</h2>\n<ul>\n<li>允许读写ArrayBuffer的一种视图。位文件I/O与网络I/O设计，API支持对缓冲数据的高度控制，但是性能会比其他视图差，对缓冲内容没有预设，也不能迭代</li>\n<li>必须在有ArrayBuffer的情况下才能创建DataView实例。该实例可以使用全部或部分ArrayBuffer，还有对缓冲实例的引用以及在缓冲中的开始位置</li>\n</ul>\n<pre><code class=\"language-js\">const buf = new ArrayBuffer(16)\nconst fullDataView = new DataView(buf)\nconsole.log(fullDataView.byteOffset)      // 0\nconsole.log(fullDataView.byteLength)      // 16\nconsole.log(fullDataView.buffer === buf)  // true\n</code></pre>\n<ul>\n<li>构造函数可以接收可选的偏移量与字节长度，第二个参数为偏移量，第三个参数为字节长度</li>\n<li>不指定字节长度则默认从偏移量到缓冲区域结束</li>\n</ul>\n<pre><code class=\"language-js\">const buf = new ArrayBuffer(16)\nconst dataView = new DataView(buf, 6, 3)\nconsole.log(dataView.byteOffset)      // 6\nconsole.log(dataView.byteLength)      // 3\nconsole.log(dataView.buffer === buf)  // true\n\nconst dataView2 = new DataView(buf, 9)\nconsole.log(dataView2.byteOffset)      // 9\nconsole.log(dataView2.byteLength)      // 7\nconsole.log(dataView2.buffer === buf)  // true\n</code></pre>\n<ul>\n<li>DataView读写组件还需要读写的字节偏移量</li>\n<li>要使用ElementType来实现JavaScript的Number类型到缓冲内二进制的转换</li>\n</ul>\n<h3>ElementType</h3>\n<ul>\n<li>DataView对存储在缓冲的数据类型没有预设，强制要求开发者在读写时指定ElementType</li>\n<li>\n<p>常见的ElementType类型如下</p>\n<ul>\n<li>Int8，1个字节，8位有符号整数，范围 -128 - 127</li>\n<li>Uint8，1个字节，8位无符号整数，范围 0 - 255</li>\n<li>Int16，2个字节，16位有符号整数，范围 -32768 - 32767</li>\n<li>Uint16，2个字节，16位无符号整数，范围 0 - 65535</li>\n<li>Int32，4个字节，32位有符号整数，范围 -2147483648 - 2147483647</li>\n<li>Uint32，4个字节，32位无符号整数，范围 0 - 42949967295</li>\n<li>Float32，4个字节，32位IEEE-754浮点数，范围 -3.4e+38 - 3.4e+38</li>\n<li>Float64，8个字节，64位IEEE-754浮点数，范围 -1.7e+308 - 1.7e+308</li>\n</ul>\n</li>\n<li>DataView给上面的每个类型都暴露了get与set方法，使用byteOffset定位要读写的值</li>\n</ul>\n<pre><code class=\"language-js\">const buf = new ArrayBuffer(2)\nconst view = new DataView(buf)\n// 因为ArrayBuffer的初始值都是0\nconsole.log(view.getInt8(0)) // 0\nconsole.log(view.getInt8(1)) // 0\nconsole.log(view.getInt16(0)) // 0\n\n// 采用8位有符号数设置\nview.setInt8(0, 255)  // 将第一个字节用255填充，也就是二进制的 11111111\nview.setInt8(1, 0xFF) // 第二个字节也用16进制的255填充，仍然是8位的1\n\nview.getInt16(0)  // -1 获取有符号的16位整数，第一位为符号位表示负数，然后转为10进制数为 -1\nview.getUint16(0) // 65535 无符号的16位整数，转为10进制数为65535\n</code></pre>\n<h3>字节序</h3>\n<ul>\n<li>字节序是指计算机维护的字节顺序的约定，DataView支持大端字节序和小端字节序。</li>\n<li>大端字节序意思是最高有效位保存在第一个字节，最低有效位保存在最后一个字节</li>\n<li>小端字节序就相反，最低有效位保存在第一个字节，最高有效位保存在最后一个字节</li>\n<li>Javascript运行时所在系统的原生字节序决定如何读写字节，但是DataView不受该影响，DataView所有的API方法都是大端字节序，可以接受一个可选的布尔值设置为true启用小端字节序</li>\n</ul>\n<pre><code class=\"language-js\">const buf2 = new ArrayBuffer(16)\nconst view2 = new DataView(buf2)\nview.setInt8(0, 0x80)   // 二进制表示 10000000\nview.setInt8(1, 0x01)   // 二进制表示 00000001\n\n// 获取16位整型，因为包含两个字节，第一个字节为 10000000，第二个字节为 00000001 \n// 采用大端字节序，从左往右读，就是 10000000 00000001，转为10进制就是 2 ** 15 + 2 ** 0 = 32769\nconsole.log(view.getUint16(0)) // 32769\n\n// 采用小端字节序，从右往左读，就是 00000001 10000000， 转为10进制就是 2 ** 8 + 2 ** 7 = 384\nconsole.log(view.getUint16(0, true)) // 384\n\n// 按大端字节序写入Uint16的 0x0004，此时字节为 00000000 00000100\nview.setUint16(0, 0x0004)\n\n// 此时按Uint8读取值为\nconsole.log(view.getUint8(0)) // 0\nconsole.log(view.getUint8(1)) // 4\n\n// 按小端字节序写入Uint16的 0x0002，此时字节为 00000010 00000000\nview.setUint16(0, 0x0002)\n\n// 此时按Uint8读取值为\nconsole.log(view.getUint8(0)) // 0\nconsole.log(view.getUint8(1)) // 2\n</code></pre>\n<h2>边界值</h2>\n<ul>\n<li>DataView的读写操作都要在足够的缓冲内进行，否则抛出RangeError</li>\n</ul>\n<pre><code class=\"language-js\">const buf3 = new ArrayBuffer(6)\nconst view3 = new DataView(buf3)\n// 读取部分超出缓冲范围  因为Int32占4个字节，缓冲区总长度为6个字节，然后从第4个字节读取，读到第7个就没有值了，所以抛出错误\nview.getInt32(4)  //VM4353:3 Uncaught RangeError: Offset is outside the bounds of the DataView\n\n// 尝试读取超出范围的值\nview.getInt32(8)  //VM4353:3 Uncaught RangeError: Offset is outside the bounds of the DataView\nview.getInt32(-1)  //VM4353:3 Uncaught RangeError: Offset is outside the bounds of the DataView\n\n// 尝试写入超出范围的值\nview.setInt32(4, 123)  //VM4353:3 Uncaught RangeError: Offset is outside the bounds of the DataView\n</code></pre>\n<ul>\n<li>DataView会尽可能地把一个值转为适当的类型，后备值为0。如果无法转换，抛出错误</li>\n</ul>\n<pre><code class=\"language-js\">const buf4 = new ArrayBuffer(1)\nconst view4 = new DataView(buf4)\n\nview4.setInt8(0, 1.5)\nconsole.log(view4.getInt8(0)) // 1\n\nview4.setInt8(0, [4])\nconsole.log(view4.getInt8(0)) // 4\n\nview4.setInt8(0, 'f')\nconsole.log(view4.getInt8(0)) // 0\n\nview4.setInt8(0, Symbol())\nconsole.log(view4.getInt8(0)) // VM4674:13 Uncaught TypeError: Cannot convert a Symbol value to a number\n</code></pre>\n<h2>定型数组</h2>\n<ul>\n<li>定型数组是另一种形式的ArrayBuffer，特定于一种ElementType并遵循原生的字节序，因此，它提供了适用面更广的Api和更好的性能</li>\n<li>创建定型数组的方式有：读取已有缓冲、使用自有缓冲、填充可迭代结构，以及填充基于任意类型的定型数组</li>\n<li>通过<ElementType>.from()和<ElementType>.of()也可以创建定型数组</li>\n</ul>\n<pre><code class=\"language-js\">// 通过缓冲区创建\nconst buf5 = new ArrayBuffer(12)\nconst ints = new Int32Array(buf5)\n// 因为我们的ArrayBuffer确定了字节数，Int32的字节数也是知道的，所以可以自动得出定型数组长度\nconsole.log(ints.length) // 3\n\n// 指定长度自己创建\nconst int1 = new Int32Array(6)\nconsole.log(int1.length)              // 6\n// 定型数组有一个关联缓冲的引用，可以根据自身的长度与字节数确定缓冲区的长度\nconsole.log(int1.buffer.byteLength)   // 24\n\n// 创建包含元素的定型数组\nconst int2 = new Int32Array([2, 4, 6, 8])\nconsole.log(int2.length) // 4\nconsole.log(int2.buffer.byteLength) // 16\nconsole.log(int2[2]) // 6\n\nconst ints3 = new Int16Array(int2)\n// 这里从int2生成了新的定型数组，元素位置都没有发生变化，只是将对应的 Int32 位数转为 Int16 位数，这样变化的只有缓冲区的大小\nconsole.log(ints3.length) // 4\nconsole.log(ints3.buffer.byteLength) // 8\nconsole.log(ints3[2]) // 6\n\n// const float = Float32Array.from([3.14, 2.718, 1.618]) 这两种方式都可以\nconst float = Float32Array.of(3.14, 2.718, 1.618)\nconsole.log(float.length) // 3\nconsole.log(float.buffer.byteLength) // 12\nconsole.log(float[2]) // 1.6180000305175781\n</code></pre>\n<ul>\n<li>定型数组的构造函数跟实例都有一个BYTES<em>PER</em>ELEMENT来表示当前定型数组每个元素的大小</li>\n</ul>\n<pre><code class=\"language-js\">console.log(Int16Array.BYTES_PER_ELEMENT) // 2\nconsole.log(Int32Array.BYTES_PER_ELEMENT) // 4\n</code></pre>\n<ul>\n<li>定型数组没有初始化，那么对应的缓冲会以0填充</li>\n<li>定型数组可以使用常用的数组方法，如some、map、every这些，并且返回的数组拥有相同元素类型的新定型数组</li>\n<li>定型数组无法改变长度，所以concat、pop、push、shift、splice、unshift方法不可用</li>\n<li>定型数组提供了set与subarray方法来复制数组元素以生成新的定型数组</li>\n<li>set方法从提供的数组中或者定性数组中把值复制到当前定型数组指定的索引位置</li>\n<li>第一个参数为被复制的数组，第二个参数为复制到定型数组的索引</li>\n<li>溢出会抛错</li>\n</ul>\n<pre><code class=\"language-js\">const container = new Int16Array(8)\ncontainer.set(Int8Array.of(1, 2, 3, 4))\nconsole.log(container) // [1, 2, 3, 4, 0, 0, 0, 0]\n\ncontainer.set([5, 6, 7, 8], 4)\nconsole.log(container) // [1, 2, 3, 4, 5, 6, 7, 8]\n\n// 剩余空间不够，溢出\ncontainer.set([5, 6, 7, 8], 7) // Uncaught RangeError: Source is too large\n</code></pre>\n<ul>\n<li>subarray方法与set相反，从指定的定型数组中复制一部分并返回这一部分组成的新定型数组</li>\n<li>接收2个参数，都可选，对应开始位置与结束位置</li>\n</ul>\n<pre><code class=\"language-js\">const source = Int32Array.of(2, 4, 6, 8)\nconst sub = source.subarray()\nconsole.log(sub)  // [2, 4, 6, 8]\n\nconst sub1 = source.subarray(2)\nconsole.log(sub1) //  [6, 8]\n\nconst sub2 = source.subarray(1,3)\nconsole.log(sub2) // [4, 6]\n</code></pre>\n<ul>\n<li>利用set手动实现一个拼接方法</li>\n</ul>\n<pre><code class=\"language-js\">function concatTypeArray(typeArrayConstructor, ...typeArrays) {\n  const totalLength = typeArrays.reduce((x, y) => (x.length || x) + y.length)\n  const resultArray = new typeArrayConstructor(totalLength)\n  let currentNum = 0\n  typeArrays.map(array => {\n    resultArray.set(array, currentNum)\n    currentNum += array.length\n  })\n  return resultArray\n}\n\nconst result = concatTypeArray(Int16Array, Int16Array.of(1, 2, 3), new Int16Array([4, 5, 6]), Int16Array.from([7, 8, 9]))\nconsole.log(result) // [1, 2, 3, 4, 5, 6, 7, 8, 9]\nconsole.log(result instanceof Int16Array) // true\n</code></pre>\n<h2>上溢与下溢</h2>\n<ul>\n<li>定型数组中元素的上溢与下溢不会影响其他索引的元素，但是要考虑自身的数据类型，如下所示</li>\n</ul>\n<pre><code class=\"language-js\">// Int8的范围为 -128 - 127\nconst ints = new Int8Array(2)\n// 上溢\nints[1] = 128 \n// 128用二进制表示为 10000000 ，因为是有符号 8 位，所以第一个 1 被当作负号的标识，所以会根据符号把它当作二补码来求原来的值\n// 首先减一得 00000001，然后再取反得 10000000 是二进制的 128，再加上判定的负数，所以为 -128\nconsole.log(ints[1]) // -128\n\n// 下溢\nints[1] = -129\n// 因为-129是负数形式，所以我们得到的 -129 得二进制表示为 129得二进制 10000001 ，然后各位取反得 01111110，然后再加 1 得 01111111，再补上符号位 1 ，因为要截取8位，所以得到的就是 01111111，转为我们的有符号数就是 127\nconsole.log(ints[1]) // 127\n\n// Uint8范围为 0 - 255\nconst unsignInts = new Uint8Array(2)\n// 上溢\nunsignInts[1] = 256\n// 256用二进制表示为 100000000，然后这里截取后面 8 位就是 00000000，转为十进制就是0\nconsole.log(unsignInts[1]) // 0\n\nunsignInts[1] = 511\n// 511 用二进制表示位 111111111，然后截取后面 8 位就是 11111111，转十进制就是255\nconsole.log(unsignInts[1]) // 255\n\n// 下溢\nunsignInts[1] = -1\n// -1 用二进制表示是 1 得二进制 00000001 ，然后各位取反 11111110，然后再加 1 得 11111111，这个用无符号数表示就是 255\nconsole.log(unsignInts[1]) // 255\n</code></pre>\n<ul>\n<li>得出结论，无符号数上溢取最低有效位的 8 位，下溢的位被转为其无符号数的等价值</li>\n<li>有符号数的上溢变成该值二补数形式，下溢也变成该值二补数形式</li>\n</ul>\n<h2>Uint8ClampedArray</h2>\n<ul>\n<li>夹板数组，不允许任何方向的溢出，大于255的变为255，小于0的变为0</li>\n</ul>\n<pre><code class=\"language-js\">const clampedInts = new Uint8ClampedArray([-1, 0, 255, 256])\nconsole.log(clampedInts) // [0, 0, 255, 255]\n</code></pre>\n<ul>\n<li>Uint8ClampedArray是canvas的历史残留，如果不是做canvas开发就不要用它</li>\n</ul>","fields":{"slug":"/ArrayBuffer/"},"frontmatter":{"title":"定型数组","tags":["JavaScript回顾"],"categories":"JavaScript"}}},{"node":{"html":"<h1>Set与WeakSet</h1>\n<h2>Set</h2>\n<ul>\n<li>Set是ES6新增的集合类型，带来了集合数据结构</li>\n<li>创建方式为 new 关键字加 Set 构造函数</li>\n<li>可以通过在构造函数内传入可迭代对象来初始化该实例，如下</li>\n</ul>\n<pre><code class=\"language-js\">const s = new Set()\nconst s1 = new Set(['val1', 'val2', 'val3'])\nconst s2 = new Set({\n  [Symbol.iterator]: function*(){\n    yield 'val1'\n    yield 'val2'\n  }\n})\nconsole.log(s1) // {\"val1\", \"val2\", \"val3\"}\nconsole.log(s2) // {\"val1\", \"val2\"}\n</code></pre>\n<ul>\n<li>add()方法可以给Set添加新的键值对，has可以判断该Set是否有对应的值</li>\n<li>\n<p>size可以获取Set的元素数量，delete()用于删除元素，clear()用于清空元素，如下</p>\n<!--more-->\n<pre><code class=\"language-js\">const s3 = new Set()\nconsole.log(s3.has('first'))  // false\nconsole.log(s3.size)          // 0\n</code></pre>\n</li>\n</ul>\n<p>// add方法会返回它自身，所以可以连续add\ns3.\nadd('first').\nadd('last')\nconsole.log(s3.has('first'))  // true</p>\n<p>s3.delete('first')\nconsole.log(s3.has('first'))  // false<br>\nconsole.log(s3.has('last'))   // true\nconsole.log(s3.size)          // 1</p>\n<p>s3.clear()</p>\n<p>console.log(s3.has('last'))   // false\nconsole.log(s3.size)          // 0</p>\n<pre><code>- Set可以使用任何类型作为键，has使用严格相等来判定该值是否存在\n\n```js\nconst s4 = new Set()\nconst funcVal = function(){}\nconst objectVal = {}\nconst symbolVal = Symbol()\n\ns4.\nadd(funcVal).\nadd(objectVal).\nadd(symbolVal)\n\nconsole.log(s4.has(funcVal))    // true\nconsole.log(s4.has(objectVal))  // true\nconsole.log(s4.has(symbolVal))  // true\n\n// 全等判断，所以独立实例不冲突\nconsole.log(s4.has(function(){})) // false\n</code></pre>\n<ul>\n<li>全等判断，所以用作值的对象在自己的内容或属性变更时仍然保持不变</li>\n</ul>\n<pre><code class=\"language-js\">const s5 = new Set()\nconst objVal = {}\n\ns5.\nadd(objVal)\n\nobjVal.m2 = 'm2'\n\nconsole.log(s5.has(objVal))    // true\n</code></pre>\n<ul>\n<li>add()跟delete()是幂等的，delete()返回一个boolean，表示是否存在要删除的值</li>\n</ul>\n<pre><code class=\"language-js\">const s6 = new Set()\n\ns6.\nadd('foo')\nconsole.log(s6.size)  // 1\ns6.\nadd('foo')\nconsole.log(s6.size)  // 1\n\nconsole.log(s6.delete('foo'))    // true\nconsole.log(s6.delete('foo'))    // false\n</code></pre>\n<h2>Set顺序与迭代</h2>\n<ul>\n<li>Set维护值插入的顺序，所以是可迭代的，实例提供了一个迭代器，以插入顺序生成集合内容。</li>\n<li>通过values()方法及其别名keys()(或者Symbol.iterator属性（引用的就是values()）)获取迭代器</li>\n</ul>\n<pre><code class=\"language-js\">const s8 = new Set(['val1', 'val2', 'val3'])\nconsole.log(s8.values === s8[Symbol.iterator]) // true\nconsole.log(s8.keys === s8[Symbol.iterator]) // true\n\nfor(let value of s8[Symbol.iterator]()) {\n  console.log(value)\n}\n// 'val1'\n// 'val2'\n// 'val3'\n</code></pre>\n<ul>\n<li>values()是默认迭代器，所以可以对实例使用拓展操作</li>\n</ul>\n<pre><code class=\"language-js\">const s8 = new Set(['val1', 'val2', 'val3'])\n\nconsole.log([...s8]) // ['val1', 'val2', 'val3']\n</code></pre>\n<ul>\n<li>也可以不用迭代器，使用回调方法，用映射的forEach方法并传入回调，依次接受每个键/值对（键跟值都是值）。回调可接受可选的第二个参数，用于重写内部的this值</li>\n<li>forEach中的两个参数都是对应的值。</li>\n</ul>\n<pre><code class=\"language-js\">const s8 = new Set(['val1', 'val2', 'val3'])\n\ns8.forEach((val, key) => { console.log(`${ key } -> ${ val }`) })\n// val1 -> val1\n// val2 -> val2\n// val3 -> val3\n\ns8.forEach(function(val, key){ console.log(`${ key } -> ${ this.name } -> ${ val}`) }, { name: 's8' })\n// val1 -> s8 -> val1\n// val2 -> s8 -> val2\n// val3 -> s8 -> val3\n</code></pre>\n<h2>WeakSet</h2>\n<ul>\n<li>WeakSet 是 Set 的兄弟类型，API也是 Set 的自己，“weak”描述的时Javascrip垃圾回收程序对待“弱映射”中键的形式</li>\n<li>WeakMap中的键只能是Object或者继承自Object的类型，使用非对象设置键会抛出TypeError，值类型无限制</li>\n<li>初始化时只要有一个键无效就会抛错，其他的初始化全部失败</li>\n</ul>\n<pre><code class=\"language-js\">const key1 = { id: 1 }\n\nconst ws = new WeakSet([key1, 'BADKEY']) // Uncaught TypeError: Invalid value used in weak set\n\n// 要使用非对象的值可以使用构造函数包装再使用\nconst ws1 = new WeakSet([key1,new String('BADKEY')]) \n</code></pre>\n<ul>\n<li>其他的基本方法add、has、delete与Set保持一致</li>\n<li>“weak”表示键不属于正式引用，可以被回收，当键被回收后，键值对消失</li>\n</ul>\n<pre><code class=\"language-js\">const ws2 = new WeakSet()\nconst container = {\n  key:{}\n}\nws2.add(container.key)\nfunction removeReference(){\n  container.key = null\n}\nremoveReference()\n</code></pre>\n<ul>\n<li>上例中container对象维护着弱集合值的引用，所以不会被回收，但是要是执行了removeReference方法，那么值的引用就消失了，那么值就会消失</li>\n<li>WeakSet中的键值随时可能消失，所以没有迭代能力，也没有提供clear()清空的方法</li>\n<li>WeakSet之所以限制只能使用对象，是为了保证只有通过键对象的引用才能取到值。要是允许原始值就无法区分初始化时的字符串字面量跟初始化之后使用一个相同的字符串了</li>\n</ul>\n<h3>WeakSet的应用</h3>\n<ul>\n<li>WeakSet不会阻止垃圾回收，所以适合给对象打标签</li>\n</ul>\n<pre><code class=\"language-js\">const disabledElements = new Set()\nconst loginButton = document.querySelector('#login')\ndisabledElements.add(loginButton)\n</code></pre>\n<ul>\n<li>这样我们查询元素在不在disabledElements就可以知道是否被禁用了。不过上面的实现在登录按钮被DOM树删除了，但因为Set中存在着按钮的引用，垃圾回收不能回收它</li>\n</ul>\n<pre><code class=\"language-js\">const disabledElements = new WeakSet()\nconst loginButton = document.querySelector('#login')\ndisabledElements.add(loginButton)\n</code></pre>\n<ul>\n<li>使用WeakMap后当节点被删除后这里的引用也会消失，内存可直接被回收</li>\n</ul>","fields":{"slug":"/Set/"},"frontmatter":{"title":"Set与WeakSet","tags":["JavaScript回顾"],"categories":"JavaScript"}}},{"node":{"html":"<h1>Map与WeakMap</h1>\n<h2>Map</h2>\n<ul>\n<li>Map是ES6新增的键值存储类型</li>\n<li>创建方式为 new 关键字加 Map构造函数</li>\n<li>可以通过在构造函数内传入可迭代对象来初始化该实例，可迭代对象的每一项需要包含键/值对数组，如下</li>\n</ul>\n<pre><code class=\"language-js\">const m = new Map()\nconst m1 = new Map([['key1', 'value1'], ['key2', 'value2'], ['key3', 'value3']])\nconst m2 = new Map({\n  [Symbol.iterator]: function*(){\n    yield ['key1', 'value1']\n    yield ['key2', 'value2']\n  }\n})\nconsole.log(m1) // {\"key1\" => \"value1\", \"key2\" => \"value2\", \"key3\" => \"value3\"}\nconsole.log(m2) // {\"key1\" => \"value1\", \"key2\" => \"value2\"}\n\n// Map会映射它期待的键值对，无论你提供不提供，如下，因为没有提供对应的键值，Map会自动以undefined填充\nconst m3 = new Map([[]])\nconsole.log(m3) // {undefined => undefined}\n</code></pre>\n<ul>\n<li>set()方法可以给Map添加新的键值对，get可以查询对应键下面的值，has可以判断该Map是否有对应的键</li>\n<li>\n<p>size可以获取Map的键值对数量，delete()用于删除指定值，clear()用于清空Map，如下</p>\n<!--more-->\n<pre><code class=\"language-js\">const m4 = new Map()\nconsole.log(m4.has('first'))  // false\nconsole.log(m4.get('first'))  // undefined\nconsole.log(m4.size)          // 0\n</code></pre>\n</li>\n</ul>\n<p>// set方法会返回它自身，所以可以连续set\nm4.\nset('first', 'matt').\nset('last', 'kuni')\nconsole.log(m4.has('first'))  // true\nconsole.log(m4.get('first'))  // 'matt'</p>\n<p>m4.delete('first')\nconsole.log(m4.has('first'))  // false<br>\nconsole.log(m4.has('last'))   // true\nconsole.log(m4.get('first'))  // undefined\nconsole.log(m4.get('last'))   // 'last'\nconsole.log(m4.size)          // 1</p>\n<p>m4.clear()</p>\n<p>console.log(m4.has('last'))   // false\nconsole.log(m4.size)          // 0</p>\n<pre><code>- Map可以使用任何类型作为键，has与get使用严格相等来判定该键是否存在\n\n```js\nconst m5 = new Map()\nconst funcKey = function(){}\nconst objectKey = {}\nconst symbolKey = Symbol()\n\nm5.\nset(funcKey, 'function').\nset(objectKey, 'object').\nset(symbolKey, 'symbol')\n\nconsole.log(m5.get(funcKey))    // function\nconsole.log(m5.get(objectKey))  // object\nconsole.log(m5.get(symbolKey))  // symbol\n\n// 全等判断，所以独立实例不冲突\nconsole.log(m5.get(function(){})) // undefined\n</code></pre>\n<ul>\n<li>全等判断，所以用作键和值的对象在自己的内容或属性变更时仍然保持不变</li>\n</ul>\n<pre><code class=\"language-js\">const m6 = new Map()\nconst objKey = {}\nconst objVal = {}\n\nm6.\nset(objKey, objVal)\n\nobjKey.m1 = 'm1'\nobjVal.m2 = 'm2'\n\nconsole.log(m6.get(objKey))    // {m2: \"m2\"}\n\n\n// 全等判断，所以独立实例不冲突\nconsole.log(m6.get({})) // undefined\n</code></pre>\n<ul>\n<li>全等判断，所以下面情况可能出问题</li>\n</ul>\n<pre><code class=\"language-js\">const m7 = new Map()\nconst a = 0/'', b = 0/'',pz = +0, nz = -0;\nconsole.log(a === b)\nconsole.log(pz === nz)\n\nm7.set(a, 'foo')  // false\nm7.set(pz, 'bar') // true\n\nconsole.log(m7.get(b))  // 'foo'\nconsole.log(m7.get(nz)) // 'bar'\n</code></pre>\n<h2>Map顺序与迭代</h2>\n<ul>\n<li>Map维护键值插入的顺序，所以是可迭代的，实例提供了一个迭代器，以插入顺序生成[key, value]形式的数组。</li>\n<li>通过entries()方法或者Symbol.iterator属性（引用的就是entries()）获取迭代器</li>\n</ul>\n<pre><code class=\"language-js\">const m8 = new Map([['key1', 'value1'], ['key2', 'value2'], ['key3', 'value3']])\nconsole.log(m8.entries === m8[Symbol.iterator]) // true\n\nfor(let pairs of m8[Symbol.iterator]()) {\n  console.log(pairs)\n}\n// [\"key1\", \"value1\"]\n// [\"key2\", \"value2\"]\n// [\"key3\", \"value3\"]\n</code></pre>\n<ul>\n<li>entries()是默认迭代器，所以可以对实例使用拓展操作</li>\n</ul>\n<pre><code class=\"language-js\">const m8 = new Map([['key1', 'value1'], ['key2', 'value2'], ['key3', 'value3']])\n\nconsole.log([...m8]) // [[\"key1\", \"value1\"], [\"key2\", \"value2\"], [\"key3\", \"value3\"]]\n</code></pre>\n<ul>\n<li>也可以不用迭代器，使用回调方法，用映射的forEach方法并传入回调，依次接受每个键/值对。回调可接受可选的第二个参数，用于重写内部的this值</li>\n<li>forEach中的第一个参数是对应的值，第二个为对应的键。</li>\n</ul>\n<pre><code class=\"language-js\">const m8 = new Map([['key1', 'value1'], ['key2', 'value2'], ['key3', 'value3']])\n\nm8.forEach((val, key) => { console.log(`${ key } -> ${ val }`) })\n// key1 -> value1\n// key2 -> value2\n// key3 -> value3\n\nm8.forEach(function(val, key){ console.log(`${ key } -> ${ this.name } -> ${ val}`) }, { name: 'm8' })\n// key1 -> m8 -> value1\n// key2 -> m8 -> value2\n// key3 -> m8 -> value3\n</code></pre>\n<ul>\n<li>keys()跟values()分别返回以插入顺序生成的键跟值</li>\n</ul>\n<pre><code class=\"language-js\">const m8 = new Map([['key1', 'value1'], ['key2', 'value2'], ['key3', 'value3']])\n\nfor(let key of m8.keys()) {\n  console.log(key)\n}\n// key1\n// key2\n// key3\n\nfor(let val of m8.values()) {\n  console.log(val)\n}\n\n// value1\n// value2\n// value3\n</code></pre>\n<ul>\n<li>\n<p>Object与Map的对比</p>\n<ul>\n<li>内存情况，Object与Map占用的内存都会随键的数量线性增加。在给定固定大小内存的情况下，Map可以比Object多存储 50% 的键值对</li>\n<li>插入性能，Object与Map对插入的消耗差不多，但是Map要快一点，所以大量的插入操作使用Map</li>\n<li>查找速度，包含少量的键值时，Object的速度更快，涉及大量的查找操作使用Object更好</li>\n<li>删除性能，Object的delete性能很差，Map的delete()比插入和查找更快。所以涉及大量删除使用Map</li>\n</ul>\n</li>\n</ul>\n<h2>WeakMap</h2>\n<ul>\n<li>WeakMap是Map的兄弟类型，API也是Map的子集，“weak”描述的时Javascrip垃圾回收程序对待“弱映射”中键的形式</li>\n<li>WeakMap中的键只能是Object或者继承自Object的类型，使用非对象设置键会抛出TypeError，值类型无限制</li>\n<li>初始化时只要有一个键无效就会抛错，其他的初始化全部失败</li>\n</ul>\n<pre><code class=\"language-js\">const key1 = { id: 1 }\nconst key2 = { id: 2 }\nconst key3 = { id: 3 }\n\nconst wm = new WeakMap([[key1, 'val1'], ['BADKEY', 'val2']]) // VM648:5 Uncaught TypeError: Invalid value used as weak map key\n\n// 要使用非对象的值可以使用构造函数包装再使用\nconst wm = new WeakMap([[key1, 'val1'], [new String('BADKEY'), 'val2']]) // {String => \"val2\", {…} => \"val1\"}\n</code></pre>\n<ul>\n<li>其他的基本方法set、get、has与Map保持一致</li>\n<li>“weak”表示键不属于正式引用，可以被回收，当键被回收后，键值对消失</li>\n</ul>\n<pre><code class=\"language-js\">const wm2 = new WeakMap()\nconst container = {\n  key:{}\n}\nwm2.set(container.key, 'val')\nfunction removeReference(){\n  container.key = null\n}\nremoveReference()\n</code></pre>\n<ul>\n<li>上例中container对象维护着弱映射键的引用，所以不会被回收，但是要是执行了removeReference方法，那么键的引用就消失了，那么键值对就会消失</li>\n<li>WeakMap中的键值随时可能消失，所以没有迭代能力，也没有提供clear()清空的方法</li>\n<li>WeabMap之所以限制只能使用对象，是为了保证只有通过键对象的引用才能取到值。要是允许原始值就无法区分初始化时的字符串字面量跟初始化之后使用一个相同的字符串了</li>\n</ul>\n<h3>WeakMap的应用</h3>\n<ul>\n<li>私有变量</li>\n</ul>\n<pre><code class=\"language-js\">const User = (() => {\n  const wm = new WeakMap()\n  class User {\n    constructor(id) {\n      this.idProperty = Symbol('id')\n      this.setId(id)\n    }\n    setPrivate(property, value) {\n      const propertyMembers = wm.get(this) || {}\n      propertyMembers[property] = value\n      wm.set(this, propertyMembers)\n    }\n    getPrivate(property) {\n      return wm.get(this)[property]\n    }\n    setId(id) {\n      this.setPrivate(this.idProperty, id)\n    }\n    getId(){\n      return this.getPrivate(this.idProperty)\n    }\n  }\n  return User\n})()\n\nconst user = new User(123)\nconsole.log(user.getId()) // 123\nuser.setId(456)\nconsole.log(user.getId()) // 456\n</code></pre>\n<ul>\n<li>DOM节点元数据</li>\n<li>WeakMap不会阻止垃圾回收，适合保存元数据</li>\n</ul>\n<pre><code class=\"language-js\">const m = new Map()\nconst loginButton = document.querySelector('#login')\nm.set(loginButton, { disabled: true })\n</code></pre>\n<ul>\n<li>上面的实现在登录按钮被DOM树删除了，但因为Map中存在着按钮的引用，所以DOM节点还会在内存中存在</li>\n</ul>\n<pre><code class=\"language-js\">const m = new WeakMap()\nconst loginButton = document.querySelector('#login')\nm.set(loginButton, { disabled: true })\n</code></pre>\n<ul>\n<li>使用WeakMap后当节点被删除后这里的引用也会消失，内存可直接被回收</li>\n</ul>","fields":{"slug":"/Map/"},"frontmatter":{"title":"Map与WeakMap","tags":["JavaScript回顾"],"categories":"JavaScript"}}},{"node":{"html":"<h1>初识webGl</h1>\n<ul>\n<li>webGl是在web端实现3d效果的Api，是OpenGl的裁剪版，适用于web端的3d效果实现</li>\n<li>webGl在浏览器端的支持情况不一致，所以我们使用时注意兼容此种情况</li>\n</ul>\n<h2>着色器</h2>\n<ul>\n<li>在使用webGl的时候我们要准备两个着色器，</li>\n<li>一个顶点着色器，用来确定我们的渲染物体的各个顶点的位置，由这些顶点可以确定画面的渲染位置</li>\n<li>一个片段着色器，用来确定顶点决定的图形的各个像素的颜色值</li>\n<li>下面我们分别定义这两个着色器</li>\n</ul>\n<pre><code class=\"language-js\">// 顶点着色器\nprecision lowp float; // 指定一下我们着色器的数据精度\nattribute vec4 inColor; // 定义一个包含4个浮点数的浮点型向量，一个属性值，将会从缓冲中获取数据，用于颜色值\nattribute vec3 v3Position; // 定义一个包含3个浮点数的浮点型向量，一个属性值，将会从缓冲中获取数据，用于表示该顶点的位置\nvarying vec4 outColor; // 可变量，是顶点着色器向片段着色器传值的方式\nvoid main() {\n  outColor = inColor; // 将获取到的顶点的值赋给可变量从而传递给片段着色器\n  gl_Position = vec4(v3Position, 1.0); // gl_Position是webgl提供的内置变量，用来表示顶点位置\n}\n\n// 片段着色器\nprecision lowp float; // 指定一下我们着色器的数据精度\nvarying vec4 outColor; // 可变量，获取顶点着色器的传值\nvoid main() {\n  gl_FragColor = outColor; // gl_fragColor也是webgl提供的内置变量，用来表示像素点的颜色\n}\n</code></pre>\n<!--more-->\n<h2>第一个实例</h2>\n<ul>\n<li>接下来我们就用一个实例来看看wenGl的编写过程</li>\n<li>首先我们需要准备一个canvas作为webGl的宿主环境</li>\n</ul>\n<pre><code class=\"language-js\">&#x3C;canvas id=\"canvas\" width='500' height='500'>&#x3C;/canvas>\n</code></pre>\n<ul>\n<li>然后开始我买的呢js代码实现，首先我们获取创建的canvas的Dom元素</li>\n<li>然后获取webGl的运行环境</li>\n</ul>\n<pre><code class=\"language-js\">// 定义着色器语句\nlet shaderVsJs = `\nprecision lowp float;  \nattribute vec3 v3Position;\nattribute vec4 inColor;\nvarying   vec4 outColor;\nvoid main(){\n  outColor = inColor;\n  gl_Position = vec4(v3Position, 1.0);\n}\n`\nlet shaderFsJs = `\nprecision lowp float;\nvarying vec4 outColor;\nvoid main(){\n  gl_FragColor = outColor;\n}\n`\n// 获取canvas环境\nlet canvas = document.querySelector('#canvas')\nwebgl = canvas.getContext('webgl')\nif(!webgl) {\n  alert('浏览器暂不支持webGl，请更换浏览器')\n  return\n}\n</code></pre>\n<ul>\n<li>接着设置webgl的视口大小，这个视口需要在canvas的范围内，所以我们先设为整个canvas的大小</li>\n</ul>\n<pre><code class=\"language-js\">// 视口的设置参数为 左上角顶点位置x，左上角顶点位置y，视口的宽度，视口的高度\nwebgl.viewport(0, 0, canvas.clientWidth, canvas.clientHeight)\n</code></pre>\n<ul>\n<li>接着需要创建我们顶点着色器与片段着色器</li>\n</ul>\n<pre><code class=\"language-js\">// 着色器的创建函数以及错误警告\nfunction initShaderSouce(webgl, shader, shaderScript){\n  webgl.shaderSource(shader, shaderScript)  // 提供数据源\n  webgl.compileShader(shader) // 编译，生成着色器\n  const success = webgl.getShaderParameter(shader, webgl.COMPILE_STATUS) // 查看着色器的编译状态\n  if(success) {\n    return shader\n  }\n  console.log(webgl.getShaderInfoLog(shader)) // 出错时打印着色器的出错日志\n  webgl.deleteShader(shader) // 着色器失败时删除对应着色器\n}\n\nconst ertexShaderObject = webgl.createShader(webgl.VERTEX_SHADER) // 创建着色器对象\nconst fragmentShaderObject = webgl.createShader(webgl.FRAGMENT_SHADER)  \n\ninitShaderSouce(webgl, vertexShaderObject, shaderVsJs)\ninitShaderSouce(webgl, fragmentShaderObject, shaderFsJs)\n</code></pre>\n<ul>\n<li>然后就要创建我们的着色程序，然后把着色器也要链接到着色程序以让他们生效</li>\n<li>然后将我们在着色器语句中创建的两个attribute变量v3Position关联到我们的属性索引</li>\n</ul>\n<pre><code class=\"language-js\">let inColorIndex = 1, v3PositionIndex = 0 // 创建对应的属性索引\nprogramObject = webgl.createProgram() // 创建着色程序\n\nwebgl.attachShader(programObject, vertexShaderObject)   // 将着色器附加到着色程序中\nwebgl.attachShader(programObject, fragmentShaderObject)\n\nwebgl.bindAttribLocation(programObject, inColor, 'inColor') // 将着色器中的变量（必须是attribute变量）关联到一个属性索引\nwebgl.bindAttribLocation(programObject, v3PositionIndex, 'v3Position') \n\nwebgl.linkProgram(programObject) // 链接我们的着色程序\nif(!webgl.getProgramParameter(programObject, webgl.LINK_STATUS)) { // 查看着色程序是否正确链接\n  console.log(webgl.getProgramInfoLog(programObject)) // 链接失败打印打印错误信息\n  return\n}\nwebgl.useProgram(programObject) // 启用我们的链接程序\n</code></pre>\n<ul>\n<li>接下来我们就要创建我们的顶点数据与索引数据了</li>\n<li>顶点数据确定了我们所有的可能使用的顶点的元素的集合</li>\n<li>索引数据确定了我们顶点的绘制顺序的集合</li>\n<li>数据集合都以buffer（缓冲）的形式保存，所以需要创建对应的缓冲变量</li>\n</ul>\n<pre><code class=\"language-js\">// 顶点数据集合\nlet triangleArrayData = [\n  // 每一行的前三个数据为顶点位置， 后4个位置为对应的颜色 rgba 值，所以一个顶点对应7个数据\n  // x,  y,   z,   r,   g,   b,  a\n  -0.5, 0.5, 0.0, 1.0, 0.0, 0.0, 1.0, // 左上\n  0.5, 0.5, 0.0, 0.0, 1.0, 0.0, 1.0, // 右上\n  0.5, -0.5, 0.0, 0.0, 0.0, 1.0, 1.0, // 右下\n  -0.5, -0.5, 0.0, 1.0, 1.0, 0.0, 1.0 // 左下\n// 索引数据集合\nlet indexArrayData = [\n  0, 1, 2,\n  0, 2, 3\n]\n\nconst triangleBuffer = webgl.createBuffer() // 缓冲区创建\nconst indexBuffer = webgl.createBuffer()\n</code></pre>\n<ul>\n<li>然后将创建的存储区设置为对应存储区类型的操作对象 （也就是说绑定了这个存储区类型要用来操作这个缓冲区了）</li>\n<li>然后给这个缓冲区确定数据、数据类型与数据的变动状况</li>\n</ul>\n<pre><code class=\"language-js\">// 绑定ARRAY_BUFFER存储区类型操作 triangleBuffer\nwebgl.bindBuffer(webgl.ARRAY_BUFFER, triangleBuffer)  \n// 给缓冲区绑定数据与确定数据的变动情况  Float32Array 表示32位浮点数， webgl.STATIC_DRAW表示这个数据我以后不会经常改\nwebgl.bufferData(webgl.ARRAY_BUFFER, new Float32Array(triangleArrayData), webgl.STATIC_DRAW) //\n\nwebgl.bindBuffer(webgl.ELEMENT_ARRAY_BUFFER, indexBuffer)\nwebgl.bufferData(webgl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indexArrayData), webgl.STATIC_DRAW)\n</code></pre>\n<ul>\n<li>然后准备清空我们的画布开始绘制我们的图形</li>\n</ul>\n<pre><code class=\"language-js\">// 清空画布的颜色 \nwebgl.clearColor(0.0, 0.0, 0.0, 1.0)\n// 执行清空操作\nwebgl.clear(webgl.COLOR_BUFFER_BIT) \n</code></pre>\n<ul>\n<li>然后我们启用之前绑定的变量索引，方便在后续更改变量值进行绘画</li>\n</ul>\n<pre><code class=\"language-js\">webgl.enableVertexAttribArray(v3PositionIndex) // 启用对应关联索引上的数组数据或元素数组数据\nwebgl.enableVertexAttribArray(inColor)\n</code></pre>\n<ul>\n<li>然后为我们的变量索引分配数据</li>\n</ul>\n<pre><code class=\"language-js\">// 为变量分配数据，参数对应为  第一个：数据绑定的变量， 第二个参数表示需要的元素个数（3表示需要3个数据，4表示需要4个数据，与定义时的 vec 后面跟的3或4相关），\n// 第三个参数为元素的数据类型， 第四个参数为是否归一化， 第五个参数为第二个数据与上一个数据的偏移量，以字节为单位（这里因为我们定义的是Float32位，所以一个数据为4个字节，偏移量就是每一组数据的个数7 * 字节数4），第六个参数是数据的偏移量（前三个数据为顶点的坐标位置，后4个为顶点的rgba值）\nwebgl.vertexAttribPointer(v3PositionIndex, 3, webgl.FLOAT, false, 7 * 4, 0) // 位置需要3个值， 第一行第一个开始就是要用的数据了，所以偏移量为0\nwebgl.vertexAttribPointer(inColor, 4, webgl.FLOAT, false, 7 * 4, 3 * 4)  // 位置需要4个值， 第一行第4个开始才是要用的数据了，所以偏移量为数据个数 3 * 字节数 4\n</code></pre>\n<ul>\n<li>之后我们的全部流程就完成了，然后再执行我们的绘画操作就可以了</li>\n</ul>\n<pre><code class=\"language-js\">// 绘制方法，第一个参数表示我们要画三角形， 第二个表示我们的顶点的绘制顺序总共有几个，第三个表示顶点绘制顺序的数据的元素类型是短整型，第四个参数是表示从数据列表的第几个开始绘制\nwebgl.drawElements(webgl.TRIANGLES, 6, webgl.UNSIGNED_SHORT, 0)\n</code></pre>\n<ul>\n<li>之后我们就绘制了出了一个渐变色正方形</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 626px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/e842cb1620e9a10679824522a6d46a82/af590/webgl_rect.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 99.6%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAACXBIWXMAABJ0AAASdAHeZh94AAACR0lEQVQ4y8XUzUtUURjH8TM5c73eq3MdX8a5WZA4F7u5aUwLTMeaWpQlIWEjOAVlWBlpCkNhICVkmTCEvSxmk4ShSC0i0jYZWCszokUULSuI/opvT2BZkTZQ5OK3uud8eM55nntUQNdRSv27/BfQ80N+u8mzkBWr0JIEshR+nyI3W2HkKHRDoeUqfH5FVr5UXyBrs5YBvx3PkDz0aswV5DJZaXJju0l/3OR4l0nzRZOtaZPwA5O8pybK8SxewVKguUrxqsjgs17GsxKHu5vCjDQ5nD3mcOiCw850mA1TDtZcGFWhZQDKMZ5X5vC+tJwZXy3jxQ2kIlGSu6O0tUeJnYvi3mzAmqxHlRkZgF7F/DaDj1vKeWLXM6HtJxVsJRmJk2iME2uP4/a3Yl1rQa21MgClEfMtAjYLWF3HhH2AlHaKZLCXRKSHWGMP7tFerL4uVKgwA1ATsFPAkwLulQprWkjZp0lqgySCw8QiQ7h7hrEOD6KKQguQZxlQxmT+vICDAnYI2CQV1nSTtIdIaKPEgmO4VXewdo2i8tcsAy6UberSlOsGH25JU/rrGO+QCpsErL5Mm32bmO8RbnAGa+M0ylyXAShD/PKewafH5cym65kciHP1RA9n9l3h4OYxdqyewdXeYBW/RmU7fwYN+SNmp3N4O1fG1EQtoyPNXOrrpPvIAPHGNA1V96kIvcCvvZNmrF8a/P4wCByyPZSWeikpyaZIhjwQyMPvz8c0C9H1IF6fLeu+3p9vpZ4vz89Z/Ob5JSv1fP1NvgAUEgYu3FVrWQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"图片\"\n        title=\"图片\"\n        src=\"/static/e842cb1620e9a10679824522a6d46a82/af590/webgl_rect.png\"\n        srcset=\"/static/e842cb1620e9a10679824522a6d46a82/0b533/webgl_rect.png 500w,\n/static/e842cb1620e9a10679824522a6d46a82/af590/webgl_rect.png 626w\"\n        sizes=\"(max-width: 626px) 100vw, 626px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>","fields":{"slug":"/webgl_shader_buffer/"},"frontmatter":{"title":"初识webGl（1）","tags":["WebGl"],"categories":"WebGl"}}}]}},"pageContext":{"limit":10,"skip":40,"currentIndex":4}},"staticQueryHashes":["2566592090"]}