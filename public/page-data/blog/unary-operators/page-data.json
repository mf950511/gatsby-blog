{"componentChunkName":"component---src-templates-blog-small-jsx","path":"/blog/unary-operators/","result":{"data":{"markdownRemark":{"html":"<h1>不常用的一元操作符</h1>\n<h2>位操作符</h2>\n<ul>\n<li>ECMAScript中数值都是已64位格式存储，但是位操作符不能直接在64位中操作，要把值转为32位整数，操作完成后再转为64位整数。</li>\n<li>对开发者来说，是不用关注64位整数的，我们感知不到，我们只需要知道32位整数的工作原理即可</li>\n<li>有符号整数由一位符号位与31位二进制数值位来表示。第一位的符号位0表示正数，1表示负数。其他的数决定这个数的大小，数值跟二进制转十进制的方式相同，从最后一位开始，第一个代表2的0次方，第二个代表2的一次方，没有实际值的按0来填充。比如18按32位来表示为</li>\n</ul>\n<pre><code class=\"language-js\">00000000000000000000000000010010 // 32位表示18\n//转换方式\n(Math.pow(2, 0)) * 0 + (Math.pow(2, 1)) * 1 + (Math.pow(2, 2)) * 0 + (Math.pow(2, 3)) * 0 + (Math.pow(2, 4)) * 1\n</code></pre>\n<ul>\n<li>负数也是用二进制来表示，但是跟正数不一样，负数的表示是对应32位正数的补码。有三个步骤</li>\n<li>第一步，写出该负数的绝对值对应的32位数</li>\n<li>第二步，将32位数中的0变为1，1变为0</li>\n<li>第三步，在第二步得到的数上加1，然后逢二进一，比如-18的表示</li>\n</ul>\n<pre><code class=\"language-js\">// 1.写出绝对值，也就是18的32位数\n00000000000000000000000000010010\n// 2.将0变为1，1变为0\n11111111111111111111111111101101\n// 3.在第二步的基础上加1\n11111111111111111111111111101110 // -18的32位表现形式\n</code></pre>\n<ul>\n<li>ECMAScript会尽量的将这些数据都给你保留，当你使用toString并指定二进制数值时，会返回'-10010'来给你</li>\n</ul>\n<pre><code class=\"language-js\">let num = -18\nconsole.log(num.toString(2)) // '-10010'\n</code></pre>\n<ul>\n<li>上面是有符号正数，当我们用来表示无符号整数是，第一位就不再是符号位，也是真正的数值位，所以无符号整数可以比有符号整数大一点</li>\n<li>在ECMAScript中使用位运算时，会先将64位整数转为32位正数，然后进行位运算，然后转为64位整数，这也就给我们一个错觉，我们在操作真正的32位正数。这也使得对二进制的操作与其他语言相似。</li>\n<li>在这个处理中有两个特殊值NaN跟Infinity会跟0的处理方式一样</li>\n<li>如果为非数值类型使用位操作符则会使用Number()强制转为数值，然后计算</li>\n</ul>\n<h2>Not操作符(~)</h2>\n<ul>\n<li>简单的返回一个数对应32位数的补码（即0变为1，1变为0）</li>\n</ul>\n<pre><code class=\"language-js\">let num = 25 \n// 对应的32位数\n000000000000000000000000000011001\n// 使用位操作符\n111111111111111111111111111100110\n// 然后将32位数转为对应的负数，将之前的三步倒过来\n// 1.减1\n111111111111111111111111111100101\n// 2. 取补码\n000000000000000000000000000011010\n// 3.计算值并加负号\n-26\n</code></pre>\n<ul>\n<li>所以我们在对25进行了~操作后就得到了-26</li>\n<li>其实，~操作的结果就是我们对要操作的数进行取反，然后减1即可</li>\n<li>位操作符因为操作数值的最低级别，所以速度极快</li>\n</ul>\n<h2>AND操作符(&#x26;)</h2>\n<ul>\n<li>该符号工作于两个值，将两个值对应的位进行操作，只有当两个值对应位都是1才返回1，否则返回0，如下</li>\n</ul>\n<pre><code class=\"language-js\">let result = 25 &#x26; 3\n// 25的32位数\n000000000000000000000000000011001\n// 3的32位数\n000000000000000000000000000000011\n// 对应值\n000000000000000000000000000000001\n// 转为整数就是1\nconsole.log(result) // 1\n</code></pre>\n<h2>OR操作符(|)</h2>\n<ul>\n<li>该符号同样作用于两个值，对两个值的为进行操作，只有当两个值对应位都是0才返回0，否则返回1，如下</li>\n</ul>\n<pre><code class=\"language-js\">let result = 25 | 3\n// 25的32位数\n000000000000000000000000000011001\n// 3的32位数\n000000000000000000000000000000011\n// 对应值\n000000000000000000000000000011011\n// 转换为整数就是 27\nconsole.log(result) // 27\n</code></pre>\n<h2>XOR操作符(^)</h2>\n<ul>\n<li>同样作用与两个值，将两个数的32位数进行比较，当相同时返回0，不同时返回1，比如 0跟0返回0，1跟1返回0， 1跟0返回1，0跟1返回1，如下</li>\n</ul>\n<pre><code class=\"language-js\">let result = 25 | 3\n// 25的32位数\n000000000000000000000000000011001\n// 3的32位数\n000000000000000000000000000000011\n// 对应值\n000000000000000000000000000011010\n// 转换为整数就是 26\nconsole.log(result) // 26\n</code></pre>\n<h2>左移操作</h2>\n<ul>\n<li>左移操作由两个 &#x3C; 表示，并且将除符号位之外所有的位数向左移动指定的位数，比如对2进行左移5操作，如下</li>\n</ul>\n<pre><code class=\"language-js\">let val = 2\nlet newVal = val &#x3C;&#x3C; 5\n// 首先将2转为32位数\n000000000000000000000000000000010\n// 然后将除符号位的数向左移动5位\n0000000000000000000000000010\n// 然后把后面空出来的用0补起来\n000000000000000000000000001000000\n// 最终得到  64\nconsole.log(newVal) // 64\n</code></pre>\n<ul>\n<li>左移操作不会修改符号位，所以对-2进行左移5位得到的是-64而不是64</li>\n</ul>\n<h2>有符号右移操作</h2>\n<ul>\n<li>有符号右移使用两个 > 然后跟一个移动数量来表示，比如对64进行右移5操作，如下</li>\n</ul>\n<pre><code class=\"language-js\">let val = 64\nlet newVal = val >> 5\n// 首先将64转为32位数\n000000000000000000000000001000000\n// 然后将除符号位的数向右移动5位\n0     000000000000000000000000010\n// 然后把前面空出来的用0补起来\n000000000000000000000000000000010\n// 最终得到  2\nconsole.log(newVal) // 2\n</code></pre>\n<ul>\n<li>有符号右移操作同样不会修改符号位，所以对-64进行右移5位得到的是-2而不是2</li>\n</ul>\n<h2>无符号右移操作</h2>\n<ul>\n<li>无符号右移操作是使用三个 > 然后跟一个右移数量表示，因为是无符号数，所以32位都表示数值，也就不会对第一位进行保留了</li>\n<li>这种情况下对正数进行右移并不会改变原来的值，因为符号位本来就是0，如下</li>\n</ul>\n<pre><code class=\"language-js\">let val = 64\nlet newVal = val >> 5\n// 首先将64转为32位数\n000000000000000000000000001000000\n// 然后将所有数向右移动5位\n     0000000000000000000000000010\n// 然后把前面空出来的用0补起来\n000000000000000000000000000000010\n// 最终得到  2\nconsole.log(newVal) // 2\n</code></pre>\n<ul>\n<li>但是针对负数就不一样了，因为负数是对应正数取补码加1，所以表现形式不一致，比如-64，如下</li>\n</ul>\n<pre><code class=\"language-js\">let val = -64\nlet newVal = val >>> 5\n// 首先将-64转为32位数\n111111111111111111111111111000000\n// 然后将所有数向右移动5位\n     1111111111111111111111111110\n// 然后把前面空出来的用0补起来\n000001111111111111111111111111110\n// 最终得到  134217726\nconsole.log(newVal) // 134217726\n</code></pre>\n<h2>逻辑与(&#x26;&#x26;)</h2>\n<ul>\n<li>同样作用于两个值，类型无要求返回逻辑如下</li>\n<li>两个都是boolean值，则只有两个都是true才返回true，否则返回false</li>\n<li>如果第一个是对象，则一定返回第二个值</li>\n<li>如果第二个是对象，则只有第一个为true时才返回这个对象</li>\n<li>两个都是对象，则返回第二个对象</li>\n<li>两个中有一个null，返回null</li>\n<li>两个中有一个NaN，返回NaN</li>\n<li>两个中有一个undefined，返回undefined</li>\n<li>如果两个为undefined、null、NaN中的两个则第一个是什么就返回什么</li>\n<li>&#x26;&#x26;为短路操作符，第一个为false，则第二个永远不会执行，如下</li>\n</ul>\n<h2>逻辑或(||)</h2>\n<ul>\n<li>同样作用与两个值，类型无要求</li>\n<li>两个都是boolean值，则只有两个都是false才返回false，否则返回true</li>\n<li>如果第一个是对象，则返回第一个</li>\n<li>如果第一个是false，则返回第二个</li>\n<li>两个都是对象，返回第一个</li>\n<li>两个都是null，返回null</li>\n<li>两个都是undefined，返回undefined</li>\n<li>两个都是NaN，返回NaN</li>\n<li>||也是短路操作符，第一个为true，则第二个不执行</li>\n</ul>","frontmatter":{"title":"不常用的一元操作符","date":"2020-09-17","tags":["JavaScript回顾"],"categories":"JavaScript"},"fields":{"slug":"/unary-operators/"}}},"pageContext":{"slug":"/unary-operators/"}},"staticQueryHashes":["2566592090"]}