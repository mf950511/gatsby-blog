{"componentChunkName":"component---src-templates-blog-small-jsx","path":"/blog/extends/","result":{"data":{"markdownRemark":{"html":"<h1>继承的实现与原理</h1>\n<h2>继承</h2>\n<ul>\n<li><code>继承</code>是面向对象中的一个特性，与<code>多态</code>，<code>封装</code>称为面向对象的三个基本特征</li>\n<li>使用<code>继承</code>可以使一个对象快速拥有另一个对象的属性与方法，并能够重新定义自己的方法</li>\n<li>\n<p><code>JavaScript</code>中并没有真正的类，所以实现<code>继承</code>可以通过<code>原型链</code>或者通过改变<code>this</code>来实现<code>伪造对象继承</code></p>\n<!--more-->\n</li>\n</ul>\n<h2>ES5中的实现</h2>\n<ul>\n<li><code>es5</code>中的继承实现一般有三种方式</li>\n<li>\n<p>构造继承</p>\n<ul>\n<li>构造继承是在子类的内部调用超类的构造函数，并将<code>this</code>的指向替换为子类</li>\n<li>可以通过<code>bind</code>,<code>apply</code>,<code>bind</code>来实现</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"language-js\">  function Person(name, age) {\n    this.name = name\n    this.age = age\n    this.say = function(){\n      console.log(`我是${this.name},我${this.age}岁了`)\n    }\n  }\n  function Child(name, age){\n    // bind方法\n    Person.bind(this)(name, age)\n    // call方法\n    Person.call(this, name, age)\n\n    // apply方法\n    Person.apply(this, [name, age])\n  }\n  var child = new Child('张三',24)\n  child.say() // 我是张三,我24岁了\n</code></pre>\n<ul>\n<li>上面三种方法都可以实现子类的继承，但是缺点是未共享父类方法，内存浪费</li>\n<li>\n<p>原型链继承</p>\n<ul>\n<li><code>原型链继承</code>其实就是将超类的一个实例作为子类的原型，从而实现子类共享父类属性与方法</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"language-js\">  function Person1(name, age){\n    this.name = [name]\n    this.age = age\n    this.rename = function(){\n      this.name.push(name)\n    }\n    this.say = function(){\n      console.log(`我是${this.name},我${this.age}岁了`)\n    }\n  }\n  function Child1(){}\n  Child1.prototype = new Person1('李四', 27)\n  var child = new Child1() \n  child.rename()\n  console.log(child.name) // [\"李四\", \"李四\"]\n  var child1 =  new Child1() \n  console.log(child1.name)   // [\"李四\", \"李四\"]\n</code></pre>\n<ul>\n<li>这里我们也发现在继承的同时我们失去了向超类传递参数的可能</li>\n<li>这里我们实现了两个子类共享了超类的<code>方法</code>，但是却也共享了<code>属性</code>，从而导致实例一调用rename方法则实例二的name属性也会变化</li>\n<li>\n<p>组合继承</p>\n<ul>\n<li><code>组合继承</code>就是将上述两种方法结合到一起，实现的属性继承且不会互相影响，并能向超类传递参数</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"language-js\">  function Person2(name, age){\n    this.name = [name]\n    this.age = age\n    this.rename = function(){\n      this.name.push(name)\n    }\n    this.say = function(){\n      console.log(`我是${this.name},我${this.age}岁了`)\n    }\n  }\n  function Child2(name, age){\n    Person2.call(this, name, age)\n  }\n  Child2.prototype = new Person2()\n  Child2.prototype.constructor = Child2\n  var child = new Child2('王五', 30)\n  child.rename()\n  child.say()  // 我是王五,王五,我30岁了   rename只改变了我自己的实例\n  var child1 = new Child2('孙刘', 40)\n  child1.say() // 并不受另一个实例的影响\n</code></pre>\n<ul>\n<li>这里我们使用<code>Child2.prototype = new Person2()</code>的时候将<code>Child2</code>的原型的构造函数给指向了<code>Person2</code>，他应该指向<code>Child2</code>的</li>\n<li>所以我们添加了<code>Child2.prototype.constructor = Child2</code>来将其指向偏转回来</li>\n<li><code>组合继承</code>相对来说比较优秀，但是<code>超类</code>构造函数被调用两次，子类实例的属性存在两份，造成内存浪费</li>\n<li>\n<p>寄生继承</p>\n<ul>\n<li>寄生继承就是利用<code>Object.create</code>方法来取得超类的<code>原型对象</code>并构造成为子类的<code>原型</code>，从而实现子类继承父类属性与方法</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"language-js\">  function Person3(name, age){\n    this.name = [name]\n    this.age = age\n    this.say = function(){\n      console.log(`我是${this.name},我${this.age}岁了`)\n    }\n  }\n  Person3.prototype.rename = function(name){\n    this.name.push(name)\n  }\n  function Child3(name, age){\n    Person3.call(this, name, age)\n  }\n  Child3.prototype = Object.create(Person3.prototype)\n  var child1 = new Child3('刘琦', 34)\n  child1.rename('小孩')\n  child1.say() // 我是刘琦,小孩,我34岁了\n  var child2 = new Child3('王八', 35)\n  child2.rename('大人')\n  child2.say() // 我是王八,大人,我35岁了\n</code></pre>\n<ul>\n<li><code>Person3.prototype</code>其实可以看作<code>Person3</code>的一个实例，这里我们使用<code>Object.create</code>创建了一个原型对象为<code>Person3.prototype</code>的对象作为<code>Child3</code>的原型对象</li>\n<li>从而实现<code>Person3</code>的实例共享同一属性与方法</li>\n</ul>\n<h2>ES6中的继承</h2>\n<ul>\n<li>\n<p>ES6中我们可以通过extends来实现继承</p>\n<pre><code class=\"language-js\">class Person {\nconstructor(name, age){\n  this.name = name\n  this.age = age\n}\nsay(){\n  console.log(`我是${this.name},我${this.age}岁了`)\n}\n}\nclass Child extends Person {\nconstructor(name, age){\n  super(name, age)\n}\n}\nvar child = new Child('张三', 18)\nchild.say() // 我是张三,我18岁了\n</code></pre>\n</li>\n<li><code>ES6</code>中的继承就跟传统语言中的一样了，只需要定义方法与私有方法即可</li>\n</ul>","frontmatter":{"title":"JavaScript中的继承","date":"2019-03-21","tags":["JavaScript","进修","ES2015"],"categories":"JavaScript"},"fields":{"slug":"/extends/"}}},"pageContext":{"slug":"/extends/"}},"staticQueryHashes":["2566592090"]}