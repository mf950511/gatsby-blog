{"componentChunkName":"component---src-pages-index-js","path":"/","result":{"data":{"allMarkdownRemark":{"totalCount":63,"edges":[{"node":{"html":"<h1>字符串排列 (No repeats please)</h1>\n<h2>题目链接</h2>\n<ul>\n<li><a href=\"https://freecodecamp.cn/challenges/no-repeats-please\">中文链接</a></li>\n<li><a href=\"https://freecodecamp.com/challenges/no-repeats-please\">英文链接</a></li>\n</ul>\n<h2>问题解释</h2>\n<ul>\n<li>这个 <code>function</code> 接收一个字符串参数 <code>str</code>。返回值为参数 <code>str</code> 没有连续重复字符串的排列个数</li>\n<li>如果 <code>str</code> 为 <code>\"aab\"</code>，则返回值应为 <code>2</code>，因为全排列后，会出现两个 <code>\"aba\"</code>，不含连续重复字符串 (排除 <code>\"aab\"</code> 和 <code>\"baa\"</code>)</li>\n</ul>\n<!--more-->\n<h1>解题思路</h1>\n<ul>\n<li>这道题应该是高级算法题目中难度稍大的一道题。题目的难点在于获取字符串的全排列。我觉得这里有必要先说一下，如何获取全排列</li>\n<li>只要我们可以获取字符串的全排列，那就至少有两种方式判断字符串是否含有连续重复的字符。可以遍历，也可以用正则</li>\n<li><a href=\"https://zh.wikipedia.org/wiki/%E7%BD%AE%E6%8F%9B\">排列 (也叫置换)，Permutation</a> 与 <a href=\"https://zh.wikipedia.org/wiki/%E7%B5%84%E5%90%88\">组合，Combination</a>，高中数学就已经涉及到。比如，对于 <code>123</code>，从中取出两个数有三种组合，分别是 <code>12</code>、<code>13</code> 和 <code>23</code>。同样是取出两个数，有六种排列，分别是 <code>12</code>、<code>21</code>、<code>13</code>、<code>31</code>、<code>23</code> 和 <code>32</code></li>\n<li>再说一下什么是全排列 (Full Permutation)，全排列的意思是，从 <code>n</code> 个中取出 <code>n</code> 个的排列。对于 <code>123</code>，取出三个数的排列，就是 <code>123</code> 的全排列。<code>123</code> 的全排列总共有六种，分别是 <code>123</code>、<code>132</code>、<code>213</code>、<code>231</code>、<code>312</code> 和 <code>321</code>。计算数量方式很简单，就是 <code>n!</code>，<code>n</code> 的阶乘。对于 <code>123</code> 来说，也就是 <code>3!</code>，得 <code>6</code></li>\n</ul>\n<h2>全排列的实现 - 封装，循环</h2>\n<ul>\n<li>\n<p>我们可以先根据这个实际的例子想想，怎样才能无遗漏的输出全排列</p>\n<ul>\n<li>两个数就不用说了，对于 <code>12</code>，只有 <code>12</code> 和 <code>21</code> 两种</li>\n<li>\n<p>三个数，比如 <code>123</code>，我们先分为三种情况，就是 <code>1</code> 开头，<code>2</code> 开头和 <code>3</code> 开头</p>\n<ul>\n<li>对于 <code>1</code> 开头的情况，剩下 <code>2</code> 和 <code>3</code>，这就回到了两个数的排列</li>\n<li>对于 <code>2</code> 开头的情况，剩下 <code>1</code> 和 <code>3</code>，这也回到了两个数的排列</li>\n<li><code>3</code> 开头的情况同理</li>\n</ul>\n</li>\n<li>四个数，先按照开头分为四种情况，然后按照三个数的排列去处理</li>\n<li>......</li>\n<li>以此类推</li>\n</ul>\n</li>\n<li>你可能已经看出来了，这就是一个递归。就好像求斐波那契数列的某一个元素，我们要先求出前面的；要想求出前面的，我们就要求出更前面的。记 \"斐波那契数列的第 <code>n</code> 位\" 这件事为 <code>F(n)</code>，则有 <code>F(n) = F(n - 1) + F(n - 2)</code></li>\n<li>类似地，记 \"求出 <code>n</code> 个字符串的全排列\" 这件事为 <code>P(n)</code>，则有 <code>P(n) = 分别以这n个字符之一开头 + P(n - 1)</code>。其中，<code>P(n - 1)</code> 表示去掉那个开头字符的剩余字符串的全排列。哪怕只有两个字符，比如对于上面例子中的 <code>12</code>，同样符合这一条结论</li>\n<li>以 <code>'abc'</code> 为例，执行步骤如下：</li>\n</ul>\n<pre><code>给出 abc\n\n1. a 作为开头 -> 求 bc 全排列 -> 得到 bc 和 cb -> 与 a 合并 -> 得到 abc 和 acb\n2. b 作为开头 -> 求 ac 全排列 -> 得到 ac 和 ca -> 与 b 合并 -> 得到 bac 和 bca\n3. c 作为开头 -> 求 ab 全排列 -> 得到 ab 和 ba -> 与 c 合并 -> 得到 cab 和 cba\n</code></pre>\n<ul>\n<li>注意，这只是其中一种实现方式。后面我们还会看到另一种实现</li>\n<li>首先我们来想一下公共逻辑是什么。对于一个字符串，我们取出一个字符作为开头，然后对去掉这个开头字符的剩余字符串继续求全排列。求出来之后，与取到的字符合并起来就行</li>\n<li>对于 <code>P(n)</code> 来说，我们要取出一个字符作为开头，而且原始的字符串可能本身就含有重复的字符。在代码中，我们可以通过开头字符在原字符串中的索引来区分</li>\n<li>对于我们封装的函数，可以直接使用字符串作为参数。这是因为，在获取剩余字符串全排列，即 <code>P(n - 1)</code> 时，我们并不关心去掉的那个，用作开头的字符是什么，只需要关心现在我们要生成谁的全排列就好</li>\n<li>因此，我们需要在递归调用时，传入去掉那个用作开头的字符之后的，剩余字符串。这个很容易实现，如果我们知道了去掉的那个字符的索引，那我们就可以用 <code>str.slice(0, i)</code> 来获取这个字符之前的字符串，用 <code>str.slice(i + 1, str.length)</code> 来获取这个字符之后的字符串 (注意，<code>slice</code> 方法的第一个参数是包含的，第二个不包含。如果 <code>i</code> 本身就是 <code>0</code>，那么取到的是 <strong>空字符串</strong>)，拼接在一起就可以作为递归调用的参数</li>\n<li>跳出条件也不难想，只要传入的参数长度为 <code>1</code> 或 <code>0</code>，直接返回即可</li>\n<li>另外，每次调用，我们都需要一个数组来保存根据当前参数生成的全排列。代码如下</li>\n</ul>\n<pre><code class=\"language-js\">function permAlone(string) {\n    function _perm(str) {\n        // 跳出条件\n        if (str.length &#x3C; 2) return str;\n        var permutations = [];\n\n        for (var i = 0; i &#x3C; str.length; i++) {\n            // 获取开头的字符串和剩余字符串\n            var start = str[i];\n            var remaining = str.slice(0, i) + str.slice(i + 1, str.length);\n\n            // 根据通过剩余字符串的全排列，生成前一次的全排列。注意 _perm(remaining) 是一个数组\n            for (var permutation of _perm(remaining)) {\n                permutations.push(start + permutation);\n            }\n        }\n        return permutations;\n    }\n}\n</code></pre>\n<h2>判断连续重复字符</h2>\n<h3>遍历</h3>\n<ul>\n<li>判断是否有连续重复的字符，最简单的方式是遍历。只需要在外面用一个变量记录上一个字符就可以</li>\n<li>只要当前的和上一个相同，直接跳出就可以，不需要继续判断。代码如下：</li>\n</ul>\n<pre><code class=\"language-js\">function hasRepeatChar(str) {\n    var previous = '';\n    for (var i = 0; i &#x3C; str.length; i++) {\n        if (previous === str[i]) {\n            return true;\n        } else {\n            // 赋值，用于下次判断\n            previous = str[i];\n        }\n    }\n    // 不存在连续重复字符\n    return false;\n}\n</code></pre>\n<h3>递归</h3>\n<ul>\n<li>递归也是很容易写的。跟上面的思路一样，调用的时候传入两个参数，分别是上一个字符，和剩余字符串。其中，剩余字符串可以通过 <code>str.slice(1)</code> 获取</li>\n<li>为避免 <code>str</code> 本身就是空字符串，需要多一次判断，即如果 <code>prevChar</code> 不是空的 (这说明 <code>prevChar</code> 被赋过值，而并非初始的空值)，我们才可以认为 <code>str</code> 不含连续重复字符，则返回 <code>false</code>。因此，跳出条件是 <code>str</code> 为空且 <code>prevChar</code> 有值。如果这时候 <code>prevChar</code> 也是空的，那就证明传入的 <code>str</code> 本身就是空的。为了防止混淆，我们直接给它返回 <code>\"Empty string\"</code>。事实上，这种 corner case 在这道题目中不会遇到。代码如下：</li>\n</ul>\n<pre><code class=\"language-js\">function hasRepeatChar(str, prevChar) {\n    if (str.length === 0) return prevChar ? false : 'Empty string';\n    if (prevChar === str[0]) return true;\n\n    return hasRepeatChar(str.slice(1), str[0]);\n}\n</code></pre>\n<h3>正则表达式</h3>\n<ul>\n<li>正则是个好东西。在正则里，有一中写法叫做 <code>back reference</code>，就是 <code>\\\\</code> 后面加一个正整数。请参考 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions\">文档</a> 中 <code>\\\\n</code> 的那一行</li>\n<li>简单来说，<code>\\\\x</code> 就是匹配之前，正数第 <code>x</code> 个 matched group (匹配组，也叫捕获组，其实就是小括号包含的内容)</li>\n<li>对于判断一个字符串是否含有连续重复字符，我们并不关注它重复了几次，也不需要关注它有几组重复的。因此，这里不需要 <code>global</code> flag <code>/g</code></li>\n<li>那么，对于字符串中的任意字符，只要这个字符右边的字符和它相同，那就匹配到，并且返回 <code>false</code>。听起来像是句废话，只是，如果你看不懂后面的正则，记得回来再读读这句话。代码如下：</li>\n</ul>\n<pre><code class=\"language-js\">function hasRepeatChar(str) {\n    return !/(\\w)\\1/.test(str);\n}\n</code></pre>\n<h1>基本解法</h1>\n<h2>思路提示</h2>\n<ul>\n<li>思路上面已经说得很清楚。通过上面的递归调用，我们可以得到了一个包含字符串全排列的数组，只需要通过上面的正则过滤一下，保留不含连续重复字符的字符串，并返回它的 <code>length</code></li>\n</ul>\n<h2>代码</h2>\n<pre><code class=\"language-js\">function permAlone(string) {\n    function _perm(str) {\n        if (str.length &#x3C; 2) return str;\n        var permutations = [];\n\n        for (var i = 0; i &#x3C; str.length; i++) {\n            var start = str[i];\n            var remaining = str.slice(0, i) + str.slice(i + 1, str.length);\n\n            for (var permutation of _perm(remaining)) {\n                permutations.push(start + permutation);\n            }\n        }\n        return permutations;\n    }\n    return _perm(string).filter(function(str) {\n        return !/(\\w)\\1/.test(str);\n    }).length;\n}\n</code></pre>\n<h1>数组方法 - 思路的优化</h1>\n<h2>思路提示</h2>\n<ul>\n<li>上面的方式是把子问题 (剩余字符串的全排列) 添加到之前取出的开头字符后面，这也就意味着，对于长度为 <code>n</code> 的字符串 <code>string</code>，开头的字符我们要获取 <code>n</code> 次。每一次取了开头，我们又要再对子问题进行 <code>n - 1</code> 次取开头的操作，因此这时候的时间复杂度会是 <code>n!</code>。效率很低</li>\n<li>如果我们换一个思路，采用 \"插值\" 的方法，会让整体操作变少一些。注意，这个思路并不一定需要用数组去实现。确切的说，如果不用数组去实现，效率会更高。只是个人觉得，用数组会比较容易写，也比较容易理解</li>\n<li>之前的方式，如果我们说它是 \"从前往后\" 实现的，那现在我们来试试从后往前实现</li>\n<li>对于字符串 <code>'abc'</code>，给出子串 <code>'bc'</code>，剩余 <code>'a'</code>。我们可以通过把 <code>'a'</code> 放到 <code>'bc'</code> 里面，不同的位置来实现排列。注意到 <code>'bc'</code> 有三个位置可以插入 <code>'a'</code>，分别是：</li>\n</ul>\n<pre><code> b c\n↑ ↑ ↑\n1 2 3\n</code></pre>\n<ul>\n<li>如果把 <code>'a'</code> 分别插入上面说的位置 <code>1</code>、<code>2</code> 和 <code>3</code>，我们就可以得到 <code>'abc'</code>、<code>'bac'</code> 和 <code>'bca</code></li>\n<li><code>'bc'</code> 排列还有一种情况 <code>'cb'</code>。再把 <code>'a'</code> 插入到 <code>'cb'</code> 的三个位置，我们就可以得到另外三种排列</li>\n<li>注意到，<code>'bc'</code> 和 <code>'cb'</code>，其实就是在子串 <code>'c'</code> 中插入 <code>'b'</code> 产生的。因为 <code>'c'</code> 只有两个位置可以插入 <code>'b'</code>：</li>\n</ul>\n<pre><code> c\n↑ ↑\n1 2\n</code></pre>\n<ul>\n<li>这样，我们就得到了一个新的递归思路，如下 (左边的竖线只是为了方便看清递归弹出的时候对应上面的哪一步，弹出步骤中的插入值与上面取出的第一个字符相对应)：</li>\n</ul>\n<pre><code>给出 'abc'\n\n|- 取出第一个字符 a，剩余 bc\n|  |- 取出第一个字符 b，剩余 c\n|  |  |- 取出第一个字符 c，剩余空字符串 (划重点，这个就是弹出的条件)\n|  |  |- 在上次剩余值中插入 c，只能得到一种情况 c\n|  |- 在上次剩余值 (c) 中插入 b，得到 bc 和 cb\n|- 在上次剩余值 (bc 和 cb) 中插入 a，得到 abc, bac, bca 和 acb, cab, cba\n</code></pre>\n<ul>\n<li>这个思路很像是，先一直走到底 (即长度为 0 的时候)，弹出的过程中，我们再来生成需要的结果</li>\n<li>这段代码加注释不太方便，详细解释还是写到代码之后吧</li>\n<li>如果你还是不知道如何写代码，不要怕麻烦，试着写出来 <code>'abcd'</code> 的详细过程，写完你就能理解了</li>\n</ul>\n<h2>代码</h2>\n<pre><code class=\"language-js\">function permAlone(string) {\n    return _perm(string.split('')).filter(function(str) {\n        return !/(\\w)\\1/.test(str);\n    }).length;\n\n    function _perm(arr) {\n        return arr.length === 0 ? [[]] : _perm(arr.slice(1)).reduce(function(accum, curr) {\n            // 插值的实现\n            for (var i = 0; i &#x3C; arr.length; i++) {\n                accum.push([curr.slice(0, i), arr[0], curr.slice(i)].join(''));\n            }\n            return accum;\n        }, []);\n    }\n}\n</code></pre>\n<h2>解释</h2>\n<ul>\n<li>先说一句，上面的代码，尽管思路优化了，但速度理论上会比之前的慢，因为咱们用了数组</li>\n<li>外面那层应该没啥疑问，既然决定了用数组去处理，那就干脆直接传入数组，一个 <code>split</code> 的事儿而已</li>\n<li>封装的 <code>_perm</code>，其实还是要进行递归调用的。当外面的 <code>string</code> 是空字符串时，返回值是 <code>[[]]</code>，而不可以是 <code>[]</code>。原因很简单，如果是 <code>[]</code>，那么 <code>reduce</code> 就不会执行了，因为没有元素。你可以试试以下的代码片段，就理解了：</li>\n</ul>\n<pre><code class=\"language-js\">// 不会输出 '执行了'，返回值是 []\n[].reduce((accum, curr) => {\n    console.log('执行了');\n    return accum;\n}, []);\n\n// 会输出 '执行了'，返回值也是 []\n[[]].reduce((accum, curr) => {\n    console.log('执行了');\n    return accum;\n}, []);\n</code></pre>\n<ul>\n<li>只要 <code>arr</code> 长度不为 <code>0</code>，那我们就递归调用 <code>_perm(arr.slice(1))</code>，直到遇到传入的 <code>arr</code> 长度为 <code>0</code>，才开始执行 <code>reduce</code> 弹出的过程。详情请看上面的思路分析</li>\n<li>里面的 <code>for</code> 循环很重要，\"插值\" 这个核心步骤就是在这里实现的。如果看不懂这个过程，请去了解一下 <code>slice</code> 方法是怎么回事，然后举几个例子带进去试一试就明白了</li>\n</ul>\n<h1>算法优化 - Heap's algorithm</h1>\n<h2>思路提示</h2>\n<ul>\n<li>注意，这里的 Heap 不是指数据结构的 \"堆\"，而是发明者的名字。如果你从来没听说过这个算法，那只靠自己想可能有些困难</li>\n<li>\n<p>给出字符串 <code>'abc'</code>，我们可以按照先确定结尾字符的思路来这样推一下：</p>\n<ul>\n<li>\n<p><code>'c'</code> 作为结尾：</p>\n<ul>\n<li>我们得到第一个排列 <code>'abc'</code></li>\n<li>通过交换 <code>'a'</code> 和 <code>'b'</code>，我们可以得到另一种排列 <code>'bac'</code></li>\n</ul>\n</li>\n<li>\n<p>交换开头结尾，这时候 <code>'b'</code> 作为结尾：</p>\n<ul>\n<li>得到 <code>'cab'</code></li>\n<li>通过交换 <code>'c'</code> 和 <code>'a'</code>，得到 <code>'acb'</code></li>\n</ul>\n</li>\n<li>\n<p>交换开头结尾，这时候 <code>'a'</code> 作为结尾：</p>\n<ul>\n<li>得到 <code>'bca'</code></li>\n<li>通过交换 <code>'b'</code> 和 <code>'c'</code>，得到 <code>'cba'</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>思路大致上是这样，通过交换去实现。交换的好处在于，我们不需要额外的空间去存储。值得注意的是，在 JavaScript 中，字符串可以通过 index 访问某一个位置的字符，但不可以修改它的值。因此，想要换位，我们还是要通过数组来实现的</li>\n<li>事实上，真正实现起来还与上面的例子有区别。在 <code>Heap's Algorithm</code> 的 <a href=\"https://en.wikipedia.org/wiki/Heap%27s_algorithm\">维基百科页面</a> 有详细的解释，也有四个元素的详细步骤示例。其实，并不是 \"交换开头结尾\" 这么简单的</li>\n<li>实现数组中元素交换的方式也非常多。有朋友可能首先想到的是用 <code>splice</code>，但这样做效率会很低，我会比较推荐用变量缓存一个值的做法，很容易写。比如，我们需要交换 index 为 <code>2</code> 和 <code>4</code> 的元素：</li>\n</ul>\n<pre><code class=\"language-js\">var arr = [1, 2, 3, 4, 5, 6];\n\nvar temp = arr[2];\narr[2] = arr[4];\narr[4] = temp;\n\nconsole.log(arr);  // [1, 2, 5, 4, 3, 6]\n</code></pre>\n<ul>\n<li>当然，还有一种比较好玩儿的黑科技：</li>\n</ul>\n<pre><code class=\"language-js\">var arr = [1, 2, 3, 4, 5, 6];\narr[2] = [arr[4], arr[4] = arr[2]][0]\n\nconsole.log(arr);  // [1, 2, 5, 4, 3, 6]\n</code></pre>\n<ul>\n<li>如果你听说过 ES6 的解构赋值，也可以这么写。注意这个在不支持 ES6 的浏览器里是不行的：</li>\n</ul>\n<pre><code class=\"language-js\">var arr = [1, 2, 3, 4, 5, 6];\n[arr[2], arr[4]] = [arr[4], arr[2]]\n\nconsole.log(arr);  // [1, 2, 5, 4, 3, 6]\n</code></pre>\n<ul>\n<li>维基百科页面也提供了伪代码，而且提供了递归和非递归的两个版本。两个版本都用到了两个参数，但我们只需要一个 <code>n</code> 就够了，不需要第二个 <code>A</code>，因为我们的数组可以通过 <code>var arr = str.split('');</code> 将它定义到函数 <code>generate</code> 外面。这样，伪代码如下：</li>\n</ul>\n<pre><code class=\"language-js\">函数 generate\n参数 num\n\n如果 num 等于 1:\n    arr.join('')，并添加到结果数组\n否则:\n    循环，0 至 num:\n        递归调用 generate(num - 1)\n        如果 num 为偶数:\n            交换 strArr[i] 与 strArr[num - 1]\n        如果 num 为奇数:\n            交换 strArr[0] 与 strArr[num - 1]\n</code></pre>\n<h2>代码</h2>\n<pre><code class=\"language-js\">function permAlone(str) {\n    var arr = str.split('');\n    var result = [];\n    // 声明需要放在这里，因为赋值是在弹出的时候执行的\n    var tempIndex;\n\n    function generate(num) {\n        if (num === 1) {\n            result.push(arr.join(''));\n        } else {\n            for (var i = 0; i &#x3C; num; i++) {\n                generate(num - 1);\n                tempIndex = num % 2 ? 0 : i;\n                arr[tempIndex] = [arr[num - 1], arr[num - 1] = arr[tempIndex]][0];\n            }\n        }\n    }\n    \n    generate(arr.length);\n    \n    return result.filter(function(str) {\n        return !/(\\w)\\1/.test(str);\n    }).length;\n}\n</code></pre>","fields":{"slug":"/advanced-no-repeats-please/"},"frontmatter":{"title":"FreeCodeCamp 高级算法题 - 字符串排列","tags":["FreeCodeCamp","高级","算法"],"categories":"FCC"}}},{"node":{"html":"<h1>类型</h1>\n<h2>内置类型</h2>\n<ul>\n<li>内置类型有哪些？如何校验？</li>\n<li>特殊类型有哪些？注意事项是？</li>\n</ul>\n<h2>问题解释</h2>\n<ul>\n<li>内置类型为空值<code>(null)</code>，未定义<code>(undefined)</code>，布尔值<code>(boolean)</code>，数字<code>(number)</code>，字符串<code>(string)</code>，对象<code>(object)</code>，符号<code>(symbol,ES6新增)</code></li>\n<li>\n<p>特殊类型为空值(特殊对象)，数组(特殊对象)，函数(特殊对象)</p>\n<!--more-->\n</li>\n<li>类型校验</li>\n</ul>\n<pre><code class=\"language-js\">typeof undefined === 'undefined' //true\ntypeof true === 'boolean' //true\ntypeof 42 === 'number' //true\ntypeof '42' === 'string' //true\ntypeof {a:2} === 'object' //true\ntypeof Symbol() === 'symbol' //true\n// 特殊情况\ntypeof null === 'object' //true\ntypeof [1,2,3] === 'object' //true\ntypeof function(){} === 'function' // true\n</code></pre>\n<h2>校验方式</h2>\n<ul>\n<li>校验null (!a &#x26;&#x26; typeof a ==='object') //true</li>\n<li>校验数组 arr.constructor === Array 或 arr instanceof Array</li>\n</ul>\n<h2>数组</h2>\n<ul>\n<li>数组可以容纳任何类型的值，无需设定大小</li>\n<li>delete运算符可以将单元从数组中删除，但，删除后，数组length属性不会发生变化</li>\n<li>数组通过数组进行索引，但因为它是对象的本质，所以也可以包含字符串键值与属性<code>(但并不计算在数组长度内)</code></li>\n</ul>\n<pre><code class=\"language-js\">    var a = []\n    a[0] = 1\n    a['foo'] = 2\n    a.length; // 1\n    a['foo']; // 2\n    a.foo;    // 2\n</code></pre>\n<ul>\n<li>注意点：若字符串键值能强制转换为数字的话，会被当作数字索引来处理</li>\n</ul>\n<pre><code class=\"language-js\">      var a = []\n      a['13'] = 42\n      a.length; // 14\n</code></pre>\n<ul>\n<li>Array.from()可将类数组对象转为数组对象，例（arguments,dom列表）</li>\n</ul>\n<h2>字符串与字符串数组</h2>\n<ul>\n<li>都具有<code>length</code>属性与<code>indexOf</code>方法和<code>concat</code>方法</li>\n</ul>\n<pre><code class=\"language-js\">    var a = 'foo'\n    var b = ['f','o','o']\n\n    a.length; // 3\n    b.length; //3\n\n    a.indexOf('o') // 1\n    b.indexOf('o') // 1\n    var c = a.concat('bar') //foobar\n    var d = b.concat(['b', 'a', 'r']) // ['f', 'o', 'o', 'b', 'a', 'r']\n</code></pre>\n<ul>\n<li>字符串没有数组函数，但可以借用数组的非变更方法来处理</li>\n</ul>\n<pre><code class=\"language-js\">    var c = Array.prototype.join.call(a, '-')\n    var d = Array.prototype.map.call(a, function(v) {\n      return v.toUpperCase() + '.'\n    }).join(\"\")\n    c; //\"f-o-o\"\n    d: //\"f.o.o\"\n</code></pre>\n<ul>\n<li>不可借用数组的可变成员函数reverse,因为字符串是不可变的<code>Array.prototype.reserve.call(a)</code>无效</li>\n<li>处理方法：</li>\n</ul>\n<pre><code class=\"language-js\">    var c = a.split(\"\").reverse().join(\"\")\n</code></pre>\n<h2>数字</h2>\n<ul>\n<li>检测是否是整数 <code>Number.isInteger()</code></li>\n<li>检测是狗是安全整数 <code>Number.isSafeInteger()</code></li>\n<li>检测是否是NaN <code>Number.isNaN()</code></li>\n<li>检测两个值是否绝对相等 <code>Object.is(a, b)</code></li>\n</ul>\n<h2>奇特的小技巧</h2>\n<ul>\n<li>~运算符可将结果强制类型转换为真值/假值</li>\n</ul>\n<pre><code class=\"language-js\">    var a = \"Hello world\"\n    if(~a.indexOf('lo')) { // true\n      // 找到匹配\n    }\n    // 相应的 !~a.indexOf('lo')为未找到匹配\n</code></pre>","fields":{"slug":"/type/"},"frontmatter":{"title":"你不知道的javascript-类型","tags":["JavaScript","入门"],"categories":"JavaScript"}}},{"node":{"html":"<h1>TCP协议的3次握手与4次分手</h1>\n<h2>TCP协议的连接与断开</h2>\n<ul>\n<li>什么是<code>TCP</code>协议的<code>三次握手</code>？为什么会有<code>三次握手</code>？</li>\n<li>什么是<code>TCP</code>协议的四次分手？为什么会有四次分手？</li>\n</ul>\n<h2>问题解释</h2>\n<ul>\n<li>TCP的<code>三次握手</code>其实是在<code>客户端</code>与<code>服务端</code>建立一个TCP连接，在<code>TCP/IP</code>协议中，采用三次握手可建立可靠的连接服务</li>\n<li>TCP的<code>四次分手</code>用来断开客户端与服务端的连接</li>\n</ul>\n<!--more-->\n<h2>详解</h2>\n<h3>TCP报文重要字段解释</h3>\n<ul>\n<li>序号：<code>seq</code>序号，标识从TCP源向目的端发送字节流，并由发送端对其标记</li>\n<li>确认序号：<code>ack</code>序号，只有<code>ACK</code>标志位为1时确认序号字段才有效，<code>ack=seq+1</code>（注意：<code>ack</code>序号与<code>ACK</code>标志位不是同一个东西）</li>\n<li>注意：确认放<code>ack</code>=发起方<code>req+1</code>时两者配对成功</li>\n<li>\n<p>标志位：共六个，即<code>URG</code>,<code>ACK</code>,<code>PSH</code>,<code>RST</code>,<code>SYN</code>,<code>FIN</code></p>\n<ul>\n<li><code>ACK</code>:确认序号有效</li>\n<li><code>PSH</code>:接收方尽快将报文提交应用层</li>\n<li><code>RST</code>:连接重置</li>\n<li><code>URG</code>:紧急指针有效</li>\n<li><code>SYN</code>:发起一个新连接</li>\n<li><code>FIN</code>:释放一个链接</li>\n</ul>\n</li>\n</ul>\n<h3>三次握手</h3>\n<ul>\n<li>\n<p>三次握手是为了在客户端与服务端建立可靠安全的连接服务，所以需要三次握手确认</p>\n<ul>\n<li>第一次：客户端将标志位<code>SYN</code>设置为<code>1</code>，产生一个随机值<code>seq=J</code>并将其发送给server,等待server确认，自己进入<code>SYN_SENT</code>状态（我要跟你连接了，你看看你听得到吗）</li>\n<li>第二次：server收到数据包由<code>SYN=1</code>知道客户端建立请求，server将标志位<code>SYN</code>与<code>ACK</code>都设置为1，随机产生一个值<code>seq=K</code>，并将该数据发回客户端确认连接请求，server进入<code>SYN_RCVD</code>状态（我听到了，你看看你听得到我吗）</li>\n<li>第三次：客户端收到确认后检查<code>ack</code>是否为<code>J+1</code>,<code>ACK</code>是否为<code>1</code>，如果正确则将标志位<code>ACK</code>设置为<code>1</code>，<code>ack=K+1</code>,并将数据包发给server，server检查<code>ack</code>是否为<code>K+1</code>,<code>ACK</code>是否为<code>1</code>，如果正确则连接建立成功，客户端与服务端进入<code>ESTABLISHED</code>状态，完成三次握手，此后客户端与服务端即可开始传输数据了（我也能听到了，咱们来交流吧）</li>\n</ul>\n</li>\n</ul>\n<h3>四次分手</h3>\n<ul>\n<li>\n<p>当我们用三次握手建立连接后数据传输完成要断开TCP链接啊，所以就有了四次分手</p>\n<ul>\n<li>由于TCP连接是双全工的，每个方向都需要单独关闭，当一方发送数据完成后需要发送一个<code>FIN</code>来终止这一方向连接，收到FIN只是表示对方不会有数据流动了，但是接收方依然可以发送数据，直到接收方也发送了<code>FIN</code></li>\n<li>第一次：客户端发送一个FIN，用来关闭客户端到服务端的数据传输，客户端进入<code>FIN_WAIT_1</code>状态（我没有要说的了，我想关闭连接了）</li>\n<li>第二次：服务端收到<code>FIN</code>后，发送一个<code>ACK</code>给客户端，确认序号为收到序号+1，服务端进入<code>CLOSE_WAIT</code>状态（我知道你不想说了，我不确定我还有没有要说的）</li>\n<li>第三次：服务端向客户端发送一个<code>FIN</code>，用来关闭服务端到客户端的数据传输，服务端进入<code>LAST_ACK</code>状态（我也没有要说的了，咱关闭连接吧）</li>\n<li>第四次：客户端收到<code>FIN</code>后，客户端进入<code>TIME_WAIT</code>状态，接着发送一个<code>ACK</code>给服务端，确认序号为收到序号+1，服务端进入<code>CLOSED</code>状态，完成四次分手（好的，我知道了，咱关闭吧，你听不到我的声音就说明关闭了）</li>\n</ul>\n</li>\n<li>\n<p>为什么建立连接是三次而分手要四次呐？</p>\n<ul>\n<li>因为服务端在<code>LISTEN</code>状态下，收到建立请求的<code>SYN</code>报文后，把<code>ACK</code>与<code>SYN</code>都放在一个报文里发给了客户端。关闭连接时当收到对方的<code>FIn</code>报文仅仅表示对方不再发数据了，但还能接数据，自己也未必把所有数据发送给对方了，所以己方可以立即关闭也可以发送数据后再发送<code>FIn</code>报文给对方同意现在关闭，因此<code>ACK</code>与<code>FIN</code>都会分开发送</li>\n</ul>\n</li>\n</ul>","fields":{"slug":"/TCP-IP-ThreeHandShake/"},"frontmatter":{"title":"HTTP与TCP/IP了解","tags":["HTTP","TCP/IP"],"categories":"HTTP"}}},{"node":{"html":"<h1>call,apply,bind详解</h1>\n<h2>call,apply,bind的使用</h2>\n<ul>\n<li>call,apply,bind的作用是什么？用法是什么？</li>\n<li>call,apply,bind之间有什么联系？区别是什么？</li>\n</ul>\n<h2>问题详解</h2>\n<ul>\n<li>功能上，call，apply，bind都可以用来改变函数内部this的指向</li>\n<li>用法上，三者都是函数调用对应的call,apply,bind方法，传入不同的参数实现函数内部this指向改变</li>\n</ul>\n<!--more-->\n<h2>apply与call</h2>\n<ul>\n<li><code>call</code>与<code>apply</code>在功能上是完全一致的，都是为了改变函数运行的上下文，即this的指向</li>\n<li>用法上，<code>apply</code>接受两个参数，第一个是重新定义的this对象，第二个则是想要传递给函数的参数列表的集合，是一个数组</li>\n<li><code>call</code>接受多个参数，第一个参数为重新定义的this对象，第二个及以后的各个参数即为传递给函数的参数列表</li>\n<li>综上，当函数的参数数量确定的情况下，可以使用<code>call</code>，当函数参数数量不确定的情况下应该使用<code>apply</code>,可以将参数push进数组，然后将数组作为第二个参数，或者可以在函数内部通过<code>arguments</code>来获取所有参数列表</li>\n</ul>\n<h2>apply与call妙用</h2>\n<ul>\n<li>当我们一个对象没有某个方法，但是别的对象有的情况下我们就可以使用call或者apply来“借用”别的对象的方法，例：</li>\n</ul>\n<pre><code class=\"language-js\">  \nvar apple = {\n  color: 'red',\n  say: function(){\n    console.log(this.color)\n  }\n}\nvar banana = {\n  color: 'yellow'\n}\napple.say.call(banana) // yellow\n</code></pre>\n<ul>\n<li>这里banana本来是没有say这个方法的，但是apple有这个方法，所以我们暂时借用他的方法来说出自己的颜色</li>\n<li>\n<p>call与apply的常用妙法</p>\n<ul>\n<li>数组之间追加</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"language-js\">  var arr1 = [12,'foo',{a:1}]\n  var arr2 = ['a', 23, {b:2}]\n  Array.prototype.push.apply(arr1, arr2)\n  console.log(arr1) // [ 12, 'foo', { a: 1 }, 'a', 23, { b: 2 } ]\n</code></pre>\n<ul>\n<li>这里利用了<code>apply</code>会将数组分解为各个参数的效果配合数组的push方法，将第二个数组分别添加到第一个数组实现数组的追加</li>\n<li>获取数组的最大值</li>\n</ul>\n<pre><code class=\"language-js\">  var numbers = [13, 14,5,34,-38,56]\n  var maxNumbers = Math.max.apply(Math, numbers)\n  console.log(maxNumbers)\n</code></pre>\n<ul>\n<li>这里数组本身没有max方法，但是Math对象有，所以我们就通过apply将其借用</li>\n<li>伪类数组调用数组方法实现自定义log方法，代理consolelog方法，并在每个打印之前添加一个（app）前缀</li>\n</ul>\n<pre><code class=\"language-js\">  function log(){\n    var args = Array.prototype.slice.apply(arguments)\n    args.unshift('(app)')\n    console.log.apply(console, args) \n  }\n  log(1) // (app) 1\n  log(1,2,3) // (app) 1 2 3\n</code></pre>\n<ul>\n<li>这里的话可能有点难懂，其实实现这个功能我们先是获取到我们需要打印的数据，因为<code>console.log()</code>可以接受多个参数，所以我们采用<code>arguments</code>来获取所有参数，因为要在打印之前添加前缀,其实就是添加一个打印内容，所以我们要在传递给<code>console.log</code>的参数列表里面新增一个，但因为参数列表是一个类数组对象，并没有数组方法，所以我们通过借用数组的slice方法将类数组对象转为数组对象，然后再传递给<code>console.log</code></li>\n</ul>\n<h2>bind方法</h2>\n<ul>\n<li>bind方法其实会创建一个新的函数，称为绑定函数，当调用这个函数的时候，绑定函数会以创建它时传入的第一个参数作为this，第二个及以后的参数按顺序作为原函数的参数来调用原函数</li>\n<li>bind常用用法</li>\n<li>改变系统函数this指向</li>\n</ul>\n<pre><code class=\"language-js\">var foo = {\n  bar: '哈哈',\n  eventBind: function(){\n    setTimeout(function(){\n      console.log(this)\n      console.log(this.bar)\n    }, 20)\n  }\n}\nfoo.eventBind() // window对象   undefined\nvar foo1 = {\n  bar: '哈哈',\n  eventBind: function(){\n    setTimeout(function(){\n      console.log(this)\n      console.log(this.bar)\n    }.bind(this), 20)\n  }\n}\nfoo1.eventBind() // 对象foo1   '哈哈'\n</code></pre>\n<ul>\n<li>这里我们想要的是打印出对象<code>foo</code>与它下面<code>bar</code>的值，但是在<code>setTimeout</code>里面，定时器函数内部的this是指向window对象的，所以<code>this.bar</code>会是一个<code>undefined</code>，所以在这里我们可以使用<code>bind</code>来改变<code>this</code>的指向，当我们在函数后面挂载<code>bind</code>并传递当前<code>this</code>进入时，函数内部的<code>this</code>就被我们偏转回了我们想要的对象<code>foo1</code>,所以正确的输出了我们想要的结果</li>\n<li>那如果我们联系bind会发生什么呐？</li>\n</ul>\n<pre><code class=\"language-js\">  var bar = function(){\n    console.log(this.x)\n  }\n  var foo = {\n    x:3\n  }\n  var sed = {\n    x: 4\n  }\n  var func = bar.bind(foo).bind(sed)\n  func() // ?\n  var fiv = {\n    x: 5\n  }\n  var func1 = bar.bind(foo).bind(sed).bind(fiv)\n  func() // ?\n</code></pre>\n<ul>\n<li>答案其实是两个3，并不是我们想象的4，5原因是在javascript中，多次bind是无效的。</li>\n</ul>\n<h2>apply,call,bind比较</h2>\n<ul>\n<li>看下面代码</li>\n</ul>\n<pre><code class=\"language-js\">  var obj = {\n    x: 81\n  }\n  var foo = {\n    getX: function(){\n      return this.x\n    }\n  }\n  console.log(foo.getX.bind(obj)()) // 81\n  console.log(foo.getX.call(obj)) // 81\n  console.log(foo.getX.apply(obj)) // 81\n</code></pre>\n<ul>\n<li>虽然三个都输出81，但是注意，bind方法之后我们又加了一个括号对其调用，所以这里bind在改变this之后并没有马上执行，而是在执行的时候才使用bind方法，而call与apply则是会立即执行</li>\n</ul>","fields":{"slug":"/call-apply/"},"frontmatter":{"title":"javascript回顾","tags":["JavaScript回顾","回顾","入门"],"categories":"JavaScript"}}},{"node":{"html":"<h1>生成器详解</h1>\n<h2>生成器</h2>\n<ul>\n<li>生成器是什么？为什么会需要生成器？</li>\n</ul>\n<h2>生成器的由来</h2>\n<ul>\n<li>传统异步流程对程序员并不友好，设定回调函数的方式不符合大脑对任务步骤的规划</li>\n<li>生成器就是实现看似同步的异步流程控制</li>\n</ul>\n<!--more-->\n<h1>生成器的奇特之处</h1>\n<h2>打破完整运行</h2>\n<ul>\n<li>传统意义上，<code>javascript</code>函数一旦开始运行，那么在结束之前将没有别的代码可以打断并插入运行</li>\n<li>ES6引入了新的函数类型，并不符合从始到终不可打断的原则，这类新的函数就是生成器</li>\n</ul>\n<pre><code class=\"language-js\">  var x = 1;\n  function foo() {\n    x++\n    bar();\n    console.log( \"x:\", x )\n  }\n  function bar() {\n    x++\n  }\n  foo(); // x: 3 \n</code></pre>\n<ul>\n<li>这里因为<code>bar</code>存在于<code>foo</code>内部，所以可以实现<code>x</code>的改变，那如过在外面调用<code>bar</code>有没有可能改变<code>x</code>的输出呐？</li>\n<li>如果在多线程语言中，这个自然可以通过抢占线程来实现，但javascript是一个单线程的语言。但是，要是我们通过让<code>foo</code>暂停然后先执行<code>bar</code>会怎么样呐？</li>\n<li>下面就是我们用生成器来实现的效果</li>\n</ul>\n<pre><code class=\"language-js\">  var x = 1;\n  function *foo() {\n    x++;\n    yield; // 暂停！\n    console.log( \"x:\", x );\n  }\n  function bar() {\n    x++;\n  } \n  // 构造一个迭代器it来控制这个生成器\n  var it = foo();\n  // 这里启动foo()！\n  it.next();\n  x; // 2\n  bar();\n  x; // 3\n  it.next(); // x: 3\n</code></pre>\n<ul>\n<li><code>it=foo()</code> 运算其实只是生成了一个迭代器，并没有执行生成器（迭代器在下面会介绍）</li>\n<li>第一个<code>it.next()</code>执行了生成器，也就运行了<code>*foo</code>代码里的<code>x++</code>这一句，停在了<code>yield</code></li>\n<li><code>*foo</code>停在了<code>yield</code>这里，第一个<code>it.next</code>调用结束，暂停了<code>foo</code>,此时<code>x</code>值变为<code>2</code></li>\n<li>暂停<code>foo</code>后我们执行了<code>bar</code>函数使<code>x</code>变为<code>3</code></li>\n<li>最后一个<code>it.next</code>将生成器恢复了，使其完成代码块的执行，打印了<code>3</code></li>\n<li>这里我们也能发现，生成器函数与普通函数相比函数名之前会多一个<code>*</code>,并且函数执行过程碰到<code>yield</code>会被暂停</li>\n</ul>\n<h2>输入与输出</h2>\n<ul>\n<li>生成器作为一个函数，除了有新的执行模式，还具备一般函数的基本特性，可接受参数与返回值</li>\n</ul>\n<pre><code class=\"language-js\">function *foo(x,y) {\n  return x * y;\n}\nvar it = foo( 6, 7 ); \nvar res = it.next();\nres.value; // 42 \n</code></pre>\n<ul>\n<li>生成器的传参，返回值与传统函数一致</li>\n<li>注意：这里我们能看到<code>foo(6,7)</code>并没有像普通函数一样执行，是因为这一步只是执行了迭代器的生成并赋值给了it,然后我们才可以对其进行暂停与恢复</li>\n<li><code>it.next</code>是让生成器从当前位置继续运行，直到碰到下一个yield或者生成器代码执行结束</li>\n<li><code>it.next</code>调用的结果是一个对象，有<code>value</code>属性，值为生成器返回的值(如果有的话)</li>\n</ul>\n<h2>迭代器消息传递</h2>\n<ul>\n<li>迭代器除了控制生成器之外，还提供了消息的输入与输出，通过yield与next(..)实现</li>\n</ul>\n<pre><code class=\"language-js\">function *foo(x) {\n  var y = x * (yield);\n  return y;\n}\nvar it = foo( 6 );\n// 启动foo(..)\nit.next();\nvar res = it.next( 7 );\nres.value; // 42 \n</code></pre>\n<ul>\n<li>这里是外部消息的输入，<code>foo</code>函数接受原始参数6，之后执行到了<code>yield</code>这一步暂停，并要求调用代码即<code>it.next</code>为<code>yield</code>提供一个结果值</li>\n<li>第二个<code>it.next</code>作为<code>yield</code>的恢复调用理所当然的需要提供一个值，也就是我们的7</li>\n<li>所以函数内部<code>y = x * (yield)</code> 其实就是<code>y = 6 * 7</code>即<code>42</code></li>\n<li>这里我们要注意，迭代器的<code>next</code>总要比生成器的<code>yield</code>多一个，因为它需要第一个<code>next</code>来启动生成器，其后才是每次遇到<code>yield</code>暂停，<code>next</code>恢复</li>\n</ul>\n<pre><code class=\"language-js\">function *foo(x) {\n  var y = x * (yield \"Hello\"); // &#x3C;-- yield一个值！\n  return y;\n}\nvar it = foo( 6 );\nvar res = it.next(); // 第一个next()，并不传入任何东西\nres.value // \"Hello\"\nres = it.next( 7 ); // 向等待的yield传入7\nres.value; // 42 \n</code></pre>\n<ul>\n<li>这里与上面的改动在于<code>yield</code>之后跟了一个数据'Hello'，它其实是<code>yield</code>传给外面的数据，用来响应<code>next</code>的调用，可以理解为我启动了你要是暂停得给我个解释啊，抛出的一个返回值</li>\n<li>上面也就是我们生成器的消息互通，通过yield与next构成消息的双向传递</li>\n</ul>\n<h1>迭代器</h1>\n<h2>为什么需要迭代器</h2>\n<ul>\n<li>生成器是对函数的暂停与恢复执行，那么在多次暂停时就需要有东西来保存其暂停时的值，而迭代器的作用也就凸现出来了</li>\n<li>迭代器是一个定义良好的接口，可以从一个生产者一步步得到一系列的值</li>\n</ul>\n<pre><code class=\"language-js\">  var something = (function(){\n    var nextVal;\n    return {\n      // for..of循环需要\n      [Symbol.iterator]: function(){ return this; },\n      // 标准迭代器接口方法\n      next: function(){\n        if (nextVal === undefined) {\n          nextVal = 1;\n        }\n        else {\n          nextVal = (3 * nextVal) + 6;\n        }\n        return { done:false, value:nextVal };\n      }\n    };\n  })();\n  something.next().value; // 1\n  something.next().value; // 9\n  something.next().value; // 33\n  something.next().value; // 105 \n</code></pre>\n<ul>\n<li>上面就是一个标准的数字生产迭代器，<code>Symbol.iterator</code>存在的原因是ES6开始要想从一个可迭代对象中提取迭代器，则该对象必须是ES6符号值<code>Symbol.iterator</code>,调用这个函数会返回一个迭代器</li>\n<li>这里我们可以通过<code>next</code>方法返回一个对象，该对象有两个属性值：<code>done</code>为boolean值，标识迭代器的完成状态，<code>value</code>返回迭代值</li>\n</ul>\n<h2>生成器与迭代器</h2>\n<ul>\n<li>上面就是迭代器的作用与简单实现，这里我们就可以知道当我们执行<code>it=foo()</code>这一步时为什么会返回一个迭代器了</li>\n<li>严格来说生成器本身并不是一个<code>iterable(可迭代对象)</code>,但当你执行一个生成器时，就得到了一个迭代器</li>\n</ul>\n<pre><code class=\"language-js\">function *foo(){ .. }\nvar it = foo(); \n</code></pre>\n<ul>\n<li>生成器通过执行返回一个迭代器也就可以实现生成器的无限次暂停与恢复</li>\n</ul>\n<h1>生成器与异步编程模式</h1>\n<h2>生成器与异步回调</h2>\n<ul>\n<li>在传统的异步函数ajax中，我们为了实现异步数据获取通常会使用异步回调的方法，如下</li>\n</ul>\n<pre><code class=\"language-js\">function foo(x,y,cb) {\n  ajax(\n  \"http://some.url.1/?x=\" + x + \"&#x26;y=\" + y,\n  cb\n  );\n}\nfoo( 11, 31, function(err,text) {\n  if (err) {\n    console.error( err );\n  }\n  else {\n    console.log( text );\n  }\n} ); \n</code></pre>\n<ul>\n<li>但是有了生成器之后我们就可以这么实现了</li>\n</ul>\n<pre><code class=\"language-js\">function foo(x,y) {\n  ajax(\n    \"http://some.url.1/?x=\" + x + \"&#x26;y=\" + y,\n    function(err,data){\n      if (err) {\n        // 向*main()抛出一个错误\n        it.throw( err );\n      }\n      else {\n        // 用收到的data恢复*main()\n        it.next( data );\n      }\n    }\n  );\n}\nfunction *main() {\n  try {\n    var text = yield foo( 11, 31 ); \n    console.log( text );\n  }\n  catch (err) {\n    console.error( err );\n  }\n}\nvar it = main();\n// 这里启动！\nit.next(); \n</code></pre>\n<ul>\n<li>这里的代码看上去比上面的好像要长一点，但是这段代码比上面的代码要好得多</li>\n<li>这段代码好像变成了之前的同步代码，在有异步请求的时候还能运行吗？当然是可以的，主要原因就在<code>yield</code>身上，当我们执行生成器<code>main</code>的时候，遇到<code>yield</code>后暂停了<code>foo(11,31)</code>后面的其他代码，等待迭代器的下一个next来恢复它的执行</li>\n<li>当我们的<code>ajax</code>执行完成后，调用了<code>next</code>方法来恢复它，并把ajax的返回值传递给了生成器，使其赋值给了<code>text</code>，接着让<code>main</code>继续执行</li>\n</ul>\n<h2>总结</h2>\n<ul>\n<li>生成器其实就是可以暂停执行与继续执行的函数，暂停与执行使用过迭代器来实现的</li>\n<li>生成器的主要作用就是解决传统异步编码回调问题，实现原理就是暂停后需要next来恢复，<code>next</code>与<code>yield</code>可以双向通信传递数据，可借此传递异步请求的数据</li>\n</ul>","fields":{"slug":"/yield/"},"frontmatter":{"title":"ES2015生成器","tags":["JavaScript","ES2015","进修"],"categories":"JavaScript"}}},{"node":{"html":"<h1>深入字符串模板</h1>\n<h2>字符串模板</h2>\n<ul>\n<li><code>ES5</code>之前我们连接字符串与变量还需要使用js的<code>+</code>运算符进行连接</li>\n<li><code>ES6</code>中我们新增了<code>字符串模板</code>这个概念，<code>字符串模板</code>使用`作为定界符</li>\n<li>大家对他的认识可能只停留在<code>拼接字符串与变量</code>并在调用的地方进行<code>变量解析</code></li>\n<li>其实<code>字符串模板</code>有很多我们还不熟知的强大功能</li>\n</ul>\n<!--more-->\n<h1>常用形式</h1>\n<h2>插入表达式</h2>\n<pre><code class=\"language-js\">  function upper(s) {\n    return s.toUpperCase()\n  }\n  var who = 'reader'\n\n  // 使用字符串模板\n  var text = \n  `A very ${upper('warm')} welcome\n  to all of you ${upper(`${who}s`)}!\n  `\n  console.log(text) \n  // A very WARM welcome\n  // to all of you READERS!\n\n\n  // 使用ES5之前\n   var text = \"A very \" + upper('warm') + \" welcome \\r\\n to all of you \" + upper(who + \"s\")\n  console.log(text) \n</code></pre>\n<ul>\n<li>上面是我们想要实现的字符串片段部分单词转大写需求，可以看出字符串模板帮我们进行了<code>字符串的解析与换行符的保留</code></li>\n<li>传统的js则需要我们自己对<code>js表达式</code>进行拼接</li>\n</ul>\n<h1>高级用法</h1>\n<h2>标签模板字面量</h2>\n<ul>\n<li>其实在<code>你不知道的JavaScript</code>中将<code>字符串模板</code>称为<code>标签字符串字面量</code></li>\n<li>看一下下面比较酷炫的用法</li>\n</ul>\n<pre><code class=\"language-js\">  function foo(strings, ...values){\n    console.log(strings)\n    console.log(values)\n  }\n\n  var desc = 'awesome'\n  foo`Everything is ${desc}!`\n  // strings [ 'Everything is ', '!' ]   \n  // values  [ 'awesome' ]\n</code></pre>\n<ul>\n<li>看到这里可能都有点懵，这还是函数吗？又没有函数调用的小括号</li>\n<li>本质上说这是一类不需要<code>()</code>的函数调用，<code>字符串字面量</code>之前是一个要调用的函数</li>\n<li>那二者组合的<code>字符串字面量作为标签调用的函数</code>会变成什么？参数又是什么含义？</li>\n<li>第一个参数<code>strings</code>，由所有普通字符串组成的数组，在这里即为： <code>'Everything is '</code>跟 <code>'!'</code></li>\n<li>第二个参数<code>values</code>则是使用了<code>...gather/rest</code>运算符将其他的所有参数收集到了名为<code>values</code>的数组中，所以这里只能是<code>'awesome'</code></li>\n</ul>\n<h2>数字格式化为美元表示</h2>\n<pre><code class=\"language-js\">  function dollabillsyall(strings, ...values) {\n    return strings.reduce(function (s, v, idx){\n      if (idx > 0) {\n        if(typeof values[idx - 1] == 'number') {\n          s += `$${values[idx - 1].toFixed(2)}`\n        } else {\n          s += values[idx - 1]\n        }\n      }\n      return s + v\n    }, \"\")\n  }\n\n  var amt1 = 11.99, amt2 = amt1 * 1.88, name=\"Kyle\"\n  var text = dollabillsyall\n  `Thanks for your purchase, ${name}! your product cost was ${amt1}, which with tax comes out to ${amt2}.`\n  console.log(text)\n  // Thanks for your purchase, Kyle! your product cost was $11.99, which with tax comes out to $22.54.\n</code></pre>\n<ul>\n<li>这里我们使用<code>reduce</code>进行字符串拼接，对每一个数字变量都进行美元符拼接并转化为两位小数保留</li>\n</ul>","fields":{"slug":"/js_template/"},"frontmatter":{"title":"ES2016字符串模板","tags":["JavaScript","ES2015","进修"],"categories":"JavaScript"}}},{"node":{"html":"<h1>一脸懵逼的迭代器</h1>\n<h2>迭代器</h2>\n<ul>\n<li>迭代器：<code>迭代器</code>是一个结构化的模式，用于从一个源一次一个的方式获取数据</li>\n<li><code>JavaScript</code>开发中从来不缺乏它的出现，总有各种各样的方法来实现它</li>\n<li><code>ES6</code>中为<code>迭代器</code>提供了一个<code>隐式的标准化接口</code>，并在一些内建数据结构中都实现了它</li>\n</ul>\n<!--more-->\n<h1>内置数据结构迭代器</h1>\n<h2>数组</h2>\n<ul>\n<li><code>数组</code>中的迭代器</li>\n</ul>\n<pre><code class=\"language-js\">  let arr = [1,2,3]\n  let it = arr[Symbol.iterator]()\n  it.next() // { value: 1, done: false }\n  it.next() // { value: 2, done: false }\n  it.next() // { value: 3, done: false }\n  it.next() // { value: undefined, done: true }\n</code></pre>\n<ul>\n<li>每次在数祖上调用<code>Symbol.iterator</code>方法时都会产生一个新的迭代器</li>\n<li>当数组迭代完成并不会立即将<code>done</code>设置为<code>true</code>,而是在迭代完所有之后再迭代一次才会将其改变</li>\n</ul>\n<h2>字符串</h2>\n<ul>\n<li><code>字符串</code>中的迭代器</li>\n</ul>\n<pre><code class=\"language-js\">  let str = 'hello'\n  let it = arr[Symbol.iterator]()\n  console.log(it.next()) // { value: 'h', done: false }\n  console.log(it.next()) // { value: 'e', done: false }\n  console.log(it.next()) // { value: 'l', done: false }\n  console.log(it.next()) // { value: 'l', done: false }\n  console.log(it.next()) // { value: 'o', done: false }\n  console.log(it.next()) // { value: undefined, done: true }\n</code></pre>\n<ul>\n<li>严格来说<code>字符串</code>本身并不是<code>iterator</code>,但是这里被强制转换为<code>String对象</code>封装形式，从而变成一个<code>iterator</code></li>\n</ul>\n<h2>map</h2>\n<ul>\n<li><code>map</code>中的迭代器</li>\n</ul>\n<pre><code class=\"language-js\">  let map = new Map()\n  map.set({name: '张三'}, {age: 24})\n  map.set('foo', 42)\n  let it = map[Symbol.iterator]()\n  console.log(it.next()) // { value: [ { name: '张三' }, { age: 24 } ], done: false }\n  console.log(it.next()) // { value: [ 'foo', 42 ], done: false }\n  console.log(it.next()) // { value: undefined, done: true }\n  let arr = [1,2,3]\n  let str = 'hello'\n  let map = new Map()\n  map.set({name: '张三'}, {age: 24})\n  map.set('foo', 42)\n  for(let v of map) {\n    console.log(v)\n  }\n</code></pre>\n<h2>for...of循环迭代器</h2>\n<ul>\n<li><code>for...of</code>可用于消耗迭代器，也就是<code>循环调用迭代器</code>，形式如下</li>\n</ul>\n<pre><code class=\"language-js\">  let map = new Map()\n  map.set({name: '张三'}, {age: 24})\n  map.set('foo', 42)\n  for(let v of map) {\n    console.log(v)\n  }\n  // [ { name: '张三' }, { age: 24 } ], [ 'foo', 42 ]\n</code></pre>\n<ul>\n<li><code>for...of</code>会将迭代器中的内容返回</li>\n</ul>\n<h1>自定义迭代器</h1>\n<ul>\n<li>利用<code>Symbol.itertor</code>我们可以构造可以与<code>ES6</code>交互的属于自己的<code>迭代器</code></li>\n<li>下面是构造一个<code>无限斐波纳契序列</code></li>\n</ul>\n<pre><code class=\"language-js\">  var Fib = {\n    [Symbol.iterator](){\n      let n1 = 1, n2 = 1\n      return {\n        [Symbol.iterator](){return this},\n        next(){\n          let current = n2\n          n2 = n1\n          n1 = current + n1\n          return {value: current, done: false}\n        },\n        return (v){\n          console.log(\n          \"Fibonacci sequence abandoned.\"\n          );\n          return { value: v, done: true }; \n        }\n      }\n    }\n  }\n  for(let v of Fib) {\n    console.log(v)\n    if(v > 500) break\n  }\n  // 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610\n</code></pre>\n<ul>\n<li>这里当我们调用<code>Fib</code>的<code>Symbol.iterator</code>方法会返回一个带有<code>next</code>跟<code>return</code>方法的迭代器</li>\n<li>通过闭包里面的<code>n1</code>与<code>n2</code>来维护数据</li>\n</ul>\n<h1>迭代器其他用法</h1>\n<h2>模拟事件队列机制</h2>\n<ul>\n<li>下面实现一个<code>运行一系列事件</code>的迭代器</li>\n</ul>\n<pre><code class=\"language-js\">  let tasks = {\n    [Symbol.iterator](){\n      let steps = this.options.slice()\n      return {\n        [Symbol.iteratro](){return this},\n        next(...args){\n          if(steps.length > 0) {\n            let res = steps.shift()(...args)\n            return {value: res, done: false}\n          } else {\n            return { done: true }\n          }\n        }\n      }\n    },\n    options: []\n  }\n  tasks.options.push(\n    function(x){\n      return x * 2\n    },\n    function(x, y){\n      return x + y * 2\n    },\n    function(x, y, z) {\n      return x * y + z\n    }\n  )\n  let it = tasks[Symbol.iterator]()\n  console.log(it.next(10)) //{ value: 20, done: false } \n  console.log(it.next(10, 20)) //{ value: 50, done: false }\n  console.log(it.next(10, 20, 30)) //{ value: 230, done: false }\n  console.log(it.next()) //{ done: true }\n</code></pre>\n<ul>\n<li>其中可以看到，我们将要运行的事件都传入我们的<code>数组集合options</code>中，然后便可以迭代运行了</li>\n</ul>\n<h2>模拟数字生成数组</h2>\n<ul>\n<li>我们可以将数字构造为一个迭代器，使其拥有迭代器的一些操作，用来<code>生成数组</code>或<code>一定次数的循环</code></li>\n</ul>\n<pre><code class=\"language-js\">  if(!Number.prototype[Symbol.iterator]){\n    Object.defineProperty(\n      Number.prototype,\n      Symbol.iterator,\n      {\n        writable: true,\n        configurable: true,\n        enumerable: false,\n        value: function iterator(){\n          var i, inc, done = false, top = +this\n          inc = 1 * (top &#x3C; 0 ? -1 : 1)\n          return {\n            [Symbol.iterator](){return this},\n            next(){\n              if(!done) {\n                if(i == null) {\n                  i = 0\n                } else if (top >= 0) {\n                  i = Math.min(top, i + inc)\n                } else {\n                  i = Math.max(top, i + inc)\n                }\n                if(i == top) {done = true}\n                return {value: i, done: false}\n              } else {\n                return {done: true}\n              }\n            }\n          }\n        }\n      }\n    )\n  }\n  for(let v of 3) {\n    console.log(v)\n  }\n  // 0 1 2 3\n\n  [...3] // [0,1,2,3]\n</code></pre>\n<ul>\n<li>第一个<code>for...of</code>循环可以使我们循环指定次数来完成我们的操作</li>\n<li>因为我们<code>ES6</code>的<code>解构符</code>本来就可以<code>消耗</code>或者说是<code>解读</code>我们的迭代器，所以会帮助我们直接生成指定长度的纯数字数组</li>\n</ul>","fields":{"slug":"/iterator/"},"frontmatter":{"title":"ES2015迭代器","tags":["JavaScript","ES2015","进修"],"categories":"JavaScript"}}},{"node":{"html":"<h1>JavaScript中的对象</h1>\n<h2>原型</h2>\n<ul>\n<li>每个对象都连接到一个原型对象，并且可以继承原型对象的属性</li>\n<li>通过字面量创建的对象都会连接到Object.prototype，它是JavaScript中的标配对象</li>\n<li>我们可以在创建对象的时候选择另一个对象作为它的原型</li>\n<li>\n<p>ES5中提供的Object.create可以帮我们实现原型对象的绑定（绑定至指定对象）</p>\n<!--more-->\n</li>\n</ul>\n<h1>原型绑定</h1>\n<ul>\n<li>下列代码就实现了对象stog绑定原型至stooge的过程</li>\n</ul>\n<pre><code class=\"language-js\">  var stooge = {\n    a: 1,\n    b: 2\n  }\n  var stog = Object.create(stooge)\n  console.log(stog.a)   // 1\n  console.log(stog.b)   // 2\n  stooge.c = 3\n  console.log(stog.c)   // 3\n  stog.d = 4\n  console.log(stooge.d) // 4\n</code></pre>\n<ul>\n<li>这里我们就实现了将stog的原型绑定至stooge，所以当从自身没找到改属性值时会沿原型链往上找，找到原型对象中的属性值</li>\n<li>若原型对象中也没有，则会返回undefined</li>\n</ul>\n<h2>手动实现Object.create</h2>\n<pre><code class=\"language-js\">  Object.createPrototype = function(o){\n    var F = function(){}\n    F.prototype = o\n    return new F()\n  }\n  var stooge = {\n    a: 1\n  }\n  var stog = Object.createPrototype(stooge)\n  console.log(stog.a) // 1\n</code></pre>\n<ul>\n<li>这里我们自己构造一个对象属性，接受一个对象作为参数，并在函数内部新建一个构造函数</li>\n<li>将改构造函数的原型指定为我们传入的对象实现原型绑定，并将新对象返回</li>\n</ul>\n<h2>属性枚举</h2>\n<ul>\n<li>有时候我们需要获取一个对象的私有属性，而不是其原型链上的属性</li>\n<li>这时我们就需要使用for...in循环跟hasOwnProperty函数来进行筛选</li>\n</ul>\n<pre><code class=\"language-js\">  var obj1 = {\n    a: 1,\n    b: 2\n  }\n  var obj2 = Object.create(obj1)\n  obj2.c = 3\n  for(var key in obj2) {\n    console.log(key) // c a b\n    if(obj2.hasOwnProperty(key)) {\n      console.log(key) // c\n    }\n  }\n</code></pre>\n<ul>\n<li>这里for...in会获取对象及其原型链上的属性值，所以我们需要hasOwnProperty()来获取独属于它的属性</li>\n</ul>\n<h2>删除对象属性</h2>\n<ul>\n<li>删除对象的制定属性需要使用delete操作符</li>\n<li>delete 对象.属性即可删除该属性</li>\n</ul>\n<pre><code class=\"language-js\">  var testDelete = {\n    canDelete: '我是原型属性'\n  }\n  var testDelete1 = Object.create(testDelete)\n  testDelete1.canDelete = '我是私有属性'\n  console.log(testDelete1.canDelete) // 我是私有属性\n  delete testDelete1.canDelete\n  console.log(testDelete1.canDelete) // 我是原型属性\n</code></pre>\n<ul>\n<li>这里删除之前打印的为我们展示的是该对象的私有属性</li>\n<li>删除之后对象本身找不到该属性，便回到原型链查找，从而返回原型对象的该属性</li>\n</ul>","fields":{"slug":"/goodJavaScript_object/"},"frontmatter":{"title":"JavaScript语言精粹-对象","tags":["JavaScript","进修"],"categories":"JavaScript"}}},{"node":{"html":"<h1>继承的实现与原理</h1>\n<h2>继承</h2>\n<ul>\n<li><code>继承</code>是面向对象中的一个特性，与<code>多态</code>，<code>封装</code>称为面向对象的三个基本特征</li>\n<li>使用<code>继承</code>可以使一个对象快速拥有另一个对象的属性与方法，并能够重新定义自己的方法</li>\n<li>\n<p><code>JavaScript</code>中并没有真正的类，所以实现<code>继承</code>可以通过<code>原型链</code>或者通过改变<code>this</code>来实现<code>伪造对象继承</code></p>\n<!--more-->\n</li>\n</ul>\n<h2>ES5中的实现</h2>\n<ul>\n<li><code>es5</code>中的继承实现一般有三种方式</li>\n<li>\n<p>构造继承</p>\n<ul>\n<li>构造继承是在子类的内部调用超类的构造函数，并将<code>this</code>的指向替换为子类</li>\n<li>可以通过<code>bind</code>,<code>apply</code>,<code>bind</code>来实现</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"language-js\">  function Person(name, age) {\n    this.name = name\n    this.age = age\n    this.say = function(){\n      console.log(`我是${this.name},我${this.age}岁了`)\n    }\n  }\n  function Child(name, age){\n    // bind方法\n    Person.bind(this)(name, age)\n    // call方法\n    Person.call(this, name, age)\n\n    // apply方法\n    Person.apply(this, [name, age])\n  }\n  var child = new Child('张三',24)\n  child.say() // 我是张三,我24岁了\n</code></pre>\n<ul>\n<li>上面三种方法都可以实现子类的继承，但是缺点是未共享父类方法，内存浪费</li>\n<li>\n<p>原型链继承</p>\n<ul>\n<li><code>原型链继承</code>其实就是将超类的一个实例作为子类的原型，从而实现子类共享父类属性与方法</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"language-js\">  function Person1(name, age){\n    this.name = [name]\n    this.age = age\n    this.rename = function(){\n      this.name.push(name)\n    }\n    this.say = function(){\n      console.log(`我是${this.name},我${this.age}岁了`)\n    }\n  }\n  function Child1(){}\n  Child1.prototype = new Person1('李四', 27)\n  var child = new Child1() \n  child.rename()\n  console.log(child.name) // [\"李四\", \"李四\"]\n  var child1 =  new Child1() \n  console.log(child1.name)   // [\"李四\", \"李四\"]\n</code></pre>\n<ul>\n<li>这里我们也发现在继承的同时我们失去了向超类传递参数的可能</li>\n<li>这里我们实现了两个子类共享了超类的<code>方法</code>，但是却也共享了<code>属性</code>，从而导致实例一调用rename方法则实例二的name属性也会变化</li>\n<li>\n<p>组合继承</p>\n<ul>\n<li><code>组合继承</code>就是将上述两种方法结合到一起，实现的属性继承且不会互相影响，并能向超类传递参数</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"language-js\">  function Person2(name, age){\n    this.name = [name]\n    this.age = age\n    this.rename = function(){\n      this.name.push(name)\n    }\n    this.say = function(){\n      console.log(`我是${this.name},我${this.age}岁了`)\n    }\n  }\n  function Child2(name, age){\n    Person2.call(this, name, age)\n  }\n  Child2.prototype = new Person2()\n  Child2.prototype.constructor = Child2\n  var child = new Child2('王五', 30)\n  child.rename()\n  child.say()  // 我是王五,王五,我30岁了   rename只改变了我自己的实例\n  var child1 = new Child2('孙刘', 40)\n  child1.say() // 并不受另一个实例的影响\n</code></pre>\n<ul>\n<li>这里我们使用<code>Child2.prototype = new Person2()</code>的时候将<code>Child2</code>的原型的构造函数给指向了<code>Person2</code>，他应该指向<code>Child2</code>的</li>\n<li>所以我们添加了<code>Child2.prototype.constructor = Child2</code>来将其指向偏转回来</li>\n<li><code>组合继承</code>相对来说比较优秀，但是<code>超类</code>构造函数被调用两次，子类实例的属性存在两份，造成内存浪费</li>\n<li>\n<p>寄生继承</p>\n<ul>\n<li>寄生继承就是利用<code>Object.create</code>方法来取得超类的<code>原型对象</code>并构造成为子类的<code>原型</code>，从而实现子类继承父类属性与方法</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"language-js\">  function Person3(name, age){\n    this.name = [name]\n    this.age = age\n    this.say = function(){\n      console.log(`我是${this.name},我${this.age}岁了`)\n    }\n  }\n  Person3.prototype.rename = function(name){\n    this.name.push(name)\n  }\n  function Child3(name, age){\n    Person3.call(this, name, age)\n  }\n  Child3.prototype = Object.create(Person3.prototype)\n  var child1 = new Child3('刘琦', 34)\n  child1.rename('小孩')\n  child1.say() // 我是刘琦,小孩,我34岁了\n  var child2 = new Child3('王八', 35)\n  child2.rename('大人')\n  child2.say() // 我是王八,大人,我35岁了\n</code></pre>\n<ul>\n<li><code>Person3.prototype</code>其实可以看作<code>Person3</code>的一个实例，这里我们使用<code>Object.create</code>创建了一个原型对象为<code>Person3.prototype</code>的对象作为<code>Child3</code>的原型对象</li>\n<li>从而实现<code>Person3</code>的实例共享同一属性与方法</li>\n</ul>\n<h2>ES6中的继承</h2>\n<ul>\n<li>\n<p>ES6中我们可以通过extends来实现继承</p>\n<pre><code class=\"language-js\">class Person {\nconstructor(name, age){\n  this.name = name\n  this.age = age\n}\nsay(){\n  console.log(`我是${this.name},我${this.age}岁了`)\n}\n}\nclass Child extends Person {\nconstructor(name, age){\n  super(name, age)\n}\n}\nvar child = new Child('张三', 18)\nchild.say() // 我是张三,我18岁了\n</code></pre>\n</li>\n<li><code>ES6</code>中的继承就跟传统语言中的一样了，只需要定义方法与私有方法即可</li>\n</ul>","fields":{"slug":"/extends/"},"frontmatter":{"title":"JavaScript中的继承","tags":["JavaScript","进修","ES2015"],"categories":"JavaScript"}}},{"node":{"html":"<h1>js中的继承（一）</h1>\n<ul>\n<li>之前也写过一篇关于js继承的一篇文章，不过是在刚开始了解继承的时候写的一篇，看了很多别人的博客，似懂非懂的情况下写了那篇，最近再看js设计模式的时候再次看到了它，也想比较详细的再写一篇</li>\n<li>因为js中没有类，所以一般会以函数内部使用this赋值属性与方法的形式使函数具有类的功能，作为与普通函数的区分，我们会将这一类函数的首字母大写来表明这是一个类</li>\n<li>继承就是让继承类具有被继承类的属性与方法，一般用于对某类的拓展</li>\n<li>既然js都没有类的，自然更不会有继承存在了，这里我们就要用一些比较灵活的方法来实现类的继承了，传统的方法有以下几种</li>\n</ul>\n<h2>继承的实现</h2>\n<h2>原型链继承</h2>\n<ul>\n<li>原型链继承的原理：继承实现的效果其实就是子类的实例具有父类的属性与方法，所以根据对象属性沿原型链查找的原理实现了原型链继承（对象查找某方法或属性时，会先在对象自身上找，当自身查找不到时，就会在<strong>proto</strong>指向的对象上面找，如果第一个<strong>proto</strong>对象上面也没有就会继续沿着<strong>proto</strong>往上找，一直到找到该属性或者null为止，这也就是原型链，对这一块感兴趣的话，可以先了解一下原型与原型链）</li>\n<li>所以实现这一继承方法的话我们只需要使子类的原型对象为父类的实例即可，这样，子类实例查找属性时便会查找到子类的原型对象也就是父类的实例，便能获取到父类的构造函数内的属性与方法，若父类实例未查找到便会查找到父类的原型对象上面，这样也就实现了继承父类原型对象的方法，具体实现如下</li>\n</ul>\n<!--more-->\n<pre><code class=\"language-js\">  function Super(){\n    this.name = '张三'\n    this.age = 24\n    this.favite = ['烧烤', '桑拿']\n    this.showName = function(){\n      console.log(this.name)\n    }\n  }\n  Super.prototype.showAge = function(){\n    console.log(this.age)\n  }\n  Super.prototype.showFavite = function(){\n    console.log(this.favite)\n  }\n\n  function Sub(){}\n  Sub.prototype = new Super()\n\n  var a = new Sub()\n  var b = new Sub()\n  a.showName()  // 张三\n  a.showAge()   // 24\n  b.showFavite() // [\"烧烤\", \"桑拿\"]\n  a.favite.push('看书')\n  b.showFavite() // [\"烧烤\", \"桑拿\", \"看书\"]\n</code></pre>\n<ul>\n<li>这里我们也能发现此方法的弊端，所有子类共用一个原型对象，若该对象上面存在引用类型的属性，则任意子类修改所有子类都会改变，而且，子类实例化的时候不能接受参数</li>\n</ul>\n<h2>构造函数继承</h2>\n<ul>\n<li>构造函数继承：这里就要理解实例化的过程（也就是new的原理），可以参考另一篇博客（<a href=\"https://blog.csdn.net/weixin_41900457/article/details/102557358\">js中new的原理与实现</a>）。类实例化其实就是生成一个对象，并将this指向该对象，所以我们可以在子类的构造函数内调用父类的构造函数并将this指向子类，如此一来子类的实例对象就可以拥有父类构造函数内的属性与方法，实现方法如下</li>\n</ul>\n<pre><code class=\"language-js\">  function SuperClass(name){\n    this.name = name\n    this.books = ['js', 'css', 'html']\n    this.showBooks = function(){\n        console.log(this.books)\n    }\n  }\n\n  // showName为原型对象方法\n  SuperClass.prototype.showName = function(){\n      console.log(this.name)\n  }\n\n\n  function SubClass(name){\n      SuperClass.call(this, name)\n  }\n\n  // 原理为使用call或apply在子类内部执行父类的构造函数，只不过将this的指向改为了子类，\n  // 所以只能继承父类的属性方法，并不能继承父类原型的方法，所以showBooks可正常工作，showName会报错\n  let a = new SubClass('张胜男')\n  let b = new SubClass('江玉成')\n  b.showBooks() // ['js', 'css', 'html']\n  a.books.push('php')\n  b.showBooks() // ['js', 'css', 'html']\n  b.showName()  // TypeError()\n</code></pre>\n<ul>\n<li>该继承方式只能继承父类的属性方法，并不能继承父类原型的方法</li>\n</ul>\n<h2>组合继承</h2>\n<ul>\n<li>组合继承就是兼顾了上两种继承的优势与劣势进行的继承方式，既可以完整继承父类，也可以对子类初始化入参， 实现如下</li>\n</ul>\n<pre><code class=\"language-js\">  function SuperClass(name){\n    this.name = name\n    this.books = ['js', 'css', 'html']\n    console.log('我执行了')\n    this.showBooks = function(){\n        console.log(this.books)\n    }\n  }\n\n  SuperClass.prototype.showName = function(){\n      console.log(this.name)\n  }\n\n  function SubClass(name){\n      SuperClass.call(this, name)\n  }\n  SubClass.prototype = new SuperClass()\n  // 这里我们需要了解，任何原型对象的constructor属性都会指向自己的构造函数\n  console.log(SubClass.prototype.constructor) // [Function: SuperClass] 这里子类的constructor属性指向了父类的构造函数，需要进行偏转\n  SubClass.prototype.constructor = SubClass\n  console.log(SubClass.prototype.constructor) // [Function: SubClass] 正常\n  // 组合式继承，call或apply继承父类属性方法，设置子类原型为父类实例继承父类原型方法，即可实现功能完备的继承\n  // 缺点：生成子类实例会调用两次父类构造函数，若父类原型对象上存在引用类型仍会出现所有子类共享该属性的问题\n  let a = new SubClass('张三')\n  let b = new SubClass('李四')\n  b.showBooks() // ['js', 'css', 'html']\n  b.showName()  // 李四\n  a.books.push('php')\n  b.showBooks() // ['js', 'css', 'html']\n  console.log(a instanceof SuperClass)\n</code></pre>\n<ul>\n<li>这里是比较常用的继承方式，但仍不是最优解，上面我们可以看到生成子类实例会调用两次父类构造函数，若父类原型对象上存在引用类型仍会出现所有子类共享该属性的问题</li>\n<li>这一篇先介绍这三种继承方式，下一篇带来剩下几种继承的形式</li>\n</ul>","fields":{"slug":"/extends_new/"},"frontmatter":{"title":"JavaScript中的继承","tags":["JavaScript回顾","设计模式","进修"],"categories":"JavaScript"}}},{"node":{"html":"<h1>new的原理与实现</h1>\n<ul>\n<li>在javascript中我们经常看到在实例化某个类的时候都会在构造函数前面加一个new调用函数来获取我们的实例，但却没有想过new这个操作符在这里面做了什么，是如何生成的实例，所以这段时间我也大概了解了下new的工作原理，并随手写一下自己的感悟</li>\n</ul>\n<h2>原理</h2>\n<ul>\n<li>构造函数实例都具有该构造函数内的共用属性与方法，同时也会拥有构造函数原型对象上的方法，所以构造函数生成实例其实会经历三个步骤</li>\n<li>第一步，构造一个实例 空对象</li>\n<li>第二步，将构造函数的this值赋给这个对象，并执行构造函数内的赋值操作，这样该实例就有了构造函数相应的属性值</li>\n<li>第三步，使实例拥有构造函数原型链上的方法，这就需要我们将该对象的<strong>proto</strong>属性指向我们的构造函数的原型对象上（涉及到对象属性的查找原理，对象查找某方法或属性时，会先在对象自身上找，当自身查找不到时，就会在<strong>proto</strong>指向的对象上面找，如果第一个<strong>proto</strong>对象上面也没有就会继续沿着<strong>proto</strong>往上找，一直到找到该属性或者null为止，对这一块感兴趣的话，可以先了解一下原型与原型链）</li>\n</ul>\n<!--more-->\n<h2>实现</h2>\n<ul>\n<li>知道了原理其实实现一个相同的方法也就简单了</li>\n</ul>\n<pre><code class=\"language-js\">  // 这里使用ES6的结构来获取构造函数所需的参数\n  // 因为结构之后获取的是一个数组结构，所以使用apply来进行构造函数this的赋值\n  // 也可以使用arguments来获取，不过ES6中不这么建议了，要用的话进行arguments[0]的提取与裁剪就可以了\n  function New(Fn, ...args){\n    var obj = {} // 构造空对象\n    Fn.apply(obj, args) // 构造函数赋值与this指向的修改\n    obj.__proto__ = Fn.prototype // 对该对象赋值构造函数原型对象上的方法\n    return obj // 返回该实例\n  }\n\n  function Person(name){\n    this.name = name\n  }\n  Person.prototype.showName = function(){\n    console.log(this.name)\n  }\n\n  var p1 = New(Person, '张三')\n  p1.showName() // 张三\n</code></pre>","fields":{"slug":"/new/"},"frontmatter":{"title":"JavaScript中new的原理与手动实现一个new","tags":["JavaScript回顾","设计模式","进修"],"categories":"JavaScript"}}},{"node":{"html":"<h1>js中的继承（二）</h1>\n<h2>原型式继承</h2>\n<ul>\n<li>原型式继承：原型式继承可以根据现有对象创建一个新的对象，并且不用显式的创建一个新的自定义类型对象（道格拉斯说的）。这也就是原型式继承的作用，创建一个继承某对象属性并可进行拓展的的新对象。</li>\n<li>原型式继承采用的其实还是类式继承的原理，只不过不会显式的构建一个对象子类，而是用一个空的构造函数类来做过渡类，然后把被继承的对象设置为过渡类的原型对象，然后返回一个过渡类的实例，这样这个返回的对象就有了被继承对象的属性与方法，具体实现见下代码</li>\n</ul>\n<!--more-->\n<pre><code class=\"language-js\">  function inheritObject(obj){\n    function F(){} // 过渡类，一般为空\n    F.prototype = obj // 设置过渡类原型对象\n    return new F() // 返回新的实例\n  }\n\n  let book = {\n    books: ['css', 'js', 'html'],\n    name: 'css book',\n    showBooks: function(){\n      console.log(this.books, this.name)\n    }\n  }\n\n  let b1 = inheritObject(book)\n  let b2 = inheritObject(book)\n  b1.name = 'js book'\n  b2.name = 'html book'\n  b2.showBooks() // [\"css\", \"js\", \"html\"]  \"html book\"\n  b1.books.push('php')\n  // 这里可以看到对b1的books属性进行操作会影响到b2的books属性\n  b2.showBooks() // [\"css\", \"js\", \"html\", \"php\"]  \"html book\"\n  b1.showBooks() // [\"css\", \"js\", \"html\", \"php\"]  \"js book\"\n</code></pre>\n<ul>\n<li>原型式继承其实就是对类式继承的另类使用，只不过使用一个空构造函数的过渡类来替代子类减少开销，用于创建对象是一个蛮不错的选择，也是后来Object.create()的实现思想来源。</li>\n</ul>\n<h2>寄生式继承</h2>\n<ul>\n<li>寄生式继承：就是对原型式继承的二次封装，并且在二次封装中对继承的对象进行了拓展，这样对象不仅拥有了父类中的对象与属性，也有了新的属性与方法</li>\n</ul>\n<pre><code class=\"language-js\">  function inheritObject(obj){\n    function F(){} // 过渡类，一般为空\n    F.prototype = obj // 设置过渡类原型对象\n    return new F() // 返回新的实例\n  }\n  function createBook(obj){\n    var o = inheritObject(obj) // 获取原型式继承的对象\n    // 对该对象进行拓展\n    o.getName = function(){ \n      console.log(this.name)\n    }\n    return o\n  }\n  let book = {\n    books: ['css', 'js', 'html'],\n    name: 'css book',\n    showBooks: function(){\n      console.log(this.books, this.name)\n    }\n  }\n\n  let b1 = createBook(book)\n  b1.getName() // css book\n</code></pre>\n<ul>\n<li>只是比原型式继承多了一个函数封装，使其拥有了自己的属性与方法，产生这个继承方式的目的也是为了寄生组合式继承模型的实现</li>\n</ul>\n<h2>完美的继承模式——寄生组合式继承</h2>\n<ul>\n<li>寄生组合式继承：是寄生式继承与构造函数继承的组合形式，取了两个继承的优点产生的目前最完美的继承形式</li>\n<li>构造函数继承使子类具有父类构造函数内的属性与方法，寄生式继承获取一个继承自父类原型对象的子对象，避免了父类原型对象的二次调用，因为该对象可获取父类原型对象上的属性与方法，设置该对象为子类原型对象继承父类原型对象上的属性与方法，最后对该对象进行属性增强修正其constructor不指向子类的错误</li>\n</ul>\n<pre><code class=\"language-js\">  function inheritObject(obj){\n    function F(){}\n    F.prototype = obj\n    return new F()\n  }\n\n  function inherit(Subclass, Superclass){\n    // 生成一个继承父类原型对象的子对象\n    let sup = inheritObject(Superclass.prototype) \n    // 该对象的constructor并不是指向子类，所以要对其进行属性拓展，修改其constructor属性至子类\n    sup.constructor = Subclass\n    // 将这个拓展过后的对象作为子类的原型对象\n    Subclass.prototype = sup\n  }\n\n  function SuperClass(name){\n    this.name = name\n    this.favite = ['吃饭', '喝酒', '打篮球']\n  }\n  // 原型对象方法\n  SuperClass.prototype.showFavite = function(){\n    console.log(this.favite)\n  }\n\n  function SubClass(name){\n    SuperClass.call(this, name)\n  }\n  // 实现继承\n  inherit(SubClass, SuperClass)\n\n  let s1 = new SubClass('张三')\n  let s2 = new SubClass('李四')\n  s2.showFavite() //  [\"吃饭\", \"喝酒\", \"打篮球\"]\n  s1.favite.push('打豆豆')\n  s2.showFavite() //  [\"吃饭\", \"喝酒\", \"打篮球\"]\n  s1.showFavite() //  [\"吃饭\", \"喝酒\", \"打篮球\", \"打豆豆\"]\n</code></pre>\n<ul>\n<li>原型链与构造函数的组合继承中子类的原型对象为父类的一个实例，也就导致在对子类实现继承的时候会执行两次父类的构造函数（一次子类构造函数调用父类构造函数，一次生成父类实例时调用）。</li>\n<li>而在寄生组合式继承中，每次继承都会由过渡类继承父类原型对象返回一个新的实例，而且由于过渡类的空构造函数并不会导致有太大的内存开销，就避免了父类构造函数的二次调用，所以这也是当下最完美的继承形式</li>\n</ul>","fields":{"slug":"/extends_new_2/"},"frontmatter":{"title":"JavaScript中的继承（二）","tags":["JavaScript回顾","设计模式","进修"],"categories":"JavaScript"}}},{"node":{"html":"<h1>JavaScript中的设计模式——工厂模式</h1>\n<ul>\n<li>在我们的项目开发中会定义很多的类，当协作开发时，每个人都有可能定义很多的类，若是不对每个人或者每一种类进行管理的话，开发中对类的使用将会极其困难，而工厂模式就是对类进行管理的一种模式</li>\n<li>工厂模式一般有以下几种，分别对应不同的使用场景</li>\n</ul>\n<!--more-->\n<h2>简易工厂模式</h2>\n<ul>\n<li>简易工厂模式：不去关心子类的创建过程，只是提供一个函数向外提供他们想要的子类即可</li>\n<li>该模式就是单纯的对同一类型的类进行管理，使用者只需要传入每一个类的别名或简称即可获取该类</li>\n</ul>\n<pre><code class=\"language-js\">    function LoginClass(){\n        console.log('我是登录模块类')\n    }\n    function RegisterClass(){\n        console.log('我是注册模块类')\n    }\n    function LogoutClass(){\n        console.log('我是退出登录模块类')\n    }\n\n    function createUserClass(name){\n        switch(name) {\n            case 'login':\n                return new LoginClass()\n            case 'register':\n                return new RegisterClass()\n            case 'logout':\n                return new LogoutClass()\n        }\n    }\n    let login = createUserClass('login') // 构建登录模块\n    let register = createUserClass('register') // 构建注册模块\n    let logout = createUserClass('logout') // 构建退出登录模块\n</code></pre>\n<ul>\n<li>上面就是一个简易的工厂模式，一般用于管理同类型的类，对外提供每个类型的别名即可使用</li>\n</ul>\n<h2>工厂模式</h2>\n<ul>\n<li>工厂模式：工厂模式一般用于会不断创建新类时使用，比如我初始提供了三个类，突然需求变化新增了一个类，如果还使用建议工厂模式的话就需要先创建这个新类，然后在对外暴露的函数中再加一条case语句，会比较繁琐，所以就产生了工厂模式</li>\n<li>工厂模式是对一个工厂类的拓展，在该类的原型对象上面绑定工厂内所能提供的子类，调用者通过传入不同的类名可获取相应的实例</li>\n<li>工厂模式由于对外提供的是一个工厂类，若是项目新成员或者不熟悉开发的成员在调用过程中将其当做普通函数处理可能会出现异常并且会在全局对象上挂载太多全局变量，所以我们这里要对工厂类进行安全模式</li>\n</ul>\n<pre><code class=\"language-js\">    function Factory(name){\n        // 是否是类式调用，即有没有使用new方法来调用，若是按普通函数来调用则this会指向window，若以new的形式来调用，则会指向当前类\n        if(this instanceof Factory) {\n            // 采用new的形式调用则直接返回他想要的类\n            return new Factory[name]()\n        } else {\n            // 若是不熟悉或者忘了new的调用则我们帮他们调用一下工厂类，最终还是返回他们想要的类\n            return new Factory(name)\n        }\n    }\n</code></pre>\n<ul>\n<li>上面就是对工厂类的安全模式，可防止意外调用导致的一系列问题</li>\n<li>对安全模式的工厂类进行原型对象绑定即可实现我们最终的工厂模式，按需创建类，按需获取类</li>\n</ul>\n<pre><code class=\"language-js\">    function Factory(name){\n        // 是否是类式调用，即有没有使用new方法来调用，若是按普通函数来调用则this会指向window，若以new的形式来调用，则会指向当前类\n        if(this instanceof Factory) {\n            // 采用new的形式调用则直接返回他想要的类，会获取原型对象上的属性，从而获取所需类的构造函数\n            return new this[name]()\n        } else {\n            // 若是不熟悉或者忘了new的调用则我们帮他们调用一下工厂类，最终还是返回他们想要的类\n            return new Factory(name)\n        }\n    }\n    // 通过对工厂类原型对象的修改来获取工厂内存在的各个类，从而可以在工厂内提供人们需要的类\n    Factory.prototype = {\n        JS: function(){\n            this.name = 'js'\n        },\n        PHP: function(){\n            this.name = 'php'\n            this.age = 16\n            this.say = function(){\n                console.log('php是世界上最好的语言')\n            }\n        },\n        JAVA: function(){\n            this.name = 'java'\n            this.advantage = '我是最稳定的'\n            this.say = function(){\n                console.log(this.advantage)\n            }\n        }\n    }\n\n    var js = new Factory('JS')          \n    var php = Factory('PHP')        // 异常调用，可正常返回所需实例\n    var java = new Factory('JAVA')  // 正常调用\n    php.say()   // php是世界上最好的语言\n    java.say()  // 我是最稳定的\n</code></pre>\n<ul>\n<li>上面就是最终的工厂模式，可以看到，当我们需要添加新类的时候只需要在工厂类的原型对象上添加即可，添加完成便可以在别的地方传入名称直接由工厂类生成，需求变化也只需要修改一个地方即可</li>\n</ul>\n<h2>抽象类</h2>\n<ul>\n<li>了解抽象工厂类之前我们需要先了解抽象类，抽象类就是只能继承，无法实例化的一种类，实例化时会抛出异常，且继承抽象类的子类必须重写抽象类的方法。js中abstract仍然只是一个保留字，并没有实现抽象类，所以抽象类需要我们模拟实现</li>\n<li>抽象类在实现上与普通类相似，只是对其方法进行了限制，下面的Car就是一个抽象类</li>\n</ul>\n<pre><code class=\"language-js\">    let Car = function(){\n        this.name = 'Car'\n    }\n    // 如果对Car直接进行实例化或者继承类没有重写下面的方法，则调用时会弹出报错\n    Car.prototype = {\n        getSpeed: function(){\n            throw new Error('不可调用抽象方法')\n        },\n        getPrice: function(){\n            throw new Error('不可调用抽象方法')\n        }\n    }\n</code></pre>\n<h2>抽象工厂类</h2>\n<ul>\n<li>抽象工厂类是对外提供抽象类的工厂模式，下面就是一个抽象工厂模式</li>\n</ul>\n<pre><code class=\"language-js\">    function VehicleFactory(SubClass, SuperClass){\n        // 判断工厂内是否存在该抽象类，存在则进行子类的继承\n        if(typeof VehicleFactory[SuperClass] === 'function'){\n            function F(){}\n            F.prototype = new VehicleFactory[SuperClass]()\n            SubClass.prototype = new F()\n            SubClass.prototype.constructor = SubClass\n        } else {\n            // 若不存在，则抛出异常\n            throw new Error('未创建该抽象类')\n        }\n    }\n    // 抽象小汽车类\n    VehicleFactory.Car = function(){\n        this.name = 'Car'\n    }\n    VehicleFactory.Car.prototype = {\n        getSpeed: function(){\n            throw new Error('不可调用抽象方法')\n        },\n        getPrice: function(){\n            throw new Error('不可调用抽象方法')\n        }\n    }\n\n    // 抽象公交车类\n    VehicleFactory.Bus = function(){\n        this.name = 'Bus'\n    }\n    VehicleFactory.Bus.prototype = {\n        getSpeed: function(){\n            throw new Error('不可调用抽象方法')\n        },\n        getPrice: function(){\n            throw new Error('不可调用抽象方法')\n        }\n    }\n    // 实体类\n    function BWM(price, speed){\n        this.price = price\n        this.speed = speed\n    }\n    // 实现BWM对抽象类Car的继承,但不重写抽象方法\n    VehicleFactory(BWM, 'Car')\n    var b = new BWM(500000, 100)\n    b.getPrice()    // Uncaught Error: 不可调用抽象方法\n    b.getSpeed()    // Uncaught Error: 不可调用抽象方法\n    // 实体类\n    function BRT(price, speed){\n        this.price = price\n        this.speed = speed\n    }\n    // 实现BRT对抽象类Bus的继承\n    VehicleFactory(BRT, 'Bus')\n    // 重写抽象类中的方法\n    BRT.prototype.getPrice = function(){\n        console.log(this.price)\n    }\n    BRT.prototype.getSpeed = function(){\n        console.log(this.speed)\n    }\n    var t = new BRT(300000, 80)\n    t.getPrice()    // 300000\n    t.getSpeed()    // 80\n</code></pre>\n<ul>\n<li>这里我们的抽象工厂可以实现一个实体类对其想要的抽象类的继承，注意点就是要重写抽象类的方法再调用，否则会抛出异常</li>\n</ul>","fields":{"slug":"/factory_mode/"},"frontmatter":{"title":"JavaScript中的设计模式——工厂模式","tags":["JavaScript回顾","设计模式","进修"],"categories":"JavaScript"}}},{"node":{"html":"<h1>采用迭代器形式封装轮播图对象</h1>\n<ul>\n<li>轮播图是我们开发中经常需要实现的一个小功能，但是应用于不同的场景需要对应不同的效果，有的需要淡入淡出，有的需要左侧划入，有的则需要上一张下一张的按钮</li>\n<li>如果针对每个效果都要重新实现的话就会做太多的无用功，所以我们可以看看轮播图的共同点，然后封装一个迭代函数来帮助我们处理轮播图</li>\n<li>轮播图都会接收一个数组作为图片的来源，轮播中我们可能会遇到上一张下一张的显示，所以我们对上一张下一张还有第一张与最后一张做特殊处理，也有可能会对轮播对象中的几个图片不做显示</li>\n<li>所以我们可以提供一个迭代器对象，能对外提供操作数据的方法，包括next、pre、first、last的获取，包括对所有元素的初始化方法，包括对个别元素的操作方法</li>\n</ul>\n<!--more-->\n<pre><code class=\"language-js\">function Iterator(item) {\n  let container = document.querySelector('.container')\n  let items = container.getElementsByTagName(item)\n  let length = items.length\n  let index = 0\n  return {\n    // 获取下一张\n    next: function(){\n      if(index === length - 1) {\n        index = length - 1\n        return null\n      } else {\n        return items[++index]\n      }\n    },\n    // 获取下一张\n    pre: function(){\n      if(index === 0) {\n        index = 0\n        return null\n      } else {\n        return items[--index]\n      }\n    },\n    // 获取第一张\n    first: function(){\n      return items[0]\n    },\n    // 获取最后一张\n    last: function(){\n      return items[length - 1]\n    },\n    // 获取指定序号一张\n    get: function(index){\n      index = index >= 0 ? index % length : index % length + length\n      return items[index]\n    },\n    // 所有图片统一处理方式\n    dealEach: function(fn){\n      Array.prototype.slice.call(items).forEach(item => {\n        fn.call(item)\n      })\n    },\n    // 单张图片特殊处理函数\n    dealItem: function(index, fn){\n      fn.call(items[index])\n    },\n    // 部分图片的排他处理\n    exclusive: function(num, allFn, itemFn){\n      this.dealEach(allFn)\n      if(Object.prototype.toString.call(num) === '[object Array]') {\n        num.forEach(item => {\n          this.dealItem(item, itemFn)\n        })\n      } else {\n        this.dealItem(num, itemFn)\n      }\n    }\n  }\n}\n</code></pre>\n<ul>\n<li>上面我们提供了一个处理轮播图对象的迭代器函数，分别对外暴露了pre,next,last,first,get,dealEach,dealItem,exlusive几个功能函数，使用时只需要指定轮播对象就可以正常使用了，使用方法如下</li>\n</ul>\n<pre><code class=\"language-js\">  var it = Iterator('li')\n  console.log(it.first()) // 获取第一个对象\n  console.log(it.next())  // 获取下一个对象\n  console.log(it.pre())   // 获取上一个对象\n  console.log(it.last())  // 获取最后一个对象\n\n  // 为元素统一设置背景色\n  it.dealEach(function(){\n    this.style.background = 'red'\n  })\n  // 单个元素修改其内容\n  it.dealItem([2], function(){\n      this.innerHTML = 'dealItem'\n  })\n  // 修改其他元素内容\n  it.exclusive([1,3], function(){\n      this.innerHTML = 'exclusive'\n  }, function(){\n      console.log(234, this)\n      this.innerHTML = 'each'\n  })\n</code></pre>\n<ul>\n<li>这样就提供了轮播图的操作对象，具体的轮播实现还要看各自的需求，借助这个轮播对象应该都会比较轻松</li>\n</ul>","fields":{"slug":"/iterator_loop/"},"frontmatter":{"title":"迭代器在轮播图中的应用","tags":["JavaScript回顾","设计模式","进修"],"categories":"JavaScript"}}},{"node":{"html":"<h1>jQuery选择器的简单实现</h1>\n<ul>\n<li>jQuery是前几年前端开发中的老大哥了，而我们最喜欢的也是他提供的选择器跟链式调用的方法了，最近在看了原型与原型链之后也是有点简单的想法，想尝试着实现以下jquery的选择器</li>\n<li>首先需要构建一个函数A可以接受一个id名，返回一个新的对象，而且对象具有jquery提供的一系列方法，所以我们可以构造一个拥有这些方法的B对象并返回</li>\n</ul>\n<pre><code class=\"language-js\">  function A(selector){\n    return B\n  }\n  let B = {\n    length: 3,\n    size: function(){\n      return this.length\n    }\n  }\n</code></pre>\n<!--more-->\n<ul>\n<li>但是单纯的B对象的没办法接收选择器名称，所以我们可以给B添加一个初始化函数init，接收一个选择器名称，并返回最后的对象，因为返回的对象需要拥有B上面的方法，所以我们还是选择将B对象返回，但是我们也需要获取到的dom元素，所以，参照jquery的方法，我们可以将B对象的0属性设置为获取到的dom元素,并且更新B对象的length属性。那如何在函数内返回B对象那？因为init方法是挂载在对象身上的，所以，我们需要返回B对象的时候只需要返回this就可以了</li>\n</ul>\n<pre><code class=\"language-js\">  function A(selector){\n    return B.init(selector)\n  }\n  let B = {\n    init: function(selector){\n      let dom = document.getElementById(selector)\n      this[0] = dom\n      this.length = 1\n      return this\n    },\n    length: 3,\n    size: function(){\n      return this.length\n    }\n  }\n</code></pre>\n<ul>\n<li>这里的话我们需要手动实现一个B对象，过于繁琐，其实我们可以将A函数的fn属性设置为这个对象，这样就省去了显式的创建B对象</li>\n</ul>\n<pre><code class=\"language-js\">  function A(selector){\n    return A.fn.init(selector)\n  }\n  A.fn = {\n    init: function(selector){\n      let dom = document.getElementById(selector)\n      this[0] = dom\n      this.length = 1\n      return this\n    },\n    length: 3,\n    size: function(){\n      return this.length\n    }\n  }\n\n  var a = A('demo') // Object {0: #demo, init: f, length: 1, size: f}\n  var t = A('test') // Object {0: #test, init: f, length: 1, size: f}\n  console.log(a)    // Object {0: #test, init: f, length: 1, size: f}\n</code></pre>\n<ul>\n<li>上面我们能发现，如果直接返回A.fn这个对象的话则所有通过A函数获取到的对象会公用一个对象，包括属性，这样的话就会相互影响，取不到我们想要的dom，所以我们可以在返回前使用new进行修饰，但是new的特性导致返回的对象中的this将不再指向我们的A.fn，也就意味这我们不能使用size()方法，所以我们可以指定A.fn.init的prototype到A.fn从而获取size方法</li>\n</ul>\n<pre><code class=\"language-js\">  function A(selector){\n    return new A.fn.init(selector)\n  }\n  A.fn = {\n    init: function(selector){\n      let dom = document.getElementById(selector)\n      this[0] = dom\n      this.length = 1\n      return this\n    },\n    length: 3,\n    size: function(){\n      return this.length\n    }\n  }\n\n  A.fn.init.prototype = A.fn\n\n  var a = A('demo')         // Object {0: #demo, init: f, length: 1, size: f}\n  var t = A('test')         // Object {0: #test, init: f, length: 1, size: f}\n  console.log(a.size())     // 1\n</code></pre>\n<h2>extend方法实现</h2>\n<ul>\n<li>上面我们就简单的实现了一个id选择器，下面的话我们需要实现一下jQuery拓展插件的方式extend，extend方法其实就是对对象的整合并返回新的对象，所以要根据参数进行拓展，单对象则在当前对象拓展，多对象则融合并返回</li>\n</ul>\n<pre><code class=\"language-js\">  A.extend = A.fn.extend = function(...args){\n    let len = args.length, target\n    if(len === 0) {\n      return\n    }\n    if(len === 1) {\n      target = this\n      for(let key in args[0]) {\n        target[key] = args[0][key]\n      }\n    } else {\n      target = args[0]\n      for(let i = 1; i &#x3C; len; i++) {\n        for(let key in args[i]) {\n          target[key] = args[i][key]\n        }\n      }\n    }\n    return target\n  }\n\n  var a = A('demo')\n  a.extend({b: 3, d: 4})\n  console.log(a) // Object {0: #demo, length: 1, b:3, d: 4}\n\n  A.extend(a, {e: 4})\n\n  console.log(a) // Object {0: #demo, length: 1, b:3, d: 4, e:4}\n</code></pre>\n<ul>\n<li>上面就是拓展插件extend方法的实现，利用这个方法，可以在A函数或者选择之后的对象进行拓展</li>\n</ul>\n<h2>链式调用的实现</h2>\n<ul>\n<li>链式调用就是在每个方法执行完成之后都将当前this放回，这样接下来的方法便都可以拿到这个对象并接着调用，所以我们可以先拓展几个常用的jquery的方法</li>\n<li>on方法的实现，由于各浏览器的兼容性问题，所以我们对事件绑定方式on进行一个简单的实现，还是要用到我们的extend方法，因为选择器返回的对象都可以调用这个方法，所以我们将其拓展到A.fn对象上面</li>\n</ul>\n<pre><code class=\"language-js\">A.fn.extend({\n  // 立即执行函数获取各浏览器下的绑定方式并绑定到on方法上，避免每次调用都要判断浏览器环境\n  on: (function(){\n    if(document.addEventListener) {\n      return function(type, fn){\n        for(let i = 0; i &#x3C; this.length; i++) {\n          this[i].addEventListener(type, fn, false)\n        }\n      }\n    } else if(document.addEvent) {\n      return function(type, fn){\n        for(let i = 0; i &#x3C; this.length; i++) {\n          this[i].addEvent('on'+type, fn)\n        }\n      }\n    } else {\n      return function(type, fn){\n        for(let i = 0; i &#x3C; this.length; i++) {\n          this[i]['on' + type] = fn\n        }\n      }\n    }\n  })()\n})\n\na.on('click', function(){\n  console.log(this.innerHTML) // 1\n})\n</code></pre>\n<ul>\n<li>上面我们对A.fn进行了拓展，使所有选择器返回的对象都可以进行数据绑定，并且可以成功打印1</li>\n<li>接下来我们依次对其进行attr,css,html方法的拓展，在对css方法进行拓展的时候我们先对A进行了拓展，使其拥有可以将-连接的css属性转为驼峰命名的css属性，从而实现我们的赋值</li>\n</ul>\n<pre><code class=\"language-js\">A.extend({\n  // 常用css转驼峰\n  cameName: function(str){\n    return str.replace(/\\-(\\w)/g, function(all, letter){\n      return letter.toUpperCase()\n    })\n  }\n})\n\nA.fn.extend({\n  attr: function(...args){\n    if(args.length &#x3C; 1) {\n      return\n    }\n    if(args.length === 1) {\n      if(typeof args[0] === 'string') {\n        return this[0].getAttribute(args[0])\n      } else {\n        for(let i = 0; i &#x3C; this.length; i++) {\n          for(let key in args[0]) {\n            this[i].setAttribute(key, args[0][key])\n          }\n        }\n      }\n    } else {\n      for(let i = 0; i &#x3C; this.length; i++) {\n        this[i].setAttribute(args[0], args[1])\n      }\n    }\n    return this\n  },\n  html: function(...args){\n    console.log(args)\n    if(args.length) {\n      for(let i = 0; i &#x3C; this.length; i++) {\n        this[i].innerHTML = args[0]\n      }\n      return this\n    } else {\n      return this[0].innerHTML\n    }\n  },\n  css: function(...args){\n    if(args.length &#x3C; 1) {\n      return\n    }\n    if(args.length === 1) {\n      const name = args[0]\n      if(typeof args[0] === 'string') {\n        if(this[0].currentStyle){\n          return this[0].currentStyle[name]\n        } else {\n          return getComputedStyle(this[0], false)[name]\n        }\n      }else if(typeof args[0] === 'object') {\n        for(let i = 0; i &#x3C; this.length; i++) {\n          for(let key in args[0]) {\n            this[i].style[A.cameName(key)] = args[0][key]\n          }\n        }\n      }\n    } else {\n      const name = args[0]\n      for(let i = 0; i &#x3C; this.length; i++) {\n        this[i].style[A.cameName(name)] = args[1]\n      }\n    }\n    return this\n  }\n})\n</code></pre>\n<ul>\n<li>上面我们就实现了jquery常用的几个方法与链式调用，下面我们就可以使用上面的方法进行调用</li>\n</ul>\n<pre><code class=\"language-js\">a.css('background-color', '#0f0').html('我是链式调用').attr('data-tag', 'div').on('click', function(){\n    alert(this.innerHTML)\n})\n</code></pre>","fields":{"slug":"/jQuery/"},"frontmatter":{"title":"jquery选择器的实现","tags":["JavaScript回顾","设计模式","进修"],"categories":"JavaScript"}}},{"node":{"html":"<h1>事件绑定的两种优化方式</h1>\n<ul>\n<li>事件绑定在我们的项目中是经常存在的，但因为各浏览器对事件绑定的支持度不同，使我们不得不写一个兼容函数来实现事件绑定，常规的写法如下</li>\n</ul>\n<pre><code class=\"language-js\">function on(dom, type, fn){\n  if(document.addEventListener) { // IE9以上及主流浏览器\n    dom.addEventListener(type, fn, false)\n  } else if(document.attachEvent) { // IE8一下浏览器\n    dom.attachEvent('on' + type, fn)\n  } else { // dom0级支持浏览器\n    dom['on' + type] = fn\n  }\n}\n</code></pre>\n<ul>\n<li>上面的写法虽然能解决我们的问题，但是在页面中使用时，每绑定一次就要走一次逻辑判断，而这一部分其实是可以优化的，优化的方式一般有两种，一种是页面加载完毕便执行一个立即执行函数完成on的赋值，另一个则是在第一次调用的时候完成on的重新赋值</li>\n<li>页面加载完成赋值的实现如下</li>\n</ul>\n<!--more-->\n<pre><code class=\"language-js\">var on = (function(){\n  if(document.addEventListener) {\n    return function(dom, type, fn){\n      dom.addEventListener(type, fn)\n    }\n  } else if(document.attachEvent) {\n    return function(dom, type, fn){\n      dom.attachEvent('on' + type, fn)\n    }\n  } else {\n    return function(dom, type, fn){\n      dom['on' + type] = fn\n    }\n  }\n})()\n</code></pre>\n<ul>\n<li>通过开始的立即执行函数完成条件判断，并重新返回一个符合该浏览器兼容的绑定函数给on，这样在之后的函数绑定时就会使用这个返回的函数而不用再去判断一次浏览器情况</li>\n<li>缺陷就是在页面开始加载的时候就会执行，如果页面依赖比较多的情况下建议使用第二种方式</li>\n<li>第一次调用时绑定，也就是利用懒性模式实现绑定，实现方式如下</li>\n</ul>\n<pre><code class=\"language-js\">function on(dom, type, fn){\n  if(document.addEventListener) {\n    on = function(dom, type, fn){\n      dom.addEventListener(type, fn, false)\n    }\n  }else if(document.attachEvent) {\n    on = function(dom, type, fn){\n      dom.attachEvent('on' + type, fn)\n    }\n  } else {\n    on = function(dom, type, fn){\n      dom['on' + type] = fn\n    }\n  }\n  on(dom, type, fn)\n}\n</code></pre>\n<ul>\n<li>这种方式的实现是在浏览器判断条件完成之后对on重新赋值，并且在赋值之后进行函数的调用，这样在第一次执行之后on就被重新赋值，下次绑定就不会再走条件判断了，适用于首屏加载依赖比较多的情况</li>\n</ul>","fields":{"slug":"/lazy_event/"},"frontmatter":{"title":"事件绑定的两种优化方式","tags":["JavaScript回顾","设计模式","进修"],"categories":"JavaScript"}}},{"node":{"html":"<h1>字符串模板的实现</h1>\n<ul>\n<li>字符串模板是针对大批量、多频率操作dom的解决方案，比如我们要根据数据动态创建一个多嵌套的元素并将其插入到页面中，如果我们采用常规创建dom元素的方式进行插，代码量会极其庞大，下面就是常规方式实现的功能</li>\n</ul>\n<!--more-->\n<pre><code class=\"language-js\">// 源数据\nlet data = {\n  data: {\n    li: [\n      {\n        span: '我是span',\n        strong: '我是strong'\n      },\n      {\n        span: '我是span',\n        strong: '我是strong'\n      },\n      {\n        span: '我是span',\n        strong: '我是strong'\n      }\n    ],\n    h2: '我是第二标题',\n    p: '我是p标签'\n  },\n  id: 'containter',\n}\n\nfunction createDom(data){\n  let div = document.createElement('div')\n  div.id = data.id\n  let ul = document.createElement('ul')\n  let p = document.createElement('p')\n  let pt = document.createTextNode(data.data.p)\n  let h2 = document.createElement('h2')\n  let ph = document.createTextNode(data.data.h2)\n  p.appendChild(pt)\n  h2.appendChild(ph)\n  let liData = data.data.li\n  for(let i = 0, len = liData.length; i &#x3C; len; i++) {\n    let li = document.createElement('li')\n    let span = document.createElement('span')\n    let strong = document.createElement('strong')\n    let t = document.createTextNode(liData[i].strong)\n    let p = document.createTextNode(liData[i].span)\n    span.appendChild(p)\n    strong.appendChild(t)\n    li.appendChild(span)\n    li.appendChild(strong)\n    ul.appendChild(li)\n  }\n\n  div.appendChild(ul)\n  div.appendChild(p)\n  div.appendChild(h2)\n  document.body.appendChild(div)\n}\n</code></pre>\n<ul>\n<li>上面的方式可以看到在大批量的创造dom，然后不停地嵌套添加，代码量大，并且效率低下</li>\n<li>所以这里我们提供了一个模板字符串的函数来生成这个模板并最后插入到页面中，首先我们要提供一个字符串替换的一个函数用来将数据替换到页面中</li>\n</ul>\n<pre><code class=\"language-js\">// 替换字符串模板中的数据\nfunction formatString(str, data){\n  return str.replace(/\\{\\{(\\w+)\\}\\}/g, function(all, key){\n    return data[key]\n  })\n}\n</code></pre>\n<ul>\n<li>然后根据数据结构创建我们的模板字符串与生成模板字符串的函数</li>\n</ul>\n<pre><code class=\"language-js\">// 生成数据的函数\nfunction createStrTemplate(data){\n  let div = document.createElement('div')\n  div.id = data.id\n  // 获取li遍历的数据\n  let liData = data.data.li\n  let ulStr = ''\n  // 根元素div的子元素模板\n  let divStr = [\n    '&#x3C;p>{{p}}&#x3C;/p>',\n    '&#x3C;h2>{{h2}}&#x3C;/h2>',\n    '&#x3C;ul>{{ul}}&#x3C;/ul>'\n  ].join('')\n  // li的模板\n  let liStr = [\n    '&#x3C;li>',\n    '&#x3C;span>{{span}}&#x3C;/span>',\n    '&#x3C;strong>{{strong}}&#x3C;/strong>',\n    '&#x3C;/li>'\n  ].join('')\n  for(let i = 0, len = liData.length; i &#x3C; len; i++) {\n    // 遍历li数组生成li元素并将内里的数据进行填充\n    ulStr += formatString(liStr, liData[i])\n  }\n  // 将填充好的字符串作为ul的源数据进行赋值\n  data.data.ul = ulStr\n  // 对div模板内的数据进行替换，并作为html内容进行赋值\n  let divStrTemplate = formatString(divStr, data.data)\n  div.innerHTML = divStrTemplate\n  document.body.appendChild(div)\n}\n\ncreateStrTemplate(data)\n</code></pre>\n<ul>\n<li>这样便实现了我们的模板字符串函数，只操作了一次dom创建与一次添加便完成了功能，能极大地提升我们的执行效率</li>\n<li>上面得代码可以看到创建的模板字符串都是同名标签加同名变量，我们可以对其进行进一步的处理</li>\n<li>构造一个生产标签加变量的函数</li>\n</ul>\n<pre><code class=\"language-js\">// 此函数可以接收字符串或者数组来生产对应的标签加变量\nfunction view(name){\n  if(Object.prototype.toString.call(name) === '[object Array]') {\n    let str = ''\n    for(let i = 0, len = name.length; i &#x3C; len; i++) {\n      str += view(name[i])\n    }\n    return str\n  } else {\n    return `&#x3C;${name}>{{${name}}}&#x3C;/${name}>`\n  }\n}\n</code></pre>\n<ul>\n<li>有了这个函数之后我们就可以对上面得代码进行进一步的优化</li>\n</ul>\n<pre><code class=\"language-js\">function createStringTemplate(data){\n  let div = document.createElement('div')\n  div.id = data.id\n  // 生成div子元素模板\n  let divStr = view(['p', 'h2', 'ul'])\n  let ulStr = ''\n  let liData = data.data.li\n  // 这一句先是生成了li子元素的模板，生成了li模板，然后又将li子元素模板作为模板数据填充进li中\n  let liTpl = formatString(view('li'), {li: view(['span', 'strong'])})\n  for(let i = 0, len = liData.length; i &#x3C; len; i++) {\n    // 遍历li数组生成li元素并将内里的数据进行填充\n    ulStr += formatString(liTpl, liData[i])\n  }\n  data.data.ul = ulStr\n  // 对div模板内的数据进行替换，并作为html内容进行赋值\n  let divStrTemplate = formatString(divStr, data.data)\n  div.innerHTML = divStrTemplate\n  document.body.appendChild(div)\n}\n\ncreateStringTemplate(data)\n</code></pre>\n<ul>\n<li>以上便是我们最终版的利用模板字符串替换频繁的dom操作，极大程度的提升我们的执行效率</li>\n</ul>","fields":{"slug":"/string_template/"},"frontmatter":{"title":"字符串模板的实现","tags":["JavaScript回顾","设计模式","进修"],"categories":"JavaScript"}}},{"node":{"html":"<h1>Storage工具类的封装</h1>\n<ul>\n<li>日常开发中我们都会涉及到前端数据的存储，对一些需要长期保存在客户端的数据，我们通常会采用浏览器提供的localStorage对象，简称Storage对象。</li>\n<li>由于所有的页面处于同一个浏览器环境下，所以各个开发工程师所存储的Storage数据可能会出现同名情况，这样就会相互覆盖相互影响，所以为了解决这一问题，我们需要每个开发者都对自己的存储数据进行前缀命名好避免数据的污染</li>\n<li>Storage的存储api提供的比较简单，所以要实现这个功能就要我们进行进一步的封装与拓展，以实现我们的需求，首先我们构建一个Storage类，接收一个开发者id与数据分隔符（用于区分内容值与内容有效时间），并初始化状态对象</li>\n</ul>\n<!--more-->  \n<pre><code class=\"language-js\">function Storage(userId, sep){\n  this.userId = userId  // 开发者标识\n  this.sep = sep || '|_|'       // 数据分隔符\n  this.Storage = localStorage || window.localStorage\n  this.status = { // 操作状态值\n    FAILUER: 0,   // 失败\n    SUCCESS: 1,   // 成功\n    TIMEOUT: 2,   // 过期\n    OVERFLOW: 3   // 溢出\n  }\n}\n</code></pre>\n<ul>\n<li>之后我们需要对这个类提供操作方法，常用的方法为get,set,remove，get方法一般接受键名与一个回调函数，set接受键名，键值，有限期与回调函数，remove接收一个键名与一个回调函数，下面我们分别来实现这几个方法</li>\n<li>为了Storage实例可以调用这几个方法，所以我们将其绑定到Storage的原型上面</li>\n</ul>\n<pre><code class=\"language-js\">Storage.prototype = {\n  // 方便后续获取键名\n  getKey: function(key){\n    return this.userId + key\n  },\n  get: function(userKey, cb){\n    let key = this.getKey(userKey)\n    let status = this.status.SUCCESS\n    let value, sepIndex, time, result\n    try {\n      value = this.Storage.getItem(key)\n    } catch(e) {\n      value = null\n      status = this.status.FAILURE\n      result = {\n        value,\n        status\n      }\n      cb &#x26;&#x26; cb(result)\n      return result\n    }\n    if(value) {\n      sepIndex = value.indexOf(this.sep)\n      time = value.slice(0, sepIndex)\n      // 查看内容是否过期\n      if(new Date().getTime() &#x3C; new Date(time).getTime() || +time === 0){\n        value = value.slice(sepIndex + this.sep.length)\n      } else {\n        status = this.status.TIMEOUT\n        value = null\n        this.remove(key)\n      }\n    } else {\n      value = null\n    }\n    result = {\n      value,\n      status\n    }\n    cb &#x26;&#x26; cb(result)\n    return result\n  },\n  set: function(userKey, value, time, time = 0, cb){\n    let key = this.getKey(userKey)\n    let status = this.status.FAILURE\n    let result\n    // 是否设置时间，未设置默认一个月\n    try {\n      time = new Date(time).getTime()\n    } catch (e) {\n      time = new Date().getTime() + 30 * 24 * 60 * 60 * 1000\n    }\n    const realValue = time + this.sep + value\n    // 检查是否数据过多溢出\n    try {\n      this.Storage.setItem(key, realValue)\n    } catch (e) {\n      status = this.status.OVERFLOW\n    }\n    result = {\n      status\n    }\n    cb &#x26;&#x26; cb(result)\n    return result\n  },\n  remove: function(userKey, cb){\n    let status = this.status.FAILUER\n    let key = this.getKey(userKey)\n    let result\n    try {\n      this.Storage.removeItem(key)\n      status = this.status.SUCCESS\n    } catch(e) {\n    }\n    result = {\n      status\n    }\n    cb &#x26;&#x26; cb(result)\n    return result\n  }\n}\n</code></pre>\n<ul>\n<li>上面就是我们对Storage操作方法的实现，实现很简单，主要是处理一下各个情况下的状态值还有错误屏蔽，防止意外报错</li>\n<li>下面我们可以尝试一下为张三设置一下存储信息</li>\n</ul>\n<pre><code class=\"language-js\">let zsStorage = new Storage('zhangsan-')\nmyStorage.set('name', '张三')  // zhangsan-name: 0|_|张三\nmyStorage.get('name')         // {value: '张三', status: 1}\nmyStorage.remove('name')\n</code></pre>\n<ul>\n<li>这样一来就可以实现了一个适合我们使用的Storage的工具类</li>\n</ul>","fields":{"slug":"/storage/"},"frontmatter":{"title":"storage工具类的封装","tags":["JavaScript回顾","设计模式","进修"],"categories":"JavaScript"}}},{"node":{"html":"<h1>栈</h1>\n<ul>\n<li>栈是我们经常听到的数据结构，拥有后入先出的特性，可以理解为存放箱子的过程，存的时候后来的都放到先来的上面，取得时候也是从上面往下取，因为上面都是后来的箱子，所以会被先取出来</li>\n<li>JavaScript并没有栈这个数据类型，所以需要我们手动来实现，因为要涉及到一堆数据的存储，并且有先后顺序，还能实现存入与取出，最理想的实现数据类型自然就是我们的数组了，下面我们来实现一下栈</li>\n<li>首先定义一个栈类，应该拥有一个存放数据的数组，以及标记最上面元素的一个标记</li>\n</ul>\n<pre><code class=\"language-js\">function Stack(){\n  this.top = 0\n  this.dataStore = []\n}\n</code></pre>\n<!--more-->\n<ul>\n<li>上面就是一个栈的基本属性了，接下来就是栈拥有的方法，分别为存入，取出,因为所有的栈都有这些方法，所以我们定义在Stack的原型上</li>\n</ul>\n<pre><code class=\"language-js\">Stack.prototype = {\n  insert: function(data){\n    // 因为top初始值为0，所以我们可以采用后加加的方式实现赋值后对top的加一来标识下一个位置\n    this.dataStore[this.top++] = data\n  },\n  pop: function(){\n    // 这里要移除最后一个元素并返回，这里top已经指向了下一个位置，所以我们返回元素需要前减减来返回我们最顶部的元素。而且我们并没有用数组pop的方式对数组进行改变，因为我们的插入方式是针对下标赋值的，只需要将下标改到最后一个元素，这样下次插入就会直接改变最后一个值了\n    return this.dataStore[--this.top] \n  },\n  peek: function(){\n    // 这里我们只是要获取栈顶元素，并不是要从栈中移除元素，所以我们不改变top值\n    return this.dataStore[this.top - 1]\n  },\n  length: function(){\n    return this.top\n  }\n}\n</code></pre>\n<ul>\n<li>上面就是一个完整的数据类型栈的实现，我们可以拿来尝试一下栈的经典案例</li>\n</ul>\n<h2>栈实现进制转换</h2>\n<ul>\n<li>进制转换的方式，对一个数值，不停的整除以要转换的进制，取余数后继续整除以，直到最后整除以后为0截至，然后将所有余数倒置拼接即可拿到转换后的数值，按照这个规则，我们可利用栈来进行进制转换</li>\n</ul>\n<pre><code class=\"language-js\">function toFixed(number, fix){\n  let stack = new Stack()\n  let str = ''\n  while(number > 0) {\n    stack.insert(number % fix)\n    number = Math.floor(number / fix)\n  }\n  while(stack.length() > 0) {\n    str += stack.pop()\n  }\n  return str\n}\n\ntoFixed(12, 2) // 1100\n</code></pre>","fields":{"slug":"/stack/"},"frontmatter":{"title":"JavaScript中实现数据结构栈","tags":["JavaScript回顾","数据结构","进修"],"categories":"数据结构"}}},{"node":{"html":"<h1>队列</h1>\n<ul>\n<li>队列也是我们编程当中经常用到的一个数据结构，具有先入先出的特性，跟平时我们的排队一样，先进来先走</li>\n<li>同样，JavaScript并没有队列这个数据类型，所以需要我们自己来实现，因为队列同样具有顺序，且可以存入与去除，所以我们采用数组来做一个简单的实现</li>\n<li>首先定义一个队列类，因为只涉及到数据的存储，所以初始设置一个容器就可以</li>\n</ul>\n<pre><code class=\"language-js\">function Quene(){\n  this.dataStore = []\n}\n</code></pre>\n<ul>\n<li>上面就是一个队列的基本属性了，接下来就是队列拥有的方法，分别为入队，出队,获取队首元素，队尾元素，队列是否为空</li>\n</ul>\n<!--more-->\n<pre><code class=\"language-js\">Quene.prototype = {\n  enquene: function(data){\n    // 队列元素只能添加到队列最后面，所以我们直接使用数组push方法即可\n    this.dataStore.push(data)\n  },\n  dequene: function(){\n    // 队列元素出队是移除第一个元素，可以使用数组的shift方法移除数组的第一个元素\n    return this.dataStore.shift()\n  },\n  front: function(){\n    // 查询队首的元素\n    return this.dataStore[0]\n  },\n  back: function(){\n    // 查询队尾的元素\n    return this.dataStore[this.dataStore.length - 1]\n  },\n  isEmpty: function(){\n    return this.dataStore.length === 0 ? true : false\n  },\n  toString: function(){\n    // 用于遍历展示队列的元素\n    let str = ''\n    for(let i = 0; i &#x3C; this.dataStore.length; i++) {\n      str += '下一个是: ' + this.dataStore[i] + ' ,'\n    }\n    return str\n  }\n}\n</code></pre>\n<ul>\n<li>上面就是一个完整的数据类型队列的实现，我们可以拿来尝试一下队列的经典案例</li>\n</ul>\n<h2>队列实现舞池效果</h2>\n<ul>\n<li>舞池效果，舞池可供男女组队跳舞，但是男女的人数都不固定，所以需要一套匹配系统，当同时有男生女生排队时则播报入场男生名字与女方入场名字，若是只有男生或者女生，则播报男生或者女生的等待名称</li>\n<li>根据这个需求，我们需要确立一个舞者的类，具有性别与姓名的属性</li>\n</ul>\n<pre><code class=\"language-js\">// 舞者类\nfunction Dancer(name, sex){\n  this.name = name\n  this.sex = sex\n}\n\n// 跳舞者的文档资料，前面为性别，后面为名称\nlet dancers = `\nF A\nM B\nF C\nM D\nF E\nM F\nM G\n`\n// 用于存储男女舞者\nlet M = new Quene()\nlet F = new Quene()\n\nfunction initDancer(){\n  let dancerArr = dancers.split('\\n')\n  // 剔除空字符串\n  dancerArr = dancerArr.filter(item => {\n    if(item.trim()) {\n      return item.trim()\n    }\n  })\n  // 对所有舞者进行分组排列\n  dancerArr.forEach(item => {\n    let name = item.split(' ')[1], sex = item.split(' ')[0]\n    if(sex === 'F') {\n      F.enquene(new Dancer(name, sex))\n    } else {\n      M.enquene(new Dancer(name, sex))\n    }\n  })\n}\n\ninitDancer()\n\nfunction dancer(){\n  console.log('The dancer parters are \\n')\n  while(!M.isEmpty() &#x26;&#x26; !F.isEmpty()) {\n    console.log(`男方入场者为：${ M.dequene().name }，女方入场者为${ F.dequene().name }`)\n  }\n  if(!M.isEmpty()){\n    console.log(`男方等待区为：${ M.dequene().name }`)\n  }\n  if(!F.isEmpty()){\n    console.log(`女方等待区为: ${ F.dequene().name }`)\n  }\n}\n\ndancer()\n// The dancer parters are \n// 男方入场者为：B，女方入场者为A\n// 男方入场者为：D，女方入场者为C\n// 男方入场者为：F，女方入场者为E\n// 男方等待区为：G\n</code></pre>","fields":{"slug":"/quene/"},"frontmatter":{"title":"JavaScript中实现数据结构队列","tags":["JavaScript回顾","数据结构","进修"],"categories":"数据结构"}}},{"node":{"html":"<h1>react hooks 下使用redux</h1>\n<h2>redux</h2>\n<ul>\n<li>redux是近年来javascript中火热的状态管理容器，提供可预测的全局状态管理。在大型的应用中我们常采用redux来进行状态管理，redux的基本使用方式如下</li>\n<li>使用redux，我们先要进行action的编写，action一般由type与其他相关数据构成，下面就是简单的两个action</li>\n</ul>\n<pre><code class=\"language-js\">const INCREMENT = 'INCREMENT'\nconst DECREMENT = 'DECREMENT'\n\n// 数字增加action\n{ type: INCREMENT, payload: number }\n\n// 数字减少action\n{ type: DECREMENT, payload: number }\n</code></pre>\n<!--more-->\n<ul>\n<li>接下来，我们就要根据action来进行我们的reducer编写,reducer是一个函数，具有两个初始值，一个是当前的状态值state，一个是当前的操作模式action</li>\n<li>我们要根据当前的操作模式进行相应的逻辑处理，并返回新的state,这里我们为state设置一个初始值 0，对应INCREMENT与DECREMENT分别进行加减操作</li>\n</ul>\n<pre><code class=\"language-js\">const initialState = 0\n\nconst numberReducer = (state = initialState, action) => {\n  switch(action.type) {\n    case INCREMENT:\n      return state + action.payload\n    case DECREMENT:\n      return state - action.payload\n    default:\n      return state\n  }\n}\n</code></pre>\n<ul>\n<li>上面只是定义了操作形式与如何响应该操作，并没有实际的进行触发，触发状态改变需要redux提供的dispatch,dispatch接收一个action并将这个action传递给reducer，从而触发最后的状态改变，如下</li>\n</ul>\n<pre><code class=\"language-js\">dispatch({ type: DECREMENT, payload: number })\n</code></pre>\n<h2>react中使用redux</h2>\n<ul>\n<li>react hooks出来之前，redux几乎是所有react项目的不二只选，但是其复杂的使用方式让许多开发者都头疼，对萌新来说更是要命，上网查了都不知道是怎么回事</li>\n<li>hooks的出现，解放了一大批的react的开发者，易上手的开发模式让开发者使用极其简单，而react-redux自然也不会放过hooks的这波狂潮，下面就让我们对比一下hooks前后的两种redux使用形式</li>\n</ul>\n<h3>react中使用redux</h3>\n<ul>\n<li>react中使用redux需要借助三方库react-redux，react-redux提供了connect来让我们在组件中使用redux，如下使用</li>\n</ul>\n<pre><code class=\"language-js\">import React from 'react'\nimport { connect } from 'react-redux'\n\nclass Test extends React.Component {\n  constructor(){\n    super()\n  }\n  mapStateToProps(state) {\n    return {\n      number: state.number\n    }\n  }\n\n  mapDispatchToProps(dispatch) {\n    return {\n      increment: (number) => dispatch({ type: 'INCREMENT', payload: number }),\n      decrement: (number) => dispatch({ type: 'DECREMMENT', payload: number }),\n    }\n  }\n\n  render() {\n    return (\n      &#x3C;div>\n        &#x3C;div>{ this.props.number }&#x3C;/div>\n        &#x3C;button onClick={() => { this.props.increment(10) }}>增加10&#x3C;/button>\n        &#x3C;button onClick={() => { this.props.decrement(5) }}>减少5&#x3C;/button>\n      &#x3C;/div>\n    )\n  }\n\n}\n\nexport default connect(mapStateToProps, mapDispatchToProps)(Test)\n</code></pre>\n<h2>react hooks中使用redux</h2>\n<ul>\n<li>hooks中使用redux需要依靠react-redux提供的 useSelector 与 useDispatch进行state取值与dispatch执行修改操作</li>\n<li>useSelector会根据接受的函数返回需要的状态值，如下面的number</li>\n<li>useDispatch会返回一个操作函数，返回的操作函数可以接收一个action执行状态值的修改</li>\n</ul>\n<pre><code class=\"language-js\">import * as React from 'react'\nimport { useSelector, useDispatch } from 'react-redux'\n\nconst Test = () => {\n  const number = useSelector(state => state.number)\n  const dispatch = useDispatch()\n  return (\n      &#x3C;div>\n        &#x3C;div>{ this.props.number }&#x3C;/div>\n        &#x3C;button onClick={() => { dispatch({ type: 'INCREMENT', payload: 10 }) }}>增加10&#x3C;/button>\n        &#x3C;button onClick={() => { dispatch({ type: 'DECREMMENT', payload: 5 }) }}>减少5&#x3C;/button>\n      &#x3C;/div>\n    )\n}\n\nexport default Test\n</code></pre>","fields":{"slug":"/redux-hooks/"},"frontmatter":{"title":"react hooks下使用react-redux","tags":["react","react hooks","redux"],"categories":"React"}}},{"node":{"html":"<h1>从零搭建一个react-hooks项目（一）</h1>\n<ul>\n<li>最近有打算仿vue-admin项目构造一个react的项目，不引用官方脚手架，从webpack开始配置一套基于react,redux,typescript的项目，并实时记录一下项目中的一些配置情况</li>\n<li>首先搭建一个基本的webpack环境</li>\n</ul>\n<h2>webpack项目搭建</h2>\n<ul>\n<li>前置基础，电脑有安装node环境，可以使用npm工具</li>\n<li>新建文件夹，命名项目名称（react-admin）,进入文件夹，使用命令 npm init ，然后一路确定生成package.json文件</li>\n<li>webpack需要安装基本依赖 webpack webpack-cli webpack-dev-server, 命令为 npm i webpack webpack-cli webpack-dev-server -D</li>\n<li>安装依赖完成，则需要进行webpack的基本配置，我们在根目录构建 webpack.config.js 文件用于配置webpack</li>\n<li>然后在根目录创建一个index.js作为入口文件，我们先构造index.js这个入口文件，代码如下</li>\n</ul>\n<!--more-->\n<pre><code class=\"language-js\">function a(number){\n  console.log(number)\n}\na(12)\n</code></pre>\n<ul>\n<li>然后开始配置我们的webpack，webpack需要配置入口及输出位置，分别对应entry与output属性</li>\n<li>entry可以接收一个字符串作为主入口的文件路径，但只能用于单入口项目。也可以接收一个对象作为入口的文件路径，如下所示</li>\n<li>output用来描述打包后的文件应该放到哪，叫什么名字，也有两个基本属性，一个是打包后的文件名，一个是打包后的文件路径，这里我们通过[name].js来获取他在入口文件中的对应名称并生成文件名，如果是单入口并且直接用字符串指定的文件路径，比如entry: './index.js'，这样最后生成的文件名就是main.js，如果采用对象形式设定的entry属性，比如entry: { app: './index.js' }，则最后生成的文件就是对应的键值app.js。 路径使用path.resolve()来在根目录下生成dist文件夹并将打包文件放到其中</li>\n</ul>\n<pre><code class=\"language-js\">const path = require('path') // node环境自带，无需下载\n// 单入口文件\nmodule.exports = {\n  entry: './index.js', // 入口为index.js\n  output: {  // 输出就是 dist/main.js\n    filename: '[name].js',\n    path: path.resolve(__dirname, 'dist')\n  }\n}\n\n// 多入口文件\nmodule.exports = {\n  entry: { // 入口也是index.js\n    app: './index.js'\n  }, \n  output: {  // 输出为dist/app.js\n    filename: '[name].js',\n    path: path.resolve(__dirname, 'dist')\n  }\n}\n</code></pre>\n<ul>\n<li>配置到这就算完成了最基本的配置，我们可以来测试一下，先在package.json中的 scripts 下新建指令 \"start\": \"webpack --config webpack.config.js\"</li>\n<li>然后再执行npm run start 就可以看到执行了打包过程，生成了dist文件夹</li>\n<li>这里我们完成了基本的配置，但是这里还有一个问题，当我们修改entry对应的文件名时，重新执行打包，会发现之前的打包文件还存在，这样就会导致我们的dist文件夹会包含很多之前打包的跟当前代码无关的文件，这样其实对我们的项目并不友好，这里我们想要在每次打包的时候都把dist给移除了，并重新生成</li>\n<li>clean-webpack-plugin 插件可以帮助我们实现这个需求，先下载这个包  npm i clean-webpack-plugin -D</li>\n<li>然后在webpack.config.js中进行配置，如下，plugins用于我们配置我们想要的相关插件，接收一个数组值，这样我们的项目就可以在每次打包前都将dist清空了，就不会存在无用文件在内了</li>\n</ul>\n<pre><code class=\"language-js\">const path = require('path')\nconst { CleanWebpackPlugin } = require('clean-webpack-plugin');\n\nmodule.exports = {\n  entry: {\n    app: './index.js'\n  },\n  output: {\n    filename: '[name].js',\n    path: path.resolve(__dirname, 'dist'),\n    chunkFilename: '[name].bundle.js'\n  },\n  plugins: [\n    new CleanWebpackPlugin()\n  ]\n}\n</code></pre>\n<ul>\n<li>接下来就让我们开始配置react相关吧，react开发中我们会用到jsx或者es6的语法，而这些语法在低版本浏览器都是不兼容的，所以我们需要配置babel来实现低版本浏览器的兼容</li>\n<li>这里我们需要下载 babel-loader @babel/preset-env(根据环境转换代码) @babel/preset-react(react使用) @babel/preset-polyfill(Babel默认只转换新的JavaScript语法，但是不转换新的API，比如 <code>Iterator</code>、<code>Generator</code>、<code>Set</code>、<code>Maps</code>、<code>Proxy</code>、<code>Reflect</code>、<code>Symbol</code>、<code>Promise</code> 等全局对象，以及一些定义在全局对象上的方法（比如<code>Object.assign</code> ）都不会转码。而<code>@babel/preset-polyfill</code>可以转码。) @babel/proposal-object-rest-spread(处理react中对象的rest写法) @babel/proposal-object-rest-spread (处理类里面的箭头函数this绑定，static属性等 ), 依赖下载完成后就需要进行babel配置了</li>\n<li>我们在根目录构建 .babelrc 文件，内里配置如下</li>\n</ul>\n<pre><code class=\"language-js\">{\n  \"presets\": [\n    \"@babel/preset-env\",\n    \"@babel/preset-react\"\n  ],\n  \"plugins\": [\n    \"@babel/proposal-object-rest-spread\", // 处理对象的rest写法\n    \"@babel/proposal-class-properties\" // 处理类里面的箭头函数绑定，static属性等 \n  ]\n}\n</code></pre>\n<ul>\n<li>然后就需要在webpack里面配置编译规则了，还是在webpack.config.js里面，新增module模块，添加不同文件的解析规则，如下</li>\n</ul>\n<pre><code class=\"language-js\">module.exports = {\n  entry: {\n    app: './index.js'\n  },\n  output: {\n    filename: '[name].js',\n    path: path.resolve(__dirname, 'dist'),\n    chunkFilename: '[name].bundle.js'\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.(js)x?$/,\n        use: ['babel-loader'],\n        exclude: /node-modules/ // 不解析node_modules中的文件\n      }\n    ]\n  },\n  plugins: [\n    new CleanWebpackPlugin()\n  ]\n}\n</code></pre>\n<ul>\n<li>然后我们可以写代码来测试一下，react 要基于 dom 展示，所以我们新建一个index.html用于dom展示，index.jsx用于执行react挂载，新建一个文件夹src用于放置react相关的组件及内里逻辑，并在里面新建一个app.jsx用于做初始组件，代码分别如下</li>\n</ul>\n<pre><code class=\"language-js\">// index.html\n&#x3C;!DOCTYPE html>\n&#x3C;html lang=\"en\">\n&#x3C;head>\n  &#x3C;meta charset=\"UTF-8\">\n  &#x3C;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  &#x3C;title>Document&#x3C;/title>\n&#x3C;/head>\n&#x3C;body>\n  \n&#x3C;div id=\"app\">&#x3C;/div>\n&#x3C;script src=\"./dist/app.js\">&#x3C;/script>\n&#x3C;script src=\"./dist/test.js\">&#x3C;/script>\n&#x3C;/body>\n&#x3C;/html>\n</code></pre>\n<pre><code class=\"language-js\">// index.jsx\nimport * as React from 'react'\nimport * as ReactDOM from 'react-dom'\nimport App from './src/app.jsx'\nReactDOM.render(\n  &#x3C;App/>\n  ,document.querySelector('#app')\n)\n</code></pre>\n<pre><code class=\"language-js\">// app.jsx\nimport * as React from 'react'\nclass App extends React.Component{\n  render(){\n    return (\n      &#x3C;div>123&#x3C;/div>\n    )\n  }\n}\nexport default App\n</code></pre>\n<ul>\n<li>然后需要在我们的webpack配置中新增加一个入口文件，如我们在html中的引入一样，需要命名为test，配置如下</li>\n</ul>\n<pre><code class=\"language-js\">module.exports = {\n  entry: {\n    app: './index.js',\n    test: './index.jsx'\n  },\n  ...// 省略\n}\n</code></pre>\n<ul>\n<li>接下来执行npm run start 执行打包，打包完成后打开页面 index.html 查看就可以发现已经插入了123进去</li>\n<li>这里我们可以发现我们需要新建一个index.html然后再主动根据生成的文件路径将其引入进去，要是生成的文件比较多则会很麻烦，所以我们接下来使用插件让其自动生成</li>\n<li>首先下载插件 html-webpack-plugin，命令为 npm i html-webpack-plugin</li>\n<li>然后再webpack.config.js里进行相关配置，还是用在plugins模块中，如下所示</li>\n</ul>\n<pre><code class=\"language-js\">const path = require('path')\nconst webpack = require('webpack')\nconst { CleanWebpackPlugin } = require('clean-webpack-plugin');\nconst HTMLWebpackPlugin = require('html-webpack-plugin')\n\nmodule.exports = {\n  entry: {\n    app: './index.js',\n    test: './index.jsx'\n  },\n  output: {\n    filename: '[name].js',\n    path: path.resolve(__dirname, 'dist'),\n    chunkFilename: '[name].bundle.js'\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.(js)x?$/,\n        use: ['babel-loader'],\n        exclude: /node-modules/\n      }\n    ]\n  },\n  plugins: [\n    new HTMLWebpackPlugin({\n      inject: true, // 所有js脚本放于body之后\n      hash: true, // 为静态资源生成hash，用于清楚缓存\n      cache: true, // 仅在文件被更改时发出文件\n      title: 'react admin',\n      filename: 'index.html',\n      template: path.resolve(__dirname, 'index.html'),\n      minify: {\n        collapseWhitespace: true, // 折叠空白\n        removeComments: true, // 删除注释\n        removeRedundantAttributes: true,\n        removeScriptTypeAttributes: true,\n        removeStyleLinkTypeAttributes: true\n      }\n    }),\n    new CleanWebpackPlugin()\n  ]\n}\n</code></pre>\n<ul>\n<li>然后在根目录放置我们的模板index.html，不需要主动引入js文件了，内容如下</li>\n</ul>\n<pre><code class=\"language-js\">// index.html\n&#x3C;!DOCTYPE html>\n&#x3C;html lang=\"en\">\n&#x3C;head>\n  &#x3C;meta charset=\"UTF-8\">\n  &#x3C;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  &#x3C;title>react admin&#x3C;/title>\n&#x3C;/head>\n&#x3C;body>\n  \n&#x3C;div id=\"app\">&#x3C;/div>\n&#x3C;/body>\n&#x3C;/html>\n</code></pre>\n<ul>\n<li>之后再执行我们的npm run start 就可以在dist中自动生成我们的index.html文件了，直接打开就能发现已经有我们要渲染的内容了</li>\n<li>react相关的就配置完成了，接下来我们需要配置一下css部分，开发中以less作为示例配置一下</li>\n<li>首先安装相关的依赖 less-loader style-loader postcss-loader css-loader autoprefixer，命令为 npm i less-loader style-loader postcss-loader css-loader autoprefixer -D</li>\n<li>接下来进行webpack配置，用以处理less文件的解析及处理</li>\n<li>还是在 module 下面的 rules 中配置规则，如下</li>\n</ul>\n<pre><code class=\"language-js\">const path = require('path')\nconst webpack = require('webpack')\nconst { CleanWebpackPlugin } = require('clean-webpack-plugin');\nconst HTMLWebpackPlugin = require('html-webpack-plugin')\n\nmodule.exports = {\n  entry: {\n    app: './index.js',\n    test: './index.jsx'\n  },\n  output: {\n    filename: '[name].js',\n    path: path.resolve(__dirname, 'dist'),\n    chunkFilename: '[name].bundle.js'\n  },\n  module: {\n    rules: [\n      { \n        test: /\\.(le|c)ss$/,\n        use: [ // 解析规则为从右向左，即 less-loader, postcss-loader, css-loader, style-loader\n          'style-loader',\n          {\n            loader: 'css-loader',\n            options: {\n              sourceMap: true //是否打开样式查找\n            }\n          },\n          {\n            loader: 'postcss-loader', // 为浏览器加前缀\n            options: {\n              ident: 'postcss',\n              sourceMap: true,\n              plugins: loaders => [\n                require('autoprefixer')({\n                })\n              ]\n            }\n          },\n          {\n            loader: 'less-loader', // 解析样式文件\n            options: {\n              sourceMap: true\n            }\n          }\n        ]\n      },\n      {\n        test: /\\.(js)x?$/,\n        use: ['babel-loader'],\n        exclude: /node-modules/\n      }\n    ]\n  },\n  plugins: [\n    new HTMLWebpackPlugin({\n      inject: true, // 所有js脚本放于body之后\n      hash: true, // 为静态资源生成hash，用于清楚缓存\n      cache: true, // 仅在文件被更改时发出文件\n      title: 'react admin',\n      filename: 'index.html',\n      template: path.resolve(__dirname, 'index.html'),\n      minify: {\n        collapseWhitespace: true, // 折叠空白\n        removeComments: true, // 删除注释\n        removeRedundantAttributes: true,\n        removeScriptTypeAttributes: true,\n        removeStyleLinkTypeAttributes: true\n      }\n    }),\n    new CleanWebpackPlugin()\n  ]\n}\n</code></pre>\n<ul>\n<li>配置完成之后我们简单做个测试，在app.jsx目录下新建app.less文件，并简单书写样式</li>\n</ul>\n<pre><code class=\"language-css\">.red{\n  color: red;\n  .blue{\n    background: blue;\n  }\n  .orange{\n    background: orange;\n  }\n}\n</code></pre>\n<ul>\n<li>修改app.jsx中的渲染内容为</li>\n</ul>\n<pre><code class=\"language-js\">import * as React from 'react'\nimport './app.less'\n\nclass App extends React.Component{\n  render(){\n    return (\n      &#x3C;div className=\"red\">\n        &#x3C;div className=\"blue\">123&#x3C;/div>\n        &#x3C;div className=\"orange\">345&#x3C;/div>\n      &#x3C;/div>\n    )\n  }\n}\n\nexport default App\n</code></pre>\n<ul>\n<li>然后执行npm run start,之后打开dist中的index.html，就发现样式已经生效了，然后F12打开开发者工具调试，能查找到对应的div生效样式的所在位置</li>\n<li>上面就完成了一个简单的demo，接下来就是要针对项目做一些配置化了</li>\n</ul>","fields":{"slug":"/react_md_1/"},"frontmatter":{"title":"从零搭建一个react-hooks项目（一）","tags":["react","react hooks","redux","webpack"],"categories":"Webpack"}}},{"node":{"html":"<h1>从零搭建一个react-hooks项目（二）</h1>\n<ul>\n<li>上一篇搭建了基本的webpack项目，可以支持react，less的基本使用，但是没有考虑到项目中的实际情况，例如生产环境的代码混淆，代码压缩，开发环境的热启动等。</li>\n<li>下面我们就针对开发与生产环境的不同需求，对webpack进行下一步的配置</li>\n<li>生产环境的配置与开发环境的配置有很多的不同点，所以我们需要分别建对应的配置文件，在根目录下分别创建 webpack.prod.js（生产配置） 与webpack.dev.js（开发配置）</li>\n<li>然后在package.json中的scripts里新建两个命令，分别是 \"build\": \"webpack --config webpack.prod.js\", \"dev\": \"webpack --config webpack.dev.js\"</li>\n</ul>\n<h2>开发环境的配置</h2>\n<ul>\n<li>先将webpack.config.js中的配置复制到webpack.dev.js中，然后进行我们的基本配置修改</li>\n<li>首先开发中需要对错误进行一个精准定位，所以在配置中开启 devtool: \"inline-source-map\"，如下所示</li>\n<li>css的样式覆盖关系在我们之前的开发中就已经使用了source: map的属性，所以可以在开发环境中继续使用</li>\n</ul>\n<!--more-->\n<pre><code class=\"language-js\">const path = require('path')\nconst webpack = require('webpack')\nconst { CleanWebpackPlugin } = require('clean-webpack-plugin');\nconst HTMLWebpackPlugin = require('html-webpack-plugin')\n\nmodule.exports = {\n  entry: {\n    app: './index.js',\n    test: './index.jsx'\n  },\n  output: {\n    filename: '[name].js',\n    path: path.resolve(__dirname, 'dist'),\n    chunkFilename: '[name].bundle.js'\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.(le|c)ss$/,\n        use: [\n          'style-loader',\n          {\n            loader: 'css-loader',\n            options: {\n              sourceMap: true //是否打开样式查找\n            }\n          },\n          {\n            loader: 'postcss-loader', // 为浏览器加前缀\n            options: {\n              ident: 'postcss',\n              sourceMap: true,\n              plugins: loaders => [\n                require('autoprefixer')({\n                })\n              ]\n            }\n          },\n          {\n            loader: 'less-loader', // 解析样式文件\n            options: {\n              sourceMap: true\n            }\n          }\n        ]\n      },\n      {\n        test: /\\.(js)x?$/,\n        use: ['babel-loader'],\n        exclude: /node-modules/\n      }\n    ]\n  },\n  devtool: 'inline-source-map',\n  plugins: [\n    new HTMLWebpackPlugin({\n      inject: true, // 所有js脚本放于body之后\n      hash: true, // 为静态资源生成hash，用于清楚缓存\n      cache: true, // 仅在文件被更改时发出文件\n      title: 'react admin',\n      filename: 'index.html',\n      template: path.resolve(__dirname, 'index.html'),\n      minify: {\n        collapseWhitespace: true, // 折叠空白\n        removeComments: true, // 删除注释\n        removeRedundantAttributes: true,\n        removeScriptTypeAttributes: true,\n        removeStyleLinkTypeAttributes: true\n      }\n    }),\n    new CleanWebpackPlugin()\n  ]\n}\n</code></pre>\n<ul>\n<li>接着在我们的开发过程中我们不希望每做一次改动都需要手动的执行一次npm run dev，所以我们这里使用我们的webpack-dev-server来为我们提供node的静态服务，配合webpack的打包可以让我们实现实时更新，实时显示，不需要手动触发npm run dev命令来进行刷新</li>\n<li>首先我们修改package.json中的dev命令为:\"webpack-dev-server --open --config webpack.dev.js\"</li>\n<li>接下来就需要对该静态服务进行配置，配置项放在配置中的devServer下面，如下</li>\n</ul>\n<pre><code class=\"language-js\">const path = require('path')\nconst webpack = require('webpack')\nconst { CleanWebpackPlugin } = require('clean-webpack-plugin');\nconst HTMLWebpackPlugin = require('html-webpack-plugin')\n\nmodule.exports = {\n  entry: {\n    ...\n  },\n  output: {\n    ...\n  },\n  module: {\n    ...\n  },\n  devtool: 'inline-source-map',\n  plugins: [\n    ...\n  ],\n  devServer: {\n    contentBase: './dist', // 静态文件目录，用于浏览器显示\n    clientLogLevel: 'warning',  // 输出日志级别\n    hot: true, // 启动热更新\n    publicPath: '/', // 浏览器访问路径\n    compress: true, // 启用gzip压缩\n    port: 9998,\n    open: true, // 自动调起浏览器\n    overlay: { // 出现错误或警告是否覆盖页面线上错误信息\n      warnings: true,\n      errors: true\n    },\n    quiet: true,\n    proxy: { // 代理\n    },\n    watchOptions: { // 监控文件相关配置\n      poll: true,\n      ignored: /node_modules/,\n      aggregateTimeout: 300  // 默认值, 当你连续改动时候, webpack可以设置构建延迟时间(防抖)\n    }\n  }\n}\n</code></pre>\n<ul>\n<li>然后在执行我们的npm run dev就可以发现会自动帮我们打开浏览器，然后当我们修改主要文件的时候也会重新帮我们刷新页面</li>\n<li>上面的自动刷新在某些场景下会有一些问题，当依赖的模块发生改变时可能当前的页面绑定关系不能即时刷新，所以我们需要引入新的模块来进行问题修复</li>\n<li>webpack 自带模块热替换插件 HotModuleReplacementPlugin ，使用时只需要引入webpack，然后在plugin中添加 new webpack.HotModuleReplacementPlugin()即可解决部分依赖刷新不及时的问题，如下</li>\n</ul>\n<pre><code class=\"language-js\">...\nconst webpack = require('webpack')\n\nmodule.exports = {\n  entry: {\n    ...\n  },\n  output: {\n    ...\n  },\n  module: {\n    ...\n  },\n  devtool: 'inline-source-map',\n  plugins: [\n    new webpack.HotModuleReplacementPlugin(),\n    ...\n  ],\n  devServer: {\n    ...\n  }\n}\n</code></pre>\n<ul>\n<li>再次执行npm run dev就能实时的更改代码并实时刷新了，至此，开发环境的基本配置就完成了</li>\n</ul>\n<h2>生产环境的构建</h2>\n<ul>\n<li>生产环境为了客户的体验与代码的隐私性，我们一般都会对代码进行混淆压缩，包括css与js代码的压缩，下面我们就来进行相关的配置</li>\n<li>首先还是将我们之前的webpack.config.js中的基本配置复制到webpack.prod.js中，然后在此基础上进行相关的修改</li>\n<li>上一章中我们将output中的filename命名为[name].js与入口文件一致，在生产环境中，为了避免名称一致导致的缓存问题，我们要对其进行修改</li>\n<li>修改为[name].[chunkhash].js，这样在生成文件的时候会默认添加一个hash值，避免缓存问题的出现，修改如下</li>\n</ul>\n<pre><code class=\"language-js\">// 先贴一下上一章最后的配置内容，后续不再完整展示\nconst path = require('path')\nconst webpack = require('webpack')\nconst { CleanWebpackPlugin } = require('clean-webpack-plugin');\nconst HTMLWebpackPlugin = require('html-webpack-plugin')\n\nmodule.exports = {\n  entry: {\n    app: './index.js',\n    test: './index.jsx'\n  },\n  output: {\n    filename: '[name].[chunkhash].js',\n    path: path.resolve(__dirname, 'dist'),\n    chunkFilename: '[name].bundle.js'\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.(le|c)ss$/,\n        use: [\n          'style-loader',\n          {\n            loader: 'css-loader',\n            options: {\n              sourceMap: true //是否打开样式查找\n            }\n          },\n          {\n            loader: 'postcss-loader', // 为浏览器加前缀\n            options: {\n              ident: 'postcss',\n              sourceMap: true,\n              plugins: loaders => [\n                require('autoprefixer')({\n                })\n              ]\n            }\n          },\n          {\n            loader: 'less-loader', // 解析样式文件\n            options: {\n              sourceMap: true\n            }\n          }\n        ]\n      },\n      {\n        test: /\\.(js)x?$/,\n        use: ['babel-loader'],\n        exclude: /node-modules/\n      }\n    ]\n  },\n  plugins: [\n    new HTMLWebpackPlugin({\n      inject: true, // 所有js脚本放于body之后\n      hash: true, // 为静态资源生成hash，用于清楚缓存\n      cache: true, // 仅在文件被更改时发出文件\n      title: 'react admin',\n      filename: 'index.html',\n      template: path.resolve(__dirname, 'index.html'),\n      minify: {\n        collapseWhitespace: true, // 折叠空白\n        removeComments: true, // 删除注释\n        removeRedundantAttributes: true,\n        removeScriptTypeAttributes: true,\n        removeStyleLinkTypeAttributes: true\n      }\n    }),\n    new CleanWebpackPlugin()\n  ]\n}\n</code></pre>\n<ul>\n<li>执行npm run build之后打开dist文件夹发现生成的文件都会带一串乱码，这样就避免了线上缓存的问题</li>\n<li>接下来我们需要打开完整的错误调试，方便线上查找问题，还是修改devtool为source-map即可，如下</li>\n</ul>\n<pre><code class=\"language-js\">...\n\nmodule.exports = {\n  entry: {\n    ...\n  },\n  devtool: 'source-map',\n  output: {\n    ...\n  },\n  ...\n}\n</code></pre>\n<ul>\n<li>然后我们尝试在index.js中主动抛出错误，执行npm run build后在浏览器点击错误就可以定位到相关错误的地方，便于错误排查</li>\n<li>然后我们就需要进行代码的压缩混淆，减少代码体积，先对js进行代码压缩，这里我们需要引用插件 terser-webpack-plugin ，先进行下载，命令为： cnpm i terser-webpack-plugin -D ，然后在配置文件中进行相关配置，如下</li>\n</ul>\n<pre><code class=\"language-js\">const path = require('path')\nconst webpack = require('webpack')\nconst { CleanWebpackPlugin } = require('clean-webpack-plugin');\nconst HTMLWebpackPlugin = require('html-webpack-plugin')\nconst TerserWebpackPlugin = require('terser-webpack-plugin')\n\nmodule.exports = {\n  entry: {\n    ...\n  },\n  devtool: 'source-map',\n  output: {\n    ...\n  },\n  module: {\n    ...\n  },\n  plugins: [\n    ...\n  ],\n  optimization: {\n    minimizer: [\n      // js压缩\n      new TerserWebpackPlugin({\n        cache: true, // 启用文件缓存\n        parallel: true, // 多线程调用\n        sourceMap: true // 错误排查\n      }),\n    ]\n  }\n}\n</code></pre>\n<ul>\n<li>接下来就是对css文件的打包进行处理，首先我们要将css文件给单独打包出来，我们可以观察到之前打包出来的文件其实是没有css文件的，因为webpack把所有的文件都打到一个文件里面了，所以我们没办法看到它，这其实对最后的生成的项目并不友好，所以我们先要在打包中将css抽离出来，这里我们就需要一个新的包 mini-css-extract-plugin ，还是使用npm下载此包： npm i mini-css-extract-plugin -D，然后在loader中将其配置起来</li>\n<li>首先我们在页面中引用该插件，然后将style-loader替换为它提供的loader，然后在plugins中进行css抽离的命名规则配置，为避免缓存问题，我们还是采用hash值进行命名，配置如下</li>\n</ul>\n<pre><code class=\"language-js\">...\nconst MiniCssExtractPlugin = require('mini-css-extract-plugin')\n\nmodule.exports = {\n  entry: {\n    ...\n  },\n  devtool: 'source-map',\n  output: {\n    ...\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.(le|c)ss$/,\n        use: [\n          MiniCssExtractPlugin.loader, // 替换了原来的style-loader\n          {\n            loader: 'css-loader',\n            options: {\n              sourceMap: true //是否打开样式查找\n            }\n          },\n          {\n            loader: 'postcss-loader', // 为浏览器加前缀\n            options: {\n              ident: 'postcss',\n              sourceMap: true,\n              plugins: loaders => [\n                require('autoprefixer')({\n                })\n              ]\n            }\n          },\n          {\n            loader: 'less-loader', // 解析样式文件\n            options: {\n              sourceMap: true\n            }\n          }\n        ]\n      },\n      ...\n    ]\n  },\n  plugins: [\n    new MiniCssExtractPlugin({// 将css打包成单独的css文件\n      filename: '[name].[hash:5].css',\n      chunkFilename: '[id].[hash:5].css'\n    }),\n    ...\n  ]\n  \n}\n</code></pre>\n<ul>\n<li>然后在运行npm run build就可以发现我们打出来的文件中出现了app.xxxxx.css的文件</li>\n<li>接下来我们就要对css进行压缩了，css的压缩需要使用 optimize-css-assets-webpack-plugin 插件，还是npm下载该插件 npm i optimize-css-assets-webpack-plugin -D，然后在webpack中进行相关配置，跟js的配置一样，需要放置在optimization 下的 minimizer 中，如下</li>\n</ul>\n<pre><code class=\"language-js\">const path = require('path')\nconst webpack = require('webpack')\nconst { CleanWebpackPlugin } = require('clean-webpack-plugin');\nconst HTMLWebpackPlugin = require('html-webpack-plugin')\nconst TerserWebpackPlugin = require('terser-webpack-plugin')\nconst MiniCssExtractPlugin = require('mini-css-extract-plugin')\nconst OptimizeCssAssetsWebpackPlugin = require('optimize-css-assets-webpack-plugin')\n\nmodule.exports = {\n  entry: {\n    ...\n  },\n  devtool: 'source-map',\n  output: {\n    ...\n  },\n  module: {\n    ...\n  },\n  plugins: [\n    ...\n  ],\n  optimization: {\n    minimizer: [\n      // js压缩\n      new TerserWebpackPlugin({\n        cache: true, // 启用文件缓存\n        parallel: true, // 多线程调用\n        sourceMap: true // 错误排查\n      }),\n      new OptimizeCssAssetsWebpackPlugin({}) // css压缩\n    ]\n  }\n}\n</code></pre>\n<ul>\n<li>到这我们就基本完成了开发与生产环境的各自配置，接下来我们就继续对项目需要进行相应的处理</li>\n<li>观察上面的开发与生产配置，其实还是有一部分的公用配置可以抽离出来，这里我们采用webpack-merge包来将其公共配置分离出来</li>\n<li>还是先下载该包：npm i webpack-merge -D</li>\n<li>然后在根目录新建一个webpack.common.js用来放置我们的公共配置</li>\n<li>观察开发与生产配置，抽离公共的配置如下</li>\n</ul>\n<pre><code class=\"language-js\">// webpack.common.js\nconst path = require('path')\nconst HtmlWebpackPlugin = require('html-webpack-plugin')\nconst { CleanWebpackPlugin } = require('clean-webpack-plugin')\nmodule.exports = {\n  entry: {\n    app: './index.js',\n    test: './index.jsx'\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.(|js)x?$/,\n        use: ['babel-loader'],\n        exclude: /node-modules/\n      }\n    ]\n  },\n  plugins: [\n    new HtmlWebpackPlugin({\n      inject: true, // 所有js脚本放于body之后\n      hash: true, // 为静态资源生成hash，用于清楚缓存\n      cache: true, // 仅在文件被更改时发出文件\n      title: 'react admin',\n      filename: 'index.html',\n      template: path.resolve(__dirname, 'index.html'),\n      minify: {\n        collapseWhitespace: true, // 折叠空白\n        removeComments: true, // 删除注释\n        removeRedundantAttributes: true,\n        removeScriptTypeAttributes: true,\n        removeStyleLinkTypeAttributes: true\n      }\n    }),\n    new CleanWebpackPlugin(),\n  ]\n}\n</code></pre>\n<ul>\n<li>之前我们的配置中没有进行代码块的抽离，这里我们也简单的进行一下补充，加一组配置即可，这个是开发与生产公用的，所以我们也加到上面的配置中，如下</li>\n</ul>\n<pre><code class=\"language-js\">// webpack.common.js\nconst path = require('path')\nconst HtmlWebpackPlugin = require('html-webpack-plugin')\nconst { CleanWebpackPlugin } = require('clean-webpack-plugin')\nmodule.exports = {\n  entry: {\n    app: './index.js',\n    test: './index.jsx'\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.(|js)x?$/,\n        use: ['babel-loader'],\n        exclude: /node-modules/\n      }\n    ]\n  },\n  plugins: [\n    new HtmlWebpackPlugin({\n      inject: true, // 所有js脚本放于body之后\n      hash: true, // 为静态资源生成hash，用于清楚缓存\n      cache: true, // 仅在文件被更改时发出文件\n      title: 'react admin',\n      filename: 'index.html',\n      template: path.resolve(__dirname, 'index.html'),\n      minify: {\n        collapseWhitespace: true, // 折叠空白\n        removeComments: true, // 删除注释\n        removeRedundantAttributes: true,\n        removeScriptTypeAttributes: true,\n        removeStyleLinkTypeAttributes: true\n      }\n    }),\n    new CleanWebpackPlugin(),\n  ],\n  optimization: { // 公共代码抽离\n    splitChunks:{ //启动代码分割，有默认配置项\n      chunks: 'all'\n    }\n  }\n}\n</code></pre>\n<ul>\n<li>这样便配置了我们的代码分割功能，然后就开始继续配置我们的生产与开发配置了</li>\n<li>然后修改webpack.dev.js，先在webpack.dev.js中引入webpack-merge与webpack.common.js，然后进行合并，因为css中的loader与生产环境不一致所以没有抽离，现在的webpack还需要给配置指定mode，取值为production或者deveopment，我们这里为开发配置，所以新增一个字段mode: 'development',最终如下</li>\n</ul>\n<pre><code class=\"language-js\">// webpack.dev.js\nconst path = require('path')\nconst webpack = require('webpack')\nconst merge = require('webpack-merge')\nconst common = require('./webpack.common.js')\n\nmodule.exports = merge(common, {\n  mode: 'development',\n  output: {\n    filename: '[name].js',\n    path: path.resolve(__dirname, 'dist'),\n    chunkFilename: '[name].bundle.js'\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.(le|c)ss$/,\n        use: [\n          'style-loader',\n          {\n            loader: 'css-loader',\n            options: {\n              sourceMap: true //是否打开样式查找\n            }\n          },\n          {\n            loader: 'postcss-loader', // 为浏览器加前缀\n            options: {\n              ident: 'postcss',\n              sourceMap: true,\n              plugins: loaders => [\n                require('autoprefixer')({\n                })\n              ]\n            }\n          },\n          {\n            loader: 'less-loader', // 解析样式文件\n            options: {\n              sourceMap: true\n            }\n          }\n        ]\n      }\n    ]\n  },\n  devtool: 'inline-source-map',\n  plugins: [\n    new webpack.HotModuleReplacementPlugin(), // 模块热替换\n    new webpack.NamedModulesPlugin() // 热更新时返回文件名而不是文件id\n  ],\n  devServer: {\n    contentBase: './dist', // 静态文件目录，用于浏览器显示\n    clientLogLevel: 'warning',  // 输出日志级别\n    hot: true, // 启动热更新\n    publicPath: '/', // 浏览器访问路径\n    compress: true, // 启用gzip压缩\n    port: 8822,\n    open: true, // 自动调起浏览器\n    overlay: { // 出现错误或警告是否覆盖页面线上错误信息\n      warnings: true,\n      errors: true\n    },\n    quiet: true,\n    proxy: { // 代理\n    },\n    watchOptions: { // 监控文件相关配置\n      poll: true,\n      ignored: /node_modules/,\n      aggregateTimeout: 300  // 默认值, 当你连续改动时候, webpack可以设置构建延迟时间(防抖)\n    }\n  }\n})\n</code></pre>\n<ul>\n<li>再运行npm run dev能够发现跟抽离之前的配置是一样的，接下来我们对生产配置也进行一个合并，然后新增一个mode: production</li>\n<li>同样是引入webpack-merge与webpack.common.js，然后进行合并，如下</li>\n</ul>\n<pre><code class=\"language-js\">// webpack.prod.js\nconst path = require('path')\nconst TerserWebpackPlugin = require('terser-webpack-plugin')\nconst MiniCssExtractPlugin = require('mini-css-extract-plugin')\nconst OptimizeCssAssetsWebpackPlugin = require('optimize-css-assets-webpack-plugin')\nconst merge = require('webpack-merge')\nconst common = require('./webpack.common.js')\n\nmodule.exports = merge(common, {\n  mode: 'production',\n  devtool: 'source-map',\n  output: {\n    filename: '[name].[chunkhash].js',\n    path: path.resolve(__dirname, 'dist'),\n    chunkFilename: '[name].bundle.js'\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.(le|c)ss$/,\n        use: [\n          MiniCssExtractPlugin.loader,\n          {\n            loader: 'css-loader',\n            options: {\n              sourceMap: true //是否打开样式查找\n            }\n          },\n          {\n            loader: 'postcss-loader', // 为浏览器加前缀\n            options: {\n              ident: 'postcss',\n              sourceMap: true,\n              plugins: loaders => [\n                require('autoprefixer')({\n                })\n              ]\n            }\n          },\n          {\n            loader: 'less-loader', // 解析样式文件\n            options: {\n              sourceMap: true\n            }\n          }\n        ]\n      }\n    ]\n  },\n  plugins: [\n    new MiniCssExtractPlugin({// 将css打包成单独的css文件\n      filename: '[name].[hash:5].css',\n      chunkFilename: '[id].[hash:5].css'\n    }),\n  ],\n  optimization: {\n    minimizer: [\n      // js压缩\n      new TerserWebpackPlugin({\n        cache: true, // 启用文件缓存\n        parallel: true, // 多线程调用\n        sourceMap: true // 错误排查\n      }),\n      new OptimizeCssAssetsWebpackPlugin({}) // css压缩\n    ]\n  }\n})\n</code></pre>\n<ul>\n<li>上面就完成了生产与开发环境的配置，但是之前的配置还有部分遗漏，一个是在开发环境没有配置css的抽离规则，一个是没有配置react开发中的图片资源加载跟字体库与icon</li>\n<li>下面我们就先针对开发环境的css进行一个处理，之前我们在运行webpack的时候是没办法区分开发与生产环境的，所以我们现在在webpack的命令中设置环境变量，用以区分开发还是生产环境，我们先引用cross-env的包，用于各平台设置环境变量的兼容，命令为 npm i cross-env -D</li>\n<li>然后修改package.json中的启动命令为 \"dev\": \"cross-env NODE<em>ENV=development webpack-dev-server --open --config webpack.dev.js\",  \"build\": \"cross-env NODE</em>ENV=production webpack --config webpack.prod.js\" 然后在webpack.common.js中打印process.env.NODE<em>ENV，然后可以观察到在npm run dev的命令下process.env.NODE</em>ENV是'development'， npm run build 的命令下 process.env.NODE_ENV是'production'，由此，我们来配置css的抽离规则，先将之前配置在webpack.prod.js中的css打包配置删除，然后在webpack.common.js中新增如下配置</li>\n</ul>\n<pre><code class=\"language-js\">// webpack.common.js\nconst path = require('path')\nconst HtmlWebpackPlugin = require('html-webpack-plugin')\nconst { CleanWebpackPlugin } = require('clean-webpack-plugin')\nconst MiniCssExtractPlugin = require('mini-css-extract-plugin')\nconst devMode = process.env.NODE_ENV === 'development' // 命令行设置的值\nconsole.log(devMode)\nmodule.exports = {\n  entry: {\n    ...\n  },\n  module: {\n    ...\n  },\n  plugins: [\n    new MiniCssExtractPlugin({// 将css打包成单独的css文件，在开发与生成生成不同的css\n      filename: devMode ? '[name].css' : '[name].[hash:5].css',\n      chunkFilename: devMode ? '[id].css' : '[id].[hash:5].css'\n    }),\n    ...\n  ]\n}\n</code></pre>\n<ul>\n<li>接下来我们要对图片进行处理，在开发中我们会经常根据当前文件的相对路径来引入图片资源，但是我们的打包又是基于入口文件的，所以经常会导致最后的图片引用路径错误，这里我们就要使用url-loader来帮我们进行图片路径处理，会将我们的引用路径替换为打包后的文件路径。</li>\n<li>url-loader还对我们提供了图片转dataUrl的功能，这样就可以将图片转为dataUrl的路径直接引入，避免了网络请求，但是图片过大的时候会影响我们的编码速率，这种时候还是应该使用网络图片请求。url-loader中的limit就是控制多大的图片以内转为dataUrl，大于该限制的就引用图片地址访问。</li>\n<li>同样，我们还是先下载url-loader的相关包， npm i url-loader file-loader -D</li>\n<li>下面我们就对各格式的图片进行配置，这部分配置生产与开发都要使用，因此在webpack.common.js下配置，配置如下</li>\n</ul>\n<pre><code class=\"language-js\">// webpack.common.js\n...\nmodule.exports = {\n  entry: {\n    ...\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.(jpg|png|gif|svg)$/,\n        use: [\n          {\n            loader: 'url-loader',\n            options: {\n              limit: 10000,\n              name: '[name]-[hash:5].[ext]',\n              outputPath: 'img/'\n            }\n          }\n        ]\n      }\n      ...\n    ]\n  },\n  plugins: [\n    ...\n  ]\n}\n</code></pre>\n<ul>\n<li>这样当图片在10k以内的时候我们就会将其转为dataUrl的路径引入，并且将图片统一放到img文件夹下</li>\n<li>webpack还为我们提供了图片的压缩功能，方便缩小我们的项目体积，需要使用 image-webpack-loader 来进行配置，还是先下载该包 npm i image-webpack-loader -D</li>\n<li>然后在开发与生产都需要进行相关的配置，所以还是在 webpack.common.js 进行配置，配置如下</li>\n</ul>\n<pre><code class=\"language-js\">// webpack.common.js\n...\nmodule.exports = {\n  entry: {\n    ...\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.(jpg|png|gif|svg)$/,\n        use: [\n          {\n            loader: 'url-loader',\n            options: {\n              limit: 10000,\n              name: '[name]-[hash:5].[ext]',\n              outputPath: 'img/'\n            }\n          },\n          {\n            loader: 'image-webpack-loader',\n            options: {\n              mozjpeg: {\n                progressive: true,\n                quality: 65\n              },\n              optipng: {\n                enabled: false\n              },\n              pngquant: {\n                quality: [0.65, 0.9],\n                speed: 4\n              },\n              gifsicle: {\n                interlaced: false\n              },\n              webp: {\n                quality: 75\n              }\n            }\n          }\n        ]\n      }\n    ]\n  },\n  plugins: [\n    ...\n  ]\n}\n</code></pre>\n<ul>\n<li>上面就完成了开发中图片的相关配置，接下来配置一下字体库，还是使用url-loader，配置规则跟图片的一致，如下</li>\n</ul>\n<pre><code class=\"language-js\">...\nmodule.exports = {\n  entry: {\n    ...\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.(woff2?|eot|ttf|otf)(\\?.*)?$/,\n        use: [\n          {\n            loader: 'url-loader',\n            options: {\n              // 文件大小小于limit参数，url-loader将会把文件转为DataUR\n              limit: 10000,\n              name: '[name]-[hash:5].[ext]',\n              ourput: 'fonts/'\n            }\n          }\n        ],\n      },\n    ]\n  },\n  plugins: [\n    ...\n  ]\n}\n</code></pre>\n<ul>\n<li>如上就完成了咱们项目的前期配置，单纯使用react已经没有什么问题了，这一章的配置就到这吧，下面把各个配置文件都贴一下，当然也可以选择源码查看，地址是 <a href=\"https://github.com/mf950511/react-admin\">react-admin</a></li>\n<li>下一章我们进行typeScript的配置，之后就开始正式进行项目开发</li>\n</ul>\n<pre><code class=\"language-js\">// webpack.common.js\nconst path = require('path')\nconst HtmlWebpackPlugin = require('html-webpack-plugin')\nconst { CleanWebpackPlugin } = require('clean-webpack-plugin')\nconst MiniCssExtractPlugin = require('mini-css-extract-plugin')\nconst devMode = process.env.NODE_ENV === 'development'\nconsole.log(devMode)\nmodule.exports = {\n  entry: {\n    app: './index.js',\n    test: './index.jsx'\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.(jpg|png|gif|svg)$/,\n        use: [\n          {\n            loader: 'url-loader',\n            options: {\n              limit: 10000,\n              name: '[name]-[hash:5].[ext]',\n              outputPath: 'img/'\n            }\n          },\n          {\n            loader: 'image-webpack-loader',\n            options: {\n              mozjpeg: {\n                progressive: true,\n                quality: 65\n              },\n              optipng: {\n                enabled: false\n              },\n              pngquant: {\n                quality: [0.65, 0.9],\n                speed: 4\n              },\n              gifsicle: {\n                interlaced: false\n              },\n              webp: {\n                quality: 75\n              }\n            }\n          }\n        ]\n      },\n      {\n        test: /\\.(woff2?|eot|ttf|otf)(\\?.*)?$/,\n        use: [\n          {\n            loader: 'url-loader',\n            options: {\n              // 文件大小小于limit参数，url-loader将会把文件转为DataUR\n              limit: 10000,\n              name: '[name]-[hash:5].[ext]',\n              ourput: 'fonts/'\n            }\n          }\n        ],\n      },\n      {\n        test: /\\.(js)x?$/,\n        use: ['babel-loader'],\n        exclude: /node-modules/\n      }\n    ]\n  },\n  plugins: [\n    new MiniCssExtractPlugin({// 将css打包成单独的css文件\n      filename: devMode ? '[name].css' : '[name].[hash:5].css',\n      chunkFilename: devMode ? '[id].css' : '[id].[hash:5].css'\n    }),\n    new HtmlWebpackPlugin({\n      inject: true, // 所有js脚本放于body之后\n      hash: true, // 为静态资源生成hash，用于清楚缓存\n      cache: true, // 仅在文件被更改时发出文件\n      title: 'react admin',\n      filename: 'index.html',\n      template: path.resolve(__dirname, 'index.html'),\n      minify: {\n        collapseWhitespace: true, // 折叠空白\n        removeComments: true, // 删除注释\n        removeRedundantAttributes: true,\n        removeScriptTypeAttributes: true,\n        removeStyleLinkTypeAttributes: true\n      }\n    }),\n    new CleanWebpackPlugin(),\n  ],\n  optimization: { // 公共代码抽离\n    splitChunks:{ //启动代码分割，有默认配置项\n      chunks: 'all'\n    }\n  }\n}\n\n// webpack.dev.js\nconst path = require('path')\nconst webpack = require('webpack')\nconst merge = require('webpack-merge')\nconst common = require('./webpack.common.js')\n\nmodule.exports = merge(common, {\n  output: {\n    filename: '[name].js',\n    path: path.resolve(__dirname, 'dist'),\n    chunkFilename: '[name].bundle.js'\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.(le|c)ss$/,\n        use: [\n          'style-loader',\n          {\n            loader: 'css-loader',\n            options: {\n              sourceMap: true //是否打开样式查找\n            }\n          },\n          {\n            loader: 'postcss-loader', // 为浏览器加前缀\n            options: {\n              ident: 'postcss',\n              sourceMap: true,\n              plugins: loaders => [\n                require('autoprefixer')({\n                })\n              ]\n            }\n          },\n          {\n            loader: 'less-loader', // 解析样式文件\n            options: {\n              sourceMap: true\n            }\n          }\n        ]\n      }\n    ]\n  },\n  devtool: 'inline-source-map',\n  plugins: [\n    new webpack.HotModuleReplacementPlugin(),\n    new webpack.NamedModulesPlugin()\n  ],\n  devServer: {\n    contentBase: './dist', // 静态文件目录，用于浏览器显示\n    // clientLogLevel: 'warning',  // 输出日志级别\n    hot: true, // 启动热更新\n    publicPath: '/', // 浏览器访问路径\n    compress: true, // 启用gzip压缩\n    port: 8822,\n    open: true, // 自动调起浏览器\n    overlay: { // 出现错误或警告是否覆盖页面线上错误信息\n      warnings: true,\n      errors: true\n    },\n    quiet: true,\n    proxy: { // 代理\n    },\n    watchOptions: { // 监控文件相关配置\n      poll: true,\n      ignored: /node_modules/,\n      aggregateTimeout: 300  // 默认值, 当你连续改动时候, webpack可以设置构建延迟时间(防抖)\n    }\n  }\n})\n\n// webpack.prod.js\nconst path = require('path')\nconst TerserWebpackPlugin = require('terser-webpack-plugin')\nconst OptimizeCssAssetsWebpackPlugin = require('optimize-css-assets-webpack-plugin')\nconst merge = require('webpack-merge')\nconst common = require('./webpack.common.js')\nconst BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin;\nconst MiniCssExtractPlugin = require('mini-css-extract-plugin')\n\nmodule.exports = merge(common, {\n  devtool: 'source-map',\n  output: {\n    filename: '[name].[chunkhash].js',\n    path: path.resolve(__dirname, 'dist'),\n    chunkFilename: '[name].bundle.js'\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.(le|c)ss$/,\n        use: [\n          MiniCssExtractPlugin.loader,\n          {\n            loader: 'css-loader',\n            options: {\n              sourceMap: true //是否打开样式查找\n            }\n          },\n          {\n            loader: 'postcss-loader', // 为浏览器加前缀\n            options: {\n              ident: 'postcss',\n              sourceMap: true,\n              plugins: loaders => [\n                require('autoprefixer')({\n                })\n              ]\n            }\n          },\n          {\n            loader: 'less-loader', // 解析样式文件\n            options: {\n              sourceMap: true\n            }\n          }\n        ]\n      }\n    ]\n  },\n  plugins: [\n    new BundleAnalyzerPlugin({\n      analyzerMode: 'server',\n      analyzerHost: '127.0.0.1',\n      analyzerPort: 7778,\n      reportFilename: 'report.html',\n      defaultSizes: 'parsed',\n      openAnalyzer: true,\n      generateStatsFile: false,\n      statsFilename: 'stats.json',\n      statsOptions: null,\n      logLevel: 'info'\n    }),\n  ],\n  optimization: {\n    minimizer: [\n      // js压缩\n      new TerserWebpackPlugin({\n        cache: true, // 启用文件缓存\n        parallel: true, // 多线程调用\n        sourceMap: true // 错误排查\n      }),\n      new OptimizeCssAssetsWebpackPlugin({}) // css压缩\n    ]\n  }\n})\n</code></pre>","fields":{"slug":"/react_md_2/"},"frontmatter":{"title":"从零搭建一个react-hooks项目（二）","tags":["react","react hooks","redux","webpack"],"categories":"Webpack"}}},{"node":{"html":"<h1>从零搭建一个react-hooks项目（三）</h1>\n<ul>\n<li>上一篇我们配置了项目相关，包括代码压缩混淆，开发生产配置抽离，图片与文字的引入使用等</li>\n<li>接下来我们就配置一下react-router，react-redux与typescript</li>\n<li>配置之前我们先补充一下webpack的部分配置，用于方便我们的开发</li>\n<li>在webpack.common.js中配置webpack的查找规则，也就是resolve，如下</li>\n</ul>\n<!--more-->\n<pre><code class=\"language-js\">...\nmodule.exports = {\n  entry: {\n    ...\n  },\n  module: {\n    ...\n  },\n  resolve: {\n    extensions: ['.jsx', '.js', '.json'],\n    alias: {\n      \"@\": path.resolve(__dirname, 'src')\n    }\n  },\n  plugins: [\n    ...\n  ],\n  optimization: { // 公共代码抽离\n    ...\n  }\n}\n</code></pre>\n<ul>\n<li>上面新增了一个resolve的解析规则，使webpack方便查找，第一个extensions中的配置表示我们在引入后缀为.jsx,.js,.json的文件时，可以直接写文件名而不用加后缀，比如引入'./index.jsx'，我们就可以直接写为'./index'</li>\n<li>下面的alias就是别名配置，用于在引入路径时方便使用，比如我们在项目中有如下的代码结构</li>\n</ul>\n<pre><code class=\"language-js\">src \n├── lib \n│ └── utils.js \n└── pages \n└── demo \n└── index.js\n</code></pre>\n<ul>\n<li>在 src/pages/demo/index.js 中如果要引用 src/lib/utils.js 那么可以通过：import utils from '../../lib/utils' ，如果目录更深一些，会越来越难看，这时可以通过设置 alias 来缩短这种写法，例如：</li>\n</ul>\n<pre><code class=\"language-js\">module.exports = {\n  resolve: {\n      '@': path.resolve(__dirname, 'src'),\n      '@lib': path.resolve(__dirname, 'src/lib')\n  }\n}\n</code></pre>\n<ul>\n<li>这样我们就可以直接使用 '@lib/utils'来进行文件的引入了</li>\n</ul>\n<h2>react-router的使用</h2>\n<ul>\n<li>配置完resolve之后我们就开始进行react-router的配置了，还是先下载react-router-dom模块，命令为： npm i react-router-dom -S</li>\n<li>然后在src下新建两个页面，pages/login.jsx与pages/home.jsx作为我们的路由页面</li>\n</ul>\n<pre><code class=\"language-js\">// pages/home.jsx\nimport React from 'react'\nconst Home = () => {\n  return (\n    &#x3C;div>我是首页&#x3C;/div>\n  )\n}\nexport default Home\n\n// pages/login.jsx\nimport React from 'react'\nconst Login = () => {\n  return (\n    &#x3C;div>我是登录页&#x3C;/div>\n  )\n}\nexport default Login\n</code></pre>\n<ul>\n<li>接着在src下新建routes/index.jsx文件作为我们的路由管理页面</li>\n<li>在文件内引入react与react-router-dom,然后引入新建的login页面与home页面</li>\n<li>页面代码如下</li>\n</ul>\n<pre><code class=\"language-js\">// routes/index.jsx\nimport React from 'react'\nimport { HashRouter as Router, Route, Switch, Redirect } from 'react-router-dom'\nimport Login from '@/pages/login'\nimport Home from '@/pages/home'\nconst RouteConfig = () => {\n  return (\n    &#x3C;Router>\n      &#x3C;Switch>\n        &#x3C;Route path=\"/home\" component={ Home }>&#x3C;/Route>\n        &#x3C;Route path=\"/login\" component={ Login }>&#x3C;/Route>\n        &#x3C;Redirect to=\"/home\" from=\"/\">&#x3C;/Redirect>\n      &#x3C;/Switch>\n    &#x3C;/Router>\n  )\n}\nexport default RouteConfig\n</code></pre>\n<ul>\n<li>然后在app.jsx里面以组件的形式引入我们的路由即可，如下</li>\n</ul>\n<pre><code class=\"language-js\">// app.jsx\nimport * as React from 'react'\nimport './app.less'\nimport RouteConfig from '@/route/index'\nclass App extends React.Component{\n  render(){\n    return (\n      &#x3C;RouteConfig>&#x3C;/RouteConfig>\n    )\n  }\n}\nexport default App\n</code></pre>\n<ul>\n<li>然后运行npm run dev就能发现自动帮我们定位到/home页面，我们手动修改路由为/login就可以发现页面跳转到了login页面</li>\n<li>至此，我们的react-router就配置完成了</li>\n</ul>\n<h2>react-redux的使用</h2>\n<ul>\n<li>redux是常用的状态管理组件，用于维护全局的数据变量，react项目中自然也需要它的存在，下面我们就配置一下redux</li>\n<li>在react中使用redux需要引入redux与react-redux，还是先安装包： npm i redux react-redux -S</li>\n<li>然后在src下新建文件夹store用于放置我们的redux相关文件</li>\n<li>redux在数据比较复杂的时候会按照模块来放置文件，最后再用redux提供的api组合起来，方便后续的维护，这里我们创立数字模块number与聊天模块chat，分别在store下面建立两个文件夹store/chat与store/number</li>\n<li>在每个文件夹下面建立我们会用到的操作该数据的操作类型与该操作类型下的数据变化情况，分别对应types.js与reducers.js</li>\n<li>先构建store/number下的types与reducers，对外提供加减两个方法，先在types下构建常量用于标识对应的方法</li>\n</ul>\n<pre><code class=\"language-js\">// store/number/types\nexport const INCREMENT = 'INCREMENT'\nexport const DECREMENT = 'DECREMENT'\n</code></pre>\n<ul>\n<li>然后再编写该方法下的数据变化情况reducers，并为这个数字模块设立初始值0，当执行方法为加减的时候就在原基础上加减对应的值，否则就原样返回</li>\n</ul>\n<pre><code class=\"language-js\">// store/number/reducers.js\nimport { INCREMENT, DECREMENT } from './types'\nconst initialState = 0\nconst numberReducer = (state = initialState, action) => {\n  switch(action.type) {\n    case INCREMENT:\n      return state + action.payload\n    case DECREMENT:\n      return state - action.payload\n    default:\n      return state\n  }\n}\nexport default numberReducer\n</code></pre>\n<ul>\n<li>上面就是简单的数字模块的两个方法了，然后我们同样实现一下chat模块的方法</li>\n</ul>\n<pre><code class=\"language-js\">// store/chat/types\nexport const SEND = 'SEND'\nexport const DELETE = 'DELETE'\n\n// store/chat/reducers\nimport { SEND, DELETE } from './types'\n\nconst initialState = []\nconst chatReducer = (state = initialState, action) => {\n  switch(action.type) {\n    case SEND:\n      return [...state, action.payload]\n    case DELETE:\n      return state.length ? state.slice(0, state.length - 1) : []\n    default:\n      return state\n  }\n}\nexport default chatReducer\n</code></pre>\n<ul>\n<li>chat模块提供了一个发送方法与删除方法用于操作聊天列表</li>\n<li>接下来我们就要使用redux提供的combineReducers方法将其合并起来</li>\n<li>在store下新建index.js文件用于最后的导出</li>\n<li>在index.js中引入combineReducers，chat模块，number模块，然后合并并导出，如下</li>\n</ul>\n<pre><code class=\"language-js\">// store/index.js\nimport { combineReducers } from 'redux'\nimport ChatReducer from './chat/reducers'\nimport NumberReducer from './number/reducer'\n\nconst rootReducer = combineReducers({\n  number: NumberReducer,\n  chat: ChatReducer\n})\n\nexport default rootReducer\n</code></pre>\n<ul>\n<li>上面就完成了redux的编写，接下来就要在react根组件上将其使用</li>\n<li>在index.jsx中引入store/index.js，引入redux提供的方法createStore创建全局状态，引入react-redux中的Provider包装根组件，如下</li>\n</ul>\n<pre><code class=\"language-js\">// index.jsx\nimport * as React from 'react'\nimport * as ReactDOM from 'react-dom'\nimport App from './src/app.jsx'\nimport { createStore } from 'redux'\nimport { Provider } from 'react-redux'\nimport RootReducer from '@/store/index'\nconst store = createStore(RootReducer)\nReactDOM.render(\n  &#x3C;Provider store={ store }>\n    &#x3C;App/>\n  &#x3C;/Provider>\n  ,document.querySelector('#app')\n)\n</code></pre>\n<ul>\n<li>上面就在我们的项目中引入了redux，接下来就是使用，我们在login组件中尝试使用number并修改</li>\n<li>在login组件中引入对应的操作方法与react-redux提供的connect方法，然后修改我们的login组件如下</li>\n</ul>\n<pre><code class=\"language-js\">// src/pages/login.jsx\nimport React from 'react'\nimport { connect } from 'react-redux'\nimport { INCREMENT, DECREMENT } from '@/store/number/types'\nconst Login = (props) => {\n  const { number, increment, decrement } = props\n  return (\n    &#x3C;div>\n      &#x3C;button>我是数字{ number }&#x3C;/button>\n      &#x3C;button onClick={() => { increment() } }>点我加10&#x3C;/button>\n      &#x3C;button onClick={() => { decrement() } }>点我减10&#x3C;/button>\n    &#x3C;/div>\n  )\n}\nfunction mapStateToProps(state){ // 将redux中的state整合到props中\n  return {\n    number: state.number \n  }\n}\n\nfunction mapDispatchToProps(dispatch){ // 将操作state的函数整合到props中\n  return {\n    increment: () => dispatch({ type: INCREMENT, payload: 10 }),\n    decrement: () => dispatch({ type: DECREMENT, payload: 10 })\n  }\n}\nexport default connect(mapStateToProps, mapDispatchToProps)(Login)\n</code></pre>\n<ul>\n<li>connect中的第一个参数接受两个函数，分别用于整合state到props中跟整合操作方法到props中，这样我们就可以在页面中使用该方法与该值了</li>\n<li>修改之后我们点击两个按钮就可以看到对应值的变化了</li>\n</ul>\n<h2>react中引入typescript</h2>\n<ul>\n<li>typescript当下如此潮流我们自然也要接入一下啦，下面就是简单的接入过程</li>\n<li>得益于我们强大的babel-7，我们不再需要去单独的使用ts-loader或者awesome-typescript-loader解析ts文件，只需要在babel中进行typescript的相关配置即可</li>\n<li>首先还是先安装我们的typescript与@babel/preset-typescript，命令为： npm i typescript @babel/preset-typescript -D</li>\n<li>然后再.babelrc文件中进行typescript的配置，如下</li>\n</ul>\n<pre><code class=\"language-js\">// .babelrc\n{\n  \"presets\": [\n    \"@babel/preset-env\",\n    \"@babel/preset-react\",\n    \"@babel/preset-rtpescript\", // 处理typescript\n  ],\n  \"plugins\": [\n    \"@babel/proposal-object-rest-spread\", // 处理对象的rest写法\n    \"@babel/proposal-class-properties\" // 处理类里面的箭头函数绑定，static属性等 \n  ]\n}\n</code></pre>\n<ul>\n<li>然后在webpack中对typescript文件配置babel解析即可，这是一个通用配置，所以还是在webpack.common.js上修改，如下</li>\n</ul>\n<pre><code class=\"language-js\">// webpack.common.js\nmodule.exports = {\n  entry: {\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.(js|ts)x?$/, // tsx或者ts文件也使用babel解析\n        use: ['babel-loader'],\n        exclude: /node-modules/\n      }\n    ]\n  },\n  resolve: {\n    extensions: ['.tsx', '.ts', '.jsx', '.js', '.json'], // 添加.tsx与.ts后缀解析\n    alias: {\n      \"@\": path.resolve(__dirname, 'src')\n    }\n  },\n  plugins: [\n    ...\n  ],\n  optimization: { // 公共代码抽离\n    ...\n  }\n}\n</code></pre>\n<ul>\n<li>然后就要配置typescript中的编译规则，在根目录下新建tsconfig.json文件，然后添加如下配置</li>\n</ul>\n<pre><code class=\"language-js\">{\n  \"compilerOptions\": {\n    \"allowSyntheticDefaultImports\": true, // 允许从没有设置默认导出的模块中默认导入。这并不影响代码的输出，仅为了类型检查。\n    \"outDir\": \"./dist/\", // 重定向输出目录\n    \"noImplicitAny\": true,// 在表达式和声明上有隐含的 any类型时报错。（默认为false，个人建议也为false，可以兼容之前的js代码，这里改为true是为了我自己检测哪些类型需要处理）\n    \"module\": \"es6\", // 模块引入方式\n    \"target\": \"esnext\",// 指定ECMAScript目标版本\n    \"jsx\": \"react\", // 在 .tsx文件里支持JSX\n    \"allowJs\": true,\n    \"sourceMap\": true, // 生成相应的 .map文件\n    \"lib\": [\n      \"es2015\",\n      \"dom.iterable\",\n      \"es2016.array.include\",\n      \"es2017.object\",\n      \"dom\"\n    ], // 编译过程中需要引入的库文件的列表。\n    \"moduleResolution\": \"node\",// 用于解析一些加载器，如css-type, source-map \n    \"baseUrl\": \"./src\", // typescript的模块解析基础路径\n    \"paths\": { // 对应的模块解析路径\n      \"store/*\": [\"store/*\"],\n    },\n  },\n  \"include\": [\n    \"src\"\n  ],\n  \"exclude\": [\n    \"./node_modules\"\n  ]\n}\n</code></pre>\n<ul>\n<li>因为我们之前配置了别名，所以需要加上后面的配置中的baseUrl与paths保证typescript能够找到对应的配置，其他的都是typescript的基本配置</li>\n<li>接下来我们尝试将入口文件修改为tsx尝试一下，在webpack.common.js中将入口文件改为app:'index.tsx'，然后再将index.jsx后缀改为tsx，之后运行npm run dev发现报错 can not find module 'react'，就说明我们的typescript已经配置完成了，可以正常检查错误</li>\n<li>上述错误是因为我们在TS中进行的开发，TS并不知道我们的react是什么类型，导出了什么，所以就报错了，这里我们就需要安装react相关的类型文件</li>\n<li>项目中我们使用了react,react-dom,react-redux,react-router-dom这四个依赖，所以我们就需要安装依赖包，命令为：npm i @types/react @types/react-dom @types/react-redux @types/react-router-dom -S</li>\n<li>之后我们再次编译，就发现项目可以正常运行了。</li>\n<li>但是使用上面的配置之后发现，在我们编译过程中类型出错webpack并不会提示我们出错，这是因为babel7中在编译过程会移除typescript，完全以javascript的形式进行打包，详见<a href=\"https://iamturns.com/typescript-babel\">(https://iamturns.com/typescript-babel)</a>。因为，要把babel跟typescript同时编译，两个编译器会导致过程十分缓慢，这可是开发者不能容忍的。针对这种情况，我们可以新建一个命令 \"check\": \"tsc -watch\"，然后使用vscode带给我们的终端启用两个终端，一个运行命令 npm run check，另一个运行命令npm run dev，这样就发现我们在开发中出现的类型错误都会在check的终端对我们进行提示。</li>\n<li>接下来我们只需要将所有的jsx文件转为tsx文件就可以进行typescript的开发了，项目地址<a href=\"https://github.com/mf950511/react-admin\">react-admin</a>，可以自行获取配置进行修改</li>\n</ul>","fields":{"slug":"/react_md_3/"},"frontmatter":{"title":"从零搭建一个react-hooks项目（三）","tags":["react","react hooks","redux","webpack"],"categories":"Webpack"}}},{"node":{"html":"<h1>从零搭建一个react-hooks项目（四）</h1>\n<ul>\n<li>前面我们搭建了基于react与typescript的开发环境，接下来就是我们项目开发中遇到的一些问题处理了</li>\n</ul>\n<h2>图片引入申明报错问题处理</h2>\n<ul>\n<li>之前我们配置了图片引入并且在页面中进行了图片引入，当我们把页面变为ts之后会发现图片引入的地方被标红了，报错为 Cannot find module './image/img.png' or its corresponding type declarations，这里是因为图片类型我们没有为其设定类型文件，所以报错，这种情况下，我们可以在src目录下新建image.d.ts文件来为其进行声名，声明文件如下</li>\n</ul>\n<pre><code class=\"language-js\">// image.d.ts\ndeclare module '*.svg'\ndeclare module '*.png'\ndeclare module '*.jpg'\ndeclare module '*.jpeg'\ndeclare module '*.gif'\ndeclare module '*.bmp'\ndeclare module '*.tiff'\n</code></pre>\n<!--more-->\n<ul>\n<li>这样就能发现我们的ts类型错误消失了</li>\n</ul>\n<h2>非组件页面进行页面跳转</h2>\n<ul>\n<li>传统中使用react-router-dom进行页面跳转需要在页面中获取props，然后props中获取history，然后采用history.push('/home')的形式进行页面跳转</li>\n<li>要是想在别的非组件页面，如request文件或者入口index.tsx中进行页面跳转就需要依赖三方库如history进行页面路由跳转，如下</li>\n</ul>\n<pre><code class=\"language-js\">// index.tsx 这样就实现了在非组件页面中的跳转，页面打开后两秒自动跳转登录\n// 需安装依赖history：npm i history -S\nimport { createHashHistory  } from 'history'\nconst history = createHashHistory() \nsetTimeout(() =>{\n  history.push('/login')\n}, 2000)\n</code></pre>\n<ul>\n<li>我们简单的将该方法封装一下，方便后续的使用，在src文件夹下创建lib/untils.ts文件用于我们的工具函数封装，如下</li>\n</ul>\n<pre><code class=\"language-js\">// src/lib/untils.js\nimport { createHashHistory  } from 'history'\nconst history = createHashHistory() \nexport {\n  history\n}\n\n// index.tsx\nimport { history } from './src/lib/untils'\nsetTimeout(() =>{\n  history.push('/home')\n}, 2000)\n</code></pre>\n<ul>\n<li>这样就可以实现在其他工具页面进行页面跳转了</li>\n</ul>\n<h2>ant4使用icon与动态渲染问题</h2>\n<ul>\n<li>ant4中icon的引用方式发生了变化，需要我们单独引入 @ant-design/icons 包，然后获取Icon名以组件的形式进行引入，这样就存在了一个问题，如何动态的引入icon，比如在后台配置icon名称，在前端进行对应的展示，如首页菜单栏，权限不一，展现不一致</li>\n<li>这种情况我们就只能全量引入icon，如下</li>\n</ul>\n<pre><code class=\"language-js\">import * as Icons from '@ant-design/icons';\n</code></pre>\n<ul>\n<li>然后再指定返回reactNode的方法</li>\n</ul>\n<pre><code class=\"language-js\">interface Icons { // 处理icon的类型\n  [PropName: string]: any\n}\nconst getIcons = (str: string, Icons: Icons) => {\n  const TestBankOutlined = Icons[str]\n  return &#x3C;TestBankOutlined />\n}\n</code></pre>\n<ul>\n<li>之后就是我们的菜单渲染函数</li>\n</ul>\n<pre><code class=\"language-js\">interface SideBar{ // 菜单栏\n  name: string;\n  children?: Array&#x3C;SideBar>,\n  [propName: string]: any;\n}\nconst sideBarTree = (menuArr: SideBar[]) => {\n  if(menuArr &#x26;&#x26; menuArr.length) {\n    return menuArr.map((item, index) => {\n      return (\n        item.children \n        ? \n        &#x3C;SubMenu className=\"home-menu\" popupClassName=\"home-sider\" key={ item.path } icon={ item.icon ? getIcons(item.icon, Icons) : '' } title={ item.name }>\n          { sideBarTree(item.children) }\n        &#x3C;/SubMenu> : &#x3C;Menu.Item className=\"home-menu-item\" icon={ item.icon ? getIcons(item.icon, Icons) : '' } key={ item.path }>{ item.name }&#x3C;/Menu.Item>\n      )\n    })\n  } else {\n    return null\n  }\n}\n</code></pre>\n<ul>\n<li>这样就完成了我们菜单与icon的可配置化</li>\n</ul>","fields":{"slug":"/react_md_4/"},"frontmatter":{"title":"从零搭建一个react-hooks项目（四）","tags":["react","react hooks","redux","webpack"],"categories":"Webpack"}}},{"node":{"html":"<h1>react hooks下封装通用redux</h1>\n<p>redux我们常用来做全局状态管理，一般我们都会按功能模块来新建相关的action，reducer然后再使用combineReducers来将其组合导出，这样的话就实现了模块的划分，让我们更方便项目的管理。但是在某些情况下，我们想要一个通用的redux管理，比如一些特别小，但是又必须要用到的场景，比如我们现在新建了一个chat模块用来管理聊天相关的redux，新建了一个menu模块来管理我们的菜单模块，新建了一个number模块用来管理我们的数据状态，但是这时候我想要对顶部导航栏的显示与隐藏添加一个reducer用来与其他组件交互，这种情况下还要单独再开一个nav模块吗？肯定是不愿意的，所以针对我们这些比较小的功能模块，我们想封装一个通用的reducer，这个通用的reducer共享一个normal数据，dispatch时接受一组数据key,value用于进行数据的改变，下面就是我们的封装过程</p>\n<!--more-->\n<ul>\n<li>首先我们需要创建一个normalReducer，如下</li>\n</ul>\n<pre><code class=\"language-js\">// store/normal/reducer.js\n\nexport const normalReducer = (state = {}, action) => {\n  if(action.type === 'normal') { // 用于标识走通用的reducer\n    const { payload: { key, value } } = action\n    return {\n      ...state,\n      [key]: value\n    }\n  } else {\n    return state\n  }\n}\n\n// store/index.js\n\nimport { normalReducer } from './normal/reducer.js'\n\nconst rootReducer = combineReducer({\n  normal: normalReducer,\n  ...\n})\n</code></pre>\n<ul>\n<li>这样我们就简单实现了一个通用的normal模块，在页面中我们可以这样使用</li>\n</ul>\n<pre><code class=\"language-js\">import * as React from 'react'\nimport { useSelector, useDispatch } from 'react-redux'\n\nconst Home = () => {\n  const normalState = useSelector((state) => state.normal) // 获取到了相应的normal状态值\n  const dispatch = useDispatch() // 获取dispatch函数\n\n  const changeOk = () => {\n    dispatch({\n      type: 'normal',\n      payload: {\n        key: 'isOk',\n        value: !normalState.isOk\n      }\n    })\n  }\n\n  return (\n    &#x3C;div className=\"home\">\n      &#x3C;div>{ normalState.isOk }&#x3C;/div>\n      &#x3C;button onClick={ changeOk }>点我切换状态&#x3C;/button>\n    &#x3C;/div>\n  )\n}\n</code></pre>\n<ul>\n<li>这样就更新了我们的数据状态，这样我们每次都需要写dispatch相关部分，还是有点繁琐，所以我们可以参考useState的写法，接收一个键值，返回数据值与数据操作函数，如下</li>\n</ul>\n<pre><code class=\"language-js\">// src/effect/reducer\nimport * as React from 'react'\nimport { useSelector, useDispatch } from 'react-redux'\n\nexport const normalReducerDispatch = (key) => {\n  const dispatch = useDispatch()\n  const normalInfo = useSelector(state => state.normal)\n  const stateValue = normalInfo[key]\n  const setNormalInfo = (value) => {\n    dispatch({\n      type: 'normal',\n      payload: {\n        key,\n        value\n      }\n    })\n  }\n  return [stateValue, setNormalInfo]\n}\n</code></pre>\n<p>// 上面封装之后我们就可以像使用useState一样来使用我们的normal模块了，在需要使用的页面引入使用即可，如下</p>\n<pre><code class=\"language-js\">// src/home.jsx\nimport * as React from 'react'\nimport { normalReducerDispatch } from 'src/effect/reducer'\n\nconst Home = () => {\n  const [isOk, setIsOk] = normalReducerDispatch('isOk')\n\n  return (\n    &#x3C;div className=\"home\">\n      &#x3C;div>{ isOk }&#x3C;/div>\n      &#x3C;button onClick={ setIsOk(!isOk) }>点我切换状态&#x3C;/button>\n    &#x3C;/div>\n  )\n}\n</code></pre>\n<ul>\n<li>这样就实现了我们上面代码同样的功能，其他需要使用redux的小模块也可以同样使用了</li>\n</ul>","fields":{"slug":"/react_hooks/"},"frontmatter":{"title":"react hooks下封装通用redux","tags":["react","react hooks","redux"],"categories":"React"}}},{"node":{"html":"<h1>对象类型与基本方法</h1>\n<ul>\n<li>对象的创建我们可以采用 new 关键字加对象类型的名称来进行创建，比如创建一个基本对象，就是</li>\n</ul>\n<pre><code class=\"language-js\">let o = new Object()\n</code></pre>\n<ul>\n<li>需要注意的是，后面的括号并不是必须的，当我们创建对象不需要传参则不需要后面的括号也不会报错，但是不推荐，如下</li>\n</ul>\n<pre><code class=\"language-js\">let o = new Object // 不推荐\n</code></pre>\n<ul>\n<li>Object类型是所有其他对象类型的基础，其他对象类型都基于它进行的衍生，所以所有的对象都具有下面这些Object的基本方法</li>\n</ul>\n<pre><code class=\"language-js\">isPropertyof(object) // 决定一个对象是否是另一个对象的原型\npropertyIsEnumerable(propertyName) // 决定一个对象属性是否可枚举\n</code></pre>","fields":{"slug":"/object-type/"},"frontmatter":{"title":"遗忘的对象基本属性","tags":["JavaScript回顾"],"categories":"JavaScript"}}},{"node":{"html":"<h1>不常用的一元操作符</h1>\n<h2>位操作符</h2>\n<ul>\n<li>ECMAScript中数值都是已64位格式存储，但是位操作符不能直接在64位中操作，要把值转为32位整数，操作完成后再转为64位整数。</li>\n<li>对开发者来说，是不用关注64位整数的，我们感知不到，我们只需要知道32位整数的工作原理即可</li>\n<li>有符号整数由一位符号位与31位二进制数值位来表示。第一位的符号位0表示正数，1表示负数。其他的数决定这个数的大小，数值跟二进制转十进制的方式相同，从最后一位开始，第一个代表2的0次方，第二个代表2的一次方，没有实际值的按0来填充。比如18按32位来表示为</li>\n</ul>\n<pre><code class=\"language-js\">00000000000000000000000000010010 // 32位表示18\n//转换方式\n(Math.pow(2, 0)) * 0 + (Math.pow(2, 1)) * 1 + (Math.pow(2, 2)) * 0 + (Math.pow(2, 3)) * 0 + (Math.pow(2, 4)) * 1\n</code></pre>\n<ul>\n<li>负数也是用二进制来表示，但是跟正数不一样，负数的表示是对应32位正数的补码。有三个步骤</li>\n<li>第一步，写出该负数的绝对值对应的32位数</li>\n<li>第二步，将32位数中的0变为1，1变为0</li>\n<li>\n<p>第三步，在第二步得到的数上加1，然后逢二进一，比如-18的表示</p>\n<!--more-->\n<pre><code class=\"language-js\">// 1.写出绝对值，也就是18的32位数\n00000000000000000000000000010010\n// 2.将0变为1，1变为0\n11111111111111111111111111101101\n// 3.在第二步的基础上加1\n11111111111111111111111111101110 // -18的32位表现形式\n</code></pre>\n</li>\n</ul>\n<pre><code>- ECMAScript会尽量的将这些数据都给你保留，当你使用toString并指定二进制数值时，会返回'-10010'来给你\n\n```js\nlet num = -18\nconsole.log(num.toString(2)) // '-10010'\n</code></pre>\n<ul>\n<li>上面是有符号正数，当我们用来表示无符号整数是，第一位就不再是符号位，也是真正的数值位，所以无符号整数可以比有符号整数大一点</li>\n<li>在ECMAScript中使用位运算时，会先将64位整数转为32位正数，然后进行位运算，然后转为64位整数，这也就给我们一个错觉，我们在操作真正的32位正数。这也使得对二进制的操作与其他语言相似。</li>\n<li>在这个处理中有两个特殊值NaN跟Infinity会跟0的处理方式一样</li>\n<li>如果为非数值类型使用位操作符则会使用Number()强制转为数值，然后计算</li>\n</ul>\n<h2>Not操作符(~)</h2>\n<ul>\n<li>简单的返回一个数对应32位数的补码（即0变为1，1变为0）</li>\n</ul>\n<pre><code class=\"language-js\">let num = 25 \n// 对应的32位数\n000000000000000000000000000011001\n// 使用位操作符\n111111111111111111111111111100110\n// 然后将32位数转为对应的负数，将之前的三步倒过来\n// 1.减1\n111111111111111111111111111100101\n// 2. 取补码\n000000000000000000000000000011010\n// 3.计算值并加负号\n-26\n</code></pre>\n<ul>\n<li>所以我们在对25进行了~操作后就得到了-26</li>\n<li>其实，~操作的结果就是我们对要操作的数进行取反，然后减1即可</li>\n<li>位操作符因为操作数值的最低级别，所以速度极快</li>\n</ul>\n<h2>AND操作符(&#x26;)</h2>\n<ul>\n<li>该符号工作于两个值，将两个值对应的位进行操作，只有当两个值对应位都是1才返回1，否则返回0，如下</li>\n</ul>\n<pre><code class=\"language-js\">let result = 25 &#x26; 3\n// 25的32位数\n000000000000000000000000000011001\n// 3的32位数\n000000000000000000000000000000011\n// 对应值\n000000000000000000000000000000001\n// 转为整数就是1\nconsole.log(result) // 1\n</code></pre>\n<h2>OR操作符(|)</h2>\n<ul>\n<li>该符号同样作用于两个值，对两个值的为进行操作，只有当两个值对应位都是0才返回0，否则返回1，如下</li>\n</ul>\n<pre><code class=\"language-js\">let result = 25 | 3\n// 25的32位数\n000000000000000000000000000011001\n// 3的32位数\n000000000000000000000000000000011\n// 对应值\n000000000000000000000000000011011\n// 转换为整数就是 27\nconsole.log(result) // 27\n</code></pre>\n<h2>XOR操作符(^)</h2>\n<ul>\n<li>同样作用与两个值，将两个数的32位数进行比较，当相同时返回0，不同时返回1，比如 0跟0返回0，1跟1返回0， 1跟0返回1，0跟1返回1，如下</li>\n</ul>\n<pre><code class=\"language-js\">let result = 25 | 3\n// 25的32位数\n000000000000000000000000000011001\n// 3的32位数\n000000000000000000000000000000011\n// 对应值\n000000000000000000000000000011010\n// 转换为整数就是 26\nconsole.log(result) // 26\n</code></pre>\n<h2>左移操作</h2>\n<ul>\n<li>左移操作由两个 &#x3C; 表示，并且将除符号位之外所有的位数向左移动指定的位数，比如对2进行左移5操作，如下</li>\n</ul>\n<pre><code class=\"language-js\">let val = 2\nlet newVal = val &#x3C;&#x3C; 5\n// 首先将2转为32位数\n000000000000000000000000000000010\n// 然后将除符号位的数向左移动5位\n0000000000000000000000000010\n// 然后把后面空出来的用0补起来\n000000000000000000000000001000000\n// 最终得到  64\nconsole.log(newVal) // 64\n</code></pre>\n<ul>\n<li>左移操作不会修改符号位，所以对-2进行左移5位得到的是-64而不是64</li>\n</ul>\n<h2>有符号右移操作</h2>\n<ul>\n<li>有符号右移使用两个 > 然后跟一个移动数量来表示，比如对64进行右移5操作，如下</li>\n</ul>\n<pre><code class=\"language-js\">let val = 64\nlet newVal = val >> 5\n// 首先将64转为32位数\n000000000000000000000000001000000\n// 然后将除符号位的数向右移动5位\n0     000000000000000000000000010\n// 然后把前面空出来的用0补起来\n000000000000000000000000000000010\n// 最终得到  2\nconsole.log(newVal) // 2\n</code></pre>\n<ul>\n<li>有符号右移操作同样不会修改符号位，所以对-64进行右移5位得到的是-2而不是2</li>\n</ul>\n<h2>无符号右移操作</h2>\n<ul>\n<li>无符号右移操作是使用三个 > 然后跟一个右移数量表示，因为是无符号数，所以32位都表示数值，也就不会对第一位进行保留了</li>\n<li>这种情况下对正数进行右移并不会改变原来的值，因为符号位本来就是0，如下</li>\n</ul>\n<pre><code class=\"language-js\">let val = 64\nlet newVal = val >> 5\n// 首先将64转为32位数\n000000000000000000000000001000000\n// 然后将所有数向右移动5位\n     0000000000000000000000000010\n// 然后把前面空出来的用0补起来\n000000000000000000000000000000010\n// 最终得到  2\nconsole.log(newVal) // 2\n</code></pre>\n<ul>\n<li>但是针对负数就不一样了，因为负数是对应正数取补码加1，所以表现形式不一致，比如-64，如下</li>\n</ul>\n<pre><code class=\"language-js\">let val = -64\nlet newVal = val >>> 5\n// 首先将-64转为32位数\n111111111111111111111111111000000\n// 然后将所有数向右移动5位\n     1111111111111111111111111110\n// 然后把前面空出来的用0补起来\n000001111111111111111111111111110\n// 最终得到  134217726\nconsole.log(newVal) // 134217726\n</code></pre>\n<h2>逻辑与(&#x26;&#x26;)</h2>\n<ul>\n<li>同样作用于两个值，类型无要求返回逻辑如下</li>\n<li>两个都是boolean值，则只有两个都是true才返回true，否则返回false</li>\n<li>如果第一个是对象，则一定返回第二个值</li>\n<li>如果第二个是对象，则只有第一个为true时才返回这个对象</li>\n<li>两个都是对象，则返回第二个对象</li>\n<li>两个中有一个null，返回null</li>\n<li>两个中有一个NaN，返回NaN</li>\n<li>两个中有一个undefined，返回undefined</li>\n<li>如果两个为undefined、null、NaN中的两个则第一个是什么就返回什么</li>\n<li>&#x26;&#x26;为短路操作符，第一个为false，则第二个永远不会执行，如下</li>\n</ul>\n<h2>逻辑或(||)</h2>\n<ul>\n<li>同样作用与两个值，类型无要求</li>\n<li>两个都是boolean值，则只有两个都是false才返回false，否则返回true</li>\n<li>如果第一个是对象，则返回第一个</li>\n<li>如果第一个是false，则返回第二个</li>\n<li>两个都是对象，返回第一个</li>\n<li>两个都是null，返回null</li>\n<li>两个都是undefined，返回undefined</li>\n<li>两个都是NaN，返回NaN</li>\n<li>||也是短路操作符，第一个为true，则第二个不执行</li>\n</ul>","fields":{"slug":"/unary-operators/"},"frontmatter":{"title":"不常用的一元操作符","tags":["JavaScript回顾"],"categories":"JavaScript"}}},{"node":{"html":"<h1>从零搭建一个react-hooks项目（五）</h1>\n<ul>\n<li>项目完成大概建起来了，但是当我打个生产包的时候都快哭了，一开始使用的devtool: \"source-map\"，用时高达 34 s，这当然是不可容忍的</li>\n<li>然后我们先将devtool改为\"none\"，然后发现变为了29s</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1075px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/0cf0800b8cd1b8010f7ea92caf0742f3/38a65/webpack.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 22.6%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAIAAADKYVtkAAAACXBIWXMAAAsSAAALEgHS3X78AAAA4klEQVQY03WO227DIBBE/TOJL8G3AIY1wQJjgh2HWFWdPKWN2v//iBK1UvtS6Wi00u7MbDT5l2FZ+skzaQlXjTAgjwc1CjWpwTNhUkSSf4hO8zr763y5Hd2CShbvcFBU8TSnQbOyiRFO8udpSAnbwK/5od2nPd+4fBw0A1MQucn2acHymm8zvE32cRoUP+cdCXGogpD7Yy4qXmFAJaWEL/Mou5430GvDhaVdR1UbACdpy6EBZb2yl7yG7/6oPUn1qvSqxzczv2sYBG8Na1WcNXZ108fg7oO56pqxomQE9N+3vwD8i0Hf7uZxMwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"图片\"\n        title=\"图片\"\n        src=\"/static/0cf0800b8cd1b8010f7ea92caf0742f3/38a65/webpack.png\"\n        srcset=\"/static/0cf0800b8cd1b8010f7ea92caf0742f3/0b533/webpack.png 500w,\n/static/0cf0800b8cd1b8010f7ea92caf0742f3/00d43/webpack.png 1000w,\n/static/0cf0800b8cd1b8010f7ea92caf0742f3/38a65/webpack.png 1075w\"\n        sizes=\"(max-width: 1075px) 100vw, 1075px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<h2>分析打包速度</h2>\n<ul>\n<li>通过 <code>speed-measure-webpack-plugin</code> 分析 <code>webpack</code> 构建期间各个阶段花费的时间，使用方法如下</li>\n</ul>\n<pre><code class=\"language-js\">const SpeedMeasurePlugin = require(\"speed-measure-webpack-plugin\");\nconst smp = new SpeedMeasurePlugin();\nmodule.exports = smp.wrap(webpackConfig)\n</code></pre>\n<ul>\n<li>然后在打包时就会显示打包中各阶段花费的时间，显示如下</li>\n</ul>\n<!--more-->\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 846px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/9d1709d15c5d6c27b8da868781ebfb3f/5b481/speed_measure.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 77.8%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAYAAAAWGF8bAAAACXBIWXMAABJ0AAASdAHeZh94AAAB4ElEQVQ4y5WUWW/aQBSF+S9VE4Lx7rE93vCGgUCBAKEli9pEVbe3/v+HrwNUTdpKiXm4Gmt0/emec66mYzoxtsjoWyGWl2CockRKYAZktkTXBWeaS7fvcf77fKk6ZhASlSVZcYkb5hiGj9EXGJqHtm9SkLc99w/sNWgnq2fcPX7n9uM33q1vGVcz5oOaRZbjOCF9Q2BZAk1vOWE1uuLx609291+4f/jB9e1nxsst0+2catkQSEno+ZjWk/QXgVE2Zr19YLrYsX7/icl8i5vkpMuMdJ6iC583Xae1jx07lqSjgqJRHsoS25RYmqCvHX++eNbcSnJQDJjfbZhcLxR4RFlVDGSKa8njVFp72AEoiojhjZpwo2SOS7w8QQ8lPTNUDSrdE2BHYB7TfGioNjVJ1ZDKAZnvoxteqxD+A+puSL24JBkOiZIRaRQRB8Ffa7I/z9sC3SxidDOkXFdERY2uvNtLPcjVnha6+/y7teS6ochzCpX8fu/2CV/oJ3poSRXKakpcqwlVwuEwZX9nugmRHyBVdU+R7CRK8q6hXNUHoB3Jg2zLFAhb0PvHy1eBXhYz2c2oVyOqKxVMMzg8EmEekZYxuoKe9U6QrNkBwUDtX5whkkw9XyE99eJo7rG6J3r4C5XEAqIGpU5aAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"图片\"\n        title=\"图片\"\n        src=\"/static/9d1709d15c5d6c27b8da868781ebfb3f/5b481/speed_measure.png\"\n        srcset=\"/static/9d1709d15c5d6c27b8da868781ebfb3f/0b533/speed_measure.png 500w,\n/static/9d1709d15c5d6c27b8da868781ebfb3f/5b481/speed_measure.png 846w\"\n        sizes=\"(max-width: 846px) 100vw, 846px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<ul>\n<li>不要在开发模式下使用这个分析插件，否则每次对代码进行修改都会导致webpack异常退出，报错 <code>Running webpack throws 'Callback was already called' error</code></li>\n</ul>\n<h2>优化一 优化解析速度 - 多进程打包</h2>\n<ul>\n<li>正常的webpack打包是单线程的，文件只能挨个处理，针对大量文件就会很慢，所以官方推荐了 thread_loader ，这个loader放在其他loader之前，，那么它后面的loader就会在单独的worker进程（node.js process）中进行</li>\n<li>thread_loader使用很简单，将它引入并放到其他loader之前即可</li>\n<li>注意：thread-loader 需要 style-loader 之后，这是因为 thread-loader 后的 loader 没法存取文件也没法获取 webpack 的选项设置。</li>\n</ul>\n<pre><code class=\"language-js\">module.exports = {\n  ...\n  module: {\n    rules: [\n      {\n        test: /\\.(ts|js)x?$/,\n        use: [\n          'thread-loader',\n          'babel-loader'\n        ],\n        exclude: /node-modules/\n      }\n    ]\n  }\n}\n</code></pre>\n<ul>\n<li>由于每个worker启动要600ms，为了防止worker启动的高延迟，我们可以进行预热</li>\n</ul>\n<pre><code class=\"language-js\">const threadLoader = require('thread-loader');\nconst jsWorkerPool = {\n  // options\n  \n  // 产生的 worker 的数量，默认是 (cpu 核心数 - 1)\n  // 当 require('os').cpus() 是 undefined 时，则为 1\n  workers: 2,\n  \n  // 闲置时定时删除 worker 进程\n  // 默认为 500ms\n  // 可以设置为无穷大， 这样在监视模式(--watch)下可以保持 worker 持续存在\n  poolTimeout: 2000\n};\nthreadLoader.warmup(jsWorkerPool, ['babel-loader']);\n\nmodule.exports = {\n  ...\n  module: {\n    rules: [\n      {\n        test: /\\.(ts|js)x?$/,\n        use: [\n          {\n            loader: 'thread-loader',\n            options: jsWorkerPool\n          },\n          'babel-loader'\n        ],\n        exclude: /node-modules/\n      }\n    ]\n  }\n}\n</code></pre>\n<ul>\n<li>然后我们再尝试打包，分析一下babel-loader的时间</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 846px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/9d1709d15c5d6c27b8da868781ebfb3f/5b481/speed_measure.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 77.8%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAYAAAAWGF8bAAAACXBIWXMAABJ0AAASdAHeZh94AAAB4ElEQVQ4y5WUWW/aQBSF+S9VE4Lx7rE93vCGgUCBAKEli9pEVbe3/v+HrwNUTdpKiXm4Gmt0/emec66mYzoxtsjoWyGWl2CockRKYAZktkTXBWeaS7fvcf77fKk6ZhASlSVZcYkb5hiGj9EXGJqHtm9SkLc99w/sNWgnq2fcPX7n9uM33q1vGVcz5oOaRZbjOCF9Q2BZAk1vOWE1uuLx609291+4f/jB9e1nxsst0+2catkQSEno+ZjWk/QXgVE2Zr19YLrYsX7/icl8i5vkpMuMdJ6iC583Xae1jx07lqSjgqJRHsoS25RYmqCvHX++eNbcSnJQDJjfbZhcLxR4RFlVDGSKa8njVFp72AEoiojhjZpwo2SOS7w8QQ8lPTNUDSrdE2BHYB7TfGioNjVJ1ZDKAZnvoxteqxD+A+puSL24JBkOiZIRaRQRB8Ffa7I/z9sC3SxidDOkXFdERY2uvNtLPcjVnha6+/y7teS6ochzCpX8fu/2CV/oJ3poSRXKakpcqwlVwuEwZX9nugmRHyBVdU+R7CRK8q6hXNUHoB3Jg2zLFAhb0PvHy1eBXhYz2c2oVyOqKxVMMzg8EmEekZYxuoKe9U6QrNkBwUDtX5whkkw9XyE99eJo7rG6J3r4C5XEAqIGpU5aAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"图片\"\n        title=\"图片\"\n        src=\"/static/9d1709d15c5d6c27b8da868781ebfb3f/5b481/speed_measure.png\"\n        srcset=\"/static/9d1709d15c5d6c27b8da868781ebfb3f/0b533/speed_measure.png 500w,\n/static/9d1709d15c5d6c27b8da868781ebfb3f/5b481/speed_measure.png 846w\"\n        sizes=\"(max-width: 846px) 100vw, 846px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<ul>\n<li>我们可以看到优化了将近 9 s</li>\n</ul>\n<h2>优化二 添加公用包的缓存</h2>\n<ul>\n<li>之前我们通过将不会发生变化的三方库进行抽离为dll文件，然后二次打包的时候不再对这些文件进行打包，以此来进行打包优化</li>\n<li>不过由于webpack的升级，已经有了不差于dll的打包性能，所以我们不再考虑dll形式的打包</li>\n<li>DLL不明显了，但是有了更好的替代品 hard-source-webpack-plugin ，只需要简单引入，之后第一次打包的时候可能会慢一点，但是从第二次开始就可以看到明显的差别</li>\n<li>使用方法如下</li>\n</ul>\n<pre><code class=\"language-js\">const HardSourceWebpackPlugin = require('hard-source-webpack-plugin');\n\nmodule.exports = {\n  ...\n  plugins: [\n    new HardSourceWebpackPlugin(),\n  ],\n}\n</code></pre>\n<ul>\n<li>之后我们再来对比一下，第一次打包</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 905px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/0a5a839f48d274f53f61f79181e56bb4/65d79/optimize_hard_source.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 59.599999999999994%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAABJ0AAASdAHeZh94AAABZ0lEQVQoz5WTwXKbMBRF+ZkmDRhsgwQSAhuBcUPjxMRtmCRtPVl0Ml32/zcnctpOvYTFmyeNNGfuvXrygmVKogvChebjTOBHKX4o8d06OO1dXQbJ+9mY8iKpyKsGqSxRbAhcLRcK6cDK9WyecTmbAExLy83hgZv9I5vunlXZIkSBnitMlDGbST74f4BjlHqresfw7SeH4cht/8Swf+JwfU9VbcmUoUgzkjjlYqRtr97ueXn9zfPxle8vv6i7A+XtBvvFslDqPUM/HJ+jlxUb+ocju/0zu/4RYztEVWI+Fw6YceHs/oONsiysZvO1pum3yNw9TJAyDwRXp9zC/xdHK0xKQ91/onI2TdNS25pCGMLoPLdkPFCsc5rBsr6r0HVFvMrxY8VVmE6avzOFOe3QUt01aDcyRWaQ8ZnFiVBPVobux7XLcYtetySJJpo74F+rkxUutcb2LWXXuB/jelkgYukUismwU70BXw2BEYpWaiQAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"图片\"\n        title=\"图片\"\n        src=\"/static/0a5a839f48d274f53f61f79181e56bb4/65d79/optimize_hard_source.png\"\n        srcset=\"/static/0a5a839f48d274f53f61f79181e56bb4/0b533/optimize_hard_source.png 500w,\n/static/0a5a839f48d274f53f61f79181e56bb4/65d79/optimize_hard_source.png 905w\"\n        sizes=\"(max-width: 905px) 100vw, 905px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<ul>\n<li>可以看到第一次的打包长中HardSourceWebpackPlugin 占了 30多s，几乎跟打包时常一样了</li>\n<li>但是当我们第二次打包的时候</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 902px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/9a5670f6b11f7999300161919faddbd7/58213/optimize_hard_source_after.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 52.2%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAABJ0AAASdAHeZh94AAABW0lEQVQoz5WSWU+DQBSF+TEtZSswwLDKFFroYukiiVVbbYzG5cH4/9+Ow9i4Jg19+HInmZsz59w7kmK6MEgARffQ012BzOkcqmJ4gt6P8zEkJ07AigkIZeiTGIaTgNohGMc1fXQPj7QVlWiaYVKtkZdLeGGGwI8Q+TFMw4dhUOimB/UUh/P1DR6e37Hdv+D67gmbzQ6L1QXS8xLRIEFEfZgW/RX/qOCk2mD/+Ibd/Suubp8wmtXIVgWyOoNzFn7NtXXkQVFhfblHxZ0u6i1iNkY8ZUiXDFYQQNbc05Yiaw66qo2OYvNKBLLqiq0r/UNj47KFmBBsNuuFOZLBVMCGc9hewp2RVgL/BMN0jJLPbVHvhNhwvAJNCmhWKBbR1dzv/6n+Qfu8b1I2ND2Swf9bn0QCzQpgkhB5XmI6W0LnkVnK3bNSzNbwKEzKe/xAzNd0KAihYKM5cm6E0BQfMxBBrC7aUMYAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"图片\"\n        title=\"图片\"\n        src=\"/static/9a5670f6b11f7999300161919faddbd7/58213/optimize_hard_source_after.png\"\n        srcset=\"/static/9a5670f6b11f7999300161919faddbd7/0b533/optimize_hard_source_after.png 500w,\n/static/9a5670f6b11f7999300161919faddbd7/58213/optimize_hard_source_after.png 902w\"\n        sizes=\"(max-width: 902px) 100vw, 902px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<ul>\n<li>这时神奇的事发生了，我们的打包时间变得只有13s了，缩短了60%</li>\n</ul>\n<h2>优化三 vendor代码分离</h2>\n<ul>\n<li>我们发现打出来的三方库的包vendor只有一个，体积达到了 2.6 M，这样对我们的首次加载是极其不友好的</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 905px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/f53ab1dd0530c86e20fa622a15fc0605/65d79/vendor_size.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 33.4%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAABJ0AAASdAHeZh94AAAA7klEQVQoz51Rf3ODIAz1+3/FnT13tlVBQBwqSOEtYW3Xs39tucvlF3l5IVWMETlnHGXfd/RCwYedogxtLAL5/DbGGzYfkFK69+YnRnU61WjbFsuyFBBWFh4kxQCtNbz3EEOPpmkgpSx1v22w1hafwZ6AXXeFEBITFe08F5syCgulFGbKhRDg3IJpmqBoQEo/LJd1fQf8qGt8the0lw6DVHBbwOr3oudrDzFquNVD0crdIEscYoKlAdp+4Y74C8i0efI4jjDGwJDPbPh/nHPYaDVen+1KjB6NN8ox8zeG+I+8HPF40OqB/ic9sHr1vwHj0CMVGwf3sgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"图片\"\n        title=\"图片\"\n        src=\"/static/f53ab1dd0530c86e20fa622a15fc0605/65d79/vendor_size.png\"\n        srcset=\"/static/f53ab1dd0530c86e20fa622a15fc0605/0b533/vendor_size.png 500w,\n/static/f53ab1dd0530c86e20fa622a15fc0605/65d79/vendor_size.png 905w\"\n        sizes=\"(max-width: 905px) 100vw, 905px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<ul>\n<li>导致vendor包过大的原因主要是我们的react组件都是同步引入的，导致webpack打包时认为是首页就需要的全部组件，从而将所有的依赖与文件都打到了一起</li>\n<li>解决这个问题我们就需要react的按需引入功能，配合webpack本身的异步分离打包实现vendor包的优化</li>\n<li>react本身支持异步导入，但是因为我们的项目使用了babel，所以我们需要确保babel可以解析异步导入语句，并能正确解析，所以引入 'babel-plugin-syntax-dynamic-import' ,使用方法如下</li>\n</ul>\n<pre><code class=\"language-js\">// 首先引入\nyarn add babel-plugin-syntax-dynamic-import -D -S\n// 然后修改 .babelrc 文件\n\"plugins\": [\n  \"syntax-dynamic-import\",\n  ...\n]\n</code></pre>\n<ul>\n<li>这样就保证我们可以正常使用react的异步导入方法了</li>\n<li>然后因为我们使用了typescript，并且配置项中的module是 es6 ，但是该模式下不支持异步导入，所以将其修改为 commonjs，如下</li>\n</ul>\n<pre><code class=\"language-js\">// tsconfig.json\n{\n  \"compilerOptions\": {\n    ...\n    \"module\": \"commonjs\", // 模块引入方式\n  }\n}\n</code></pre>\n<ul>\n<li>然后就完成了webpack基本项的配置，接下来就要修改我们的react代码</li>\n<li>我们使用react提供的 lazy 方法对组件页面进行异步引入</li>\n</ul>\n<pre><code class=\"language-js\">// 原代码\nimport * as React from 'react'\nimport Home from 'pages/home'\n\n// 异步导入\nimport * as React from 'react'\nconst { lazy } = React\nconst Home = lazy(() => import('pages/home'))\n</code></pre>\n<ul>\n<li>按这种形式将我们的所有页面引入都修改了，然后再进行打包尝试，打包后的结果如下</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 877px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/8c16623f3cc19666704e5d027dcf4353/4b446/vendor_list.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 73.4%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAABJ0AAASdAHeZh94AAAB80lEQVQ4y22TC2+bQBCE/f9/VSu1TZO0lZo2TnFjqDE2YDhe5mXzmO5cjEUMJ50SuNvhm93xwvd95HkOrr7v9eY6n89I0xR5keN0OqEsS/2cZZm+0zSNfndbt3h5WSIIgslBJZdd10UYhiiKAvZmA9O0EEXR23lVIUmSa92wFiyaJRSqOI5xPB41IYtDpTQhFz+Sy54QGoahSSaEQuB5HpSIFEWpXTiOo4kHwVlCFvHLwxoOSUV7JKrrWtNSlH0czsfOroIbe4P9hXB8WNeVFqAQaZUKtZNxDwf77wRp43A4TCyTioK0xWIKMxHq4oaEs4LbrQPP9yaCJxFkMS1SkPbYvyhS6LoeXdvOWzYtC7v9fnYoJKJF5o00vnyY77quQ9s284S8MEzuNja0y9jU8j+nStt818kdio6DfRV8Xa91HKaEl2Crt2DTOp89z0WrCdvrxCeEQRjgdukwX4LNAZEmGQilhxQs54L9Vwi3ux1q+e0WjII0upVDPnsyfSUihQimIuzL1EPpaSeFvJPODcX7eof950+wP36Af/cF8Y/vqJbPqGUHD/dI5Ln4/QvHp58IH+9lP6BZGXJniezbI3uDfiS6MFcW1n9MrJ4N/HvdwF7b8B3JmxfBsRy4tvTRVfovdxykSFUG5cdQjsSta98J/gdmnITTfyFT7QAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"图片\"\n        title=\"图片\"\n        src=\"/static/8c16623f3cc19666704e5d027dcf4353/4b446/vendor_list.png\"\n        srcset=\"/static/8c16623f3cc19666704e5d027dcf4353/0b533/vendor_list.png 500w,\n/static/8c16623f3cc19666704e5d027dcf4353/4b446/vendor_list.png 877w\"\n        sizes=\"(max-width: 877px) 100vw, 877px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<ul>\n<li>可以看到我们的vendor变成了 160 多k，并且将原来的大文件拆分为很多小的bundle文件，这对我们的首屏加载有很大的帮助</li>\n</ul>\n<h2>优化四 cdn引入</h2>\n<ul>\n<li>当前项目打包完成后能发现 echarts 的模块体积太大，这时我们就要对 echarts 进行cdn引入了，避免打包体积大影响我们的页面加载，如下</li>\n<li>移除 package.json 中的依赖</li>\n<li>html中新增script标签引入echarts </li>\n<li>配置webpack中的externals，使其能够正确的查找到 echarts 的依赖</li>\n</ul>\n<pre><code class=\"language-js\">// 引入cdn\n&#x3C;script src=\"https://cdn.staticfile.org/echarts/4.3.0/echarts.min.js\">&#x3C;/script>\n\n\n// 然后修改 webpack.common.js 文件\n\"externals\": {\n  echarts: \"echarts\"\n},\n</code></pre>\n<h2>优化五 添加打包进度</h2>\n<ul>\n<li>采用依赖库 webpackbar 即可实现打包进度，</li>\n</ul>\n<pre><code class=\"language-js\">// 首先引入\nyarn add webpackbar -D\n// 然后修改 webpack.common.js 文件\nconst webpackBar = require('webpackbar')\n\nmodule.exports = {\n  ...,\n  plugins: [\n    new webpackBar({\n      name: devMode ? '启动中' : '打包中',\n      color: '#3c99b0',\n    })\n  ],\n}\n</code></pre>","fields":{"slug":"/react_md_5/"},"frontmatter":{"title":"从零搭建一个react-hooks项目（五）","tags":["react","react hooks","redux","webpack"],"categories":"Webpack"}}},{"node":{"html":"<h1>javascript中的垃圾回收</h1>\n<ul>\n<li>javascript中的垃圾回收历史有两种，一种是最常用的标记清除，一种是不常用的引用计数清除法。</li>\n</ul>\n<h2>标记清除</h2>\n<ul>\n<li>标记清除是现代浏览器最常用的垃圾回收方式，原理是：</li>\n<li>当上下文有变量进入的时候就为它添加一个标记，这样整个程序执行时每一个创建的变量都会被添加标记。当变量离开上下文时也会被加上离开上下文的标记。然后当垃圾回收进程执行时，会把当前上下文的所有变量跟被引用的变量去除标记，这样剩下的有标记就都是不被引用也不被使用的变量了，这样就可以做内存清理了，销毁带标记的值并回收内存。</li>\n</ul>\n<h2>引用计数清除</h2>\n<ul>\n<li>这种计数方式在早期浏览器有使用过，后面就基本不怎么使用了，原理如下：</li>\n<li>当一个值被赋值给一个变量时就会把该值的引用数加一。比如，当声明一个变量并引用该值，则该值的引用数加一，当这个值被赋给另一个变量时，引用数继续加一。当一个引用该值的变量被其他值覆盖了，则该值的引用数减一，当引用数为0则表示该值不可被访问了，就会被垃圾回收。</li>\n<li>\n<p>该方式不常用是因为在循环引用时会无法释放内存，比如当a是一个对象，b也是一个对象，a的某个属性指向了b，b的某个属性指向了a，这样他们的引用值一直都不会为0，也就导致了该值一直存在无法回收。只有当我们显示的将a对应的属性跟b对应的属性都赋值null才会让他们进入垃圾回收。</p>\n<!--more-->\n<h2>性能优化</h2>\n</li>\n<li>现代浏览器的垃圾回收都是按照已分配对象的大小跟数量来判断的，这是因为早期IE是根据分配数来进行垃圾回收，比如设定了256个变量或者64k的字符串等，当满足其中的条件就会进行回收，这有可能整个脚本始终存在这么多的变量就导致了一直在运行，严重影响性能。</li>\n<li>所以改为了现有的根据分配对象来进行，首先它的起始阈值跟之前是一致的，只不过当某次垃圾回收的内存不到已分配的15%，那么就说明程序过大，这个阈值不够了，就会对阈值进行翻倍，然后下一次如果还是不到15%就继续翻倍，直到它满足15%以上为止</li>\n<li>如果某次的内存已经达到了85%，说明这个阈值已经过大了，应该再频繁一点，然后就会重置为默认值，重复进行这两个步骤，这样我们的性能就有很好的提升</li>\n<li>对声明的全局变量要是不再使用应该置为null</li>\n<li>多使用let、const提升性能，因为都是块级作用域，肯定会比全局变量更早终止，也就有可能更早的被回收</li>\n</ul>\n<h2>隐藏类优化性能</h2>\n<ul>\n<li>当我们的两个对象共享一个构造函数与原型时，在v8引擎会默认两个实例引用同一个隐藏类，如下：</li>\n</ul>\n<pre><code class=\"language-js\">function Article(){\n  this.title = \"my name\"\n}\nlet a1 = new Article()\nlet a2 = new Article()\n</code></pre>\n<ul>\n<li>这种情况下会默认使用一个隐藏类，但是当我们对对象进行了删除或者新增属性就会打破这个规则，如下</li>\n</ul>\n<pre><code class=\"language-js\">// 新增属性\nfunction Article(){\n  this.title = \"my name\"\n}\nlet a1 = new Article()\nlet a2 = new Article()\na2.name = 'danny'\n\n// 删除属性\nfunction Article(){\n  this.title = \"my name\"\n}\nlet a1 = new Article()\nlet a2 = new Article()\ndelete a2.title\n</code></pre>\n<ul>\n<li>这两种情况都会导致不再共享一个隐藏类，对应两个隐藏类，如果隐藏类过大就会影响性能，我们可以进行下面的优化</li>\n<li>对需要新增的属性操作添加在原型内，如下</li>\n</ul>\n<pre><code class=\"language-js\">function Article(name){\n  this.title = \"my name\"\n  this.name = name\n}\nlet a1 = new Article()\nlet a2 = new Article('danny')\n</code></pre>\n<ul>\n<li>这样还是共用一个隐藏类，针对删除操作，我们不要显示的删除，只需要将值设为null即可，如下</li>\n</ul>\n<pre><code class=\"language-js\">function Article(){\n  this.title = \"my name\"\n}\nlet a1 = new Article()\nlet a2 = new Article()\na2.title = null\n</code></pre>","fields":{"slug":"/collect-garbage2/"},"frontmatter":{"title":"javascript中的垃圾回收","tags":["JavaScript回顾"],"categories":"JavaScript"}}},{"node":{"html":"<ul>\n<li>javascript中的垃圾回收历史有两种，一种是最常用的标记清除，一种是不常用的引用计数清除法。</li>\n</ul>\n<h2>标记清除</h2>\n<ul>\n<li>标记清除是现代浏览器最常用的垃圾回收方式，原理是：</li>\n<li>当上下文有变量进入的时候就为它添加一个标记，这样整个程序执行时每一个创建的变量都会被添加标记。当变量离开上下文时也会被加上离开上下文的标记。然后当垃圾回收进程执行时，会把当前上下文的所有变量跟被引用的变量去除标记，这样剩下的有标记就都是不被引用也不被使用的变量了，这样就可以做内存清理了，销毁带标记的值并回收内存。</li>\n</ul>\n<h2>引用计数清除</h2>\n<ul>\n<li>这种计数方式在早期浏览器有使用过，后面就基本不怎么使用了，原理如下：</li>\n<li>当一个值被赋值给一个变量时就会把该值的引用数加一。比如，当声明一个变量并引用该值，则该值的引用数加一，当这个值被赋给另一个变量时，引用数继续加一。当一个引用该值的变量被其他值覆盖了，则该值的引用数减一，当引用数为0则表示该值不可被访问了，就会被垃圾回收。</li>\n<li>\n<p>该方式不常用是因为在循环引用时会无法释放内存，比如当a是一个对象，b也是一个对象，a的某个属性指向了b，b的某个属性指向了a，这样他们的引用值一直都不会为0，也就导致了该值一直存在无法回收。只有当我们显示的将a对应的属性跟b对应的属性都赋值null才会让他们进入垃圾回收。</p>\n<!--more-->\n<h2>性能优化</h2>\n</li>\n<li>现代浏览器的垃圾回收都是按照已分配对象的大小跟数量来判断的，这是因为早期IE是根据分配数来进行垃圾回收，比如设定了256个变量或者64k的字符串等，当满足其中的条件就会进行回收，这有可能整个脚本始终存在这么多的变量就导致了一直在运行，严重影响性能。</li>\n<li>所以改为了现有的根据分配对象来进行，首先它的起始阈值跟之前是一致的，只不过当某次垃圾回收的内存不到已分配的15%，那么就说明程序过大，这个阈值不够了，就会对阈值进行翻倍，然后下一次如果还是不到15%就继续翻倍，直到它满足15%以上为止</li>\n<li>如果某次的内存已经达到了85%，说明这个阈值已经过大了，应该再频繁一点，然后就会重置为默认值，重复进行这两个步骤，这样我们的性能就有很好的提升</li>\n<li>对声明的全局变量要是不再使用应该置为null</li>\n<li>多使用let、const提升性能，因为都是块级作用域，肯定会比全局变量更早终止，也就有可能更早的被回收</li>\n</ul>\n<h2>隐藏类优化性能</h2>\n<ul>\n<li>当我们的两个对象共享一个构造函数与原型时，在v8引擎会默认两个实例引用同一个隐藏类，如下：</li>\n</ul>\n<pre><code class=\"language-js\">function Article(){\n  this.title = \"my name\"\n}\nlet a1 = new Article()\nlet a2 = new Article()\n</code></pre>\n<ul>\n<li>这种情况下会默认使用一个隐藏类，但是当我们对对象进行了删除或者新增属性就会打破这个规则，如下</li>\n</ul>\n<pre><code class=\"language-js\">// 新增属性\nfunction Article(){\n  this.title = \"my name\"\n}\nlet a1 = new Article()\nlet a2 = new Article()\na2.name = 'danny'\n\n// 删除属性\nfunction Article(){\n  this.title = \"my name\"\n}\nlet a1 = new Article()\nlet a2 = new Article()\ndelete a2.title\n</code></pre>\n<ul>\n<li>这两种情况都会导致不再共享一个隐藏类，对应两个隐藏类，如果隐藏类过大就会影响性能，我们可以进行下面的优化</li>\n<li>对需要新增的属性操作添加在原型内，如下</li>\n</ul>\n<pre><code class=\"language-js\">function Article(name){\n  this.title = \"my name\"\n  this.name = name\n}\nlet a1 = new Article()\nlet a2 = new Article('danny')\n</code></pre>\n<ul>\n<li>这样还是共用一个隐藏类，针对删除操作，我们不要显示的删除，只需要将值设为null即可，如下</li>\n</ul>\n<pre><code class=\"language-js\">function Article(){\n  this.title = \"my name\"\n}\nlet a1 = new Article()\nlet a2 = new Article()\na2.title = null\n</code></pre>","fields":{"slug":"/collect-garbage/"},"frontmatter":{"title":"javascript中的垃圾回收","tags":["JavaScript回顾"],"categories":"JavaScript"}}},{"node":{"html":"<h1>乘、除、取余、指数、加法、减法、比较、相等操作符</h1>\n<h2>乘</h2>\n<ul>\n<li>乘法的计算遵循下面的原则</li>\n<li>如果结果超出ECMAScript所表示的范围，那么最终会得到 Infinity 或者 -Infinity</li>\n<li>NaN参与运算，得到NaN</li>\n<li>Infinity 与 0 相乘得 NaN </li>\n<li>Infinity 与 非 0 数相乘得 Infinity 或者 -Infinity ，由非 0 数决定符号</li>\n<li>如果其中一个是非数值，将会被Number()强制转为数值参与计算</li>\n</ul>\n<h2>除</h2>\n<ul>\n<li>除法的计算遵循下原则</li>\n<li>如果结果超出ECMAScript所表示的范围，那么最终会得到 Infinity 或者 -Infinity</li>\n<li>NaN参与运算，得到NaN</li>\n<li>Infinity 除以 Infinity 得到 NaN</li>\n<li>0 除以 0 得 NaN</li>\n<li>Infinity 除以 任何数都得 Infinity 或者 -Infinity ，符号由除数决定</li>\n<li>\n<p>如果其中一个操作符为非数值，则被Number()转为数值参与计算</p>\n<!--more-->\n<h2>取余</h2>\n</li>\n<li>取余的计算规则如下</li>\n<li>如果被除数是 Infinity ，除数是有限值，那么结果为 NaN</li>\n<li>如果被除数是 有限值，除数为 0，那么结果为 NaN</li>\n<li>除数跟被除数都是Infinity,则结果为NaN</li>\n<li>被除数是有限值，除数是Infinity,结果是被除数</li>\n<li>被除数是0，除数是非0，结果是0</li>\n<li>如果其中一个操作符为非数值，则被Number()转为数值参与计算</li>\n</ul>\n<h2>指数操作符</h2>\n<ul>\n<li>指数被用来表示某个数的多少次方，用<code>Math.pow()</code>来计算，在ECMAScript 7中可以使用 <code>**</code> 来表示</li>\n</ul>\n<pre><code class=\"language-js\">console.log(Math.pow(3, 2)) // 9\nconsole.log(3 ** 2) // 9\n</code></pre>\n<ul>\n<li>有了 <code>**</code>操作符自然也就有了对应的速写计算符<code>**=</code>，如下</li>\n</ul>\n<pre><code class=\"language-js\">let square = 3\nsquare **= 2\nconsole.log(square) // 9\n</code></pre>\n<h2>加法操作符</h2>\n<ul>\n<li>加法操作符比较特殊，对应不同的数据状态会发生不同的数据类型转换，规则如下</li>\n</ul>\n<h3>两个数都是数值的计算规则</h3>\n<ul>\n<li>如果两个数都是数值类型，那么对应规则如下</li>\n<li>有NaN参与计算，则值为NaN</li>\n<li>Infinity 加 -Infinity，结果为NaN</li>\n<li>-0 加 +0，结果为+0</li>\n<li>-0 加 -0，为-0， +0 加 +0，为+0</li>\n<li>Infinity 加 Infinity为Infinity，-Infinity 加 -Infinity 为 -Infinity</li>\n</ul>\n<h3>字符串参与计算的规则如下</h3>\n<ul>\n<li>其中一个值为字符串，则另一个值会被转为字符串然后进行拼接</li>\n</ul>\n<h2>减法操作符</h2>\n<ul>\n<li>减法操作符的计算规则</li>\n<li>NaN参与运算结果为NaN</li>\n<li>Infinity 减 Infinity ,结果为NaN</li>\n<li>-Infinity 减 -Infinity，结果为NaN</li>\n<li>Infinity 减 -Infinity，结果为Infinity</li>\n<li>-Infiniy 减 Infinity，结果为 -Infinity</li>\n<li>+0 减 +0 结果为 +0</li>\n<li>-0 减 +0 结果为 -0</li>\n<li>-0 减 -0 结果为 +0</li>\n<li>如果其中一个是 字符串、布尔值、null或者undefined，会使用Number()转为数值参与计算</li>\n<li>如果其中一个是对象，则会调用该对象的 valueOf() 方法来获取数值进行计算，如果对象没有valueOf方法，那么会调用toString()方法来获取值并转为对象参与计算</li>\n</ul>\n<h2>比较运算符</h2>\n<ul>\n<li>比较运算法有 >, &#x3C;, &#x3C;=, >=</li>\n<li>用来比较两个变量的大小关系，会返回一个布尔值</li>\n<li>针对不同数据类型，比较规则如下</li>\n<li>数值则直接比较大小</li>\n<li>都是字符串则依次比较每个字符对应的字符编码</li>\n<li>其中一个是数值则把另一个转为数值进行比较</li>\n<li>如果是对象，则调用 valueOf() 获取值参与比较，没有该属性就获取 toString()方法获取值参与比较</li>\n<li>如果其中一个是布尔值，则把它转为数值参与计算</li>\n<li>字符串比较时，所有的小写字母都要大于大写字母，所以要是想按字母顺序比较的话需要同时转为大写或者小写，如下</li>\n</ul>\n<pre><code class=\"language-js\">let result = \"Brick\" &#x3C; \"alphabet\"\nconsole.log(result) // true，并不是我们的预期\n\nlet result = \"Brick\".toLowerCase() &#x3C; \"alphabet\".toLowerCase()\nconsole.log(result) // false\n</code></pre>\n<ul>\n<li>NaN参与比较运算符永远都得false，哪怕是比较两个 NaN</li>\n</ul>\n<pre><code class=\"language-js\">let result = NaN > 3 // false\nlet result = NaN &#x3C;= 3 // false\n\nlet result = NaN > NaN // false\nlet result = NaN &#x3C;= NaN // false\n</code></pre>\n<h2>相等运算符</h2>\n<ul>\n<li>相等运算符分为全等与不全等运算符，不全等运算符不会比较类型，而是在比较时进行类型转换</li>\n</ul>\n<h3>不全等运算符规则</h3>\n<ul>\n<li>null 跟 undefined 相等</li>\n<li>null 跟 undefined 不会被转为其他类型进行比较</li>\n<li>NaN 参与比较永远返回false</li>\n<li>两个对象比较则对比是否两个是同一个对象，是就返回true，不是就返回false</li>\n<li></li>\n</ul>","fields":{"slug":"/multiplicative-operators/"},"frontmatter":{"title":"常用计算符独特的计算属性","tags":["JavaScript回顾"],"categories":"JavaScript"}}},{"node":{"html":"<h1>循环语句</h1>\n<h2>for-in 循环语句</h2>\n<ul>\n<li>for-in是严格迭代语句，会迭代一个对象中非Symbol的其他属性值，语法如下</li>\n</ul>\n<pre><code class=\"language-js\">for(const prop in obj) {\n  console.log(prop)  \n}\n</code></pre>\n<ul>\n<li>for-in迭代对象是无序的，各浏览器下返回的顺序可能不一致</li>\n<li>const并不是必须的，但建议使用，避免影响外界变量</li>\n<li>迭代null或undefined则迭代内的表达式不会被执行</li>\n</ul>\n<h2>for-of 循环语句</h2>\n<ul>\n<li>for-of也是迭代语句，只能迭代一个可迭代对象，语法如下</li>\n</ul>\n<pre><code class=\"language-js\">for(const value in obj) {\n  console.log(value)  \n}\n</code></pre>\n<ul>\n<li>迭代是有序的，由对象内部的next()方法决定</li>\n<li>\n<p>迭代一个非迭代器对象会抛出错误</p>\n<!--more-->\n<h2>标记语法</h2>\n</li>\n<li>用来标记一个表达式，用于在后续使用，一般用于配合break、continue打破循环使用</li>\n<li>标记语法如下</li>\n</ul>\n<pre><code class=\"language-js\">label: statement\n</code></pre>\n<ul>\n<li>break用于结束这个循环体，执行循环体后的语句</li>\n<li>continue用于结束单次循环，进行该循环体的下一次循环</li>\n<li>配合标记语法如下</li>\n</ul>\n<pre><code class=\"language-js\">let num = 0\noutermost: for(let i = 0; i &#x3C; 10; i++) {\n  for(let j = 0; j &#x3C; 10; j++) {\n    if(i === 5 &#x26;&#x26; j === 5) {\n      break outermost\n    }\n    num++\n  }\n}\n\nconsole.log(num) // 55\n</code></pre>\n<ul>\n<li>这里当执行到i跟j都是5的时候，我们的break将外层循环结束了，导致后续的4次大循环与当次剩余的5次小循环无法继续，所以导致最终的输出为55</li>\n</ul>\n<pre><code class=\"language-js\">let num = 0\noutermost: for(let i = 0; i &#x3C; 10; i++) {\n  for(let j = 0; j &#x3C; 10; j++) {\n    if(i === 5 &#x26;&#x26; j === 5) {\n      continue outermost\n    }\n    num++\n  }\n}\n\nconsole.log(num) // 95\n</code></pre>\n<ul>\n<li>这里的continue跳过了外层循环，导致子循环后续的5次没法执行直接到了下一个循环，所以最终次数会少5，变成了95</li>\n</ul>\n<h2>with语法</h2>\n<ul>\n<li>with语法用于将一个代码执行块与一个变量绑定，语法如下</li>\n</ul>\n<pre><code class=\"language-js\">with (expression) statement;\n</code></pre>\n<ul>\n<li>当一个对象被一次又一次的引用执行的时候就可以使用with语法来简化，比如下场景</li>\n</ul>\n<pre><code class=\"language-js\">let qs = location.search.substring(1)\nlet hostname = location.hostname\nlet url = location.href\n</code></pre>\n<ul>\n<li>这里我们的location对象被多次重复引用，我们可以使用with进行简化</li>\n</ul>\n<pre><code class=\"language-js\">with(location){\n  let qs = search.substring(1)\n  let hostname = hostname\n  let url = href\n}\n</code></pre>\n<ul>\n<li>with工作原理会在当前的作用域内查找是否有对应的变量，如果没有就会从对应location对象上面查找对应的同名属性</li>\n<li>在严格模式下with语法会报错</li>\n<li>with语法会降低代码性能与导致一些奇怪的bug，所以不推荐使用</li>\n</ul>","fields":{"slug":"/loop-statement/"},"frontmatter":{"title":"常用循环语句的基本属性","tags":["JavaScript回顾"],"categories":"JavaScript"}}},{"node":{"html":"<h1>script不为人知的标签属性</h1>\n<h2>普通引用</h2>\n<ul>\n<li>js加载与执行都会阻塞页面渲染与执行，等到js加载并执行完成后才会继续页面的渲染</li>\n</ul>\n<h2>async</h2>\n<ul>\n<li>js加载不会阻塞页面渲染，js加载后就会立即执行，执行时会阻塞页面渲染，有多个async的文件时，跟引入的顺序无关，谁先加载完就执行谁</li>\n</ul>\n<h2>defer</h2>\n<ul>\n<li>\n<p>js加载不会阻塞页面渲染，js加载后不会立即执行，等页面渲染完成后才执行，在 DOMContentLoaded 事件之前执行，有多个 defer 文件时，规范应该是按引入的顺序执行，但实际情况下并不一定按原有顺序执行，所以多个 defer 引入需注意</p>\n<!--more-->\n<h2>charset</h2>\n</li>\n<li>定义js脚本使用的编码值，大多数浏览器都没有遵守它，无意义</li>\n</ul>\n<h2>crossorigin</h2>\n<ul>\n<li>当正常引入跨域资源脚本时，因为浏览器限制，如果该脚本报错我们是拿不到报错信息的，监听onerror只能拿到script error，但是最新的html5规范又规定允许本地获取到跨域脚本错误的，这个时候，满足两个条件就可以实现</li>\n<li>跨域资源服务器通过 Access-Control-Allow-Origin 头信息允许当前域名可以获取错误信息。</li>\n<li>script标签指定脚本地址是跨域资源，也就是我们的 crossorigin，当值为 anonymous 时不携带cookie等认证信息，当值为 use-credentials 会携带cookie等认证信息</li>\n</ul>\n<h2>integrity</h2>\n<ul>\n<li>又称SRI，子资源完整性完整性。该值由两部分组成签名算法跟摘要签名内容组成，用 - 连接。</li>\n<li>指定了该值之后，浏览器在拿到资源后会用 integrity 指定的签名算法对资源进行计算并与 摘要签名内容 进行比较，如果值不统一，说明是经过篡改的，就不会执行该资源</li>\n</ul>\n<h2>type</h2>\n<ul>\n<li>传统意义上该值为\"text/javscript\"或者\"text/ecmascript\"，但是这两个值已经不赞成使用了</li>\n<li>通常我们应该设置该值为\"application/x-javascript\"，虽然设置该值可能会导致脚本被忽略</li>\n<li>其他在非IE浏览器下，我们可以设置为\"application/javascript\"或者\"application/ecmascript\"</li>\n<li>如果设置该值为\"module\"，则该文件下的code会被视为ES6模块，只有这样才能使用import跟export关键字</li>\n</ul>","fields":{"slug":"/script-element/"},"frontmatter":{"title":"script不为人知的标签属性","tags":["JavaScript回顾"],"categories":"JavaScript"}}},{"node":{"html":"<h1>符号类型(symbol)</h1>\n<ul>\n<li>Symbol是ES6新增的一种数据类型，用以标识独一无二的类型，所有的Symbol实例都是独一无二的</li>\n</ul>\n<h2>Symbol的使用方式</h2>\n<ul>\n<li>Symbol跟其他类不同，生成实例不需要使用 new 关键字，使用 new 关键字会报错，可以接受一个字符串作为Symbol的入参，也可以不传参直接生成，如下</li>\n</ul>\n<pre><code class=\"language-js\">let sm = new Symbol() // TypeError: Symbol is not a constructor\n\nlet sm1 = Symbol()\nconsole.log(sm1) // Symbol()\nconsole.log(typeof sm1) // symbol\nlet sm2 = Symbol('test')\nconsole.log(sm2) // Symbol('test')\n</code></pre>\n<!--more-->\n<ul>\n<li>每一个Symbol实例都不相同，如下实验</li>\n</ul>\n<pre><code class=\"language-js\">let sm = Symbol()\nlet sm1 = Symbol()\nconsole.log(sm === sm1) // false\n\nlet sm2 = Symbol('test')\nlet sm3 = Symbol('test')\nconsole.log(sm2 === sm3) // false\n</code></pre>\n<ul>\n<li>这也是Symbol最显著的特殊，可以让我们无后顾之忧的拓展对象属性，而不用担心会跟其现有的属性或方法冲突</li>\n</ul>\n<h2>Symbol.for()</h2>\n<ul>\n<li>如果都是使用上面的Symbol()来给对象赋值的的话我们就没法读取到该属性值了，如下</li>\n</ul>\n<pre><code class=\"language-js\">let a = {}\na[Symbol('test')] = 123\nconsole.log(a[Symbol('test')]) // undefined\n</code></pre>\n<ul>\n<li>因为在这里我们赋值跟取值的Symbol是完全不同的，为了避免这种情况，且能获取到对应的值我们需要使用Symbol.for()</li>\n<li>Symbol.for()方法的使用跟Symbol()的使用是一致的，可以接收一个字符串来做Symbol的唯一表示，调用该方式时，会从全局运行注册对象中查找有没有该Symbol，如果没有找到，就会生成一个Symbol对象并注册到全局运行注册对象中，然后返回该对象，如果查到了该Symbol，则直接返回该对象，所以看下示例：</li>\n</ul>\n<pre><code class=\"language-js\">let a = Symbol.for('test') // 没找到，创建实例\nlet b = Symbol.for('test') // 找到，直接返回实例\nconsole.log(a === b) // true\n\nlet c = {}\nc[Symbol.for('foo')] = 123\nconsole.log(c[Symbol.for('foo')]) // 123\n</code></pre>\n<ul>\n<li>使用Symbol()给对象赋值的方式，如下</li>\n</ul>\n<pre><code class=\"language-js\">let s1 = Symbol('foo'),\n  s2 = Symbol('bar'),\n  s3 = Symbol('baz'),\n  s4 = Symbol('qux')\nlet o = {\n  [s1]: 'foo val'\n}\nconsole.log(o) // {Symbol(foo): \"foo val\"}\nObject.defineProperty(o, s2, { value: 'bar val' })\nconsole.log(o) // {Symbol(foo): \"foo val\", Symbol(bar): \"bar val\"}\nObject.defineProperties(o, {\n  [s3]: { value: 'baz val' },\n  [s4]: { value: 'qux val' }\n})\nconsole.log(o) // {Symbol(foo): \"foo val\", Symbol(bar): \"bar val\", Symbol(baz): \"baz val\", Symbol(qux): \"qux val\"}\n</code></pre>\n<h2>Symbol.keyFor()</h2>\n<ul>\n<li>我们可以使用 Symbol.keyFor() 来检查一个Symbol实例是否存在与全局运行注册表中，该方法接收一个Symbol实例，如果全局注册表中存在该实例，则返回对应的key值，如果不存在，就会返回一个undefined，如下</li>\n</ul>\n<pre><code class=\"language-js\">Symbol.keyFor(Symbol.for('test')) // 'test'，通过Symbol.for()创建的Symbol实例会自动在注册表中注册\nSymbol.keyFor(Symbol('test')) // undefined 通过Symbol()方式创建的不会在注册表中注册，所以会返回undefined\n</code></pre>\n<h2>Object.getOwnPropertyNames() 跟 Object.getOwnPropertySymbols()</h2>\n<ul>\n<li>然后我们尝试使用 Object.getOwnPropertyNames 跟 Object.getOwnPropertySymbols 来获取一下对象o的值来看一下</li>\n</ul>\n<pre><code class=\"language-js\">Object.getOwnPropertyNames(o) // []\nObject.getOwnPropertySymbols(o) // [Symbol(foo), Symbol(bar), Symbol(baz), Symbol(qux)]\n</code></pre>\n<ul>\n<li>这里我们能看到使用 Object.getOwnPropertyNames 好像并不能获取到我们Symbol实例键，我们再给o拓展几个普通属性试试</li>\n</ul>\n<pre><code class=\"language-js\">o['baz'] = '123'\no['foo'] = '234'\n\nObject.getOwnPropertyNames(o) // [\"baz\", \"foo\"]\nObject.getOwnPropertySymbols(o) // [Symbol(foo), Symbol(bar), Symbol(baz), Symbol(qux)]\n</code></pre>\n<ul>\n<li>看到上结果我们也能知道，Object.getOwnPropertyNames 用于获取我们的常规除Symbol外的常规键值，Object.getOwnPropertySymbols 用于获取我们的Symbol键值</li>\n</ul>\n<h2>Object.getOwnPropertyDescriptors() 跟 Reflect.ownKeys()</h2>\n<ul>\n<li>然后我们再使用 Object.getOwnPropertyDescriptors() 跟 Reflect.ownKeys()来获取一下o的属性</li>\n</ul>\n<pre><code class=\"language-js\">Object.getOwnPropertyDescriptors(o) // {baz: {…}, foo: {…}, Symbol(foo): {…}, Symbol(bar): {…}, Symbol(baz): {…},Symbol(qux): {...}}\nReflect.keys(o) // [\"baz\", \"foo\", Symbol(foo), Symbol(bar), Symbol(baz), Symbol(qux)]\n</code></pre>\n<ul>\n<li>从中我们能看到 Object.getOwnPropertyDescriptors() 可以获取对象的常规值跟Symbol对应的值，Reflec.ownKeys() 可以获取对象的常规键跟Symbol键</li>\n</ul>","fields":{"slug":"/symbol/"},"frontmatter":{"title":"符号类型(symbol)","tags":["JavaScript回顾"],"categories":"JavaScript"}}},{"node":{"html":"<h1>字符串模板标记函数</h1>\n<h2>字符串模板</h2>\n<ul>\n<li>ES6新增的字符串定义方式，可以通过 <code></code> 配合${} 来进行变量的嵌入，如下示例</li>\n</ul>\n<pre><code class=\"language-js\">let name = '张三'\nlet age = 24\n// 常规定义字符串的方式\nlet str = '我的名字叫' + name + ', 我今年' + age + '岁了'\n\n// 字符串模板定义\nlet str1 = `我的名字叫${ name },我今年${ age }岁了`\n\nconsole.log(str === str1) // true\n</code></pre>\n<!--more-->\n<h2>模板标记函数</h2>\n<ul>\n<li>模板标记函数的定义跟普通函数一致，但是在使用它之前要准备一个字符串模板，调用方式也跟常规的函数调用方法不同，不需要使用 functionName() 的形式调用，直接在函数名后面跟模板字符串即可，如下:</li>\n</ul>\n<pre><code class=\"language-js\">let a = 6\nlet b = 9\nlet sum = 15\nfunction tagTemplate(strings, aVariable, bVariable, sumVariable) {\n  console.log(strings)        // ['', ' + ', ' = ', '']\n  console.log(aVariable)      // 6\n  console.log(bVariable)      // 9\n  console.log(sumVariable)    // 15\n}\n\ntagTemplate`${a} + ${b} = ${sum}`\n\nlet c = '张三'\nlet d = 24\nfunction tagTemplate(strings, cVariable, dVariable, notVariable) {\n  console.log(strings)        // ['我叫', '，今年', '岁了']\n  console.log(cVariable)      // '张三'\n  console.log(dVariable)      // 24\n  console.log(notVariable)    // undefined\n}\n\ntagTemplate`我叫${c}，今年${d}岁了`\n</code></pre>\n<ul>\n<li>使用标记函数可以看到，参数里面的第一个参数是数组，是由字符串模板被插入变量分割之后剩余字符串组成的数组，之后的参数依次就是按顺序插入变量的值了</li>\n<li>知道参数的形式后我们就可以用ES6的结构对插入变量进行一个遍历了</li>\n</ul>\n<pre><code class=\"language-js\">let c = '张三'\nlet d = 24\nfunction tagTemplate(strings, ...variable) {\n  console.log(strings)        // ['我叫', '，今年', '岁了']\n  for(let i = 0; i &#x3C; variable.length; i++) {\n    console.log(variable[i])\n  }\n  // '张三'  24\n}\n\ntagTemplate`我叫${c}，今年${d}岁了`\n</code></pre>\n<h3>模板标记函数下的raw数组</h3>\n<ul>\n<li>采用模板标记函数后，第一个数组返回的是我们的非变量插入的字符串片段，这里的字符串片段是会转换成我们的实际展示形式的，比如 \\u00A9 会转为 ©，\\n 会转为一个空格</li>\n<li>如果我们想要拿到没有经过转换的原版字符串，这里我们就可以使用这个数组上的raw属性来获取原版字符串的数组，我们可以看下代码</li>\n</ul>\n<pre><code class=\"language-js\">function tagTest(strings, ...rest){\n  for(let value of strings) {\n    console.log(value)\n  }\n  for(let value of strings.raw) {\n    console.log(value)\n  }\n}\nlet a = '张三'\nlet b = 24\ntagTest`你${ a }\\u00A9,哈哈\\n${ b }我`\n// strings遍历\n// 你\n// ©,哈哈 \n// 我\n\n// strings.raw遍历\n// 你\n// \\u00A9,哈哈\\n\n// 我\n</code></pre>\n<ul>\n<li>这就是模板标记函数给我们提供的一些特性，其实归结起来就是插入变量的提取跟原始字符串的收集，方便我们的使用</li>\n</ul>\n<h2>String.raw</h2>\n<ul>\n<li>String.raw是ES6标准的一个字符串方法，使用方式类似于模板标记函数，后面直接跟一个模板字符串即可，会原样返回该模板字符串的值，不受可编译字符的影响，普通的字符串会返回经过转义的字符串结果，如下</li>\n</ul>\n<pre><code class=\"language-js\">console.log(`\\u00A9`)\n// ©\nconsole.log(String.raw`\\u00A9`)\n// \\u00A9\n\nconsole.log(`Hi\\n`)\n// Hi\nconsole.log(String.raw`Hi\\n`)\n// Hi\\n\n\nconsole.log(`Hi\n张三`)\n// Hi\n// 张三\nconsole.log(String.raw`Hi\n张三`)\n// Hi\n// 张三\n</code></pre>\n<ul>\n<li>它只对会被重新编译的字符串生效，实际的回车或者空格是不会被转义回去的</li>\n<li>其实我也没想好这玩意哪里能用到，既然看到了就记录一下</li>\n</ul>","fields":{"slug":"/template-tag-function/"},"frontmatter":{"title":"字符串模板标记函数","tags":["JavaScript回顾"],"categories":"JavaScript"}}},{"node":{"html":"<h1>Well-Known Symbols</h1>\n<ul>\n<li>well-known symbols 是es6引入的在整个javascript中使用的一系列方法，用于直接访问、重写、模拟语言内部的一系列行为。这些方法或者说符号以字符串属性存在于Symbol的工厂函数上。</li>\n<li>这些符号存在的主要意义就是重新定义它们用于修改原生语言中的构造函数表现形式。例如，for of 循环其实是依靠于对象原型提供的 Symbol.iterator 属性，所以我们可以通过重新定义对象的 Symbol.iterator 属性来控制它的for of 表现。</li>\n<li>well-known symbols 这些符号就是Symbol对象上的一些字符串属性，定义良好的符号都具有不可写入、不可重复、不可配置的特性。</li>\n</ul>\n<h2>Symbol.asyncIterator</h2>\n<ul>\n<li>ECMAScript规范中，此符号用于描述一个对象返回默认异步迭代对象的方法属性。当对象具有该属性则该对象是异步可迭代的，可以被 for await of 表达式调用。</li>\n<li>语言构造器例如 for await of 利用该符号对应的方法来实现异步迭代。</li>\n<li>所以我们可以对一个自定义对象添加该符号方法实现其可被for await of 调用</li>\n<li>\n<p>for await of 的调用必须在async 函数下才可以</p>\n<!--more-->\n<pre><code class=\"language-js\">var a = { a :1, b: 2 }\nasync function b(){\nfor await(var value of a) {\nconsole.log(a)\n}\n}\nb() // TypeError: a is not async iterable\n</code></pre>\n</li>\n</ul>\n<p>var a = {\na :1,\nb: 2,\n*<a href=\"\">Symbol.asyncIterator</a>{\n}\n}\nasync function b(){\nfor await(var value of a) {\nconsole.log(a)\n}\n}\nb() // Promise {<resolved>: undefined}</p>\n<pre><code>- 可以看出只要我们实现了符号对应的异步方法，就可以正常调用，下面我们可以自定义我们想要的表现形式\n\n```js\nclass Emitter {\n  constructor(max) {\n    this.max = max\n    this.asyncIdx = 0\n  }\n  async*[Symbol.asyncIterator] () {\n    while(this.asyncIdx &#x3C; this.max) {\n      if(this.asyncIdx % 2 === 0) {\n        yield new Promise(resolve => resolve(this.asyncIdx++))\n      } else {\n        yield new Promise(resolve => {\n          setTimeout(() => {\n            resolve(this.asyncIdx++)\n          }, 1000)\n        })\n      }\n    }\n  }\n}\nvar a = new Emitter(6)\nasync function b(){\n  for await(let value of a) {\n    console.log(value)\n  }\n}\nb() // 0 1 2 3 4 5 \n</code></pre>\n<h2>Symbol.hasInstance</h2>\n<ul>\n<li>在ECMAScript标准中，该符号用做决定对象是否为构造器的实例。也就是“一个方法用来决定构造函数是否识别一个对象为它的实例。在语法上由instanceof方法调用”。instanceof操作符提供了一个方法判断一个对象实例在其原型链中是否有该原型。</li>\n<li>instanceof使用如下</li>\n</ul>\n<pre><code class=\"language-js\">function Foo(){}\nlet f = new Foo()\n\nconsole.log(f instanceof Foo) // true\n</code></pre>\n<ul>\n<li>在ES6中，instanceof 操作使用 SYmbol.hasInstance 来衡量这个关系。该键对应一个函数具有跟instanceof相同的表现，但是操作方式相反，如下</li>\n</ul>\n<pre><code class=\"language-js\">function Foo(){}\nlet f = new Foo()\nconsole.log(Foo[Symbol.hasInstance](f)) // true\n</code></pre>\n<ul>\n<li>该属性被定义到了函数原型上面，所以所有的函数跟类都自动具有了该方法，因为instanceof操作符会在原型链上查找这个属性值，所以我们可以在一个继承类上来重新定义该属性。</li>\n</ul>\n<pre><code class=\"language-js\">class Bar{}\nclass Baz extends Bar{\n  static [Symbol.hasInstance] (){\n    return false\n  }\n}\n\nlet b = new Baz()\nconsole.log(Bar[Symbol.hasInstance](b)) // true\nconsole.log(b instanceof Bar) // true\nconsole.log(Baz[Symbol.hasInstance](b)) // false\nconsole.log(b instanceof Baz) // false\n</code></pre>\n<ul>\n<li>我们能看到，当我们查找是否是Bar的实例时，因为我们的构造函数就是继承自Bar，并且没有修改Bar的相关属性，所以能正常返回true。但是当我们修改了Baz的构造函数之后，再次调用Baz返回的就是我们修改后的函数值了</li>\n</ul>\n<h2>Symbol.isConcatSpreadable</h2>\n<ul>\n<li>在ECMAScript标准中，此符号用来决定一个对象在被Array.prototype.concat()方法调用的时候是否要被扁平化。Array.prototype.concat()方法在ES6中将会基于传入的类数组对象来决定如何将其与数组实例拼接。符号Symbol.isConcatSpreadable将允许你重写这个方法。</li>\n<li>数组对象在默认情况下将会被扁平化处理到当前数组中，当对应实例的Symbol.isConcatSpreadable属性为false或者falsy数据时，则数组对象会被整个塞到当前数组中。如下</li>\n</ul>\n<pre><code class=\"language-js\">let initial = ['foo']\nlet array = ['baz']\nconsole.log(initial.concat(array)) // [\"foo\", \"baz\"]\n\nlet initial = ['foo']\nlet array = ['baz']\narray[Symbol.isConcatSpreadable] = false\nconsole.log(initial.concat(array)) // [\"foo\", Array(1)]\n</code></pre>\n<ul>\n<li>类数组对象在默认情况下会被整个塞到当前数组中，类似于append表现，当我们修改其Symbol.isConcatSpreadable属性为true或者truthy时，这个对象将会被扁平化处理，然后拼接到数组中。</li>\n<li>类数组对象有两个特征，一个是length属性值为数值，一个是有数字键值，看以下表现</li>\n</ul>\n<pre><code class=\"language-js\">// 默认值\nlet arrayLikeObject = { length: 1, 0: 'baz'}\nlet initial = ['foo']\nconsole.log(initial.concat(arrayLikeObject)) // [\"foo\", {…}]\n\n// 修改后\nlet arrayLikeObject = { length: 1, 0: 'baz'}\nlet initial = ['foo']\narrayLikeObject[Symbol.isConcatSpreadable] = true\nconsole.log(initial.concat(arrayLikeObject)) // [\"foo\", \"baz\"]\n</code></pre>\n<ul>\n<li>其他的非数组或者类数组对象在设置了Symbol.isConcatSpreadable为true时都会被忽略，并不会被添加进去</li>\n</ul>\n<pre><code class=\"language-js\">let otherObject = new Set().add('qux')\nlet initial = ['foo']\nconsole.log(initial.concat(otherObject)) // [\"foo\", Set(1)]\n\nlet otherObject = new Set().add('qux')\nlet initial = ['foo']\notherObject[Symbol.isConcatSpreadable] = true\nconsole.log(initial.concat(otherObject)) // [\"foo\"]\n</code></pre>\n<h2>Symbol.iterator</h2>\n<ul>\n<li>在ECMAScript标准中，该符号用于描述一个对象返回默认迭代器对象的方法属性。当对象具有该属性则该对象是可迭代的，可以被for of 循环调用。</li>\n<li>for of 语句就是利用此符号来执行迭代，该语句将会调用Symbol.iterator对应的函数，并期望它返回一个实现了迭代器的对象，在很多场景下会返回一个生成器(一个实现了Iterator api的对象。)</li>\n</ul>\n<pre><code class=\"language-js\">class Foo{\n  *[Symbol.iterator](){}\n}\nlet f = new Foo()\nconsole.log(f[Symbol.iterator]()) // Generator {&#x3C;suspended>}\n</code></pre>\n<ul>\n<li>需要注意的是，通过Symbol.iterator生产的对象需要能够连续生产对象凭借 next() 方法。这可以通过显示声明next方法或者通过生成器函数生成。</li>\n</ul>\n<pre><code class=\"language-js\">// 显式定义next\nclass Emitter{\n  constructor(max){\n    this.max = max\n    this.idx = 0\n  }\n  [Symbol.iterator](){\n    return {\n      next:() => {\n        if(this.idx &#x3C; this.max) {\n          return { value: this.idx++, done: false}\n        } else {\n          return { done: true }\n        }\n      }\n    }\n  }\n}\nfunction count(){\n  let emitter = new Emitter(6)\n  for(let x of emitter) {\n    console.log(x)\n  }\n}\ncount() // 0 1 2 3 4 5\n\n// 生成器函数生成\nclass Emitter{\n  constructor(max){\n    this.max = max\n    this.idx = 0\n  }\n  *[Symbol.iterator](){\n    while(this.idx &#x3C; this.max) {\n      yield this.idx++\n    }\n  }\n}\n\nfunction count(){\n  let emitter = new Emitter(5)\n  for(const x of emitter) {\n    console.log(x)\n  }\n}\n\ncount()  // 0 1 2 3 4\n</code></pre>\n<h2>Symbol.match</h2>\n<ul>\n<li>ECMAScript标准中，此符号是用于描述一个字符串与正则表达式的匹配关系的方法属性。被String.prototype.match()方法调用，String.prototype.match()方法会调用Symbol.match对应的函数去计算表达式，因为正则表达式的原型上有该方法属性，所以所有的正则表达式都可以被String.prototype.mactch()方法调用。</li>\n<li>如果提供其他的非正则表达式参数给String.prototype.match()将会把参数转为正则表达式。</li>\n<li>如果要避免此行为并且想要将参数直接使用，我们可以通过为参数指定 Symbol.match 属性为函数来绕过这个限制，该函数只接受一个参数，参数为调用match方法的字符串实例，返回值为任意类型。</li>\n</ul>\n<pre><code class=\"language-js\">// 正常情况\nvar a = {}\n'123123'.match(a) // null\n\n// 添加值\nvar a = {}\nObject.prototype[Symbol.match] = string => string.includes('123')\n'123123'.match(a) // true\n</code></pre>\n<ul>\n<li>上面我们就是为对象指定了Symbol.match属性，所以但我们传递进去对象值时都会返回true</li>\n</ul>\n<h2>Symbol.replace</h2>\n<ul>\n<li>ECMAScript标准中，此符号是用于描述“替换字符串中匹配到的子字符串的一个正则表达式方法，被String.prototype.replace()方法调用”</li>\n<li>String.prototype.replace将会调用参数上的Symbol.replace对应的方法来进行表达式计算</li>\n<li>正则表达式原型有Symbol.replace方法，所以所有的正则表达式都可以被replace方法调用。</li>\n<li>同样的，如果传入的是非正则类型，则会被强制转为正则类型。我们可以通过为入参定义Symbol.replace方法来绕过并重新定义行为</li>\n<li>定义的方法有两个参数，一个是原始字符串，一个是要替换的字符串</li>\n</ul>\n<pre><code class=\"language-js\">// 原表现形式\nclass Test{\n  constructor(str){\n    this.str = str\n  }\n}\n\"aaasdasddd\".replace(new Test('asd'), '123') // 'aaasdasddd'\n\n// 重新定义属性\nclass Test{\n  constructor(str){\n    this.str = str\n  }\n  [Symbol.replace] = (str, replaceStr) => str.split(this.str).join(replaceStr)\n}\n\"aaasdasddd\".replace(new Test('asd'), '123') // 'aa123123dd'\n</code></pre>\n<ul>\n<li>上面我们就实现了传递一个非正则对象给replace方法并成功完成我们想要的展示形式</li>\n</ul>\n<h2>Symbol.search</h2>\n<ul>\n<li>在ECMAScript规范中，该符号用来描述“一个用来返回字符串中符合对应正则表达式的字符串的位置，被String.prototype.search()方法调用”</li>\n<li>String.prototype.search将会调用参数上的Symbol.search对应的方法来进行表达式计算</li>\n<li>正则表达式原型有Symbol.search方法属性，所以所有的正则表达式都可以被search方法调用。</li>\n<li>同样的，如果传入的是非正则类型，则会被强制转为正则类型。我们可以通过为入参定义Symbol.search方法来绕过并重新定义行为</li>\n<li>定义的方法只有一个参数，就是对应的字符串实例，返回值为任意类型</li>\n</ul>\n<pre><code class=\"language-js\">// 原表现形式\nclass Search{\n  constructor(str){\n    this.str = str\n  }\n}\n\"hahaha\".search(new Search('ha')) // -1\n\n// 重新定义属性\nclass Search{\n  constructor(str){\n    this.str = str\n  }\n  [Symbol.replace] = (str) => str.indexOf(this.str)\n}\n\"hahaha\".replace(new Search('ha')) // 0\n</code></pre>\n<h2>Symbol.species</h2>\n<ul>\n<li>该符号被构建函数调用创造派生实例</li>\n<li>在构造类中声明静态getter方法Symbol.species将会覆盖新创建实例原型的构建函数</li>\n<li>当我们调用map方法或者concat方法时会默认返回对应实例的默认构造函数，如果我们这里通过声明getter方法Symbol.species来将其修改为其他构建对象，那在map或concat方法后返回的对象类型就会发生变化</li>\n</ul>\n<pre><code class=\"language-js\">class Bar extends Array {}\nvar b = new Bar(1, 2, 3)\nconsole.log(b instanceof Array) // true\nconsole.log(b instanceof Bar) // true\n\n// 添加getter方法\nclass Baz extends Array {\n  static get [Symbol.species] () {\n    return Number\n  }\n}\nvar c = new Baz(1, 2, 3)\nconsole.log(c instanceof Array)   // true\nconsole.log(c instanceof Baz)     // true\nconsole.log(c instanceof Number)  // false\n\nconsole.log(c.concat(c) instanceof Array)   // false\nconsole.log(c.concat(c) instanceof Baz)     // false\nconsole.log(c.concat(c) instanceof Number)  // true\n</code></pre>\n<ul>\n<li>从上面我们可以看出，声明getter方法Symbol.species后，对单独的实例不会有影响，但是当返回默认的构造函数时，就会使用我们Symbol.species中返回的构造函数了</li>\n</ul>\n<h2>Symbol.split</h2>\n<ul>\n<li>该符号用于描述“一个用于在匹配正则表达式的位置进行字符串分割的正则表达式方法，被String.prototype.split()方法调用”</li>\n<li>String.prototype.split将会调用入参对象的Symbol.split属性方法来进行表达式计算。</li>\n<li>正则表达式原型有Symbol.split方法属性，所以所有的正则表达式都可以被split方法调用。</li>\n<li>同样的，如果传入的是非正则类型，则会被强制转为正则类型。我们可以通过为入参定义Symbol.split方法来绕过并重新定义行为</li>\n<li>定义的方法只有一个参数，就是对应的字符串实例，返回值为任意类型</li>\n</ul>\n<pre><code class=\"language-js\">// 原表现形式\nclass Split{\n  constructor(str){\n    this.str = str\n  }\n}\n\"123hahaha123\".split(new Split('ha')) // [\"123hahaha123\"]\n\n// 重新定义属性\nclass Split{\n  constructor(str){\n    this.str = str\n  }\n  [Symbol.split](target){\n    console.log(123, target, this.str)\n    return target.split(this.str)\n  }\n}\n\"123hahaha123\".split(new Split('ha')) // [\"123\", \"\", \"\", \"123\"]\n</code></pre>\n<h2>Symbol.toPrimitive</h2>\n<ul>\n<li>该符号用于描述“一个将对象转换为常规数据类型的方法，被强制类型操作符所调用”。很多内置操作符都会尝试将对象转为基本数据类型，例如：string类型、number类型、number类型，或者其他的基本类型。</li>\n<li>对一个自定义的对象，我们可以通过定义它的Symbol.toPrimitive属性来决定它的强制类型转换方式。该方法接收一个它原本会被转换为的数据类型的类型字符串名称，所以我们根据这个情况构造我们想要的形式</li>\n</ul>\n<pre><code class=\"language-js\">// 原始类型\nclass Foo{}\nlet foo = new Foo()\nconsole.log(3 + foo) // \"3[object Object]\"\nconsole.log(3 - foo)  // NaN\nconsole.log(String(foo))  // \"[object Object]\"\n\n// 自定义表现形式\nclass Bar {\n  constructor(){\n    this[Symbol.toPrimitive] = function (hint){\n      switch(hint) {\n        case 'string':\n          return 'string bar'\n        case 'number':\n          return 3\n        case 'default':\n        default:\n          return 'default bar'\n      }\n    }\n  }\n}\nlet bar = new Bar()\nconsole.log(3 + bar) // 3default bar\nconsole.log(3 - bar)  // 0\nconsole.log(String(bar))  // string bar\n</code></pre>\n<ul>\n<li>上面我们可以看到，当对象遇到 + 操作符时它无法确定要执行字符串拼接的 + 操作还是数值的相加 + 操作，所以就返回了默认的 default bar;当对象遇到 - 操作时明确的知道自己要被转为数值类型，所以走了 case 'number' ，返回了3，然后被执行操作；当预定String()方法时也明确的知道自己要返回字符串类型，所以返回了 string bar</li>\n</ul>\n<h2>Symbol.toStringTag</h2>\n<ul>\n<li>该符号用于描述“一个对象的创建对象类型的默认字符串描述，被Object.prototype.toString所调用”，该创建对象的字符串描述会依靠Symbol.toStringTag方法来获取，默认为\"Object\"</li>\n<li>内置类型都有声明这个属性方法，但是自定义对象就需要我们显式声明了</li>\n</ul>\n<pre><code class=\"language-js\">// 内置对象\nvar s = new Set()\nconsole.log(s)                      // Set(0) {}\nconsole.log(s.toString())           // [object Set]\nconsole.log(s[Symbol.toStringTag])  // Set\n// 自定义对象\nclass Foo{}\nvar f = new Foo()\nconsole.log(f)                      // Foo {}\nconsole.log(f.toString())           // [object Object]\nconsole.log(f[Symbol.toStringTag])  // undefined\n\n// 修改后的自定义对象\nclass Bar{\n  constructor(){\n    this[Symbol.toStringTag] = 'Bar'\n  }\n}\nvar b = new Bar()\nconsole.log(b)                      // Bar {Symbol(Symbol.toStringTag): \"Bar\"}\nconsole.log(b.toString())           // [object Bar]\nconsole.log(b[Symbol.toStringTag])  // Bar\n</code></pre>\n<h2>Symbol.unscopables</h2>\n<ul>\n<li>该符号用于描述“防止被width操作绑定到该对象的自有属性或者继承属性”，设置这个属性将指定键值改为true则with方法将无法在该对象上查找指定属性</li>\n</ul>\n<pre><code class=\"language-js\">// 正常形式\nvar o = { foo: 'asd' }\nwith(o) {\n  console.log(foo) // 'asd'\n}\n\n// 自定义后\nvar o = { foo: 'asd' }\no[Symbol.unscopables] = {\n  foo: true\n}\nwith(o) {\n  console.log(foo)  // Uncaught ReferenceError: foo is not defined\n}\n</code></pre>\n<ul>\n<li>新的ECMAScript规范中已经不推荐使用with方法了，所以，我们的Symbol.unscopables也不再推荐使用</li>\n</ul>","fields":{"slug":"/well-known-symbol/"},"frontmatter":{"title":"Well-Known Symbols","tags":["JavaScript回顾"],"categories":"JavaScript"}}},{"node":{"html":"<h1>Date 类型</h1>\n<ul>\n<li>Date构造函数可以接收毫秒数来创建时间对象，对此提供了辅助函数来进行毫秒数的获取</li>\n</ul>\n<h2>Date.parse()</h2>\n<ul>\n<li>\n<p>该方法接收一个表示日期的字符串，并转为对应的毫秒数，接受的格式如下</p>\n<ul>\n<li>\"月/日/年\"，如\"5/23/2019\"</li>\n<li>\"月名日,年\"，如\"May 23, 2019\"</li>\n<li>\"周几月名日年时:分:秒:时区\"，如\"Tue May 23 2020 00:00:00 GMT-0700\"</li>\n<li>拓展格式\"YYYY-MM-DDTHH:mm:ss.sssZ\"，如：\"2020-05-23T00:00:00\"</li>\n</ul>\n</li>\n<li>使用方式如下</li>\n</ul>\n<pre><code class=\"language-js\">let time1 = new Date(Date.parse(\"May 23, 2020\"))\n// Sat May 23 2020 00:00:00 GMT+0800 (中国标准时间)\n</code></pre>\n<ul>\n<li>如果传给Date.parse()的字符串不能表示时间该方法返回NaN</li>\n<li>如果在给new Date()传参时直接传了表示时间的字符串，那Date会在后台隐式调用Date.parse()，下代码与上面同样</li>\n</ul>\n<pre><code class=\"language-js\">let time1 = new Date(\"May 23, 2020\")\n// Sat May 23 2020 00:00:00 GMT+0800 (中国标准时间)\n</code></pre>\n<ul>\n<li>\n<p>关于越界时间，当我们传了一个不存在的时间比如3月32号时部分浏览器会返回4月1号的时间，有些浏览器则会直接返回当前时间，比如你在5月1日运行代码就会返回5月1号的时间</p>\n<!--more-->\n<h2>Date.UTC()</h2>\n</li>\n<li>这个方法也是用于返回日期的毫秒数，但是参数不一样，参数是年，零起点的月数（也就是1月用0表示，2月用1表示，依次类推），日，时（0-24），分，秒，毫秒</li>\n<li>只有年跟月是必须，其他的不填都默认为0，使用方式如下</li>\n</ul>\n<pre><code class=\"language-js\">let time2 = new Date(Date.UTC(2020, 09, 12, 15, 44, 03))\n// Mon Oct 12 2020 23:44:03 GMT+0800 (中国标准时间)\n</code></pre>\n<ul>\n<li>可以看到其实会被我们的参数当做UTC时间来做解析，最后得到的是本地的 23：44</li>\n<li>当我们在new Date()的时候使用Date.UTC形式的参数，那Date也会隐式调用Date.UTC()，但是不同的是不会被当做UTC时间处理而是当做本地时间处理，如下</li>\n</ul>\n<pre><code class=\"language-js\">let time2 = new Date(2020, 09, 12, 15, 44, 03)\n// Mon Oct 12 2020 15:44:03 GMT+0800 (中国标准时间)\n</code></pre>\n<h2>Date原型方法</h2>\n<ul>\n<li>Date对象重写了toString、valueOf、toLocalString方法</li>\n<li>toLocalString与toString，两个方法分别返回对应的GMT时间与本地时间，如下</li>\n</ul>\n<pre><code class=\"language-js\">new Date().toLocaleString()\n// \"2020/10/12 下午3:53:58\"\nnew Date().toString()\n// \"Mon Oct 12 2020 15:54:04 GMT+0800 (中国标准时间)\"\n</code></pre>\n<ul>\n<li>valueOf方法会返回对应时间的毫秒数，数字类型</li>\n</ul>\n<pre><code class=\"language-js\">new Date().valueOf()\n// 1602489459169\n</code></pre>\n<ul>\n<li>\n<p>Date格式时间的方法</p>\n<ul>\n<li>toDateString()，显示时间中的周几、月、日、年</li>\n<li>toTimeString()，显示时间中的时、分、秒、时区</li>\n<li>toLocalDateString()，获取本地时间的周几、月、日、年</li>\n<li>toLocalTimeString()，获取本地时间的时、分、秒、时区</li>\n<li>toUTCString()，显示完整的UTC时间</li>\n</ul>\n</li>\n</ul>","fields":{"slug":"/Date/"},"frontmatter":{"title":"Date类型","tags":["JavaScript回顾"],"categories":"JavaScript"}}},{"node":{"html":"<h1>Number 类型</h1>\n<ul>\n<li>Number对象也重写了toString、toLocalString、valueOf方法</li>\n<li>valueOf返回原数值</li>\n<li>toString()接收一个参数用于表示该数字的几进制数，如下</li>\n</ul>\n<pre><code class=\"language-js\">let num = 10\nconsole.log(num.toString()) // '10'\nconsole.log(num.toString(2)) // '1010'\nconsole.log(num.toString(8)) // '12'\nconsole.log(num.toString(10)) // '10'\nconsole.log(num.toString(16)) // 'a'\n</code></pre>\n<ul>\n<li>toExponential()用于表示数值的科学技术法的表示字符串</li>\n</ul>\n<pre><code class=\"language-js\">console.log(num.toExponential()) // 1e+1\n</code></pre>\n<ul>\n<li>\n<p>toPrecision()会根据你传入的参数决定输出结果，该参数表示结果中的数字的位数，如下</p>\n<!--more-->\n<pre><code class=\"language-js\">let num1 = 99\nconsole.log(num1.toPrecision(1)) // 1e+2\nconsole.log(num1.toPrecision(2)) // 99\nconsole.log(num1.toPrecision(3)) // 99.0\n</code></pre>\n</li>\n<li>ES6新增isInteger()用于判断是否是整数</li>\n</ul>\n<pre><code class=\"language-js\">console.log(Number.isInteger(1)) // true\nconsole.log(Number.isInteger(1.00)) // true\nconsole.log(Number.isInteger(1.01)) // false\n</code></pre>\n<ul>\n<li>该方法不会受到小数点后都是0的影响</li>\n<li>IEEE 754数值格式有一个特殊的数值范围，此范围内的二进制值可表示一个整数，该范围为Number.MIN<em>SAFE</em>INTEGER((-2) ** 53 + 1) 到 Number.MAX<em>SAFE</em>INTEGER(2 ** 53 - 1)</li>\n<li>超出这个范围的值在保存为整数时数值可能会变化，所以我们可以通过 Number.isSafeInteger()来判断一个整数是否在该范围内</li>\n</ul>\n<pre><code class=\"language-js\">console.log(Number.isSafeInteger(-1 * (2 ** 53))) // false\nconsole.log(Number.isSafeInteger(-1 * (2 ** 53) + 1)) // true\n</code></pre>","fields":{"slug":"/Number/"},"frontmatter":{"title":"Number类型","tags":["JavaScript回顾"],"categories":"JavaScript"}}},{"node":{"html":"<h1>String类型</h1>\n<ul>\n<li>字符串由16位码元组成，多数字符都是16位码元对应一个字符，length属性就是表示有多少个16位码元</li>\n<li>charAt()方法返回给定索引位置的字符，参数为索引位置</li>\n<li>javascript采用UCS-2和UTF-16两种Unicode编码混合策略，对于(U+0000~U+FFFF)，这两种编码是一样的</li>\n<li>charCodeAt()可以查看对应索引位置的字符编码，参数为索引位置</li>\n<li>fromCharCode()可以根据给定的UTF-16码元创建字符串，然后将其拼接返回</li>\n</ul>\n<pre><code class=\"language-js\">let message = 'abcde'\nconsole.log(message.charAt(2)) // 'c'\nconsole.log(message.charCodeAt(2)) // 99\n// 可以16进制入参\nconsole.log(String.fromCharCode(0x61, 0x62, 0x63, 0x64, 0x65)) // \"abcde\"\nconsole.log(String.fromCharCode(97, 98, 99, 100, 101)) // \"abcde\"\n</code></pre>\n<ul>\n<li>对于在U+0000~U+FFFF范围内的字符，length、charAt()、charCodeAt()、fromCharCode()都可以正常运行</li>\n<li>当拓展到Unicode增补字符平面就不行了，上面的16位只能标识65536个字符，这些表示基本多语言平面，为了表示更多的字符，采用了每个字符使用另外16位去选择一个增补平面。这种每个字符使用两个16位码元的策略称为代理对</li>\n<li>\n<p>当我们对含有代理对编码的字符串就会有问题，如下</p>\n<!--more-->\n<pre><code class=\"language-js\">let message = 'ab😊de'\nconsole.log(message.length)     // 6\nconsole.log(message.charAt(1))  // b\nconsole.log(message.charAt(2))  // �\nconsole.log(message.charAt(3))  // �\nconsole.log(message.charAt(4))  // d \nconsole.log(message.charCodeAt(1))  // 98\nconsole.log(message.charCodeAt(2))  // 55357\nconsole.log(message.charCodeAt(3))  // 56842\nconsole.log(message.charCodeAt(4))  // 100\n</code></pre>\n</li>\n</ul>\n<p>console.log(String.fromCharCode(97, 98, 55357, 56842, 100, 101)) // ab😊de</p>\n<pre><code>- 这里我们能看到笑脸符明显占了两个字符，然后我们尝试使用fromCharCode()来将代理对进行解析为字符串是没有问题的，这是因为浏览器可以正常解析代理对\n- 针对这种情况，我们可以使用codePointAt()来替代charCodeAt()\n- codePointAt()使用方法跟charCodeAt()基本一致，也是接受一个表示索引的参数并返回该索引的码点。码点是Unicode中一个字符的完整标识，可能是16位，也有可能32位，codePointAt()可以查看完整的码点\n\n```js\nlet message = 'ab😊de'\nconsole.log(message.codePointAt(1))  // 98\nconsole.log(message.codePointAt(2))  // 128522\nconsole.log(message.codePointAt(3))  // 56842\nconsole.log(message.codePointAt(4))  // 100\n</code></pre>\n<ul>\n<li>我们可以通过字符串解析来识别代理对，如下</li>\n</ul>\n<pre><code class=\"language-js\">let message = 'ab😊de'\nconsole.log([...message]) // [\"a\", \"b\", \"😊\", \"d\", \"e\"]\n</code></pre>\n<ul>\n<li>这样就将我们的代理对给完整解析了</li>\n<li>对应的，我们也有fromCodePoint()来讲对应的码点转为字符串，并拼接返回</li>\n</ul>\n<pre><code class=\"language-js\">// 使用 fromCharCode要有6位数字才可以\nconsole.log(String.fromCharCode(97, 98, 55357, 56842, 100, 101)) // ab😊de\n// 使用 fromCodePoint\nconsole.log(String.fromCodePoint(97, 98, 128522, 100, 101)) // ab😊de\n</code></pre>\n<h2>normalize 方法</h2>\n<ul>\n<li>该方法针对一些可以使用多种编码方式表达的unicode字符，比如下面字符</li>\n</ul>\n<pre><code class=\"language-js\">// 上面带圆圈的 A\nconsole.log(String.fromCharCode(0x00C5))          // Å\n// 长度单位 “埃”\nconsole.log(String.fromCharCode(0x212B))          // Å\n// U+004大写字符 A, U+030A 上面的圆圈\nconsole.log(String.fromCharCode(0x0041, 0x030A))  // Å\n</code></pre>\n<ul>\n<li>上面三种编码返回的字符串看上去是一样的，其实编码不一样，所以比较起来也不会一样</li>\n</ul>\n<pre><code class=\"language-js\">let a1 = String.fromCharCode(0x00C5),\na2 = String.fromCharCode(0x212B),\na3 = String.fromCharCode(0x0041, 0x030A)\nconsole.log(a1 === a2)  // false\nconsole.log(a1 === a3)  // false\nconsole.log(a2 === a3)  // false\n</code></pre>\n<ul>\n<li>针对上情况，Unicode提供了4种格式化方法，将类似上面的字符串转为一致格式，分别是NFD、NFC、NFKD、NFKC</li>\n<li>然后我们就可以使用normalize方法跟对应的优化方法名称来进行格式化</li>\n</ul>\n<pre><code class=\"language-js\">let a1 = String.fromCharCode(0x00C5),\na2 = String.fromCharCode(0x212B),\na3 = String.fromCharCode(0x0041, 0x030A)\n\n// U+005C是对U+212B进行NFC/NFKC规范之后的结果\nconsole.log(a1 === a1.normalize('NFD')) // false\nconsole.log(a1 === a1.normalize('NFC')) // true\nconsole.log(a1 === a1.normalize('NFKD')) // false\nconsole.log(a1 === a1.normalize('NFKC')) // true\n\n// U+212B是未规范化的\nconsole.log(a2 === a2.normalize('NFD')) // false\nconsole.log(a2 === a2.normalize('NFC')) // false\nconsole.log(a2 === a2.normalize('NFKD')) // false\nconsole.log(a2 === a2.normalize('NFKC')) // false\n\n// U+0041/U+030A是对U+212B进行NFD/NFKD规范之后的结果\nconsole.log(a3 === a3.normalize('NFD')) // true\nconsole.log(a3 === a3.normalize('NFC')) // false\nconsole.log(a3 === a3.normalize('NFKD')) // true\nconsole.log(a3 === a3.normalize('NFKC')) // false\n</code></pre>\n<ul>\n<li>当对上述编码采用同样的规范方式可以让比较操作符返回正确结果</li>\n</ul>\n<pre><code class=\"language-js\">let a1 = String.fromCharCode(0x00C5),\na2 = String.fromCharCode(0x212B),\na3 = String.fromCharCode(0x0041, 0x030A)\n\nconsole.log(a1.normalize(\"NFD\") === a2.normalize(\"NFD\")) // true\nconsole.log(a1.normalize(\"NFKC\") === a3.normalize(\"NFKC\")) // true\nconsole.log(a2.normalize(\"NFC\") === a3.normalize(\"NFC\")) // true\n</code></pre>\n<h2>slice、substr、substring对比</h2>\n<ul>\n<li>这三种方法都是从字符串中提取子字符串</li>\n<li>都接收一个或两个参数，第一个参数为开始位置</li>\n<li>slice跟substring第二个参数为提取结束的位置，该位置之前的字符串都会被提取</li>\n<li>substr第二个参数表示要提取的字符串的长度</li>\n<li>忽略第二个参数这三个方法的返回值一致，都会提取到字符串尾</li>\n</ul>\n<pre><code class=\"language-js\">let stringValue = 'hello world'\nconsole.log(stringValue.slice(3))      //  'lo world'\nconsole.log(stringValue.substring(3))  //  'lo world'\nconsole.log(stringValue.substr(3))     //  'lo world'\nconsole.log(stringValue.slice(3, 7))      //  'lo w'\nconsole.log(stringValue.substring(3, 7))  //  'lo w'\nconsole.log(stringValue.substr(3, 7))     //  'lo worl'\n</code></pre>\n<ul>\n<li>当参数为负数时，slice会将所有负数跟字符串长度相加作为新的参数</li>\n<li>substr会将第一个负数参数与字符串长度相加，第二个负数参数转为0</li>\n<li>substring会将所有的负数参数转为0，会将小的参数作为起点，大的参数作为终点</li>\n</ul>\n<pre><code class=\"language-js\">let stringValue = 'hello world'\nconsole.log(stringValue.slice(-3))      //  'rld'\nconsole.log(stringValue.substring(-3))  //  'hello world'\nconsole.log(stringValue.substr(-3))     //  'rld'\nconsole.log(stringValue.slice(3, -4))      //  'lo w'\nconsole.log(stringValue.substring(3, -4))  //  'hel'\nconsole.log(stringValue.substr(3, -4))     //  ''\n</code></pre>\n<h2>indexOf与lastIndexOf</h2>\n<ul>\n<li>都是查找指定字符串，接受两个参数，第一个是查找字符串，第二个是起始位置</li>\n<li>indexOf默认从0开始向后找，指定第二个参数后会从第二个参数指定的下标开始找，忽略该下标之前的字符</li>\n<li>lastIndexOf默认从字符串最后一位开始向前找，指定第二个参数则会从参数指定的下标向前找，忽略该下标之前的字符</li>\n</ul>\n<h2>startsWith、endsWith、includes</h2>\n<ul>\n<li>ES6新增用于判断字符串中是否包含另外字符串的方法，都返回布尔值</li>\n<li>startsWith检查开始于索引0的匹配项</li>\n<li>endsWith检查开始于索引(string.length - subString.length)的匹配项</li>\n<li>includes检查整个字符串</li>\n</ul>\n<pre><code class=\"language-js\">let message = 'foobarbaz'\n\nconsole.log(message.startsWith('foo')) // true\nconsole.log(message.startsWith('bar')) // false\n\nconsole.log(message.endsWith('baz')) // true\nconsole.log(message.endsWith('bar')) // false\n\nconsole.log(message.includes('bar')) // true\nconsole.log(message.includes('foo')) // true\n</code></pre>\n<ul>\n<li>startsWith与includes可接收第二个参数，用于表示开始查找的位置，传入该参数会忽略该参数之前的字符</li>\n<li>endsWith也可以接收第二个参数，用于表示字符串末尾的位置，传入该参数就好像将被查找字符串截断了一样</li>\n</ul>\n<pre><code class=\"language-js\">let message = 'foobarbaz'\n\nconsole.log(message.startsWith('foo')) // true\nconsole.log(message.startsWith('foo', 1)) // false\n\nconsole.log(message.includes('bar')) // true\nconsole.log(message.includes('bar', 4)) // false\n\nconsole.log(message.endsWith('bar')) // false\nconsole.log(message.endsWith('bar', 6)) // true\n</code></pre>\n<h2>trim、trimRight、trimLeft</h2>\n<ul>\n<li>分别用于去除两端的空格、右面的空格、左面的空格</li>\n</ul>\n<h2>repeat方法</h2>\n<ul>\n<li>接收一个整数参数，表示将该字符串复制多少次然后拼接返回</li>\n</ul>\n<pre><code class=\"language-js\">let stringValue = 'na '\nconsole.log(stringValue.repeat(8)) // 'na na na na na na na na '\n</code></pre>\n<h2>padStart、padEnd方法</h2>\n<ul>\n<li>这两个方法会复制字符串，如果小于指定字符串，则在相应的一边填充字符，直到满足条件，第一个参数是长度，第二个参数是可选的填充字符串，默认为空格</li>\n</ul>\n<pre><code class=\"language-js\">let stringValue = 'foo'\nconsole.log(stringValue.padStart(6))      // '   foo'\nconsole.log(stringValue.padStart(6, '.')) // '...foo'\nconsole.log(stringValue.padEnd(6))        // 'foo   '\nconsole.log(stringValue.padEnd(6, '.'))   // 'foo...'\n</code></pre>\n<ul>\n<li>要是第二个参数指定的是多个字符的字符串，那么在复制后如果长度超出会把参数指定的字符串裁剪</li>\n<li>如果第一个参数指定的长度小于等于原始字符串长度，则返回原始字符串</li>\n</ul>\n<pre><code class=\"language-js\">let stringValue = 'foo'\nconsole.log(stringValue.padStart(8, 'bar')) // 'barbafoo'\nconsole.log(stringValue.padStart(2))        // 'foo'\nconsole.log(stringValue.padEnd(8, 'bar'))   // 'foobarba'\nconsole.log(stringValue.padEnd(2))          // 'foo'\n</code></pre>\n<h2>字符串解析与迭代</h2>\n<ul>\n<li>字符串原型暴露了 @@iterator方法，所以字符串可以被解析与迭代，如下</li>\n</ul>\n<pre><code class=\"language-js\">let a = 'abcde'\nfor(const c of a) {\n  console.log(c)\n}\n// a\n// b\n// c\n// d\n// e\nconsole.log([...a])\n// [\"a\", \"b\", \"c\", \"d\", \"e\"]\n</code></pre>\n<h2>toLowerCase、toUpperCase、toLocalLowerCase、toLocalUpperCase</h2>\n<ul>\n<li>都是用于进行大小写转换的，toLowerCase与toLocalLowerCase都是将字符串转为小写字母表示，toLocalLowerCase是为了防止出现地方字符无法转换的情况</li>\n<li>toUpperCase与toLocalUpperCase都是将字符串转为大写字母表示，toLocalUpperCase是为了防止出现地方字符无法转换的情况</li>\n</ul>\n<h2>match、search、replace方法</h2>\n<ul>\n<li>match方法接收一个正则表达式或正则表达式字符串，返回一个数组，第一个元素是与正则匹配的字符串，其余的元素是表达式中的捕获组匹配到的字符串('()'中的内容)</li>\n<li>search方法是查找方法，也是接收一个正则表达式或者正则表达式字符串，返回匹配到的第一个的索引，没有找到返回-1</li>\n<li>replace是替换方法，接受两个参数，第一个参数是正则表达式或者字符串（该字符串时不会转为正则表达式），第二个参数是字符串或者函数。当地一个参数为字符串时只会替换查找到的第一个字符串，要想全部替换必须用正则表达式</li>\n</ul>\n<pre><code class=\"language-js\">let text = 'cat, bat, sat, fat'\nconsole.log(text.replace('at', 'ond'))    // cond, bat, sat, fat\nconsole.log(text.replace(/at/g, 'ond'))   // cond, bond, sond, fond\nconsole.log(text.replace(/(.at)/g, 'word ($1)')) // word (cat), word (bat), word (sat), word (fat)\n</code></pre>\n<ul>\n<li>第二个参数为函数时，当匹配项只有一个时，有三个参数，整个模式匹配的字符串、匹配字符串的开始位置、整个字符串。</li>\n<li>当有多个捕获组的情况下，每个匹配的捕获组的字符串也会被当做参数，最后两个参数仍然是匹配字符串的开始位置、整个字符串</li>\n<li>这个函数应该返回一个字符串，表示把匹配项换成什么</li>\n</ul>\n<h2>split方法</h2>\n<ul>\n<li>split会根据传入的参数将字符串转为数组，参数可以是字符串，也可以是RegExp对象。还可以接收第二个参数来表示数组大小，确保数组不会超过指定大小</li>\n</ul>\n<pre><code class=\"language-js\">let color = 'red,blue,green,yellow'\nconsole.log(color.split(','))     // [\"red\", \"blue\", \"green\", \"yellow\"]\nconsole.log(color.split(',', 2))  // [\"red\", \"blue\"]\nconsole.log(color.split(/[^,]+/)) // [\"\", \",\", \",\", \",\", \"\"]\n</code></pre>\n<h2>localeCompare方法</h2>\n<ul>\n<li>用于比较字符串</li>\n<li>按照字母排序，如果字符串应该排在字符串参数之前，返回负数</li>\n<li>字符串与参数字符串相同，返回0</li>\n<li>字符串应该在字符串参数之后，返回正数</li>\n</ul>\n<pre><code class=\"language-js\">let stringValue = 'yellow'\nconsole.log(stringValue.localeCompare('brick'))   // 1\nconsole.log(stringValue.localeCompare('yellow'))  // 0\nconsole.log(stringValue.localeCompare('zoo'))     // -1\n</code></pre>","fields":{"slug":"/String/"},"frontmatter":{"title":"String类型","tags":["JavaScript回顾"],"categories":"JavaScript"}}},{"node":{"html":"<h1>Global对象及方法</h1>\n<h2>encodeURI、encodeURIComponent</h2>\n<ul>\n<li>这两个方法都是用于编码统一资源标识符（URI），以传给浏览器</li>\n<li>区别是encodeURI不会编码属于URL组件的特殊字符，如冒号、斜杠、问号、井号，而encodeURIComponent会编码所有的非标准字符</li>\n<li>所以一般我们会使用encodeURIComponent</li>\n<li>它们分别对应的解码方法时decodeURI与decodeURIComponent</li>\n</ul>\n<h2>eval</h2>\n<ul>\n<li>eval接收一个完整的要执行的ECMAScript字符串，当解释器发现eval()方法时会将其解释为真实的ECMAScript语句</li>\n<li>然后将其插入当前位置，插入的语句属于该调用的执行上下文，被执行语句与该上下文有同样的作用域链</li>\n</ul>\n<pre><code class=\"language-js\">let msg = 'hello'\neval(\"console.log(msg)\") // 'hello'\n</code></pre>\n<!--more-->\n<ul>\n<li>可以在eval中定义函数或变量，然后在外面引用</li>\n</ul>\n<pre><code class=\"language-js\">eval(\"function sayHi(){ console.log('hi')}\")\nsayHi() // hi\n\neval(\"let msg = 'world'\")\nconsole.log(msg) // msg is not defined\n</code></pre>\n<ul>\n<li>这是因为eval中的变量跟函数都无法被提升，只有到执行之后才会被创建，所以函数可以正常执行，但是变量在编译阶段就会报错</li>\n<li>在严格模式下使用eval会报错</li>\n</ul>\n<h2>Math对象</h2>\n<ul>\n<li>Math.E,自然对数的基数e的值</li>\n<li>Math.LN10，10为底的自然对数</li>\n<li>Math.LN2，2为底的自然对数</li>\n<li>Math.LOG2E，以2为底e的对数</li>\n<li>Math.LOG10E，以10为底e的对数</li>\n<li>Math.PI，数字π</li>\n<li>Math.SQRT1_2，1/2的平方根</li>\n<li>Math.SQRT2，2的平方根</li>\n</ul>\n<h3>min和max方法</h3>\n<ul>\n<li>min，确定一组数值的最小值</li>\n<li>max，确定一组数值的最大值</li>\n</ul>\n<pre><code class=\"language-js\">console.log(Math.min(3, 8, 4, 12, 66,44, 66, 77)) // 3\nconsole.log(Math.max(3, 8, 4, 12, 66,44, 66, 77)) // 77\n</code></pre>\n<ul>\n<li>由接受参数形式可以对数组解构来获取最大最小值</li>\n</ul>\n<pre><code class=\"language-js\">let arr = [3, 8, 4, 12, 66,44, 66, 77]\nconsole.log(Math.min(...arr)) // 3\nconsole.log(Math.max(...arr)) // 77\n</code></pre>\n<ul>\n<li>其他方法</li>\n<li>Math.abs()，返回绝对值</li>\n<li>Math.exp(x)，返回MATH.E的x次幂</li>\n<li>Math.expm1(x)，Math.exp(x) - 1</li>\n<li>Math.log(x)，返回x的自然对数</li>\n<li>Math.log1p(x)，等于1 + Math.log(x)</li>\n<li>Math.pow(x, power)，返回x的power次幂</li>\n<li>Math.hypot(...nums)，返回nums中每个数平方和的平方根</li>\n<li>Math.clz32(x)，返回32位整数x的前置0的数量</li>\n<li>Math.sign(x)，返回表示x符号的1，0，-0，-1</li>\n<li>Math.trunc(x)，返回x的整数部分，删除所有小数部分</li>\n<li>Math.sqrt(x)，返回x的平方根</li>\n<li>Math.cbrt(x)，返回x的立方根</li>\n<li>Math.acos(x)，返回x的反余弦</li>\n<li>Math.acosh(x)，返回x的反双曲余弦</li>\n<li>Math.asin(x)，返回x的反正弦</li>\n<li>Math.asinh(x)，返回x的双反曲正弦</li>\n<li>Math.atan(x)，返回x的反正切</li>\n<li>Math.atanh(x)，返回x的双反曲正切</li>\n<li>Math.atan2(y, x)，返回y/x的反正切</li>\n<li>Math.cos(x)，返回x的余弦</li>\n<li>Math.sin(x)，返回x的正弦</li>\n<li>Math.tan(x)，返回x的正切</li>\n</ul>","fields":{"slug":"/Global/"},"frontmatter":{"title":"Global对象","tags":["JavaScript回顾"],"categories":"JavaScript"}}},{"node":{"html":"<h1>Array对象</h1>\n<h2>Array的创建</h2>\n<ul>\n<li>Array构建函数创建</li>\n<li>无参数创建会生成一个空的数组</li>\n<li>当传入一个数值时，会生成一个数组，并且长度设为该数值</li>\n<li>当传入一个非数值时，会生成一个数组，并且数组第一项位该值</li>\n<li>如果传入多个值时，会生成一个数组，并且这几个值都会依次存在于数组中</li>\n</ul>\n<pre><code class=\"language-js\">let arr1 = new Array()\nlet arr2 = new Array(3)\nlet arr3 = new Array('张三')\nlet arr4 = new Array({ name: '张三' })\nlet arr5 = new Array(5, '张三', 24)\nconsole.log(arr1, arr2, arr3, arr4, arr5)\n// []\n// [empty × 3]\n// [\"张三\"]\n// [{…}]\n// [5, \"张三\", 24]\n</code></pre>\n<h2>Array.from、Array.of</h2>\n<ul>\n<li>这两个都是Array构造函数的静态方法，属于ES6新增范畴</li>\n<li>Array.from用于将类数组结构转为数组</li>\n<li>Array.from方法接收的第一个参数是一个类数组对象（任何可迭代的结构）或者有length属性与可索引元素的结构</li>\n</ul>\n<!--more-->\n<pre><code class=\"language-js\">// 字符串转为数组\nconsole.log(Array.from(\"Matt\"))\n// [\"M\", \"a\", \"t\", \"t\"]\nconst m = new Map().set(1,2).set(3,4)\nconst s = new Set().add(1).add(2).add(3).add(4)\nconsole.log(Array.from(m)) // [[1, 2], [3, 4]]\nconsole.log(Array.from(s)) // [1, 2, 3, 4]\nconst iter = {\n  *[Symbol.iterator](){\n    yield 1;\n    yield 2;\n    yield 3;\n    yield 4;\n    yield 5;\n  }\n}\nconsole.log(Array.from(iter)) // [1, 2, 3, 4, 5]\n\nfunction getArgsArray(){\n  return Array.from(arguments)\n}\nconsole.log(getArgsArray(1,2,3,4)) // [1, 2, 3, 4]\n\nconst arrayLikeObject = {\n  0: 1,\n  1: 2,\n  3: 3,\n  4: 4,\n  length:4\n}\nconsole.log(Array.from(arrayLikeObject)) // [1, 2, 3, 4]\n</code></pre>\n<ul>\n<li>Array.from的第二个参数（可选）接收的是一个对新数组操作的函数，会对新数组的每一项都执行该函数</li>\n<li>第三个参数（可选）接收的是操作函数的this的值，当第二个参数是箭头函数时，这个值无效</li>\n</ul>\n<pre><code class=\"language-js\">const array = [1,2,3,4]\nconst a2 = Array.from(array, x => x ** 2)\nconst a3 = Array.from(array, function(x) { return x ** this.exponent}, { exponent: 2 })\nconsole.log(a2) // [1, 4, 9, 16]\nconsole.log(a3) // [1, 4, 9, 16]\n</code></pre>\n<ul>\n<li>Array.of可以把一组参数专为数组，用于替代之前的Array.prototype.slice.call(arguments)</li>\n</ul>\n<pre><code class=\"language-js\">console.log(Array.of(1, 2, 3, 4)) // [1, 2, 3, 4]\nconsole.log(Array.of(undefined))  // [undefined]\n</code></pre>\n<h2>数组检测</h2>\n<ul>\n<li>在只有一个全局上下文时只用 instanceof 就够用了，但是要是有两个全局上下文，那么对应的Array构造函数可能不同，这种情况下可能不合适</li>\n<li>所以针对这种情况就提供了 Array.isArray()方法，该方法只用于确定一个值是否是数组，跟上下文环境无关</li>\n</ul>\n<pre><code class=\"language-js\">let array = [1, 2, 3, 4]\nlet arrayLike = {\n  0: 1,\n  1: 2,\n  2: 3,\n  length: 3\n}\nconsole.log(array instanceof Array)     // true\nconsole.log(arrayLike instanceof Array) // false\n\nconsole.log(Array.isArray(array))       // true\nconsole.log(Array.isArray(arrayLike))   // false\n</code></pre>\n<h2>迭代器方法</h2>\n<ul>\n<li>Array原型暴露了3个检索数组内容的方法，keys()，values()，entries()</li>\n<li>keys返回数组索引的迭代器</li>\n<li>values返回数组元素的迭代器</li>\n<li>entries返回索引/元素的迭代器</li>\n</ul>\n<pre><code class=\"language-js\">// 都是迭代器，所以可以直接使用Array.from转为数组\nconst a = ['foo', 'bar', 'baz', 'qux']\nconsole.log(Array.from(a.keys()))     //  [0, 1, 2, 3]\nconsole.log(Array.from(a.values()))   // [\"foo\", \"bar\", \"baz\", \"qux\"]\nconsole.log(Array.from(a.entries()))  // [[0, \"foo\"], [1, \"bar\"], [2, \"baz\"], [3, \"qux\"]]\n</code></pre>\n<h2>填充方法copyWithin、fill</h2>\n<ul>\n<li>数组填充方法 fill() 可以向一个已有的数组中插入全部或部分相同的值。</li>\n<li>第一个参数为填充值</li>\n<li>第二个参数为开始索引，指定开始填充的位置（可选），</li>\n<li>第三个参数为结束索引位置（填充不包含该位置），不提供结束索引就一直填充到数组末尾</li>\n<li>负值索引从数组末尾开始计算（也可以理解为数组长度加上它得到的正值索引）</li>\n</ul>\n<pre><code class=\"language-js\">const zeroes = [0, 0, 0, 0, 0]\nzeroes.fill(5) // [5, 5, 5, 5, 5]\nzeroes.fill(0) // 重置为 0 [0, 0, 0, 0, 0]\n\nzeroes.fill(6, 3) // [0, 0, 0, 6, 6]\nzeroes.fill(0)\n\nzeroes.fill(7, 1, 3) // [0, 7, 7, 0, 0]\nzeroes.fill(0)\n\n// -4 + 5 = 1, -1 + 5 = 4,等价于zeroes.fill(1, 4)\nzeroes.fill(8, -4, -1) // [0, 8, 8, 8, 0]\n</code></pre>\n<ul>\n<li>fill()静默忽略超出数组边界，零长度以及相反索引</li>\n</ul>\n<pre><code class=\"language-js\">const zeroes = [0, 0, 0, 0, 0]\nzeroes.fill(1, -10, -6) // 索引过低 [0, 0, 0, 0, 0]\nzeroes.fill(0)\n\nzeroes.fill(1, 10 ,15) // 索引过高 [0, 0, 0, 0, 0]\nzeroes.fill(0)\n\nzeroes.fill(7, 4, 2) // 索引相反，忽略 [0, 0, 0, 0, 0]\nzeroes.fill(0)\n\n// -4 + 5 = 1, -1 + 5 = 4,等价于zeroes.fill(1, 4)\nzeroes.fill(8, 3, 10) // [0, 0, 0, 8, 8]\n</code></pre>\n<ul>\n<li>copyWithin会浅复制数组中的部分内容，然后再插入到指定索引的位置，开始索引与结束索引与fill计算方式一直</li>\n<li>第一个参数为插入元素的开始位置</li>\n<li>第二个参数为复制数组的开始位置（可选），默认为0</li>\n<li>第三个参数为复制数组的结束位置（可选），不指定则会一直复制到数组结束</li>\n</ul>\n<pre><code class=\"language-js\">let ints, reset = () => ints = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nreset()\n\n// 未指定开始位置表示从数组的第0个位置开始复制，然后插入到第5个位置\nints.copyWithin(5) // [0, 1, 2, 3, 4, 0, 1, 2, 3, 4]\nreset()\n\n// 第二个参数为5，表示从数组的第5个位置开始复制，然后从3的位置开始插入\nints.copyWithin(3, 5) // [0, 1, 2, 5, 6, 7, 8, 9, 8, 9]\nreset()\n\n// 第二个参数为0，表示从数组的第0个位置开始复制，复制到第3的位置，然后从第4个位置插入\nints.copyWithin(4, 0, 3) // [0, 1, 2, 3, 0, 1, 2, 7, 8, 9]\nreset()\n\n// 负值的算法与fill一致， -4 + 10 = 6， -7 + 10 = 3，-3  + 10 = 7,等价于 ints.copyWithin(6, 3, 7)\nints.copyWithin(-4, -7, -3) // [0, 1, 2, 3, 4, 5, 3, 4, 5, 6]\n</code></pre>\n<ul>\n<li>copyWithin()也会静默忽略超出数组边界，零长度以及相反索引</li>\n</ul>\n<pre><code class=\"language-js\">let ints, reset = () => ints = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nreset()\n\n// 索引过低，忽略\nints.copyWithin(1, -15, -12) // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nreset()\n\n// 索引过高，忽略\nints.copyWithin(1, 12, 15) // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nreset()\n\n// 索引反向，忽略\nints.copyWithin(4, 3, 1) // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nreset()\n\n// 部分索引可用\nints.copyWithin(4, 7, 10) // [0, 1, 2, 3, 7, 8, 9, 7, 8, 9]\n</code></pre>\n<h2>转换方法</h2>\n<ul>\n<li>所有对象都有toLocalString、toString、valueOf方法。</li>\n<li>数组中valueOf返回数组本身</li>\n<li>toString返回数组每一项调用toString返回的字符串用逗号拼接的一个字符串</li>\n<li>toLocalString返回数组每一项调用toLocalString返回的字符串用逗号拼接的一个字符串</li>\n</ul>\n<pre><code class=\"language-js\">let a = [1,2,3,4]\nconsole.log(a.valueOf())  // [1, 2, 3, 4]\nconsole.log(a.toString()) // 1,2,3,4\n</code></pre>\n<h2>reverse与sort</h2>\n<ul>\n<li>reverse就是简单地将数组翻转</li>\n<li>sort默认会将数组的每一项调用String方法，然后再按照升序排列元素，所以对数字的排序会有问题</li>\n<li>所以sort可以接收一个比较函数，如果第一个值要在第二个值前面，返回-1，两个参数相等，返回0，第一个值在第二个值后面，返回1</li>\n</ul>\n<pre><code class=\"language-js\">let arr = [0, 1, 5, 10, 15]\nconsole.log(arr.sort()) // [0, 1, 10, 15, 5]\n\nfunction compare(x, y){\n  if(x > y) {\n    return 1\n  } else if(x &#x3C; y) {\n    return -1\n  } else {\n    return 0\n  }\n}\nconsole.log(arr.sort(compare)) // [0, 1, 5, 10, 15]\n</code></pre>\n<ul>\n<li>上面直接对数字数组调用出错是因为对数字排序时也会转为字符串在比较，'10' 对应的字符串要小于 '5'的字符串</li>\n<li>下面进行了值比较后就正常了，单看这个比较，其实简单地 arr.sort((a, b) => a - b) 也可以实现</li>\n</ul>\n<h2>concat方法</h2>\n<ul>\n<li>concat是数组拼接方法，会创建一个数组的副本，然后把它的参数拼接到副本末尾，然后返回这个副本</li>\n<li>如果参数是数组，会把数组的每一项都加到结果数组，如果是非数组，则直接加到结果数组中</li>\n</ul>\n<pre><code class=\"language-js\">let colors = ['red', 'green', 'blue']\nlet colors1 = colors.concat('yellow', ['black', 'brown'])\nconsole.log(colors)   // [\"red\", \"green\", \"blue\"]\nconsole.log(colors1)  // [\"red\", \"green\", \"blue\", \"yellow\", \"black\", \"brown\"]\n</code></pre>\n<ul>\n<li>参数中的数组是否被展开拼接可以通过符号 Symbol.isConcatSpreadable 控制，为false不再展开，为true强制展开</li>\n</ul>\n<pre><code class=\"language-js\">let colors = ['red', 'green', 'blue']\nlet newColors = ['black', 'brown']\nnewColors[Symbol.isConcatSpreadable] = false\nlet moreNewColors = {\n  [Symbol.isConcatSpreadable]: true,\n  length: 2,\n  0: 'pink',\n  1: 'cyan'\n}\nconsole.log(colors.concat(newColors))     // [\"red\", \"green\", \"blue\", Array(2)]\nconsole.log(colors.concat(moreNewColors)) // [\"red\", \"green\", \"blue\", \"pink\", \"cyan\"]\n</code></pre>\n<h2>slice与splice</h2>\n<ul>\n<li>slice就是简单地创建一个包含原数组一个或多个元素的数组</li>\n<li>参数有两个，第一个为开始位置，第二个为结束位置（可选）</li>\n<li>不设置结束位置则一直到数组尾的全部元素</li>\n<li>如果结束位置小于开始位置，返回空数组</li>\n<li>如果参数为负值，则认为值为该负值加数组长度后的值</li>\n<li>splice用于向数组删除与插入元素</li>\n<li>第一个参数表示删除元素的位置</li>\n<li>第二个参数表示删除的数量</li>\n<li>第三个及以后的参数表示在删除位置要插入的元素</li>\n<li>该方法返回值为删除后的元素</li>\n</ul>\n<h2>find与findIndex</h2>\n<ul>\n<li>都用于查找元素，find返回第一个匹配的元素，findIndex返回第一个匹配元素的索引</li>\n<li>没找到find返回undefined，findIndex返回-1</li>\n<li>找到元素后两个方法都不会继续执行</li>\n</ul>\n<pre><code class=\"language-js\">let arr1 = [2, 4, 6]\nconsole.log(arr1.find(x => x === 4)) // 4\nconsole.log(arr1.findIndex(x => x === 4)) // 1\n</code></pre>\n<h2>迭代方法</h2>\n<ul>\n<li>every()，数组每一项都执行传入的函数，都返回true则结果返回true</li>\n<li>filter()，数组每一项都运行该函数，函数返回true则会将返回true的项拼接为数组后返回</li>\n<li>forEach()，数组每一项都执行该函数，无返回值</li>\n<li>map()，数组每一项都执行该值，返回由函数调用结果够成的数组</li>\n<li>some()，数组每一项都执行该值，有一项返回true，则方法返回true</li>\n</ul>\n<h2>reduce与reduceRight</h2>\n<ul>\n<li>两个方法都会迭代数组所有项，然后构建一个最终值并返回</li>\n<li>区别是reduce从数组第一项开始迭代，reduceRight从数组最后一项开始迭代</li>\n<li>两个方法都接受两个参数，第一个为归并函数，第二个为初始值（可选）</li>\n<li>归并函数接收4个参数，上一个归并值，当前项，当前索引，数组本身</li>\n<li>当方法的第二个参数不存在时，归并函数从第二个值开始，第一个值作为初始值</li>\n<li>以此可以做数组求和</li>\n</ul>\n<pre><code class=\"language-js\">let values = [1, 2, 3, 4, 5]\n// 可以无初始值\nlet sum = values.reduce((prev, cur, index, array) => prev + cur)\nconsole.log(sum) // 15\n// 有初始值\nsum = values.reduce((prev, cur, index, array) => prev + cur, 0)\nconsole.log(sum) // 15\n\n// 使用reduceRight\n// 有初始值\nsum = values.reduceRight((prev, cur, index, array) => prev + cur, 0)\nconsole.log(sum) // 15\n</code></pre>","fields":{"slug":"/ObjectArray/"},"frontmatter":{"title":"Array对象","tags":["JavaScript回顾"],"categories":"JavaScript"}}},{"node":{"html":"<h1>定型数组</h1>\n<ul>\n<li>WebGL的出现导致了定型数组的出现，WebGL的API不需要javascript默认的双精度浮点格式的数值，但是这种数值恰好是javascript数组在内存中的格式。</li>\n<li>因此每次WebGL与javascript运行时传递数组WebGL都需要在目标环境分配新数组，以其当前形式迭代数组，然后将数值类型转为新数组中的适当格式，但是这一过程太过耗时</li>\n<li>所以产生了CanvasFloatArray(现在的Float32Array)。javascript可以分配、读取和写入这个数组。这个数组可以直接传给底层的图形驱动API，也可以直接从底层API获取到</li>\n<li>Float32Array是定型数组的一种</li>\n</ul>\n<h2>ArrayBuffer</h2>\n<ul>\n<li>Float32Array其实是一种“视图”，允许jiavascript访问一块名为ArrayBuffer的预分配内存。ArrayBuffer是所有定型数组以及视图引用的基本单位</li>\n<li>ArrayBuffer是普通的javascript构造函数，用于在内存中分配特定数量的字节空间</li>\n<li>\n<p>ArrayBuffer一经创建就不可更改大小，但是可以使用slice复制到一个新实例中</p>\n<!--more-->\n<pre><code class=\"language-js\">const buf1 = new ArrayBuffer(16)\nconsole.log(buf1.byteLength)    // 16\nconst buf2 = buf1.slice(4, 12)\nconsole.log(buf2.byteLength)    // 8\n</code></pre>\n</li>\n<li>ArrayBuffer分配失败会抛错，分配的内存不可超过Number.MAX<em>SAFE</em>INTEGER(2 ** 53 - 1)字节</li>\n<li>ArrayBuffer初始化会将所有二进制位初始化位0</li>\n<li>不可直接对ArrayBuffer进行读取或写入内容，需要借助视图。视图有不同的类型，但是引用的都是ArrayBuffer中的二进制数据</li>\n</ul>\n<h2>DataView</h2>\n<ul>\n<li>允许读写ArrayBuffer的一种视图。位文件I/O与网络I/O设计，API支持对缓冲数据的高度控制，但是性能会比其他视图差，对缓冲内容没有预设，也不能迭代</li>\n<li>必须在有ArrayBuffer的情况下才能创建DataView实例。该实例可以使用全部或部分ArrayBuffer，还有对缓冲实例的引用以及在缓冲中的开始位置</li>\n</ul>\n<pre><code class=\"language-js\">const buf = new ArrayBuffer(16)\nconst fullDataView = new DataView(buf)\nconsole.log(fullDataView.byteOffset)      // 0\nconsole.log(fullDataView.byteLength)      // 16\nconsole.log(fullDataView.buffer === buf)  // true\n</code></pre>\n<ul>\n<li>构造函数可以接收可选的偏移量与字节长度，第二个参数为偏移量，第三个参数为字节长度</li>\n<li>不指定字节长度则默认从偏移量到缓冲区域结束</li>\n</ul>\n<pre><code class=\"language-js\">const buf = new ArrayBuffer(16)\nconst dataView = new DataView(buf, 6, 3)\nconsole.log(dataView.byteOffset)      // 6\nconsole.log(dataView.byteLength)      // 3\nconsole.log(dataView.buffer === buf)  // true\n\nconst dataView2 = new DataView(buf, 9)\nconsole.log(dataView2.byteOffset)      // 9\nconsole.log(dataView2.byteLength)      // 7\nconsole.log(dataView2.buffer === buf)  // true\n</code></pre>\n<ul>\n<li>DataView读写组件还需要读写的字节偏移量</li>\n<li>要使用ElementType来实现JavaScript的Number类型到缓冲内二进制的转换</li>\n</ul>\n<h3>ElementType</h3>\n<ul>\n<li>DataView对存储在缓冲的数据类型没有预设，强制要求开发者在读写时指定ElementType</li>\n<li>\n<p>常见的ElementType类型如下</p>\n<ul>\n<li>Int8，1个字节，8位有符号整数，范围 -128 - 127</li>\n<li>Uint8，1个字节，8位无符号整数，范围 0 - 255</li>\n<li>Int16，2个字节，16位有符号整数，范围 -32768 - 32767</li>\n<li>Uint16，2个字节，16位无符号整数，范围 0 - 65535</li>\n<li>Int32，4个字节，32位有符号整数，范围 -2147483648 - 2147483647</li>\n<li>Uint32，4个字节，32位无符号整数，范围 0 - 42949967295</li>\n<li>Float32，4个字节，32位IEEE-754浮点数，范围 -3.4e+38 - 3.4e+38</li>\n<li>Float64，8个字节，64位IEEE-754浮点数，范围 -1.7e+308 - 1.7e+308</li>\n</ul>\n</li>\n<li>DataView给上面的每个类型都暴露了get与set方法，使用byteOffset定位要读写的值</li>\n</ul>\n<pre><code class=\"language-js\">const buf = new ArrayBuffer(2)\nconst view = new DataView(buf)\n// 因为ArrayBuffer的初始值都是0\nconsole.log(view.getInt8(0)) // 0\nconsole.log(view.getInt8(1)) // 0\nconsole.log(view.getInt16(0)) // 0\n\n// 采用8位有符号数设置\nview.setInt8(0, 255)  // 将第一个字节用255填充，也就是二进制的 11111111\nview.setInt8(1, 0xFF) // 第二个字节也用16进制的255填充，仍然是8位的1\n\nview.getInt16(0)  // -1 获取有符号的16位整数，第一位为符号位表示负数，然后转为10进制数为 -1\nview.getUint16(0) // 65535 无符号的16位整数，转为10进制数为65535\n</code></pre>\n<h3>字节序</h3>\n<ul>\n<li>字节序是指计算机维护的字节顺序的约定，DataView支持大端字节序和小端字节序。</li>\n<li>大端字节序意思是最高有效位保存在第一个字节，最低有效位保存在最后一个字节</li>\n<li>小端字节序就相反，最低有效位保存在第一个字节，最高有效位保存在最后一个字节</li>\n<li>Javascript运行时所在系统的原生字节序决定如何读写字节，但是DataView不受该影响，DataView所有的API方法都是大端字节序，可以接受一个可选的布尔值设置为true启用小端字节序</li>\n</ul>\n<pre><code class=\"language-js\">const buf2 = new ArrayBuffer(16)\nconst view2 = new DataView(buf2)\nview.setInt8(0, 0x80)   // 二进制表示 10000000\nview.setInt8(1, 0x01)   // 二进制表示 00000001\n\n// 获取16位整型，因为包含两个字节，第一个字节为 10000000，第二个字节为 00000001 \n// 采用大端字节序，从左往右读，就是 10000000 00000001，转为10进制就是 2 ** 15 + 2 ** 0 = 32769\nconsole.log(view.getUint16(0)) // 32769\n\n// 采用小端字节序，从右往左读，就是 00000001 10000000， 转为10进制就是 2 ** 8 + 2 ** 7 = 384\nconsole.log(view.getUint16(0, true)) // 384\n\n// 按大端字节序写入Uint16的 0x0004，此时字节为 00000000 00000100\nview.setUint16(0, 0x0004)\n\n// 此时按Uint8读取值为\nconsole.log(view.getUint8(0)) // 0\nconsole.log(view.getUint8(1)) // 4\n\n// 按小端字节序写入Uint16的 0x0002，此时字节为 00000010 00000000\nview.setUint16(0, 0x0002)\n\n// 此时按Uint8读取值为\nconsole.log(view.getUint8(0)) // 0\nconsole.log(view.getUint8(1)) // 2\n</code></pre>\n<h2>边界值</h2>\n<ul>\n<li>DataView的读写操作都要在足够的缓冲内进行，否则抛出RangeError</li>\n</ul>\n<pre><code class=\"language-js\">const buf3 = new ArrayBuffer(6)\nconst view3 = new DataView(buf3)\n// 读取部分超出缓冲范围  因为Int32占4个字节，缓冲区总长度为6个字节，然后从第4个字节读取，读到第7个就没有值了，所以抛出错误\nview.getInt32(4)  //VM4353:3 Uncaught RangeError: Offset is outside the bounds of the DataView\n\n// 尝试读取超出范围的值\nview.getInt32(8)  //VM4353:3 Uncaught RangeError: Offset is outside the bounds of the DataView\nview.getInt32(-1)  //VM4353:3 Uncaught RangeError: Offset is outside the bounds of the DataView\n\n// 尝试写入超出范围的值\nview.setInt32(4, 123)  //VM4353:3 Uncaught RangeError: Offset is outside the bounds of the DataView\n</code></pre>\n<ul>\n<li>DataView会尽可能地把一个值转为适当的类型，后备值为0。如果无法转换，抛出错误</li>\n</ul>\n<pre><code class=\"language-js\">const buf4 = new ArrayBuffer(1)\nconst view4 = new DataView(buf4)\n\nview4.setInt8(0, 1.5)\nconsole.log(view4.getInt8(0)) // 1\n\nview4.setInt8(0, [4])\nconsole.log(view4.getInt8(0)) // 4\n\nview4.setInt8(0, 'f')\nconsole.log(view4.getInt8(0)) // 0\n\nview4.setInt8(0, Symbol())\nconsole.log(view4.getInt8(0)) // VM4674:13 Uncaught TypeError: Cannot convert a Symbol value to a number\n</code></pre>\n<h2>定型数组</h2>\n<ul>\n<li>定型数组是另一种形式的ArrayBuffer，特定于一种ElementType并遵循原生的字节序，因此，它提供了适用面更广的Api和更好的性能</li>\n<li>创建定型数组的方式有：读取已有缓冲、使用自有缓冲、填充可迭代结构，以及填充基于任意类型的定型数组</li>\n<li>通过<ElementType>.from()和<ElementType>.of()也可以创建定型数组</li>\n</ul>\n<pre><code class=\"language-js\">// 通过缓冲区创建\nconst buf5 = new ArrayBuffer(12)\nconst ints = new Int32Array(buf5)\n// 因为我们的ArrayBuffer确定了字节数，Int32的字节数也是知道的，所以可以自动得出定型数组长度\nconsole.log(ints.length) // 3\n\n// 指定长度自己创建\nconst int1 = new Int32Array(6)\nconsole.log(int1.length)              // 6\n// 定型数组有一个关联缓冲的引用，可以根据自身的长度与字节数确定缓冲区的长度\nconsole.log(int1.buffer.byteLength)   // 24\n\n// 创建包含元素的定型数组\nconst int2 = new Int32Array([2, 4, 6, 8])\nconsole.log(int2.length) // 4\nconsole.log(int2.buffer.byteLength) // 16\nconsole.log(int2[2]) // 6\n\nconst ints3 = new Int16Array(int2)\n// 这里从int2生成了新的定型数组，元素位置都没有发生变化，只是将对应的 Int32 位数转为 Int16 位数，这样变化的只有缓冲区的大小\nconsole.log(ints3.length) // 4\nconsole.log(ints3.buffer.byteLength) // 8\nconsole.log(ints3[2]) // 6\n\n// const float = Float32Array.from([3.14, 2.718, 1.618]) 这两种方式都可以\nconst float = Float32Array.of(3.14, 2.718, 1.618)\nconsole.log(float.length) // 3\nconsole.log(float.buffer.byteLength) // 12\nconsole.log(float[2]) // 1.6180000305175781\n</code></pre>\n<ul>\n<li>定型数组的构造函数跟实例都有一个BYTES<em>PER</em>ELEMENT来表示当前定型数组每个元素的大小</li>\n</ul>\n<pre><code class=\"language-js\">console.log(Int16Array.BYTES_PER_ELEMENT) // 2\nconsole.log(Int32Array.BYTES_PER_ELEMENT) // 4\n</code></pre>\n<ul>\n<li>定型数组没有初始化，那么对应的缓冲会以0填充</li>\n<li>定型数组可以使用常用的数组方法，如some、map、every这些，并且返回的数组拥有相同元素类型的新定型数组</li>\n<li>定型数组无法改变长度，所以concat、pop、push、shift、splice、unshift方法不可用</li>\n<li>定型数组提供了set与subarray方法来复制数组元素以生成新的定型数组</li>\n<li>set方法从提供的数组中或者定性数组中把值复制到当前定型数组指定的索引位置</li>\n<li>第一个参数为被复制的数组，第二个参数为复制到定型数组的索引</li>\n<li>溢出会抛错</li>\n</ul>\n<pre><code class=\"language-js\">const container = new Int16Array(8)\ncontainer.set(Int8Array.of(1, 2, 3, 4))\nconsole.log(container) // [1, 2, 3, 4, 0, 0, 0, 0]\n\ncontainer.set([5, 6, 7, 8], 4)\nconsole.log(container) // [1, 2, 3, 4, 5, 6, 7, 8]\n\n// 剩余空间不够，溢出\ncontainer.set([5, 6, 7, 8], 7) // Uncaught RangeError: Source is too large\n</code></pre>\n<ul>\n<li>subarray方法与set相反，从指定的定型数组中复制一部分并返回这一部分组成的新定型数组</li>\n<li>接收2个参数，都可选，对应开始位置与结束位置</li>\n</ul>\n<pre><code class=\"language-js\">const source = Int32Array.of(2, 4, 6, 8)\nconst sub = source.subarray()\nconsole.log(sub)  // [2, 4, 6, 8]\n\nconst sub1 = source.subarray(2)\nconsole.log(sub1) //  [6, 8]\n\nconst sub2 = source.subarray(1,3)\nconsole.log(sub2) // [4, 6]\n</code></pre>\n<ul>\n<li>利用set手动实现一个拼接方法</li>\n</ul>\n<pre><code class=\"language-js\">function concatTypeArray(typeArrayConstructor, ...typeArrays) {\n  const totalLength = typeArrays.reduce((x, y) => (x.length || x) + y.length)\n  const resultArray = new typeArrayConstructor(totalLength)\n  let currentNum = 0\n  typeArrays.map(array => {\n    resultArray.set(array, currentNum)\n    currentNum += array.length\n  })\n  return resultArray\n}\n\nconst result = concatTypeArray(Int16Array, Int16Array.of(1, 2, 3), new Int16Array([4, 5, 6]), Int16Array.from([7, 8, 9]))\nconsole.log(result) // [1, 2, 3, 4, 5, 6, 7, 8, 9]\nconsole.log(result instanceof Int16Array) // true\n</code></pre>\n<h2>上溢与下溢</h2>\n<ul>\n<li>定型数组中元素的上溢与下溢不会影响其他索引的元素，但是要考虑自身的数据类型，如下所示</li>\n</ul>\n<pre><code class=\"language-js\">// Int8的范围为 -128 - 127\nconst ints = new Int8Array(2)\n// 上溢\nints[1] = 128 \n// 128用二进制表示为 10000000 ，因为是有符号 8 位，所以第一个 1 被当作负号的标识，所以会根据符号把它当作二补码来求原来的值\n// 首先减一得 00000001，然后再取反得 10000000 是二进制的 128，再加上判定的负数，所以为 -128\nconsole.log(ints[1]) // -128\n\n// 下溢\nints[1] = -129\n// 因为-129是负数形式，所以我们得到的 -129 得二进制表示为 129得二进制 10000001 ，然后各位取反得 01111110，然后再加 1 得 01111111，再补上符号位 1 ，因为要截取8位，所以得到的就是 01111111，转为我们的有符号数就是 127\nconsole.log(ints[1]) // 127\n\n// Uint8范围为 0 - 255\nconst unsignInts = new Uint8Array(2)\n// 上溢\nunsignInts[1] = 256\n// 256用二进制表示为 100000000，然后这里截取后面 8 位就是 00000000，转为十进制就是0\nconsole.log(unsignInts[1]) // 0\n\nunsignInts[1] = 511\n// 511 用二进制表示位 111111111，然后截取后面 8 位就是 11111111，转十进制就是255\nconsole.log(unsignInts[1]) // 255\n\n// 下溢\nunsignInts[1] = -1\n// -1 用二进制表示是 1 得二进制 00000001 ，然后各位取反 11111110，然后再加 1 得 11111111，这个用无符号数表示就是 255\nconsole.log(unsignInts[1]) // 255\n</code></pre>\n<ul>\n<li>得出结论，无符号数上溢取最低有效位的 8 位，下溢的位被转为其无符号数的等价值</li>\n<li>有符号数的上溢变成该值二补数形式，下溢也变成该值二补数形式</li>\n</ul>\n<h2>Uint8ClampedArray</h2>\n<ul>\n<li>夹板数组，不允许任何方向的溢出，大于255的变为255，小于0的变为0</li>\n</ul>\n<pre><code class=\"language-js\">const clampedInts = new Uint8ClampedArray([-1, 0, 255, 256])\nconsole.log(clampedInts) // [0, 0, 255, 255]\n</code></pre>\n<ul>\n<li>Uint8ClampedArray是canvas的历史残留，如果不是做canvas开发就不要用它</li>\n</ul>","fields":{"slug":"/ArrayBuffer/"},"frontmatter":{"title":"定型数组","tags":["JavaScript回顾"],"categories":"JavaScript"}}},{"node":{"html":"<h1>Set与WeakSet</h1>\n<h2>Set</h2>\n<ul>\n<li>Set是ES6新增的集合类型，带来了集合数据结构</li>\n<li>创建方式为 new 关键字加 Set 构造函数</li>\n<li>可以通过在构造函数内传入可迭代对象来初始化该实例，如下</li>\n</ul>\n<pre><code class=\"language-js\">const s = new Set()\nconst s1 = new Set(['val1', 'val2', 'val3'])\nconst s2 = new Set({\n  [Symbol.iterator]: function*(){\n    yield 'val1'\n    yield 'val2'\n  }\n})\nconsole.log(s1) // {\"val1\", \"val2\", \"val3\"}\nconsole.log(s2) // {\"val1\", \"val2\"}\n</code></pre>\n<ul>\n<li>add()方法可以给Set添加新的键值对，has可以判断该Set是否有对应的值</li>\n<li>\n<p>size可以获取Set的元素数量，delete()用于删除元素，clear()用于清空元素，如下</p>\n<!--more-->\n<pre><code class=\"language-js\">const s3 = new Set()\nconsole.log(s3.has('first'))  // false\nconsole.log(s3.size)          // 0\n</code></pre>\n</li>\n</ul>\n<p>// add方法会返回它自身，所以可以连续add\ns3.\nadd('first').\nadd('last')\nconsole.log(s3.has('first'))  // true</p>\n<p>s3.delete('first')\nconsole.log(s3.has('first'))  // false<br>\nconsole.log(s3.has('last'))   // true\nconsole.log(s3.size)          // 1</p>\n<p>s3.clear()</p>\n<p>console.log(s3.has('last'))   // false\nconsole.log(s3.size)          // 0</p>\n<pre><code>- Set可以使用任何类型作为键，has使用严格相等来判定该值是否存在\n\n```js\nconst s4 = new Set()\nconst funcVal = function(){}\nconst objectVal = {}\nconst symbolVal = Symbol()\n\ns4.\nadd(funcVal).\nadd(objectVal).\nadd(symbolVal)\n\nconsole.log(s4.has(funcVal))    // true\nconsole.log(s4.has(objectVal))  // true\nconsole.log(s4.has(symbolVal))  // true\n\n// 全等判断，所以独立实例不冲突\nconsole.log(s4.has(function(){})) // false\n</code></pre>\n<ul>\n<li>全等判断，所以用作值的对象在自己的内容或属性变更时仍然保持不变</li>\n</ul>\n<pre><code class=\"language-js\">const s5 = new Set()\nconst objVal = {}\n\ns5.\nadd(objVal)\n\nobjVal.m2 = 'm2'\n\nconsole.log(s5.has(objVal))    // true\n</code></pre>\n<ul>\n<li>add()跟delete()是幂等的，delete()返回一个boolean，表示是否存在要删除的值</li>\n</ul>\n<pre><code class=\"language-js\">const s6 = new Set()\n\ns6.\nadd('foo')\nconsole.log(s6.size)  // 1\ns6.\nadd('foo')\nconsole.log(s6.size)  // 1\n\nconsole.log(s6.delete('foo'))    // true\nconsole.log(s6.delete('foo'))    // false\n</code></pre>\n<h2>Set顺序与迭代</h2>\n<ul>\n<li>Set维护值插入的顺序，所以是可迭代的，实例提供了一个迭代器，以插入顺序生成集合内容。</li>\n<li>通过values()方法及其别名keys()(或者Symbol.iterator属性（引用的就是values()）)获取迭代器</li>\n</ul>\n<pre><code class=\"language-js\">const s8 = new Set(['val1', 'val2', 'val3'])\nconsole.log(s8.values === s8[Symbol.iterator]) // true\nconsole.log(s8.keys === s8[Symbol.iterator]) // true\n\nfor(let value of s8[Symbol.iterator]()) {\n  console.log(value)\n}\n// 'val1'\n// 'val2'\n// 'val3'\n</code></pre>\n<ul>\n<li>values()是默认迭代器，所以可以对实例使用拓展操作</li>\n</ul>\n<pre><code class=\"language-js\">const s8 = new Set(['val1', 'val2', 'val3'])\n\nconsole.log([...s8]) // ['val1', 'val2', 'val3']\n</code></pre>\n<ul>\n<li>也可以不用迭代器，使用回调方法，用映射的forEach方法并传入回调，依次接受每个键/值对（键跟值都是值）。回调可接受可选的第二个参数，用于重写内部的this值</li>\n<li>forEach中的两个参数都是对应的值。</li>\n</ul>\n<pre><code class=\"language-js\">const s8 = new Set(['val1', 'val2', 'val3'])\n\ns8.forEach((val, key) => { console.log(`${ key } -> ${ val }`) })\n// val1 -> val1\n// val2 -> val2\n// val3 -> val3\n\ns8.forEach(function(val, key){ console.log(`${ key } -> ${ this.name } -> ${ val}`) }, { name: 's8' })\n// val1 -> s8 -> val1\n// val2 -> s8 -> val2\n// val3 -> s8 -> val3\n</code></pre>\n<h2>WeakSet</h2>\n<ul>\n<li>WeakSet 是 Set 的兄弟类型，API也是 Set 的自己，“weak”描述的时Javascrip垃圾回收程序对待“弱映射”中键的形式</li>\n<li>WeakMap中的键只能是Object或者继承自Object的类型，使用非对象设置键会抛出TypeError，值类型无限制</li>\n<li>初始化时只要有一个键无效就会抛错，其他的初始化全部失败</li>\n</ul>\n<pre><code class=\"language-js\">const key1 = { id: 1 }\n\nconst ws = new WeakSet([key1, 'BADKEY']) // Uncaught TypeError: Invalid value used in weak set\n\n// 要使用非对象的值可以使用构造函数包装再使用\nconst ws1 = new WeakSet([key1,new String('BADKEY')]) \n</code></pre>\n<ul>\n<li>其他的基本方法add、has、delete与Set保持一致</li>\n<li>“weak”表示键不属于正式引用，可以被回收，当键被回收后，键值对消失</li>\n</ul>\n<pre><code class=\"language-js\">const ws2 = new WeakSet()\nconst container = {\n  key:{}\n}\nws2.add(container.key)\nfunction removeReference(){\n  container.key = null\n}\nremoveReference()\n</code></pre>\n<ul>\n<li>上例中container对象维护着弱集合值的引用，所以不会被回收，但是要是执行了removeReference方法，那么值的引用就消失了，那么值就会消失</li>\n<li>WeakSet中的键值随时可能消失，所以没有迭代能力，也没有提供clear()清空的方法</li>\n<li>WeakSet之所以限制只能使用对象，是为了保证只有通过键对象的引用才能取到值。要是允许原始值就无法区分初始化时的字符串字面量跟初始化之后使用一个相同的字符串了</li>\n</ul>\n<h3>WeakSet的应用</h3>\n<ul>\n<li>WeakSet不会阻止垃圾回收，所以适合给对象打标签</li>\n</ul>\n<pre><code class=\"language-js\">const disabledElements = new Set()\nconst loginButton = document.querySelector('#login')\ndisabledElements.add(loginButton)\n</code></pre>\n<ul>\n<li>这样我们查询元素在不在disabledElements就可以知道是否被禁用了。不过上面的实现在登录按钮被DOM树删除了，但因为Set中存在着按钮的引用，垃圾回收不能回收它</li>\n</ul>\n<pre><code class=\"language-js\">const disabledElements = new WeakSet()\nconst loginButton = document.querySelector('#login')\ndisabledElements.add(loginButton)\n</code></pre>\n<ul>\n<li>使用WeakMap后当节点被删除后这里的引用也会消失，内存可直接被回收</li>\n</ul>","fields":{"slug":"/Set/"},"frontmatter":{"title":"Set与WeakSet","tags":["JavaScript回顾"],"categories":"JavaScript"}}},{"node":{"html":"<h1>Map与WeakMap</h1>\n<h2>Map</h2>\n<ul>\n<li>Map是ES6新增的键值存储类型</li>\n<li>创建方式为 new 关键字加 Map构造函数</li>\n<li>可以通过在构造函数内传入可迭代对象来初始化该实例，可迭代对象的每一项需要包含键/值对数组，如下</li>\n</ul>\n<pre><code class=\"language-js\">const m = new Map()\nconst m1 = new Map([['key1', 'value1'], ['key2', 'value2'], ['key3', 'value3']])\nconst m2 = new Map({\n  [Symbol.iterator]: function*(){\n    yield ['key1', 'value1']\n    yield ['key2', 'value2']\n  }\n})\nconsole.log(m1) // {\"key1\" => \"value1\", \"key2\" => \"value2\", \"key3\" => \"value3\"}\nconsole.log(m2) // {\"key1\" => \"value1\", \"key2\" => \"value2\"}\n\n// Map会映射它期待的键值对，无论你提供不提供，如下，因为没有提供对应的键值，Map会自动以undefined填充\nconst m3 = new Map([[]])\nconsole.log(m3) // {undefined => undefined}\n</code></pre>\n<ul>\n<li>set()方法可以给Map添加新的键值对，get可以查询对应键下面的值，has可以判断该Map是否有对应的键</li>\n<li>\n<p>size可以获取Map的键值对数量，delete()用于删除指定值，clear()用于清空Map，如下</p>\n<!--more-->\n<pre><code class=\"language-js\">const m4 = new Map()\nconsole.log(m4.has('first'))  // false\nconsole.log(m4.get('first'))  // undefined\nconsole.log(m4.size)          // 0\n</code></pre>\n</li>\n</ul>\n<p>// set方法会返回它自身，所以可以连续set\nm4.\nset('first', 'matt').\nset('last', 'kuni')\nconsole.log(m4.has('first'))  // true\nconsole.log(m4.get('first'))  // 'matt'</p>\n<p>m4.delete('first')\nconsole.log(m4.has('first'))  // false<br>\nconsole.log(m4.has('last'))   // true\nconsole.log(m4.get('first'))  // undefined\nconsole.log(m4.get('last'))   // 'last'\nconsole.log(m4.size)          // 1</p>\n<p>m4.clear()</p>\n<p>console.log(m4.has('last'))   // false\nconsole.log(m4.size)          // 0</p>\n<pre><code>- Map可以使用任何类型作为键，has与get使用严格相等来判定该键是否存在\n\n```js\nconst m5 = new Map()\nconst funcKey = function(){}\nconst objectKey = {}\nconst symbolKey = Symbol()\n\nm5.\nset(funcKey, 'function').\nset(objectKey, 'object').\nset(symbolKey, 'symbol')\n\nconsole.log(m5.get(funcKey))    // function\nconsole.log(m5.get(objectKey))  // object\nconsole.log(m5.get(symbolKey))  // symbol\n\n// 全等判断，所以独立实例不冲突\nconsole.log(m5.get(function(){})) // undefined\n</code></pre>\n<ul>\n<li>全等判断，所以用作键和值的对象在自己的内容或属性变更时仍然保持不变</li>\n</ul>\n<pre><code class=\"language-js\">const m6 = new Map()\nconst objKey = {}\nconst objVal = {}\n\nm6.\nset(objKey, objVal)\n\nobjKey.m1 = 'm1'\nobjVal.m2 = 'm2'\n\nconsole.log(m6.get(objKey))    // {m2: \"m2\"}\n\n\n// 全等判断，所以独立实例不冲突\nconsole.log(m6.get({})) // undefined\n</code></pre>\n<ul>\n<li>全等判断，所以下面情况可能出问题</li>\n</ul>\n<pre><code class=\"language-js\">const m7 = new Map()\nconst a = 0/'', b = 0/'',pz = +0, nz = -0;\nconsole.log(a === b)\nconsole.log(pz === nz)\n\nm7.set(a, 'foo')  // false\nm7.set(pz, 'bar') // true\n\nconsole.log(m7.get(b))  // 'foo'\nconsole.log(m7.get(nz)) // 'bar'\n</code></pre>\n<h2>Map顺序与迭代</h2>\n<ul>\n<li>Map维护键值插入的顺序，所以是可迭代的，实例提供了一个迭代器，以插入顺序生成[key, value]形式的数组。</li>\n<li>通过entries()方法或者Symbol.iterator属性（引用的就是entries()）获取迭代器</li>\n</ul>\n<pre><code class=\"language-js\">const m8 = new Map([['key1', 'value1'], ['key2', 'value2'], ['key3', 'value3']])\nconsole.log(m8.entries === m8[Symbol.iterator]) // true\n\nfor(let pairs of m8[Symbol.iterator]()) {\n  console.log(pairs)\n}\n// [\"key1\", \"value1\"]\n// [\"key2\", \"value2\"]\n// [\"key3\", \"value3\"]\n</code></pre>\n<ul>\n<li>entries()是默认迭代器，所以可以对实例使用拓展操作</li>\n</ul>\n<pre><code class=\"language-js\">const m8 = new Map([['key1', 'value1'], ['key2', 'value2'], ['key3', 'value3']])\n\nconsole.log([...m8]) // [[\"key1\", \"value1\"], [\"key2\", \"value2\"], [\"key3\", \"value3\"]]\n</code></pre>\n<ul>\n<li>也可以不用迭代器，使用回调方法，用映射的forEach方法并传入回调，依次接受每个键/值对。回调可接受可选的第二个参数，用于重写内部的this值</li>\n<li>forEach中的第一个参数是对应的值，第二个为对应的键。</li>\n</ul>\n<pre><code class=\"language-js\">const m8 = new Map([['key1', 'value1'], ['key2', 'value2'], ['key3', 'value3']])\n\nm8.forEach((val, key) => { console.log(`${ key } -> ${ val }`) })\n// key1 -> value1\n// key2 -> value2\n// key3 -> value3\n\nm8.forEach(function(val, key){ console.log(`${ key } -> ${ this.name } -> ${ val}`) }, { name: 'm8' })\n// key1 -> m8 -> value1\n// key2 -> m8 -> value2\n// key3 -> m8 -> value3\n</code></pre>\n<ul>\n<li>keys()跟values()分别返回以插入顺序生成的键跟值</li>\n</ul>\n<pre><code class=\"language-js\">const m8 = new Map([['key1', 'value1'], ['key2', 'value2'], ['key3', 'value3']])\n\nfor(let key of m8.keys()) {\n  console.log(key)\n}\n// key1\n// key2\n// key3\n\nfor(let val of m8.values()) {\n  console.log(val)\n}\n\n// value1\n// value2\n// value3\n</code></pre>\n<ul>\n<li>\n<p>Object与Map的对比</p>\n<ul>\n<li>内存情况，Object与Map占用的内存都会随键的数量线性增加。在给定固定大小内存的情况下，Map可以比Object多存储 50% 的键值对</li>\n<li>插入性能，Object与Map对插入的消耗差不多，但是Map要快一点，所以大量的插入操作使用Map</li>\n<li>查找速度，包含少量的键值时，Object的速度更快，涉及大量的查找操作使用Object更好</li>\n<li>删除性能，Object的delete性能很差，Map的delete()比插入和查找更快。所以涉及大量删除使用Map</li>\n</ul>\n</li>\n</ul>\n<h2>WeakMap</h2>\n<ul>\n<li>WeakMap是Map的兄弟类型，API也是Map的子集，“weak”描述的时Javascrip垃圾回收程序对待“弱映射”中键的形式</li>\n<li>WeakMap中的键只能是Object或者继承自Object的类型，使用非对象设置键会抛出TypeError，值类型无限制</li>\n<li>初始化时只要有一个键无效就会抛错，其他的初始化全部失败</li>\n</ul>\n<pre><code class=\"language-js\">const key1 = { id: 1 }\nconst key2 = { id: 2 }\nconst key3 = { id: 3 }\n\nconst wm = new WeakMap([[key1, 'val1'], ['BADKEY', 'val2']]) // VM648:5 Uncaught TypeError: Invalid value used as weak map key\n\n// 要使用非对象的值可以使用构造函数包装再使用\nconst wm = new WeakMap([[key1, 'val1'], [new String('BADKEY'), 'val2']]) // {String => \"val2\", {…} => \"val1\"}\n</code></pre>\n<ul>\n<li>其他的基本方法set、get、has与Map保持一致</li>\n<li>“weak”表示键不属于正式引用，可以被回收，当键被回收后，键值对消失</li>\n</ul>\n<pre><code class=\"language-js\">const wm2 = new WeakMap()\nconst container = {\n  key:{}\n}\nwm2.set(container.key, 'val')\nfunction removeReference(){\n  container.key = null\n}\nremoveReference()\n</code></pre>\n<ul>\n<li>上例中container对象维护着弱映射键的引用，所以不会被回收，但是要是执行了removeReference方法，那么键的引用就消失了，那么键值对就会消失</li>\n<li>WeakMap中的键值随时可能消失，所以没有迭代能力，也没有提供clear()清空的方法</li>\n<li>WeabMap之所以限制只能使用对象，是为了保证只有通过键对象的引用才能取到值。要是允许原始值就无法区分初始化时的字符串字面量跟初始化之后使用一个相同的字符串了</li>\n</ul>\n<h3>WeakMap的应用</h3>\n<ul>\n<li>私有变量</li>\n</ul>\n<pre><code class=\"language-js\">const User = (() => {\n  const wm = new WeakMap()\n  class User {\n    constructor(id) {\n      this.idProperty = Symbol('id')\n      this.setId(id)\n    }\n    setPrivate(property, value) {\n      const propertyMembers = wm.get(this) || {}\n      propertyMembers[property] = value\n      wm.set(this, propertyMembers)\n    }\n    getPrivate(property) {\n      return wm.get(this)[property]\n    }\n    setId(id) {\n      this.setPrivate(this.idProperty, id)\n    }\n    getId(){\n      return this.getPrivate(this.idProperty)\n    }\n  }\n  return User\n})()\n\nconst user = new User(123)\nconsole.log(user.getId()) // 123\nuser.setId(456)\nconsole.log(user.getId()) // 456\n</code></pre>\n<ul>\n<li>DOM节点元数据</li>\n<li>WeakMap不会阻止垃圾回收，适合保存元数据</li>\n</ul>\n<pre><code class=\"language-js\">const m = new Map()\nconst loginButton = document.querySelector('#login')\nm.set(loginButton, { disabled: true })\n</code></pre>\n<ul>\n<li>上面的实现在登录按钮被DOM树删除了，但因为Map中存在着按钮的引用，所以DOM节点还会在内存中存在</li>\n</ul>\n<pre><code class=\"language-js\">const m = new WeakMap()\nconst loginButton = document.querySelector('#login')\nm.set(loginButton, { disabled: true })\n</code></pre>\n<ul>\n<li>使用WeakMap后当节点被删除后这里的引用也会消失，内存可直接被回收</li>\n</ul>","fields":{"slug":"/Map/"},"frontmatter":{"title":"Map与WeakMap","tags":["JavaScript回顾"],"categories":"JavaScript"}}},{"node":{"html":"<h1>初识webGl</h1>\n<ul>\n<li>webGl是在web端实现3d效果的Api，是OpenGl的裁剪版，适用于web端的3d效果实现</li>\n<li>webGl在浏览器端的支持情况不一致，所以我们使用时注意兼容此种情况</li>\n</ul>\n<h2>着色器</h2>\n<ul>\n<li>在使用webGl的时候我们要准备两个着色器，</li>\n<li>一个顶点着色器，用来确定我们的渲染物体的各个顶点的位置，由这些顶点可以确定画面的渲染位置</li>\n<li>一个片段着色器，用来确定顶点决定的图形的各个像素的颜色值</li>\n<li>下面我们分别定义这两个着色器</li>\n</ul>\n<pre><code class=\"language-js\">// 顶点着色器\nprecision lowp float; // 指定一下我们着色器的数据精度\nattribute vec4 inColor; // 定义一个包含4个浮点数的浮点型向量，一个属性值，将会从缓冲中获取数据，用于颜色值\nattribute vec3 v3Position; // 定义一个包含3个浮点数的浮点型向量，一个属性值，将会从缓冲中获取数据，用于表示该顶点的位置\nvarying vec4 outColor; // 可变量，是顶点着色器向片段着色器传值的方式\nvoid main() {\n  outColor = inColor; // 将获取到的顶点的值赋给可变量从而传递给片段着色器\n  gl_Position = vec4(v3Position, 1.0); // gl_Position是webgl提供的内置变量，用来表示顶点位置\n}\n\n// 片段着色器\nprecision lowp float; // 指定一下我们着色器的数据精度\nvarying vec4 outColor; // 可变量，获取顶点着色器的传值\nvoid main() {\n  gl_FragColor = outColor; // gl_fragColor也是webgl提供的内置变量，用来表示像素点的颜色\n}\n</code></pre>\n<!--more-->\n<h2>第一个实例</h2>\n<ul>\n<li>接下来我们就用一个实例来看看wenGl的编写过程</li>\n<li>首先我们需要准备一个canvas作为webGl的宿主环境</li>\n</ul>\n<pre><code class=\"language-js\">&#x3C;canvas id=\"canvas\" width='500' height='500'>&#x3C;/canvas>\n</code></pre>\n<ul>\n<li>然后开始我买的呢js代码实现，首先我们获取创建的canvas的Dom元素</li>\n<li>然后获取webGl的运行环境</li>\n</ul>\n<pre><code class=\"language-js\">// 定义着色器语句\nlet shaderVsJs = `\nprecision lowp float;  \nattribute vec3 v3Position;\nattribute vec4 inColor;\nvarying   vec4 outColor;\nvoid main(){\n  outColor = inColor;\n  gl_Position = vec4(v3Position, 1.0);\n}\n`\nlet shaderFsJs = `\nprecision lowp float;\nvarying vec4 outColor;\nvoid main(){\n  gl_FragColor = outColor;\n}\n`\n// 获取canvas环境\nlet canvas = document.querySelector('#canvas')\nwebgl = canvas.getContext('webgl')\nif(!webgl) {\n  alert('浏览器暂不支持webGl，请更换浏览器')\n  return\n}\n</code></pre>\n<ul>\n<li>接着设置webgl的视口大小，这个视口需要在canvas的范围内，所以我们先设为整个canvas的大小</li>\n</ul>\n<pre><code class=\"language-js\">// 视口的设置参数为 左上角顶点位置x，左上角顶点位置y，视口的宽度，视口的高度\nwebgl.viewport(0, 0, canvas.clientWidth, canvas.clientHeight)\n</code></pre>\n<ul>\n<li>接着需要创建我们顶点着色器与片段着色器</li>\n</ul>\n<pre><code class=\"language-js\">// 着色器的创建函数以及错误警告\nfunction initShaderSouce(webgl, shader, shaderScript){\n  webgl.shaderSource(shader, shaderScript)  // 提供数据源\n  webgl.compileShader(shader) // 编译，生成着色器\n  const success = webgl.getShaderParameter(shader, webgl.COMPILE_STATUS) // 查看着色器的编译状态\n  if(success) {\n    return shader\n  }\n  console.log(webgl.getShaderInfoLog(shader)) // 出错时打印着色器的出错日志\n  webgl.deleteShader(shader) // 着色器失败时删除对应着色器\n}\n\nconst ertexShaderObject = webgl.createShader(webgl.VERTEX_SHADER) // 创建着色器对象\nconst fragmentShaderObject = webgl.createShader(webgl.FRAGMENT_SHADER)  \n\ninitShaderSouce(webgl, vertexShaderObject, shaderVsJs)\ninitShaderSouce(webgl, fragmentShaderObject, shaderFsJs)\n</code></pre>\n<ul>\n<li>然后就要创建我们的着色程序，然后把着色器也要链接到着色程序以让他们生效</li>\n<li>然后将我们在着色器语句中创建的两个attribute变量v3Position关联到我们的属性索引</li>\n</ul>\n<pre><code class=\"language-js\">let inColorIndex = 1, v3PositionIndex = 0 // 创建对应的属性索引\nprogramObject = webgl.createProgram() // 创建着色程序\n\nwebgl.attachShader(programObject, vertexShaderObject)   // 将着色器附加到着色程序中\nwebgl.attachShader(programObject, fragmentShaderObject)\n\nwebgl.bindAttribLocation(programObject, inColor, 'inColor') // 将着色器中的变量（必须是attribute变量）关联到一个属性索引\nwebgl.bindAttribLocation(programObject, v3PositionIndex, 'v3Position') \n\nwebgl.linkProgram(programObject) // 链接我们的着色程序\nif(!webgl.getProgramParameter(programObject, webgl.LINK_STATUS)) { // 查看着色程序是否正确链接\n  console.log(webgl.getProgramInfoLog(programObject)) // 链接失败打印打印错误信息\n  return\n}\nwebgl.useProgram(programObject) // 启用我们的链接程序\n</code></pre>\n<ul>\n<li>接下来我们就要创建我们的顶点数据与索引数据了</li>\n<li>顶点数据确定了我们所有的可能使用的顶点的元素的集合</li>\n<li>索引数据确定了我们顶点的绘制顺序的集合</li>\n<li>数据集合都以buffer（缓冲）的形式保存，所以需要创建对应的缓冲变量</li>\n</ul>\n<pre><code class=\"language-js\">// 顶点数据集合\nlet triangleArrayData = [\n  // 每一行的前三个数据为顶点位置， 后4个位置为对应的颜色 rgba 值，所以一个顶点对应7个数据\n  // x,  y,   z,   r,   g,   b,  a\n  -0.5, 0.5, 0.0, 1.0, 0.0, 0.0, 1.0, // 左上\n  0.5, 0.5, 0.0, 0.0, 1.0, 0.0, 1.0, // 右上\n  0.5, -0.5, 0.0, 0.0, 0.0, 1.0, 1.0, // 右下\n  -0.5, -0.5, 0.0, 1.0, 1.0, 0.0, 1.0 // 左下\n// 索引数据集合\nlet indexArrayData = [\n  0, 1, 2,\n  0, 2, 3\n]\n\nconst triangleBuffer = webgl.createBuffer() // 缓冲区创建\nconst indexBuffer = webgl.createBuffer()\n</code></pre>\n<ul>\n<li>然后将创建的存储区设置为对应存储区类型的操作对象 （也就是说绑定了这个存储区类型要用来操作这个缓冲区了）</li>\n<li>然后给这个缓冲区确定数据、数据类型与数据的变动状况</li>\n</ul>\n<pre><code class=\"language-js\">// 绑定ARRAY_BUFFER存储区类型操作 triangleBuffer\nwebgl.bindBuffer(webgl.ARRAY_BUFFER, triangleBuffer)  \n// 给缓冲区绑定数据与确定数据的变动情况  Float32Array 表示32位浮点数， webgl.STATIC_DRAW表示这个数据我以后不会经常改\nwebgl.bufferData(webgl.ARRAY_BUFFER, new Float32Array(triangleArrayData), webgl.STATIC_DRAW) //\n\nwebgl.bindBuffer(webgl.ELEMENT_ARRAY_BUFFER, indexBuffer)\nwebgl.bufferData(webgl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indexArrayData), webgl.STATIC_DRAW)\n</code></pre>\n<ul>\n<li>然后准备清空我们的画布开始绘制我们的图形</li>\n</ul>\n<pre><code class=\"language-js\">// 清空画布的颜色 \nwebgl.clearColor(0.0, 0.0, 0.0, 1.0)\n// 执行清空操作\nwebgl.clear(webgl.COLOR_BUFFER_BIT) \n</code></pre>\n<ul>\n<li>然后我们启用之前绑定的变量索引，方便在后续更改变量值进行绘画</li>\n</ul>\n<pre><code class=\"language-js\">webgl.enableVertexAttribArray(v3PositionIndex) // 启用对应关联索引上的数组数据或元素数组数据\nwebgl.enableVertexAttribArray(inColor)\n</code></pre>\n<ul>\n<li>然后为我们的变量索引分配数据</li>\n</ul>\n<pre><code class=\"language-js\">// 为变量分配数据，参数对应为  第一个：数据绑定的变量， 第二个参数表示需要的元素个数（3表示需要3个数据，4表示需要4个数据，与定义时的 vec 后面跟的3或4相关），\n// 第三个参数为元素的数据类型， 第四个参数为是否归一化， 第五个参数为第二个数据与上一个数据的偏移量，以字节为单位（这里因为我们定义的是Float32位，所以一个数据为4个字节，偏移量就是每一组数据的个数7 * 字节数4），第六个参数是数据的偏移量（前三个数据为顶点的坐标位置，后4个为顶点的rgba值）\nwebgl.vertexAttribPointer(v3PositionIndex, 3, webgl.FLOAT, false, 7 * 4, 0) // 位置需要3个值， 第一行第一个开始就是要用的数据了，所以偏移量为0\nwebgl.vertexAttribPointer(inColor, 4, webgl.FLOAT, false, 7 * 4, 3 * 4)  // 位置需要4个值， 第一行第4个开始才是要用的数据了，所以偏移量为数据个数 3 * 字节数 4\n</code></pre>\n<ul>\n<li>之后我们的全部流程就完成了，然后再执行我们的绘画操作就可以了</li>\n</ul>\n<pre><code class=\"language-js\">// 绘制方法，第一个参数表示我们要画三角形， 第二个表示我们的顶点的绘制顺序总共有几个，第三个表示顶点绘制顺序的数据的元素类型是短整型，第四个参数是表示从数据列表的第几个开始绘制\nwebgl.drawElements(webgl.TRIANGLES, 6, webgl.UNSIGNED_SHORT, 0)\n</code></pre>\n<ul>\n<li>之后我们就绘制了出了一个渐变色正方形</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 626px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/e842cb1620e9a10679824522a6d46a82/af590/webgl_rect.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 99.6%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAACXBIWXMAABJ0AAASdAHeZh94AAACR0lEQVQ4y8XUzUtUURjH8TM5c73eq3MdX8a5WZA4F7u5aUwLTMeaWpQlIWEjOAVlWBlpCkNhICVkmTCEvSxmk4ShSC0i0jYZWCszokUULSuI/opvT2BZkTZQ5OK3uud8eM55nntUQNdRSv27/BfQ80N+u8mzkBWr0JIEshR+nyI3W2HkKHRDoeUqfH5FVr5UXyBrs5YBvx3PkDz0aswV5DJZaXJju0l/3OR4l0nzRZOtaZPwA5O8pybK8SxewVKguUrxqsjgs17GsxKHu5vCjDQ5nD3mcOiCw850mA1TDtZcGFWhZQDKMZ5X5vC+tJwZXy3jxQ2kIlGSu6O0tUeJnYvi3mzAmqxHlRkZgF7F/DaDj1vKeWLXM6HtJxVsJRmJk2iME2uP4/a3Yl1rQa21MgClEfMtAjYLWF3HhH2AlHaKZLCXRKSHWGMP7tFerL4uVKgwA1ATsFPAkwLulQprWkjZp0lqgySCw8QiQ7h7hrEOD6KKQguQZxlQxmT+vICDAnYI2CQV1nSTtIdIaKPEgmO4VXewdo2i8tcsAy6UberSlOsGH25JU/rrGO+QCpsErL5Mm32bmO8RbnAGa+M0ylyXAShD/PKewafH5cym65kciHP1RA9n9l3h4OYxdqyewdXeYBW/RmU7fwYN+SNmp3N4O1fG1EQtoyPNXOrrpPvIAPHGNA1V96kIvcCvvZNmrF8a/P4wCByyPZSWeikpyaZIhjwQyMPvz8c0C9H1IF6fLeu+3p9vpZ4vz89Z/Ob5JSv1fP1NvgAUEgYu3FVrWQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"图片\"\n        title=\"图片\"\n        src=\"/static/e842cb1620e9a10679824522a6d46a82/af590/webgl_rect.png\"\n        srcset=\"/static/e842cb1620e9a10679824522a6d46a82/0b533/webgl_rect.png 500w,\n/static/e842cb1620e9a10679824522a6d46a82/af590/webgl_rect.png 626w\"\n        sizes=\"(max-width: 626px) 100vw, 626px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>","fields":{"slug":"/webgl_shader_buffer/"},"frontmatter":{"title":"初识webGl（1）","tags":["WebGl"],"categories":"WebGl"}}},{"node":{"html":"<h1>迭代器</h1>\n<ul>\n<li>迭代器模式描述了一个方案，将某些结构称为“可迭代对象”，因为它们都实现了正式的Iterable接口，而且可以通过迭代器Iterator消费</li>\n<li>可迭代对象：数组或集合这样的集合类型的对象。特点：包含元素有限，具有无歧义的遍历顺序</li>\n<li>任何实现Iterable接口的数据结构都可以被实现Iterator接口的结构“消费”</li>\n<li>迭代器是按需生成的一次性对象。每个迭代器都会关联一个可迭代对象，迭代器暴露了与之关联的可迭代对象的api</li>\n<li>迭代器不关心与它关联的可迭代对象数据结构，只关心如何取得连续的值</li>\n</ul>\n<h2>可迭代协议</h2>\n<ul>\n<li>实现Iterable(可迭代协议)要求两种能力：支持迭代的自我识别能力与创建实现Iterator接口的对象的能力。</li>\n<li>ECMAScript中暴露一个属性值作为“默认迭代器”，而且该属性用特殊的Symbol.iterator作为键。</li>\n<li>这个默认迭代器必须引用一个迭代器工厂函数，调用工厂函数必须返回一个新迭代器</li>\n<li>\n<p>实现Iteratable的内置类型</p>\n<ul>\n<li>字符串</li>\n<li>数组</li>\n<li>映射</li>\n<li>集合</li>\n<li>arguments对象</li>\n<li>NodeList等DOM集合</li>\n</ul>\n</li>\n<li>可以通过检查是否存在默认迭代器属性来暴露工厂函数</li>\n<li>\n<p>调用工厂函数可以生成一个迭代器</p>\n<!--more-->\n<pre><code class=\"language-js\">let num = 1\nlet str = 'abc'\nlet arr = [1, 2, 3]\nconsole.log(num[Symbol.iterator]) // undefined\nconsole.log(str[Symbol.iterator]) // [Symbol.iterator]() { [native code] }\nconsole.log(arr[Symbol.iterator]) // values() { [native code] }\n</code></pre>\n</li>\n</ul>\n<p>console.log(str<a href=\"\">Symbol.iterator</a>) // StringIterator {}\nconsole.log(arr<a href=\"\">Symbol.iterator</a>) // Array Iterator {}</p>\n<pre><code>- 实际代码中不需要显式调用工厂函数来生成迭代器。实现可迭代协议的所有类型会自动兼容接收可迭代对象的任何语言特性。\n- 接收可迭代对象的原生语言特性有：\n  - for-of循环\n  - 数组解构\n  - 拓展操作符\n  - Array.from()\n  - 创建集合\n  - 创建映射\n  - Promise.all()接收由期约组成的可迭代对象\n  - Promise.race()接收由期约组成的可迭代对象\n  - yield* 操作符，在生成器中使用\n- 这些语言结构会在后台调用提供的可迭代对象的工厂函数，从而创建迭代器\n\n```js\nlet arr = ['a', 'b', 'c']\nfor(let el of arr) {\n  console.log(el) // a, b, c\n}\n\nlet [a, b, c] = arr\nconsole.log(a, b, c) // a, b, c\n\nlet arr2 = [...arr]\nconsole.log(arr2) // [\"a\", \"b\", \"c\"]\n\nlet arr3 = Array.from(arr)\nconsole.log(arr3) // [\"a\", \"b\", \"c\"]\n\nlet set = new Set(arr)\nconsole.log(set) // Set(3) {\"a\", \"b\", \"c\"}\n\nlet pairs = arr.map((x, i) => [x, i])\nlet map = new Map(pairs)\nconsole.log(map) // Map(3) {\"a\" => 0, \"b\" => 1, \"c\" => 2}\n</code></pre>\n<h2>迭代器协议</h2>\n<ul>\n<li>迭代器是一次性使用的对象，用于迭代与其关联的可迭代对象。</li>\n<li>迭代器api使用next()方法可以遍历迭代器中的数据。</li>\n<li>每次调用next都会返回一个IteratorResult对象，其中包含迭代器返回的下一个值</li>\n<li>不调用next无法知道迭代器的当前位置</li>\n<li>IteratorResult包含两个属性，done跟value，done为布尔值，表示是否可以调用next获取下一个值，value包含可迭代对象的下一个值（done为false），或者undefined（done为true）</li>\n</ul>\n<pre><code class=\"language-js\">// 可迭代对象\nlet arr = ['foo', 'bar']\n\n// 迭代器工厂函数\nconsole.log(arr[Symbol.iterator]) // ƒ values() { [native code] }\n\n// 迭代器\nlet iter = arr[Symbol.iterator]() // Array Iterator {}\n\n// 执行迭代\nconsole.log(iter.next()) // {value: \"foo\", done: false}\nconsole.log(iter.next()) // {value: \"bar\", done: false}\nconsole.log(iter.next()) // {value: undefined, done: true}\nconsole.log(iter.next()) // {value: undefined, done: true}\n</code></pre>\n<ul>\n<li>迭代器并不知道怎么从可迭代对象取下一个值，也不知道可迭代对象多大，只要迭代器到达done:true的状态，后续调用netx()就一直返回同样的值</li>\n<li>每个迭代器都表示对可迭代对象的一次遍历，不同迭代器实例没有联系，只会独立的遍历</li>\n</ul>\n<pre><code class=\"language-js\">let arr2 = ['foo', 'bar']\nlet iter1 = arr2[Symbol.iterator]()\nlet iter2 = arr2[Symbol.iterator]()\n\nconsole.log(iter1.next()) // {value: \"foo\", done: false}\nconsole.log(iter2.next()) // {value: \"foo\", done: false}\nconsole.log(iter1.next()) // {value: \"bar\", done: false}\nconsole.log(iter2.next()) // {value: \"bar\", done: false}\n</code></pre>\n<ul>\n<li>迭代器不会与可迭代对象的某个时刻绑定，而是记录遍历可迭代对象的过程，如果遍历中可迭代对象变了，那迭代器会反应相应的变化</li>\n</ul>\n<pre><code class=\"language-js\">let arr = ['foo', 'bar']\nlet iter = arr[Symbol.iterator]() // Array Iterator {}\nconsole.log(iter.next()) // {value: \"foo\", done: false}\narr.splice(1, 0, 'baz')\nconsole.log(iter.next()) // {value: \"baz\", done: false}\nconsole.log(iter.next()) // {value: \"bar\", done: false}\nconsole.log(iter.next()) // {value: undefined, done: true}\n</code></pre>\n<ul>\n<li>迭代器维护着可迭代对象的引用，所以迭代器会阻止垃圾回收程序回收可迭代对象</li>\n</ul>\n<h2>自定义迭代器</h2>\n<ul>\n<li>与Iterable接口类似，实现了Iterator接口的对象都可以作为迭代器使用。</li>\n</ul>\n<pre><code class=\"language-js\">class Counter{\n  constructor(limit){\n    this.count = 1\n    this.limit = limit\n  }\n  next(){\n    if(this.count &#x3C;= this.limit) {\n      return {\n        done: false,\n        value: this.count++\n      }\n    } else {\n      return {\n        done: true,\n        value: undefined\n      }\n    }\n  }\n  [Symbol.iterator](){\n    return this\n  }\n}\n\nlet counter = new Counter(3)\nfor(let i of counter) {\n  console.log(i) // 1, 2, 3\n}\n\nfor(let i of counter) {\n  console.log(i) // 没有值\n}\n</code></pre>\n<ul>\n<li>这样实现了Iterator接口，但是每个实例只能被迭代一次，所以我们把计数器变量放到闭包中</li>\n</ul>\n<pre><code class=\"language-js\">class Counter{\n  constructor(limit) {\n    this.limit = limit\n  }\n\n  [Symbol.iterator](){\n    let count = 1,limit = this.limit\n    return {\n      next(){\n        if(count &#x3C;= limit) {\n          return {\n            done: false,\n            value: count++\n          }\n        } else {\n          return {\n            done: true,\n            value: undefined\n          }\n        }\n      }\n    }\n  }\n}\n\nlet counter = new Counter(3)\nfor(let i of counter) {\n  console.log(i) // 1, 2, 3\n}\n\nfor(let i of counter) {\n  console.log(i) // 1, 2, 3\n}\n</code></pre>\n<ul>\n<li>每个以这种方式创建的迭代器都实现了Iterator接口。Symbol.iterator属性引用的工厂函数会返回相同的迭代器</li>\n<li>因为每个迭代器也实现了Iterable接口，所以可以再任何期待可迭代对象的地方使用，比如for-of循环</li>\n</ul>\n<pre><code class=\"language-js\">let arr = [3, 1, 4]\nlet iter = arr[Symbol.iterator]()\nfor(let item of arr) {\n  console.log(item) // 3, 1, 4\n}\n\nfor(let item of iter) {\n  console.log(item) // 3, 1, 4\n}\n</code></pre>\n<h2>提前终止迭代器</h2>\n<ul>\n<li>\n<p>可选的return方法用于指定在迭代器提前关闭时执行的逻辑。执行迭代的结构在想让迭代器知道它不想遍历到可迭代对象耗尽时，可以关闭迭代器。情况有：</p>\n<ul>\n<li>for-of循环通过break、continue、return、或者throw提前退出</li>\n<li>结构操作并未消费所有值</li>\n</ul>\n</li>\n<li>return方法必须返回一个幼小的IteratorResult对象，可以只返回{done: true}</li>\n<li>下面代码所示，内置语言结构发现还有值可以迭代，但不会消费这些值时，会自动调用return</li>\n</ul>\n<pre><code class=\"language-js\">class Counter{\n  constructor(limit) {\n    this.limit = limit\n  }\n\n  [Symbol.iterator](){\n    let count = 1,limit = this.limit\n    return {\n      next(){\n        if(count &#x3C;= limit) {\n          return {\n            done: false,\n            value: count++\n          }\n        } else {\n          return {\n            done: true,\n            value: undefined\n          }\n        }\n      },\n      return (){\n        console.log('exit early')\n        return { done: true }\n      }\n    }\n  }\n}\n\nlet counter1 = new Counter(5)\nfor(let i of counter1) {\n  if(i > 2) {\n    break\n  }\n  console.log(i)\n}\n// 1\n// 2\n// exit early\n\nlet counter2 = new Counter(5)\ntry {\n  for(let i of counter1) {\n    if(i > 2) {\n      throw 'err'\n    }\n    console.log(i)\n  }\n} catch(e) {}\n// 1\n// 2\n// exit early\n\nlet counter3 = new Counter(5)\nlet [a, b] = counter3\n// exit early\n</code></pre>\n<ul>\n<li>如果迭代器没有关闭，就可以从上次离开的地方继续迭代，比如数组的迭代不可关闭</li>\n</ul>\n<pre><code class=\"language-js\">let arr3 = [1, 2, 3, 4, 5]\nlet iter1 = arr3[Symbol.iterator]()\nfor(let i of iter1) {\n  console.log(i)\n  if(i > 2) {\n    break\n  }\n}\n// 1\n// 2\n// 3\n\n\nfor(let i of iter1) {\n  console.log(i)\n}\n// 4\n// 5\n</code></pre>\n<ul>\n<li>return方法是可选的，所以并非所有迭代都可以关闭，可以通过测试迭代器的return属性是不是方法确定是否可关闭。</li>\n<li>仅仅给给不可关闭的迭代器加return方法并不能使其变成可关闭的。这是因为调用return并不会强制迭代器进入关闭状态。但是return方法仍然会调用</li>\n</ul>\n<pre><code class=\"language-js\">let arr4 = [1, 2, 3, 4, 5]\nlet iter4 = arr4[Symbol.iterator]()\niter4.return = function(){\n  console.log('exit early')\n  return { done: true }\n}\n\nfor(let i of iter4) {\n  console.log(i)\n  if(i > 2) {\n    break\n  }\n}\n// 1\n// 2\n// 3\n// exit early\n\n\nfor(let i of iter4) {\n  console.log(i)\n}\n// 4\n// 5\n</code></pre>\n<h2>小结</h2>\n<ul>\n<li>迭代器是一个由任意对象实现的接口，支持连续获取对象产出的每一个值。任何实现Iterable接口的对象都有一个Symbol.iterator属性，这个属性引用默认迭代器。默认迭代器就像一个迭代器工厂，也就是一个函数，调用之后会产生一个实现Iterator接口的对象</li>\n<li>迭代器必须通过next方法才能连续取到值，这个方法返回IteratorObject。包含一个done属性跟value属性。这个借口可以通过手动反复调用next消费，也可以通过for-of这样的原生消费者消费</li>\n</ul>","fields":{"slug":"/iterator2/"},"frontmatter":{"title":"再读迭代器","tags":["JavaScript回顾"],"categories":"JavaScript"}}},{"node":{"html":"<h1>生成器</h1>\n<ul>\n<li>生成器是ECMAScript 6新增的拥有在一个函数块内暂停和恢复代码执行的能力</li>\n<li>使用该能力可以自定义迭代器和实现协称</li>\n<li>生成器是一个函数，函数名前加一个 * 表示它是一个生成器</li>\n<li>可以定义函数的地方都可以定义生成器</li>\n<li>箭头函数不可以定义生成器函数</li>\n</ul>\n<pre><code class=\"language-js\">function *generatorFn(){}\nlet generatorFn = function* () {}\nlet foo = {\n  *generatorFn(){}\n}\nclass Foo{\n  *generatorFn(){}\n}\nclass Bar{\n  static *generatorFn(){}\n}\n</code></pre>\n<ul>\n<li>生成器函数的 * 不受两侧空格影响</li>\n</ul>\n<pre><code class=\"language-js\">// 等价的生成方式\nfunction *generatorFn(){}\nfunction* generatorFn(){}\nfunction * generatorFn(){}\n</code></pre>\n<!--more-->\n<ul>\n<li>调用生成器函数会生成一个生成器对象。</li>\n<li>生成器对象开始处于暂停状态</li>\n<li>与迭代器相似，生成器对象也实现了Iterator接口，因此也有next方法。调用这个方法可以开始或恢复执行</li>\n</ul>\n<pre><code class=\"language-js\">const generatorFn = function* (){}\nconst g = generatorFn()\nconsole.log(g) // generatorFn {&#x3C;suspended>}\nconsole.log(g.next) // ƒ next() { [native code] }\nconsole.log(g.next()) // {value: undefined, done: true}\n</code></pre>\n<ul>\n<li>next返回的值类似于迭代器，有一个done跟value属性。函数体为空的生成器函数中间不会停留，调用一次就会让生成器到达done: true的状态</li>\n<li>value属性是生成器函数的返回值，默认为undefined，可以通过生成器函数的返回值指定</li>\n</ul>\n<pre><code class=\"language-js\">const generatorFn1 = function* (){\n  return 'bar'\n}\nconst g1 = generatorFn1()\nconsole.log(g1.next()) // {value: \"bar\", done: true}\n</code></pre>\n<ul>\n<li>生成器函数只会在初次调用next方法后开始执行，如下所示</li>\n</ul>\n<pre><code class=\"language-js\">const generatorFn2 = function* (){\n  console.log('foobar')\n}\nconst generatorObject2 = generatorFn2()\ngeneratorObject2.next() // 'foobar'\n</code></pre>\n<ul>\n<li>生成器对象实现了Iterator接口，它们默认的迭代器是自引用的</li>\n</ul>\n<pre><code class=\"language-js\">const generatorFn3 = function* (){\n}\nconsole.log(generatorFn3)  // ƒ* (){}\nconsole.log(generatorFn3()) // generatorFn3 {&#x3C;suspended>}\nconsole.log(generatorFn3()[Symbol.iterator]) // ƒ [Symbol.iterator]() { [native code] }\nconsole.log(generatorFn3()[Symbol.iterator]()) // generatorFn3 {&#x3C;suspended>}\n\nconst g3 = generatorFn3()\nconsole.log(g3 === g3[Symbol.iterator]()) // true\n</code></pre>\n<h2>yield</h2>\n<ul>\n<li>yield关键字可以让生成器停止和开始执行</li>\n<li>生成器函数再遇到yield之前正常执行，遇到这个关键字会停止执行，函数作用域状态保留</li>\n<li>停止执行的生成器函数只能通过在生成器对象上调用next方法恢复执行</li>\n</ul>\n<pre><code class=\"language-js\">const generatorFn4 = function* (){\n  yield\n}\nconst generatorObject4 = generatorFn4()\nconsole.log(generatorObject4.next()) // {value: undefined, done: false}\nconsole.log(generatorObject4.next()) // {value: undefined, done: true}\n</code></pre>\n<ul>\n<li>yield关键字类似于函数中的中间返回语句，生成的值会在next方法返回的对象里，通过yield退出的生成器函数会处在done: false的状态，通过return方法退出的生成器函数会处在 done: true的状态</li>\n</ul>\n<pre><code class=\"language-js\">const generatorFn5 = function* (){\n  yield 'foo'\n  yield 'bar'\n  return 'baz'\n}\nconst generatorObject5 = generatorFn5()\nconsole.log(generatorObject5.next()) // {value: \"foo\", done: false}\nconsole.log(generatorObject5.next()) // {value: \"bar\", done: false}\nconsole.log(generatorObject5.next()) // {value: \"baz\", done: true}\n</code></pre>\n<ul>\n<li>生成器函数内部的执行流程会对每个生成器对象区分作用域。在一个生成器上调用next不会影响其他生成器</li>\n</ul>\n<pre><code class=\"language-js\">const generatorFn6 = function* (){\n  yield 'foo'\n  yield 'bar'\n  return 'baz'\n}\nconst generatorObject6 = generatorFn6()\nconst generatorObject61 = generatorFn6()\nconsole.log(generatorObject6.next()) // {value: \"foo\", done: false}\nconsole.log(generatorObject61.next()) // {value: \"foo\", done: false}\nconsole.log(generatorObject6.next()) // {value: \"bar\", done: false}\nconsole.log(generatorObject61.next()) // {value: \"bar\", done: false}\n</code></pre>\n<ul>\n<li>yield关键字只能在生成器函数内部使用，其他地方会报错。类似return语句，yield必须直接位于生成器函数定义中，出现在嵌套的非生成器函数会抛错</li>\n</ul>\n<pre><code class=\"language-js\">// 有效\nfunction* validGeneratorFn(){\n  yield\n}\n\n// 无效\nfunction* invalidGeneratorFn(){\n  function a(){\n    yield\n  }\n}\n\n// 无效\nfunction* invalidGeneratorFn(){\n  const b = () => {\n    yield\n  }\n}\n\n// 无效\nfunction* invalidGeneratorFn(){\n  (() => {\n    yield\n  })()\n}\n</code></pre>\n<h2>生成器作为可迭代对象</h2>\n<ul>\n<li>可以把生成器当做可迭代对象使用</li>\n</ul>\n<pre><code class=\"language-js\">function* generatorFn7(){\n  yield 1\n  yield 2\n  yield 3\n}\nfor(const x of generatorFn7()) {\n  console.log(x) // 1, 2, 3\n}\n</code></pre>\n<ul>\n<li>在需要自定义迭代对象时我们可以使用生成器对象。比如，当我们需要定义一个可迭代对象，它会产生一个迭代器，迭代器会执行指定的次数</li>\n<li>使用生成器可以用一个简单地循环实现</li>\n</ul>\n<pre><code class=\"language-js\">function* generatorFn8(n){\n  while(n--) {\n    yield\n  }\n}\nfor(let _ of generatorFn8(3)) {\n  console.log('foo') // 'foo', 'foo', 'foo'\n}\n</code></pre>\n<h2>yield实现输入输出</h2>\n<ul>\n<li>除了作为函数的中间返回语句，yield还可以作为函数的中间参数使用。上一次让生成器函数暂停的yield关键字会接收到传给next的第一个值。</li>\n<li>第一次调用next方法传入的值不会被使用，因为第一次是为了开始执行生成器函数</li>\n</ul>\n<pre><code class=\"language-js\">function* generatorFn9(initial){\n  console.log(initial)\n  console.log(yield)\n  console.log(yield)\n}\nlet generatorObject9 = generatorFn9('foo')\n\ngeneratorObject9.next('bar') // foo\ngeneratorObject9.next('baz') // baz\ngeneratorObject9.next('qux') // qux\n</code></pre>\n<ul>\n<li>yield还可以同时用于输入输出</li>\n</ul>\n<pre><code class=\"language-js\">function* generatorFn10(){\n  return yield 'foo'\n}\nlet generatorObject10 = generatorFn10()\n\nconsole.log(generatorObject10.next()) // {value: \"foo\", done: false}\nconsole.log(generatorObject10.next('bar')) // {value: 'bar', done: true}\n</code></pre>\n<ul>\n<li>因为函数必须要对整个表达式求值才可以返回，再遇到yield时暂停并计算返回的值'foo'。下一次调用next()传入了'bar'，作为交给同一个yield的值。然后这个值被定为生成器函数要返回的值</li>\n<li>yield关键字可以多次使用</li>\n<li>如果我们定义一个生成器函数，根据配制的值迭代相应次数，并产生迭代索引。初始化一个数组可以实现，不用数组也可以</li>\n</ul>\n<pre><code class=\"language-js\">function* nTimes(n){\n  for(let i = 0; i &#x3C; n; ++i) {\n    yield i\n  }\n}\n\n// 或者用while实现\nfunction* nTimes(n){\n  let i = 0\n  while(n--) {\n    yield i++\n  }\n}\n</code></pre>\n<ul>\n<li>使用生成器可以填充范围数组</li>\n</ul>\n<pre><code class=\"language-js\">function* range(start, end) {\n  while(end > start) {\n    yield start++\n  }\n}\nfor(let x of range(4, 7)) {\n  console.log(x) // 4, 5, 6\n}\n\nfunction* zeroes(n) {\n  while(n--) {\n    yield 0\n  }\n}\nconsole.log(Array.from(zeroes(8))) // [0, 0, 0, 0, 0, 0, 0, 0]\n</code></pre>\n<h2>产生可迭代对象</h2>\n<ul>\n<li>可以使用 * 加强yield的行为，让它迭代一个可迭代对象，从而一次产出一个值</li>\n</ul>\n<pre><code class=\"language-js\">function* generatorFn11(){\n  yield* [1, 2, 3]\n}\nfor(let x of generatorFn11()) {\n  console.log(x)\n}\n\n// 等价于\nfunction* generatorFn11(){\n  for(const x of [1, 2, 3]) {\n    yield x\n  }\n}\n</code></pre>\n<ul>\n<li>yield星号两侧也不受空格影响</li>\n<li>yield* 其实只是将一个可迭代对象序列化为一串可以单独产出的值，跟放在循环里没有什么不同</li>\n<li>yield* 的值是关联迭代器返回done:true时的value属性。对于普通迭代器来说，这个值是undefined</li>\n</ul>\n<pre><code class=\"language-js\">function* generatorFn12(){\n  console.log('iter value:', yield* [1, 2, 3])\n}\nfor(const x of generatorFn12()) {\n  console.log('value: ', x)\n}\n// value:  1\n// value:  2\n// value:  3\n// iter value: undefined\n</code></pre>\n<ul>\n<li>对于生成器函数产生的迭代器来说，这个值就是生成器函数返回的值</li>\n</ul>\n<pre><code class=\"language-js\">function* generatorFn13(){\n  yield 'foo'\n  return 'bar'\n}\nfunction* othergeneratorFn13(genObj){\n  console.log('iter value:', yield* generatorFn13())\n}\nfor(const x of othergeneratorFn13()) {\n  console.log('value: ', x)\n}\n\n// value:  foo\n// iter value: bar\n</code></pre>\n<h2>yield*实现递归</h2>\n<ul>\n<li>这也是yield*最有用的地方</li>\n</ul>\n<pre><code class=\"language-js\">function* nTimes(n) {\n  if(n > 0) {\n    yield* nTimes(n - 1)\n    yield n - 1\n  }\n}\nfor(const x of nTimes(3)) {\n  console.log(z)\n}\n// 0\n// 1\n// 2\n</code></pre>\n<ul>\n<li>这里每个生成器都会从新创建的生成器对象产出值，然后再产生一个整数。</li>\n<li>下面是一个图的实现，生成一个随机的双向图</li>\n</ul>\n<pre><code class=\"language-js\">class Node {\n  constructor(id){\n    this.id = id\n    this.neighbors = new Set()\n  }\n  connect(node){\n    if(node !== this) {\n      this.neighbors.add(node)\n      node.neighbors.add(this)\n    }\n  }\n}\nclass RandomGraph {\n  constructor(size) {\n    this.nodes = new Set()\n    for(let i = 0; i &#x3C; size; ++i) {\n      this.nodes.add(new Node(i))\n    }\n    const threshold = 1 / size\n    for(const x of this.nodes) {\n      for(const y of this.nodes) {\n        if(Math.random() &#x3C; threshold) {\n          x.connect(y)\n        }\n      }\n    }\n  }\n\n  print(){\n    for(const node of this.nodes) {\n      // console.log([...node.neighbors])\n      const ids = [...node.neighbors].map((n) => n.id).join(',')\n      console.log(`${ node.id }: ${ ids }`)\n    }\n  }\n}\n\nconst gra = new RandomGraph(6)\ngra.print()\n// 0: 1,5\n// 1: 0,2,5\n// 2: 1,3,5\n// 3: 2\n// 4: 5\n// 5: 0,2,1,4\n</code></pre>\n<ul>\n<li>图结构数据适合递归遍历，而递归生成器可以实现这个需求。生成器函数必须包含一个可迭代对象，产出该对象的每个值，并对值进行递归。如此可以测试是否有某个点不可到达。</li>\n</ul>\n<pre><code class=\"language-js\">class Node {\n  constructor(id){\n    this.id = id\n    this.neighbors = new Set()\n  }\n  connect(node){\n    if(node !== this) {\n      this.neighbors.add(node)\n      node.neighbors.add(this)\n    }\n  }\n}\nclass RandomGraph {\n  constructor(size) {\n    this.nodes = new Set()\n    for(let i = 0; i &#x3C; size; ++i) {\n      this.nodes.add(new Node(i))\n    }\n    const threshold = 1 / size\n    for(const x of this.nodes) {\n      for(const y of this.nodes) {\n        if(Math.random() &#x3C; threshold) {\n          x.connect(y)\n        }\n      }\n    }\n  }\n\n  print(){\n    for(const node of this.nodes) {\n      // console.log([...node.neighbors])\n      const ids = [...node.neighbors].map((n) => n.id).join(',')\n      console.log(`${ node.id }: ${ ids }`)\n    }\n  }\n\n  isConnect(){\n    let visitedNode = new Set()\n    function* traverse(nodes){\n      for(let node of nodes) {\n        if(!visitedNode.has(node)) {\n          yield node\n          yield* traverse(node.neighbors)\n        }\n      }\n    }\n    const firstNode = this.nodes[Symbol.iterator]().next().value\n    for(const node of traverse([firstNode])) {\n      visitedNode.add(node)\n    }\n    return visitedNode.size === this.nodes.size\n  }\n}\n</code></pre>\n<ul>\n<li>因为生成器对象实现了Iterable接口，而且生成器函数和默认迭代器对象调用之后都会产生迭代器，所以生成器格外适合做为默认迭代器，下面是一个简单地例子</li>\n</ul>\n<pre><code class=\"language-js\">class Foo{\n  constructor(){\n    this.values = [1, 2, 3]\n  }\n  * [Symbol.iterator]() {\n    yield* this.values\n  }\n}\n\nconst f = new Foo()\nfor(const x of f) {\n  console.log(x)\n}\n// 1, 2, 3\n</code></pre>\n<ul>\n<li>for-of循环调用默认迭代器（刚好也是一个生成器函数）并产生一个生成器对象，生成器对象是可迭代的，所以可以在迭代中使用</li>\n</ul>\n<h2>提前终止生成器</h2>\n<ul>\n<li>生成器支持“可关闭”的概念。一个实现Iterator接口的对象一定有next方法，还有一个可选的return方法用于提前终止迭代器。生成器对象除了这两个方法，还有第三个方法： throw</li>\n</ul>\n<pre><code class=\"language-js\">function* generatorF(){}\nconst ge = generatorF()\nconsole.log(ge) // generatorF {&#x3C;suspended>}\nconsole.log(ge.next) // ƒ next() { [native code] }\nconsole.log(ge.return) // ƒ return() { [native code] }\nconsole.log(ge.throw) // ƒ throw() { [native code] }\n</code></pre>\n<ul>\n<li>return与throw都可以强制生成器进入关闭状态</li>\n<li>return 方法强制生成器进入关闭状态，提供给return的值就是终止迭代器对象的值</li>\n</ul>\n<pre><code class=\"language-js\">function* generatorF1(){\n  for(const x of [1,2,3]) {\n    yield x\n  }\n}\nconst ge1 = generatorF1()\nconsole.log(ge1) // generatorF1 {&#x3C;suspended>}\nconsole.log(ge1.return(3)) // {value: 3, done: true}\nconsole.log(ge1) // generatorF1 {&#x3C;closed>}\n</code></pre>\n<ul>\n<li>跟迭代器不一样，生成器对象一旦进入关闭状态就无法恢复了。后续调用next会显示done: true的状态，而且这个值不会被存储或传播</li>\n</ul>\n<pre><code class=\"language-js\">function* generatorF2(){\n  for(const x of [1,2,3]) {\n    yield x\n\nconst ge2 = generatorF2()\nconsole.log(ge2.next()) // {value: 1, done: false}\nconsole.log(ge2.return(4)) // {value: 4, done: true}\nconsole.log(ge2.next()) // {value: undefined, done: true}\nconsole.log(ge2.next()) // {value: undefined, done: true}  }\n}\n</code></pre>\n<ul>\n<li>for-of循环等内置语言结构会忽略状态为done: true的IteratorObject内部的值</li>\n</ul>\n<pre><code class=\"language-js\">function* generatorF3(){\n  for(const x of [1,2,3]) {\n    yield x\n  }\n}\nconst ge3 = generatorF3()\nfor(const x of ge3) {\n  if(x > 1) {\n    ge3.return(4)\n  }\n  console.log(x)\n}\n// 1\n// 2\n</code></pre>\n<ul>\n<li>throw方法会在暂停时讲一个提供的错误注入到生成器对象中，要是错误没有被处理，生成器就会关闭</li>\n</ul>\n<pre><code class=\"language-js\">function* generatorF4(){\n  for(const x of [1,2,3]) {\n    yield x\n  }\n}\nconst ge4 = generatorF4()\nconsole.log(ge4) // generatorF4 {&#x3C;suspended>}\ntry {\n  ge4.throw('foo')\n} catch(e) {\n  console.log(e) // foo\n}\nconsole.log(ge4) // generatorF4 {&#x3C;closed>}\n</code></pre>\n<ul>\n<li>要是生成器内部处理了这个值，那生成器就不会关闭，而且可以恢复执行。错误处理会跳过对应的yield，因此下例中会跳过一个值</li>\n</ul>\n<pre><code class=\"language-js\">function* generatorF5(){\n  for(const x of [1,2,3]) {\n    try {\n      yield x\n    } catch (e) {\n      console.log(e)\n    }\n  }\n}\nconst ge5 = generatorF5()\nge5.throw('foo') // 'foo'\nconsole.log(ge5.next()) // {value: 3, done: false}\n</code></pre>\n<ul>\n<li>上面生成器在try/catch块中的yield关键字暂停执行。暂停期间throw向生成器对象内部注入了一个错误：字符串\"foo\"。因为错误是在生成器的try/catch抛出，仍然在生成器内部捕获。</li>\n<li>由于yield抛出了错误，生成器不会产出2.此时，生成器函数继续执行，下一次迭代再次遇到yield关键字时产出了3</li>\n<li>如果生成器还没有开始执行，那么调用throw抛出的错误不会在函数内部被捕获，因为这相当于在函数外部抛出了错误</li>\n</ul>\n<h2>小结</h2>\n<ul>\n<li>生成器是一种特殊的函数，调用返回一个生成器对象。生成器对象实现了Iterable接口，因此能用在任何消费可迭代对象的地方。</li>\n<li>生成器支持yield关键字，该关键字可以暂停执行生成器函数。yield关键字可以通过next接收输入和输出。</li>\n<li>yield加上 * 后可以将后面的可迭代对象序列化为一串值</li>\n</ul>","fields":{"slug":"/generator2/"},"frontmatter":{"title":"再读生成器","tags":["JavaScript回顾"],"categories":"JavaScript"}}},{"node":{"html":"<h1>对象基本概念</h1>\n<ul>\n<li>ECMA-262定义的对象是一组属性的无序集合。就是说对象是一组没有顺序的值</li>\n<li>可以将对象想象为散列表，内容就是一组名/值对</li>\n<li>对象实例通常都有属性跟方法</li>\n</ul>\n<h2>属性类型</h2>\n<ul>\n<li>ECMA-262使用内部特性来描述属性的特质。这些特性都由javascript实现引擎的规范定义的。</li>\n<li>因此开发者不能在javascript中直接访问这些特性。为了将某个特性标志为内部特征，规范会用两个中括号包裹，比如[[Enumerable]]</li>\n<li>属性分为数据属性和访问器属性</li>\n</ul>\n<h3>数据属性</h3>\n<ul>\n<li>\n<p>数据属性包含一个保存数据值得位置。值会从这个位置读取，也会写到这个位置，有4个特性描述它的行为</p>\n<ul>\n<li>[[Configurable]]: 表示属性是否可以通过delete删除并重新定义，是否可以修改它的特性，以及是否可以把它改为访问器属性。默认情况下，直接定义在对象上的属性，这个值都是true</li>\n<li>[[Enumberable]]: 表示属性是否可以通过for-in循环返回。默认情况下，直接定义在对象上的属性，这个值都是true</li>\n<li>[[Writable]]: 表示属性的值是否可以被修改。默认情况下，直接定义在对象上的属性，这个值都是true</li>\n<li>[[Value]]: 包含属性实际的值，读取和写入属性值的位置。默认值为undefined</li>\n</ul>\n</li>\n<li>\n<p>当我们显式的将属性添加到对象之后，[[Configurable]],[[Enumberable]],[[Writable]]都被设为true，[[Value]]被设为指定值</p>\n<!--more-->\n<pre><code class=\"language-js\">let person = {\nname: 'Nicholas'\n}\n</code></pre>\n</li>\n<li>这里我们创建该属性后， [[Value]]会被设置为'Nicholas'，之后对这个name的修改都会放到这个位置</li>\n<li>修改属性的默认特性，要使用Object.defineProperty()方法。接收三个参数：添加属性的对象，属性名称和描述符对象。最后一个参数描述符对象属性包括：configurable、writable、enumerable、value，跟特性名称一一对应。根据要修改的特性，设置一个或多个值。</li>\n</ul>\n<pre><code class=\"language-js\">let person = {}\nObject.defineProperty(person, \"name\", {\n  value: 'Nicholas',\n  writable: false\n})\nconsole.log(person.name) // Nicholas\nperson.name = 'zhangsan'\nconsole.log(person.name)// Nicholas\n</code></pre>\n<ul>\n<li>这里我们设置了writable为false就是表明它制度，就不可以修改，非严格模式下赋值会被忽略，严格模式下报错</li>\n</ul>\n<pre><code class=\"language-js\">let person = {}\nObject.defineProperty(person, \"name\", {\n  value: 'Nicholas',\n  configurable: false\n})\ndelete person.name\nconsole.log(person.name) // Nicholas\n\n// 尝试再次修改\nObject.defineProperty(person, \"name\", {\n  value: 'Nicholas',\n  configurable: true\n})\n// VM68586:8 Uncaught TypeError: Cannot redefine property: name\n</code></pre>\n<ul>\n<li>设置configurable之后删除该属性无效，在严格模式下删除该属性会报错</li>\n<li>设置configurable之后这个属性就被改为不可再配置得了，再次调用Object.defineProperty()并修改非writable的属性会导致报错</li>\n<li>在调用Object.defineProperty时，configurable、enumerable、writable如果不指定则都默认为false</li>\n</ul>\n<h3>访问器属性</h3>\n<ul>\n<li>访问器属性不包含数据值。相反，它包含一个获取（getter）函数和一个设置（setter）函数，这两个函数都是非必须的。</li>\n<li>在读取访问器属性时，会调用获取函数，该函数的责任是返回一个有效的值。在写入访问器属性时，会调用设置函数并传入新值，这个函数必须决定对数据做出什么修改。</li>\n<li>\n<p>访问器属性也有4个特性描述它们的行为</p>\n<ul>\n<li>[[Configurable]]: 表示属性是否可以通过delete删除并重新定义，是否可以修改它的特性，是否可以把它改为数据属性。默认情况下，直接定义在对象上的属性的这个特性值都是true</li>\n<li>[[Enumerable]]: 表示属性是否可以通过for-in循环返回。默认情况下，直接定义在对象上的属性的这个特性值都是true</li>\n<li>[[Get]]: 获取函数，读取属性时调用。默认值为undefined</li>\n<li>[[Set]]: 设置函数，写入属性时调用。默认值为undefined</li>\n</ul>\n</li>\n<li>访问器属性也需要使用defineProperty来定义</li>\n</ul>\n<pre><code class=\"language-js\">let book = {\n  year_: 2017,\n  edition: 1\n}\nObject.defineProperty(book, 'year', {\n  get(){\n    return this.year_\n  },\n  set(newValue){\n    if(newValue > 2017) {\n      this.year_ = newValue\n      this.edition += newValue - 2017\n    }\n  }\n})\nconsole.log(book.year) // 2017\nbook.year = 2018\nconsole.log(book.edition) // 2\n</code></pre>\n<ul>\n<li>这个例子中book有两个默认属性year<em>跟edition。year</em>中的下划线表示该属性不想在对象方法的外面被访问。</li>\n<li>另一个属性year被定义为访问器属性，其中获取函数简单地返回year<em>的值，而设置函数会计算决定正确的版本。因此把year变为2018会导致year</em>变为2018，edition变为2。</li>\n<li>获取属性跟设置属性不一定都要定义。只定义获取属性意味属性是只读的，尝试修改会忽略。严格模式下会报错</li>\n<li>只有一个设置函数的属性是不可读取的，非严格模式返回undefined，严格模式报错</li>\n<li>在不支持Object.defineProperty()的浏览器中没法修改[[Configurable]]或[[Enumerable]]</li>\n<li>ECMAScript5之前，开发者通过非标准的访问器属性访问创建访问器属性：<strong>defineGetter</strong>()和<strong>defineSetter</strong>()。</li>\n</ul>\n<h3>定义多个属性</h3>\n<ul>\n<li>ECMAScript提供了Object.defineProperties()方法。该方法可以通过多个描述符一次性定义多个属性。</li>\n<li>接收两个参数：要为之添加或修改属性的对象和另一个描述符对象，属性与要添加或修改的属性一一对应。</li>\n</ul>\n<pre><code class=\"language-js\">let book = {}\nObject.defineProperties(book, {\n  year_: {\n    value: 2017\n  },\n  edition: {\n    value: 1,\n  },\n  year: {\n    get(){\n      return this.year_\n    },\n    set(newValue){\n      if(newValue > 2017) {\n        this.year_ = newValue\n        this.deition += newValue - 2017\n      }\n    }\n  }\n})\n</code></pre>\n<ul>\n<li>这段代码定义了两个数据属性year_跟edition，还有一个访问器属性year。最终的效果跟之前实现的效果一样。</li>\n<li>区别就是所有属性都是同时定义的，并且数据属性configurable、enumerable、和writable特性值都是false</li>\n</ul>\n<h3>读取属性特性</h3>\n<ul>\n<li>使用Object.getOwnPropertyDescriptor()方法可以读取指定属性的属性描述符。</li>\n<li>该方法接收两个参数：属性所在的对象和要取得的属性名。</li>\n<li>返回值是一个对象，对于数据属性包含configurable、enumerable、writable、value属性。对于访问器属性包含configurable、enumerable、get和set属性</li>\n</ul>\n<pre><code class=\"language-js\">let book = {}\nObject.defineProperties(book, {\n  year_: {\n    value: 2017\n  },\n  edition: {\n    value: 1,\n  },\n  year: {\n    get(){\n      return this.year_\n    },\n    set(newValue){\n      if(newValue > 2017) {\n        this.year_ = newValue\n        this.edition += newValue - 2017\n      }\n    }\n  }\n})\nlet descriptor = Object.getOwnPropertyDescriptor(book, \"year_\")\nconsole.log(descriptor)\n// {\n//   configurable: false\n//   enumerable: false\n//   value: 2017\n//   writable: false\n// }\nlet descriptor1 = Object.getOwnPropertyDescriptor(book, \"year\")\nconsole.log(descriptor1)\n// {\n//   configurable: false\n//   enumerable: false\n//   get: ƒ get()\n//   set: ƒ set(newValue)\n// }\n</code></pre>\n<ul>\n<li>ECMAScript2017中新增了Object.getOwnPropertyDescriptors()静态方法。该方法会在每个自有属性上调用Object.getOwnPropertyDescriptor()方法，并在一个新对象中返回。</li>\n</ul>\n<pre><code class=\"language-js\">let book = {}\nObject.defineProperties(book, {\n  year_: {\n    value: 2017\n  },\n  edition: {\n    value: 1,\n  },\n  year: {\n    get(){\n      return this.year_\n    },\n    set(newValue){\n      if(newValue > 2017) {\n        this.year_ = newValue\n        this.edition += newValue - 2017\n      }\n    }\n  }\n})\nconsole.log(Object.getOwnPropertyDescriptors(books))\n// {\n//     \"year_\":{\n//         \"value\":2017,\n//         \"writable\":false,\n//         \"enumerable\":false,\n//         \"configurable\":false\n//     },\n//     \"edition\":{\n//         \"value\":1,\n//         \"writable\":false,\n//         \"enumerable\":false,\n//         \"configurable\":false\n//     },\n//     \"year\":{\n//         \"enumerable\":false,\n//         \"configurable\":false,\n//         \"get\": ƒ get(),\n//         \"set\": ƒ set(newValue)\n//     }\n// }\n</code></pre>\n<ul>\n<li>ES6新增了Object.assign方法来实现对象的合并。这个方法接收一个目标对象和多个源对象作为参数，然后将每个源对象中可枚举（Object.propertyIsEnumerable()返回true）和自有（Object.hasOwnProperty()返回true）的属性复制到目标对象.</li>\n<li>以字符串跟符号为键的属性会被复制。对符合条件的属性，这个方法会使用源对象上的[[Get]]取得属性的值，然后使用目标对象上的[[Set]]设置属性的值</li>\n</ul>\n<pre><code class=\"language-js\">let dest = {\n  set a(val) {\n    console.log(`Invoke dest setter with param ${val}`)\n  }\n}\nlet src = {\n  get a(){\n    console.log('Invoke src getter')\n    return 'foo'\n  }\n}\nObject.assign(dest, src)\n// 调用src的获取方法  Invoke src getter\n// 调用dest的设置方法并传入参数‘foo’   Invoke dest setter with param foo\nconsole.log(dest)\n// 因为dest的设置函数并没有执行赋值操作，所以值并没有过来\n// { ser a()}\n</code></pre>\n<ul>\n<li>该方法采用的是浅复制。如果多个源对象有相同的属性，则以最后一次为准。</li>\n<li>从源对象访问器属性获取的值，比如获取函数会作为一个静态值赋给目标对象。也就是说，不能在两个对象之间转移获取函数和设置函数</li>\n<li>如果赋值期间出错，操作会终止并退出，同时抛出错误。但是并不能回滚之前的操作，因此它是一个尽力而为、可能只完成部分复制的方法</li>\n</ul>\n<pre><code class=\"language-js\">let desc,src,result\ndesc = {}\nsrc = {\n  a: 'foo',\n  get b(){\n    throw new Error()\n  },\n  c: 'bar'\n}\ntry {\n  Object.assign(desc, src)\n} catch(e) {}\n// 出错了，但无法回滚\nconsole.log(desc) // {a: \"foo\"}\n</code></pre>\n<h3>对象标识与相等判断</h3>\n<ul>\n<li>ES6之前，有些特殊情况 === 也无法判断大小，如下</li>\n</ul>\n<pre><code class=\"language-js\">console.log(+0 === -0) // true\nconsole.log(+0 === 0) // true\nconsole.log(-0 === 0) // true\nconsole.log(NaN === NaN) // false\n// 判断NaN必须使用isNaN\nconsole.log(isNaN(NaN)) // true\n</code></pre>\n<ul>\n<li>ES6新增了Object.is()方法，接收两个值，作用跟 === 相似</li>\n</ul>\n<pre><code class=\"language-js\">console.log(Object.is(+0, -0)) // false\nconsole.log(Object.is(+0, 0)) // true\nconsole.log(Object.is(-0, 0)) // false\nconsole.log(Object.is(NaN, NaN)) // true\n</code></pre>\n<ul>\n<li>递归调用可以检查多个值</li>\n</ul>\n<pre><code class=\"language-js\">function recursivelyCheckEqual(x, ...rest) {\n  return x === rest[0] &#x26;&#x26; (rest.length &#x3C; 2 || recursivelyCheckEqual(...rest))\n}\nrecursivelyCheckEqual(1, 1, 1) // true\nrecursivelyCheckEqual(1, 1, 2) // false\n</code></pre>","fields":{"slug":"/Object2/"},"frontmatter":{"title":"对象基本概念","tags":["JavaScript回顾"],"categories":"JavaScript"}}},{"node":{"html":"<h1>创建对象与原型</h1>\n<ul>\n<li>创建普通对象我们使用Object构造函数或者字面量，但是针对多个具有同样接口的对象我们再使用构造函数或者字面量会产生很多重复代码</li>\n<li>ECMAScript5.1并没有正式支持面向对象结构。ES6开始正式支持类和继承。但也仅仅是封装了ES5.1构造函数加原型继承语法糖</li>\n</ul>\n<h2>工厂模式</h2>\n<ul>\n<li>工厂模式就是抽象用于创建特定类型对象的过程，如下</li>\n</ul>\n<pre><code class=\"language-js\">function createPerson(name, age, job) {\n  let o = {\n    name,\n    age,\n    job,\n    sayName: function(){\n      console.log(this.name)\n    }\n  }\n  return o\n}\n\nlet person1 = createPerson('张三', 24, 'teacher')\nperson1.sayName() // 张三\nlet person2 = createPerson('李四', 24, 'doctor')\n</code></pre>\n<!--more-->\n<ul>\n<li>这就是一个简单工厂模式，帮我们简化了每一步赋值对象的过程</li>\n</ul>\n<h2>构造函数模式</h2>\n<ul>\n<li>我们可以自定义构造函数来为对象定义属性和方法</li>\n</ul>\n<pre><code class=\"language-js\">function Person(name, age, job) {\n  this.name = name\n  this.age = age\n  this.job = job\n  this.sayName = function(){\n    console.log(this.name)\n  }\n}\nlet person3 = new Person('张三', 24, 'teacher')\nperson3.sayName() // 张三\nlet person4 = new Person('李四', 24, 'doctor')\n\nconsole.log(person3.constructor === Person) // true\nconsole.log(person4.constructor === Person) // true\n</code></pre>\n<ul>\n<li>\n<p>这里我们看到其实就是讲属性和方法给了this，然后使用new关键字创建就可以了。其实这段语句内里的操作是：</p>\n<ul>\n<li>在内存中创建一个新对象</li>\n<li>将新对象的[[Prototype]]特性赋值为构造函数的prototype属性</li>\n<li>构造函数内部的this被赋值为这个新对象</li>\n<li>执行构造函数内部的代码（给新对象添加属性）</li>\n<li>如果构造函数返回非空对象，就返回该对象；否则返回刚创建的新对象</li>\n</ul>\n</li>\n<li>用该方式创建的实例都有一个constructor属性指向Person</li>\n<li>constructor本来是用于标识对象类型的。不过一般用instanceof来确定对象类型更加可靠。</li>\n</ul>\n<h3>构造函数创建的问题</h3>\n<ul>\n<li>定义的方法会在每个实例上都创建一遍，意味着两个实例都是对应的方法属性，而且不是同一个Function实例。</li>\n<li>我们的实例中的函数属性是做一样的事，所以没必要用两个Function实例。this对象可以吧函数与对象的绑定推迟到运行时</li>\n</ul>\n<pre><code class=\"language-js\">function Person(name, age, job){\n  this.name = name\n  this.age = age\n  this.job = job\n  this.sayName = sayName\n}\nfunction sayName(){\n  console.log(this.name)\n}\n</code></pre>\n<ul>\n<li>这样的实现就让所有的实例都共享了定义在外面的sayName函数。</li>\n<li>这样虽然解决了问题，但是污染了全局作用域，要是有多个方法属性就要在外面定义多个函数</li>\n</ul>\n<h2>原型模式</h2>\n<ul>\n<li>每个函数都会创建一个prototype属性，这个属性是一个对象，包含应该由特定引用类型的实例共享的属性与方法。</li>\n<li>这个对象就是通过调用构造函数创建的对象的原型。</li>\n<li>原型对象上定义的属性和方法可以被对象的实例共享。</li>\n</ul>\n<pre><code class=\"language-js\">function Person(){}\nPerson.prototype.name = '张三'\nPerson.prototype.age = 24\nPerson.prototype.sayName = function(){\n  console.log(this.name)\n}\n\nlet person1 = new Person()\nlet person2 = new Person()\nconsole.log(person1.sayName === person2.sayName) // true\n</code></pre>\n<ul>\n<li>使用这样的模式定义的属性与方法都由实例共享</li>\n</ul>\n<h2>原型</h2>\n<ul>\n<li>无论何时，只要创建函数，就会按照一定规则给函数创建一个prototype属性（指向原型对象）。默认情况下，所有原型对象获得一个名为constructor的属性，指回与之关联的构造函数</li>\n<li>然后就有了 Person.prototype.constructor === Person。</li>\n<li>在自定义构造函数时，原型对象默认只有constructor属性，其他的所有方法都继承自Object。</li>\n<li>每次调用构造函数都会创建一个新实例，这个实例内部[[Prototype]]会被赋值为构造函数的原型对象。脚本中没有标准的访问[[Prototype]]的犯法，但是一般浏览器会在对象上暴露<strong>proto</strong>属性来访问对象的原型。</li>\n<li>实例与构造函数原型有直接联系，但实例与构造函数之间没有，如下代码</li>\n</ul>\n<pre><code class=\"language-js\">function Person(){}\nconsole.log(typeof Person.prototype) // object\nconsole.log(Person.prototype) // \n// {\n//   constructor: ƒ Person()\n// __proto__: Object\n// }\n\nconsole.log(Person.prototype.constructor === Person) // true\n\n// 正常的原型链都会终止于Object的原型对象，Object的原型的原型是null\nconsole.log(Person.prototype.__proto__ === Object.prototype)   // true\nconsole.log(Person.prototype.__proto__.constructor === Object) // true\nconsole.log(Person.prototype.__proto__.__proto__ === null)     // true\nconsole.log(Person.prototype.__proto__)                        \n// {\n//   constructor: ƒ Object()\n// hasOwnProperty: ƒ hasOwnProperty()\n// isPrototypeOf: ƒ isPrototypeOf()\n// propertyIsEnumerable: ƒ propertyIsEnumerable()\n// toLocaleString: ƒ toLocaleString()\n// toString: ƒ toString()\n// valueOf: ƒ valueOf()\n// __defineGetter__: ƒ __defineGetter__()\n// __defineSetter__: ƒ __defineSetter__()\n// __lookupGetter__: ƒ __lookupGetter__()\n// __lookupSetter__: ƒ __lookupSetter__()\n// get __proto__: ƒ __proto__()\n// set __proto__: ƒ __proto__()\n// }\n\n// 实例与构造函数没有直接联系，与原型对象有直接联系\nlet person1 = new Person()\nconsole.log(person1.__proto__ === Person.prototype)  //true\nconsole.log(person1.__proto__.constructor === Person) // true\n</code></pre>\n<ul>\n<li>Person.prototype指向原型对象，而Person.prototype.constructor指回Person构造函数。</li>\n<li>虽然不是所有实现都暴露[[Prototype]]，但可以使用isPrototypeOf()确定两个对象之间的关系。本质上，isPrototypeOf()会在传入参数的[[Prototype]]指向调用它的对象时返回true</li>\n</ul>\n<pre><code class=\"language-js\">console.log(Person.prototype.isPrototypeOf(person1)) // true\n</code></pre>\n<ul>\n<li>ECMAScript的Object类型有一个方法Object.getPrototypeOf()，返回参数内部的特性[[Protptype]]的值</li>\n</ul>\n<pre><code class=\"language-js\">console.log(Object.getPrototypeOf(person1) === Person.prototype) // true\n</code></pre>\n<ul>\n<li>该方法可以方便的取得一个对象的原型</li>\n<li>Object还有一个setPrototypeOf()方法，可以向实例的私有属性[[Prototype]]写入一个新值。</li>\n</ul>\n<pre><code class=\"language-js\">let biped = {\n  numLegs: 2\n}\nlet person = {\n  name: 'Matt'\n}\nObject.setPrototypeOf(person, biped)\nconsole.log(person.name) // Matt\nconsole.log(person.numLegs) // 2\nconsole.log(Object.getPrototypeOf(person) === biped) // true\n</code></pre>\n<ul>\n<li>Object.setPrototypeOf()可能会严重影响代码性能。在所有的JavaScript引擎中，修改继承关系的影响都微妙而深远。这种影响不仅仅是执行Object.setPrototypeOf()语句那么简单，而是涉及所有修改过[[Prototype]]的对象的代码</li>\n<li>为避免使用Object.setPrototypeOf()导致的性能下降，可以使用Object.create()来创建对象，并指定原型</li>\n</ul>\n<pre><code class=\"language-js\">let biped = {\n  numLegs: 2\n}\nlet person = Object.create(biped)\nperson.name = 'Matt'\nconsole.log(person.numLegs) // 2\nconsole.log(person.name) // Matt\nconsole.log(Object.getPrototypeOf(person) === biped) // true\n</code></pre>\n<ul>\n<li>hasOwnProperty()用于确定某个属性存在于实例还是原型对象上。该方法继承自Object，会在属性存在于调用它的对象时返回true</li>\n<li>ECMAScript中的Object.getOwnPropertyDescriptor()只对实例属性有效。要取原型属性的描述符，就要在原型对象上调用Object.getOwnPropertyDescriptor()</li>\n</ul>\n<h3>原型和in操作符</h3>\n<ul>\n<li>in操作符有两种使用，一种是直接使用，一种配合for-in循环使用。</li>\n<li>单独使用时，in会在可以访问对象指定属性时返回true，无论该属性在实例上还是原型上</li>\n</ul>\n<pre><code class=\"language-js\">function Person(){}\nPerson.prototype.name = '张三'\nlet person = new Person()\nperson.age = 24\nconsole.log(\"name\" in person) // true\nconsole.log(\"age\" in person)  // true\n</code></pre>\n<ul>\n<li>in配合hasOwnProperty()可以实现判断某个属性是否在原型上</li>\n</ul>\n<pre><code class=\"language-js\">function hasPrototypeProperty(object, name){\n  return !object.hasOwnProperty(name) &#x26;&#x26; (name in object)\n}\n</code></pre>\n<ul>\n<li>在for-in使用in操作符可以通过对象访问可以被枚举的属性，包括实例属性和原型属性。屏蔽原型中不可枚举（[[Enumerable]]特性设置为false）也会在for-in循环中返回。因为默认情况下开发者定义的属性都是可枚举的</li>\n<li>可以通过Object.keys()获取对象上的所有可枚举的实例属性。不包含原型上的属性</li>\n<li>Object.getOwnPropertyNames()返回所有的实例属性，无论是否可以枚举。</li>\n<li>ES6新增符号类型后新增方法Object.getOwnPropertyNames()，因为以符号为键的属性没有名称概念。该方法与Object.getOwnPropertyNames()类似，只是针对符号而已</li>\n</ul>\n<h3>属性的枚举顺序</h3>\n<ul>\n<li>for-in与Object.keys()枚举顺序不确定，取决于JavaScript引擎</li>\n<li>Object.getOwnPropertyNames()、Object.getOwnPropertySymbols()和Object.assign()的枚举顺序是确定的，先以升序枚举数值键，然后以插入顺序枚举字符串和符号键</li>\n</ul>\n<pre><code class=\"language-js\">let k1 = Symbol('k1'), k2 = Symbol('k2')\nlet o = {\n  1: 1,\n  first: 'first',\n  [k1]:'sym1',\n  second: 'second',\n  0: 0\n}\no[k2] = 'sym2'\no[3] = 3\no.third = 'third'\no[2] = 2\nconsole.log(Object.getOwnPropertyNames(o))  //  [\"0\", \"1\", \"2\", \"3\", \"first\", \"second\", \"third\"]\nconsole.log(Object.getOwnPropertySymbols(o))  // [Symbol(k1), Symbol(k2)]\n</code></pre>\n<h3>对象迭代</h3>\n<ul>\n<li>ECMAScript2017新增了两个静态方法Object.values()、Object.entries()</li>\n<li>Object.values()返回对象值的数组，Object.entries()返回键/值的数组</li>\n</ul>\n<pre><code class=\"language-js\">const o = {\n  foo: 'bar',\n  baz: 1,\n  qux: {}\n}\nconsole.log(Object.entries(o)) //  [[\"foo\", \"bar\"],  [\"baz\", 1], [\"qux\", {…}]]\nconsole.log(Object.values(o)) //  [\"bar\", 1, {…}]\n</code></pre>\n<ul>\n<li>符号属性会被忽略</li>\n</ul>\n<pre><code class=\"language-js\">const sym = Symbol()\nconst o1 = {\n  [sym]: 'foo'\n}\nconsole.log(Object.entries(o1)) //  []\nconsole.log(Object.values(o1)) //  []\n</code></pre>\n<ul>\n<li>之前我们看到的原型上定义一个属性或方法都要把Person.prototype重写一遍，所以我们可以通过一个包含所有属性和方法的对象字面量重写原型</li>\n</ul>\n<pre><code class=\"language-js\">function Person(){}\nPerson.prototype = {\n  name: '张三',\n  age: 28,\n  sayName(){\n    console.log(this.name)\n  }\n}\n</code></pre>\n<ul>\n<li>这里Person.prototype被设置为跟前面一样的新对象，但是这样有一个问题，Person.prototype的constructor属性就指向Person了。</li>\n<li>之前创建函数时，也会创建它的prototype对象，并自动为这个原型的constructor属性赋值。</li>\n<li>字面量方式创建就完全重写了默认的prototype对象，因此其constructor属性也就指向了完全不同的新对象（Object构造函数），不再是原来的构造函数。</li>\n<li>虽然instanceof依然可以可靠地返回值，但是不能靠constructor属性来识别类型了</li>\n</ul>\n<pre><code class=\"language-js\">function Person(){}\nPerson.prototype = {\n  name: '张三',\n  age: 28,\n  sayName(){\n    console.log(this.name)\n  }\n}\nlet person2 = new Person()\nconsole.log(person2 instanceof Person) // true\nconsole.log(person2 instanceof Object) // true\nconsole.log(person2.constructor === Person) // false\nconsole.log(person2.constructor === Object) // true\n</code></pre>\n<ul>\n<li>如果还是决定要使用constructor，可以专门设置一下它的值</li>\n</ul>\n<pre><code class=\"language-js\">function Person(){}\nPerson.prototype = {\n  constructor: Person,\n  name: '张三',\n  age: 28,\n  sayName(){\n    console.log(this.name)\n  }\n}\n</code></pre>\n<ul>\n<li>但是要注意，这种方式恢复的constructor属性会创建一个[[Enumerable]]为true的属性。而原生的constructor属性默认不可枚举，所以需要使用Object.defineProperty来进行设置</li>\n</ul>","fields":{"slug":"/createObject/"},"frontmatter":{"title":"对象创建与原型","tags":["JavaScript回顾"],"categories":"JavaScript"}}},{"node":{"html":"<h1>类</h1>\n<ul>\n<li>ECMAScript 6 引入了class关键字来实现正式定义类的能力</li>\n<li>类定义也是两种方法：声明类与类表达式</li>\n</ul>\n<pre><code class=\"language-js\">// 类声明\nclass Person {}\n\n// 类表达式\nconst Person = class {}\n</code></pre>\n<ul>\n<li>类定义不可变量提升，声明前不可使用</li>\n<li>函数受函数作用域限制，类受块作用域限制</li>\n<li>\n<p>类可以包含构造函数方法、实例方法、获取函数、设置函数与静态类方法</p>\n<!--more-->\n<h2>构造函数</h2>\n</li>\n<li>构造函数非必须，不定义则默认为空</li>\n<li>默认情况下，构造函数会在执行后返回this对象。构造函数返回的对象会被用作实例化对象，如果没有引用新创建的this对象，则对象会被销毁</li>\n<li>如果返回的不是this对象，而是其他对象，那么这个对象不回通过instanceof操作符检测出与类有关联，因为对象的原型指针没有被修改</li>\n</ul>\n<pre><code class=\"language-js\">class Person{\n  constructor(override){\n    this.foo = 'foo'\n    if(override) {\n      return { bar: 'bar' }\n    }\n  }\n}\n\nlet p1 = new Person()\nlet p2 = new Person(true)\nconsole.log(p1) // Person {foo: \"foo\"}\nconsole.log(p1 instanceof Person) // true\n\nconsole.log(p2) // {bar: \"bar\"}\nconsole.log(p2 instanceof Person) // false\n</code></pre>\n<ul>\n<li>类中定义的constructor不会被当做构造函数，对它使用instanceof会返回false</li>\n</ul>\n<pre><code class=\"language-js\">class Person{\n  constructor(){\n    this.foo = 'foo'\n  }\n}\n\nlet p1 = new Person()\nconsole.log(p1 instanceof Person) // true\nconsole.log(p1 instanceof Person.constructor) // false\n</code></pre>\n<ul>\n<li>类也可以立即被实例化</li>\n</ul>\n<pre><code class=\"language-js\">let p = new class Foo{\n  constructor(x){\n    console.log(x)\n  }\n}('foo') // 'foo'\n</code></pre>\n<h2>实例、原型和类成员</h2>\n<ul>\n<li>定义在构造函数内的属性为实例属性，实例独享</li>\n<li>定义在类块中的方法为原型方法，所有实例共享，可以在类块中定义方法，但不能定义属性</li>\n</ul>\n<pre><code class=\"language-js\">class Person {\n  name: 'Jack' // Uncaught SyntaxError: Unexpected token\n}\n</code></pre>\n<ul>\n<li>类上定义静态方法，一般用于执行不特定于市里的操作，不要求存在类的实例，使用static修饰</li>\n</ul>\n<h2>super</h2>\n<ul>\n<li>派生类可以通过super关键字引用他们的原型。只能在派生类中使用，而且仅限于类构造函数、实例方法、静态方法内部。</li>\n<li>构造函数中使用super可以调用父类构造函数（这种情况下super之前不允许出现this）</li>\n<li>ES6给类构造函数与静态方法添加了内部特征[[HomeObject]]，是一个指针，指向定义该方法的对象。只能在javascript引擎内部访问。</li>\n<li>super始终会定义为[[HomeObject]]的原型</li>\n<li>super不可单独使用，要么用它调用构造函数，要么引用静态方法</li>\n</ul>\n<pre><code class=\"language-js\">class Vehicle {\n\n}\nclass Bus extends Vehicle{\n  constructor(){\n    console.log(super)  // SyntaxError: 'super' keyword unexpected here\n  }\n}\n</code></pre>\n<ul>\n<li>调用super会调用父类构造函数，并将返回的实例赋值给this</li>\n<li>如果没有定义类构造函数，实例化派生类时会调用super，并传入所有给派生类的参数</li>\n<li>如果派生类定义了构造函数，那么要么在其中调用super，要么必须在其中返回一个对象</li>\n</ul>\n<h2>抽象基类</h2>\n<ul>\n<li>基类就是可供继承但不可被实例化的类，ECMAScript没有单独实现，但是可以使用new.target来实现，new.target保存了通过new调用的类或者函数。所以可以如下实现</li>\n</ul>\n<pre><code class=\"language-js\">class Vehicle {\n  constructor(){\n    if(new.target === Vehicle) {\n      throw new Error('Vehicle cannot be directly instantiated')\n    }\n  }\n}\nnew Vehicle() // Error: Vehicle cannot be directly instantiated\n</code></pre>\n<h2>类混入</h2>\n<ul>\n<li>将不同类集中到一个类中</li>\n</ul>\n<pre><code class=\"language-js\">class Vehicle {}\nlet FooMixin = (Superclass) => class extends Superclass {\n    foo() {\n      console.log('foo')\n    }\n  }\n\n  let BarMixin = (Superclass) => class extends Superclass {\n    bar() {\n      console.log('bar')\n    }\n  }\n\n  let BazMixin = (Superclass) => class extends Superclass {\n    baz() {\n      console.log('baz')\n    }\n  }\n\n  class Bus extends FooMixin(BarMixin(BazMixin(Vehicle))) {}\n  let b = new Bus()\n  b.foo()  // 'foo'\n  b.bar()  // 'bar'\n  b.baz()  // 'baz'\n</code></pre>\n<ul>\n<li>很多javascript已经放弃混入模式，转为组合模式，也就是著名的“组合胜过继承”</li>\n</ul>","fields":{"slug":"/class2/"},"frontmatter":{"title":"类--高程4","tags":["JavaScript回顾"],"categories":"JavaScript"}}},{"node":{"html":"<h1>JS中的继承-（高程4）</h1>\n<h2>原型链继承</h2>\n<ul>\n<li>基本思想为：每个构造函数都有一个原型对象，原型有一个属性指回构造函数，实例有一个内部指针指向原型。</li>\n<li>如果一个原型是另一个原型的实例，就是说这个原型内部有一个内部指针指向另一个原型，相应的另一个原型也有一个指针指向另一个构造函数。</li>\n<li>\n<p>这样就在原型和实例间构造了原型链</p>\n<!--more-->\n<pre><code class=\"language-js\">function SuperType(){\nthis.property = true\n}\n</code></pre>\n</li>\n</ul>\n<p>SuperType.prototype.getSuperValue = function(){\nconsole.log(333)\nreturn this.property\n}</p>\n<p>function SubType (){\nthis.subproperty = false\n}</p>\n<p>SubType.prototype = new SuperType()</p>\n<p>SubType.prototype.getSubValue = function(){\nreturn this.subproperty\n}</p>\n<p>var instance = new SubType()\nconsole.log(instance.getSuperValue()) // true</p>\n<pre><code>- 这里SubType没有用默认的原型对象，用了SuperType的实例。这样SubType与SuperType就挂上了构，所以instance内部的[[Prototype]]指向了SubType.prototype，而SubType.prototype内部的[[Prototype]]指向了SuperType.prototype。这样就通过原型链查找实现了继承\n- 因为SubType.prototype的constructor属性被重写为指向了SuperType，所以instance.constructor也指向了SuperType\n- isPrototypeOf方法，用于判断一个原型是否在手里的原型链上，每个原型都可以调用，只要在原型链就返回true\n\n```js\nconsole.log(Object.prototype.isPrototypeOf(instance)) // true\n</code></pre>\n<h3>原型继承现存问题</h3>\n<ul>\n<li>原型包含引用值时，会在所有实例共享</li>\n<li>子类型在实例化时无法给父类型的构造函数传参</li>\n</ul>\n<h2>经典继承或对象伪装</h2>\n<ul>\n<li>基本思路：在子类的构造函数中调用父类的构造函数。然后使用call或者apply方法以新创建的对象作为上下文执行构造函数</li>\n</ul>\n<pre><code class=\"language-js\">function SuperType (){\n  this.colors = ['red', 'blue']\n}\nfunction SubType(){\n  // 继承实现\n  SuperType.call(this)\n}\n\nlet instance1 = new SubType()\ninstance1.colors.push('black')\nconsole.log(instance1.colors) // ['red', 'blue', 'black']\nlet instance2 = new SubType()\nconsole.log(instance2.colors) // ['red', 'blue']\n</code></pre>\n<ul>\n<li>盗用构造函数还可以向父类构造函数传递参数</li>\n</ul>\n<pre><code class=\"language-js\">function SuperType (name){\n  this.name = name\n  this.age = 28\n}\nfunction SubType(name){\n  // 继承实现\n  SuperType.call(this, name)\n}\n\nlet instance1 = new SubType('张三')\nconsole.log(instance1.name) // '张三'\nlet instance2 = new SubType('李四')\nconsole.log(instance2.name) // '李四'\n</code></pre>\n<h3>经典继承现存问题</h3>\n<ul>\n<li>必须在构造函数中定义方法，函数无法重用</li>\n<li>子类型无法访问父类原型上的方法，所有类型都只能用构造函数模式</li>\n</ul>\n<h2>组合继承（伪经典继承）</h2>\n<ul>\n<li>将原型链与盗用构造函数结合起来，使用原型链继承原型上的属性和方法，通过盗用构造函数继承实例属性。</li>\n</ul>\n<pre><code class=\"language-js\">function SuperType (name){\n  this.name = name\n  this.colors = ['red', 'blue']\n}\nSuperType.prototype.sayName = function(){\n  return this.name\n}\n\nfunction SubType(name, age){\n  SuperType.call(this, name)\n  this.age = age\n}\nSubType.prototype = new SuperType()\nSubType.prototype.constructor = SubType\nSubType.prototype.sayAge = function(){\n  return this.age\n}\n\nlet instance1 = new SubType('张三', 27)\ninstance1.colors.push('black')\ninstance1.sayName() // '张三'\nconsole.log(instance1.colors) // ['red', 'blue', 'black']\ninstance1.sayAge() // 27\n\n\n\nlet instance2 = new SubType('李四', 28)\ninstance2.sayName() // '李四'\nconsole.log(instance2.colors) // ['red', 'blue']\ninstance2.sayAge() // 28\n</code></pre>\n<ul>\n<li>组合继承弥补了原型继承与盗用构造函数的不足，是javascript中使用最多的继承，而且也保留了instanceof与isPrototypeOf的识别能力</li>\n</ul>\n<h3>组合式继承问题</h3>\n<ul>\n<li>组合继承存在效率问题，主要问题便是父元素构造函数会被调用两次，一次是创建子类型时调用，另一次是子类构造函数中使用。</li>\n</ul>\n<h2>原型式继承</h2>\n<ul>\n<li>原型式继承是不自定义类型也能通过原型实现对象之间的信息共享，原理就一个函数</li>\n</ul>\n<pre><code class=\"language-js\">function object(o) {\n  function F(){}\n  F.prototype = o\n  return new F()\n}\n</code></pre>\n<ul>\n<li>创建一个临时的构造函数，原型指向传入的对象，然后再返回这个临时类型的实例</li>\n</ul>\n<pre><code class=\"language-js\">function object(o) {\n  function F(){}\n  F.prototype = o\n  return new F()\n}\nlet person = {\n  name: 'Nick',\n  friends: ['Shel', 'Court']\n}\n\nlet anotherPerson = object(person)\nanotherPerson.name = 'Greg'\nanotherPerson.friends.push('Rob')\n\nlet yetAnotherPerson = object(person)\nyetAnotherPerson.name = 'Linda'\nyetAnotherPerson.friends.push('Barieb')\n\nconsole.log(person.friends) // [\"Shel\", \"Court\", \"Rob\", \"Barieb\"]\n</code></pre>\n<ul>\n<li>这里的原型式继承适用于：你有一个对象，在现有基础上创建一个新对象。</li>\n<li>ECMAScript 5 增加了Object.create()来将原型式继承规范化了。接收两个参数：作为新对象原型的对象，给新对象定义额外属性的对象。</li>\n</ul>\n<pre><code class=\"language-js\">let person = {\n  name: 'Nick',\n  friends: ['Shel', 'Court']\n}\n\nlet anotherPerson = Object.create(person)\nanotherPerson.name = 'Greg'\nanotherPerson.friends.push('Rob')\n\nlet yetAnotherPerson = Object.create(person)\nyetAnotherPerson.name = 'Linda'\nyetAnotherPerson.friends.push('Barieb')\n\nconsole.log(person.friends) // [\"Shel\", \"Court\", \"Rob\", \"Barieb\"]\n\nlet morePerson = Object.create(person, { name: { value: 'Francis' } })\nmorePerson.name // Francis\n</code></pre>\n<ul>\n<li>这里Object.create方法第二个参数跟Object.defineProperties方法第二个参数一样，都需要通过各自的描述符来描述。</li>\n</ul>\n<h2>寄生式继承</h2>\n<ul>\n<li>寄生式继承的原理：创建一个实现继承的函数，以某种方式增强对象，然后返回对象</li>\n</ul>\n<pre><code class=\"language-js\">function object(o){\n  function F(){}\n  F.prototype = o\n  return new F()\n}\n\nfunction createAnother(original) {\n  let clone = object(original)\n  clone.sayHi = function(){\n    console.log('Hi')\n  }\n  return clone\n}\n\n\nlet person = {\n  name: 'Nick',\n  friends: ['Shel', 'Court']\n}\nlet another = createAnother(person)\nanother.sayHi() // 'Hi'\n</code></pre>\n<h3>问题</h3>\n<ul>\n<li>通过寄生式继承给对象添加函数难以复用，与构造函数模式类似</li>\n</ul>\n<h2>寄生式组合继承</h2>\n<ul>\n<li>前面说到组合继承存在效率问题，本质上子类原型只需要包含超类对象的所有实例属性，子函数在执行时重写自己的原型就可以了</li>\n</ul>\n<pre><code class=\"language-js\">function SuperType (name){\n  this.name = name\n  this.colors = ['red', 'blue']\n}\nSuperType.prototype.sayName = function(){\n  return this.name\n}\n\nfunction SubType(name, age){\n  // 第二次调用\n  SuperType.call(this, name)\n  this.age = age\n}\nSubType.prototype = new SuperType() // 第一次调用\nSubType.prototype.constructor = SubType\nSubType.prototype.sayAge = function(){\n  return this.age\n}\n\nlet instance1 = new SubType('张三', 27)\n</code></pre>\n<ul>\n<li>寄生式组合继承通过盗用构造函数继承属性，但是使用混合式原型链集成方法。</li>\n<li>基本思路就是不通过调用父类构造函数给子类原型赋值，而是取得父元素原型的一个副本。</li>\n<li>就是使用寄生式继承继承父类原型，然后将获取到的新对象赋值给子类原型。</li>\n</ul>\n<pre><code class=\"language-js\">function object(o) {\n  function F(){}\n  F.prototype = o\n  return new F()\n}\nfunction inheritPrototype(subType, superType) {\n  let prototype = object(superType)\n  // 解决由于原型重写导致的默认constructor丢失问题\n  prototype.constructor = subType\n  subType.prototype = prototype\n}\n\nfunction SuperType (name){\n  this.name = name\n  this.colors = ['red', 'blue']\n}\nSuperType.prototype.sayName = function(){\n  return this.name\n}\n\nfunction SubType(name, age){\n  SuperType.call(this, name)\n  this.age = age\n}\ninheritPrototype(SubType, SuperType)\nSubType.prototype.sayAge = function(){\n  return this.age\n}\n</code></pre>\n<ul>\n<li>这里只调用了一次SuperType的构造函数，避免了SubType上用不到的属性，所以效率更高。</li>\n<li>而且原型链也保持不变，可以说是引用类型继承的最佳模式</li>\n</ul>","fields":{"slug":"/extend2/"},"frontmatter":{"title":"继承--高程4","tags":["JavaScript回顾"],"categories":"JavaScript"}}},{"node":{"html":"<h1>代理</h1>\n<ul>\n<li>ECMAScript 6新增了代理与反射为开发者提供了拦截并向基本操作嵌入额外行为的能力</li>\n<li>就是可以给目标对象定义一个关联的代理对象，代理对象可以作为抽象的目标对象来使用，在对目标对象实行的各种操作影响目标对象之前，都可以在代理对象中对这些操作加以控制</li>\n<li>代理是新的基础性语言能力，所以转移程序无法将其转为之前的ECMAScript代码，因为代理是无可替代的，所以在使用前要检测平台是否支持</li>\n</ul>\n<h2>代理基础</h2>\n<ul>\n<li>\n<p>代理使用Proxy构造函数来创建，接收两个参数： 目标对象和处理程序对象，缺少任何一个参数都会报错，创建一个空代理只需要将对象字面量作为处理程序传递即可，如下</p>\n<!--more-->\n<pre><code class=\"language-js\">const target = {\nid: 'target'\n}\nconst handler = {}\nconst proxy = new Proxy(target, handler)\nconsole.log(target.id) // target\nconsole.log(proxy.id)   // target \n</code></pre>\n</li>\n</ul>\n<p>target.id = 'foo'\nconsole.log(target.id) // foo\nconsole.log(proxy.id)  // foo</p>\n<p>proxy.id = 'bar'\nconsole.log(target.id) // bar\nconsole.log(proxy.id)  // bar</p>\n<p>console.log(target.hasOwnProperty('id')) // true\nconsole.log(proxy.hasOwnProperty('id'))  // true</p>\n<p>console.log(target instanceof Proxy) // Uncaught TypeError: Function has non-object prototype 'undefined' in instanceof check\nconsole.log(proxy instanceof Proxy)  // Uncaught TypeError: Function has non-object prototype 'undefined' in instanceof check</p>\n<p>console.log(target === proxy) // false</p>\n<pre><code>- 这里属性会访问同一个值，对目标属性赋值会反映在两个对象，因为它们访问的是一个值\n- 对代理赋值会反应在两个对象，因为赋值会转移到目标对象\n- hasOwnProperty()在两个地方都会应用到目标对象\n- Proxy.prototype是undefined，所以不能使用instanceof\n- 目标跟代理对象不是严格相等\n\n## 定义捕获器\n\n- 捕获器就是处理程序对象中定义的“基本操作的拦截器”。每个处理程序对象可以包含任意个捕获器，每个捕获器都对应一个基本操作，可以直接或间接在代理对象上调用。\n- 每次在代理上调用这些基本操作，代理都可以在这些操作到达目标对象前调用捕捉器函数，从而拦截并修改相应的行为\n- 如下就是定义了一个get()捕捉器\n\n```js\nconst target = {\n  foo: 'bar'\n}\nconst handler = {\n  get () {\n    return 'handler override'\n  }\n}\n\nconst proxy = new Proxy(target, handler)\nconsole.log(target.foo) // bar\nconsole.log(proxy.foo)  // handler override\n</code></pre>\n<ul>\n<li>当通过代理对象触发get操作时就会触发定义的get()捕获器，get()方法不是ECMAScript对象可以调用的方法，而是通过其他形式触发被捕获的</li>\n<li>proxy[property]、proxy.property 或者 Object.create(proxy)[property]等操作都会触发get()方法</li>\n<li>在目标对象上执行这些操作仍然是正常的行为</li>\n</ul>\n<h2>捕获器参数与反射API</h2>\n<ul>\n<li>捕获器都可以访问相应的参数，基于这些参数可以重建被捕获方法的原始行为。例如get()捕获器可以收到目标对象、要查询的属性和代理对象三个参数</li>\n</ul>\n<pre><code class=\"language-js\">const target = {\n  foo: 'bar'\n}\nconst handler = {\n  get (tarpTarget, property, receiver) {\n    console.log(tarpTarget === target)  // true\n    console.log(property)  // 'foo'\n    console.log(receiver === proxy) // true\n  }\n}\n\nconst proxy = new Proxy(target, handler)\nproxy.foo\n</code></pre>\n<ul>\n<li>有了这些参数我们就可以重建被捕获方法的原始行为</li>\n</ul>\n<pre><code class=\"language-js\">const target = {\n  foo: 'bar'\n}\nconst handler = {\n  get (tarpTarget, property, receiver) {\n    return tarpTarget[property]\n  }\n}\n\nconst proxy = new Proxy(target, handler)\nconsole.log(target.foo) // bar\nconsole.log(proxy.foo)  // bar\n</code></pre>\n<ul>\n<li>所有的捕获器都可以基于自己的参数重建原始操作，但是有些原始操作很复杂，手写太麻烦，所以我们可以调用全局Reflect（封装了原始行为）对象上的同名方法来重建</li>\n<li>处理程序对象中的所有可以捕获的方法都由对应的反射（Reflect）API方法。这些方法与捕获器拦截的方法有相同的名称和函数签名，与被拦截方法有相同的行为，所以可以使用如下方式定义</li>\n</ul>\n<pre><code class=\"language-js\">const target = {\n  foo: 'bar'\n}\nconst handler = {\n  get () {\n    return Reflect.get(...arguments)\n  }\n}\n\nconst proxy = new Proxy(target, handler)\nconsole.log(target.foo) // bar\nconsole.log(proxy.foo)  // bar\n\n// 或者\nconst target = {\n  foo: 'bar'\n}\nconst handler = {\n  get: Reflect.get\n}\n\nconst proxy = new Proxy(target, handler)\nconsole.log(target.foo) // bar\nconsole.log(proxy.foo)  // bar\n</code></pre>\n<ul>\n<li>如果只是想捕获所有方法，然后转发给对应的反射API的空代理，都不需要定义处理程序对象</li>\n</ul>\n<pre><code class=\"language-js\">const target = {\n  foo: 'bar'\n}\n\nconst proxy = new Proxy(target, Reflect)\nconsole.log(target.foo) // bar\nconsole.log(proxy.foo)  // bar\n\nconst target = {\n  foo: 'bar',\n  bar: 'baz'\n}\nconst handler = {\n  get(tarpTarget, property, receiver) {\n    let decoration = ''\n    if(property === 'foo') {\n      decoration = '!!!'\n    }\n    return Reflect.get(...arguments) + decoration\n  }\n}\n\nconst proxy = new Proxy(target, handler)\nconsole.log(proxy.foo) // bar!!!\nconsole.log(proxy.bar)  // baz\n</code></pre>\n<ul>\n<li>捕获器可以改变几乎所有的基本方法，但是有限制，每个捕获的方法都知道目标对象上下文、捕获函数签名，捕获函数处理程序的行为必须遵循“捕获器不变式”</li>\n<li>比如目标对象有一个不可配置不可写的数据属性，那么捕获器返回一个与该属性不同的值会报错</li>\n</ul>\n<pre><code class=\"language-js\">const target = {}\nObject.defineProperty(target, 'foo', {\n  configurable: false,\n  wirtable: false,\n  value: 'bar'\n})\nconst handler = {\n  get(){\n    return 'qux'\n  }\n}\nconst proxy = new Proxy(target, handler)\nconsole.log(proxy.foo) // Uncaught TypeError: 'get' on proxy: property 'foo' is a read-only and non-configurable data property on the proxy target but the proxy did not return its actual value (expected 'bar' but got 'qux')\n</code></pre>\n<h3>可撤销代理</h3>\n<ul>\n<li>对使用new Proxy创建的代理会在代理对象的生命周期中一直存在，有时候我们需要终端代理对象与目标对象的联系，这个时候就要用到Proxy暴露的revocable()方法</li>\n<li>这个方法支持撤销目标对象跟对象的关联，是不可逆的，调用多次结果都是一样，撤销之后在调用代理会抛错</li>\n</ul>\n<pre><code class=\"language-js\">const target = {\n  foo: 'bar'\n}\nconst handler = {\n  get () {\n    return \"interceped\"\n  }\n}\n\nconst { proxy, revoke } = Proxy.revocable(target, handler)\nconsole.log(proxy.foo)  // interceped\n\nrevoke()\nconsole.log(proxy.foo) // Uncaught TypeError: Cannot perform 'get' on a proxy that has been revoked\n</code></pre>\n<ul>\n<li>特定情况下应该优先使用反射API，理由如下</li>\n<li>反射API不限于捕捉处理程序</li>\n<li>大多数反射API方法在Object类型上有对应的方法</li>\n<li>通常Object上的方法是用于通用程序，而反射方法适用于细粒度的对象控制</li>\n<li>很多反射方法会返回“状态标记”的布尔值，表示该操作是否成功，很多时候，状态标记比返回修改后的对象或错误更有用，看以下对比</li>\n</ul>\n<pre><code class=\"language-js\">const o = {}\ntry {\n  Object.defineProperty(o, 'foo', 'bar')\n  console.log('success')\n} catch(e){\n  console.log('failuer')\n}\n\n// 重构后\nconst o = {}\nif(Reflect.defineProperty(o, 'foo', { value: 'bar' })) {\n  console.log('success')\n} else {\n  console.log('failure')\n}\n</code></pre>\n<ul>\n<li>\n<p>以下方法会提供状态标记</p>\n<ul>\n<li>Reflect.defineProperty()</li>\n<li>Reflect.preventExtensions()</li>\n<li>Reflect.setPrototypeOf()</li>\n<li>Relfect.set()</li>\n<li>Relfect.deleteProperty()</li>\n</ul>\n</li>\n<li>\n<p>用一等函数替代操作符，以下反射方法只有通过操作符才可以完成</p>\n<ul>\n<li>Reflect.get(): 可以替代对象属性访问操作符</li>\n<li>Reflect.set(): 可以替代=赋值操作符</li>\n<li>Reflect.has(): 可以替代in操作符</li>\n<li>Reflect.deleteProperty(): 可以替代delete操作符</li>\n<li>Reflect.construct(): 可以替代new操作符</li>\n</ul>\n</li>\n<li>\n<p>安全的使用函数</p>\n<ul>\n<li>通过apply方法调用函数时，被调用函数可能定义了自己的apply属性。为了绕过这个问题，可以使用定义在Function原型上的apply方法</li>\n<li>但是调用Function原型上的方法会很难读，所以可以使用Reflect.apply来替代</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"language-js\">Function.prototype.apply.call(muFunc, thisVal, argumentList)\n\n// 用Reflect.apply替代\nReflect.apply(myFunc, thisVal, argumentList)\n</code></pre>\n<ul>\n<li>代理另一个代理，代理可以拦截反射API的操作，所以我们可以创建一个代理，利用它去代理另一个代理，就构建了多层拦截网</li>\n</ul>\n<pre><code class=\"language-js\">const target = {\n  foo: 'bar'\n}\nconst firstProxy = new Proxy(target, {\n  get() {\n    console.log('first proxy')\n    return Reflect.get(...arguments)\n  }\n})\n\nconst secondProxy = new Proxy(firstProxy, {\n  get() {\n    console.log('seond proxy')\n    return Reflect.get(...arguments)\n  }\n})\nconsole.log(secondProxy.foo)\n\n// seond proxy\n// first proxy\n// bar\n</code></pre>\n<h2>代理的问题与不足</h2>\n<ul>\n<li>代理中的this，方法中的this通常指向调用这个方法的对象，如果目标依赖于对象表示，可能会出问题，如下用WeakMap报错私有变量的例子，简化版</li>\n</ul>\n<pre><code class=\"language-js\">const wm = new WeakMap()\n\nclass User{\n  constructor(userid){\n    wm.set(this, userid)\n  }\n  set id(userid){\n    wm.set(this, userid)\n  }\n  get id(userid) {\n    return wm.get(this)\n  }\n}\n\nconst user = new User(123)\nconsole.log(user.id)  // 123\n\nconst userInstanceProxy = new Proxy(user, {})\nconsole.log(userInstanceProxy.id) // undefined\n</code></pre>\n<ul>\n<li>这里User实例使用目标对象作为WeakMap的键，但是代理对象却从自身取这个实例，所以就出问题了</li>\n<li>解决问题就是将代理User实例改为代理User类本身，之后在创建代理实例就会以代理实例作为WeakMap的值了</li>\n</ul>\n<pre><code class=\"language-js\">const UserClassProxy = new Proxy(User, {})\nconst proxyUser = new UserClassProxy(456)\nconsole.log(proxyUser.id)\n</code></pre>\n<ul>\n<li>代理与内置类型（如Array）的实例可以很好地协作，但有些ECMAScript内置类型可能会导致代理某些方法出错，比如Date类型</li>\n<li>Date类型依赖this值上的[[NumberDate]]槽位，这个槽位无法通过get()跟set()方法访问到，所以代理拦截后转发给目标对象的方法会报错</li>\n</ul>\n<pre><code class=\"language-js\">const target = new Date()\nconst proxy = new Proxy(target, {})\nconsole.log(proxy instanceof Date) // true\nproxy.getDate() // Uncaught TypeError: this is not a Date object.\n</code></pre>\n<h2>代理捕获器与反射方法</h2>\n<ul>\n<li>代理可以捕获13中不同的基本操作。这些操作有各自不同的反射API方法、参数、关联的ECMAScript方法与不变式</li>\n<li>不同的JavsScript操作可以出发同一个捕获器处理。但是对于在代理对象上的任何操作，都只会有一个捕获处理程序被调用，不存在重复捕获的情况</li>\n</ul>\n<h3>get()</h3>\n<ul>\n<li>get()捕获器会在获取属性值的操作被调用，对应的反射API为Reflect.get()</li>\n<li>返回值无限制</li>\n<li>\n<p>拦截的操作： </p>\n<ul>\n<li>proxy.property</li>\n<li>proxy[property]</li>\n<li>Object.create(proxy)[Property]</li>\n<li>Reflect.get(proxy, property, receiver)</li>\n</ul>\n</li>\n<li>\n<p>捕获器处理程序参数</p>\n<ul>\n<li>target: 目标对象</li>\n<li>property: 引用目标对象上的字符串属性（也有可能是符号键）</li>\n<li>receiver: 代理对象或继承代理对象的对象</li>\n</ul>\n</li>\n<li>\n<p>捕获器不定式</p>\n<ul>\n<li>如果target.property不可写切不可配置，则返回的值必须跟target.property一致</li>\n<li>如果target.property不可写且[[Get]]特性为undefined，处理程序的返回值也必须是undefined</li>\n</ul>\n</li>\n</ul>\n<h3>set()</h3>\n<ul>\n<li>set()会在设置属性值的操作中被调用，对应的反射API为Reflect.set()</li>\n<li>返回值为true表示成功；为false表示失败，严格模式下抛错</li>\n<li>\n<p>拦截的操作</p>\n<ul>\n<li>proxy.property = value</li>\n<li>proxy[property] = value</li>\n<li>Object.create(proxy)[property] = value</li>\n<li>Reflect.set(proxy, property, value, receiver)</li>\n</ul>\n</li>\n<li>\n<p>捕获器处理程序参数</p>\n<ul>\n<li>target: 目标对象</li>\n<li>property: 引用目标对象的字符串健属性</li>\n<li>value: 要赋给属性的值</li>\n<li>receiver: 接收最初赋值的对象</li>\n</ul>\n</li>\n<li>\n<p>捕获器不定式</p>\n<ul>\n<li>如果target.property不可写且不可配置，则不能修改目标属性的值</li>\n<li>如果target.property不可配置且[[Set]]特性为undefined，则不可修改目标属性的值</li>\n<li>严格模式下，处理程序返回false会报错</li>\n</ul>\n</li>\n</ul>\n<h3>has()</h3>\n<ul>\n<li>has()捕获器在in操作符中被调用，对应的反射API为Reflect.has()</li>\n<li>返回值必须式布尔值，表示属性是否存在。非布尔值会被转为布尔值</li>\n<li>\n<p>拦截的操作</p>\n<ul>\n<li>property in proxy</li>\n<li>property in Object.create(proxy)</li>\n<li>with(proxy){(property)}</li>\n<li>Reflect.has(proxy, property)</li>\n</ul>\n</li>\n<li>\n<p>捕获器处理程序参数</p>\n<ul>\n<li>target: 目标对象</li>\n<li>property: 引用的目标对象上的字符串键属性</li>\n</ul>\n</li>\n<li>\n<p>捕获器不定式</p>\n<ul>\n<li>如果target.property存在且不可配置，则处理程序必须返回true</li>\n<li>如果target.property存在目标且目标对象不可拓展，则处理程序必须返回true</li>\n</ul>\n</li>\n</ul>\n<h3>defineProperty</h3>\n<ul>\n<li>defineProperty()捕获器会在Object.defineProperty()中被调用，对应的反射API为Reflect.defineProperty()</li>\n<li>返回值必须为布尔值，表示属性是否定义成功。返回非布尔值会被转为布尔值</li>\n<li>\n<p>拦截的操作</p>\n<ul>\n<li>Object.defineProperty(proxy, property, descriptor)</li>\n<li>Reflect.defineProperty(proxy, property, descriptor)</li>\n</ul>\n</li>\n<li>\n<p>捕获器处理程序参数</p>\n<ul>\n<li>target: 目标对象</li>\n<li>property: 引用目标对象上的字符串键属性</li>\n<li>descriptor: 包含可选的enumerable、configuable、writable、value、get、set定义的对象</li>\n</ul>\n</li>\n<li>\n<p>捕获器不定式</p>\n<ul>\n<li>如果目标对象不可拓展，则无法定义属性</li>\n<li>如果目标对象有一个可配置的属性，则不能添加同名的不可配置的属性</li>\n<li>如果目标对象有一个不可配置的属性，则不能添加同名的可配置属性</li>\n</ul>\n</li>\n</ul>\n<h3>getOwnPropertyDescriptor()</h3>\n<ul>\n<li>getOwnPropertyDescriptor()捕获器会在Object.getOwnPropertyDescriptor中被调用，对应的反射API为Reflect.getOwnPropertyDescriptor</li>\n<li>返回值必须返回对象，如果在属性不存在时返回undefined</li>\n<li>\n<p>拦截的操作</p>\n<ul>\n<li>Object.getOwnPropertyDescriptor(proxy, property)</li>\n<li>Reflect.getOwnPropertyDescriptor(proxy, property)</li>\n</ul>\n</li>\n<li>\n<p>捕获器处理程序参数</p>\n<ul>\n<li>target: 目标对象</li>\n<li>property: 引用的目标对象上的字符串键值</li>\n</ul>\n</li>\n<li>\n<p>捕获器不变式</p>\n<ul>\n<li>如果自有的target.property存在且不可配置，则处理程序必须返回一个表示该属性存在的对象</li>\n<li>如果自有的target.property存在且target可拓展，则处理程序必须返回一个表示该属性可配置的对象</li>\n<li>如果自有的target.property存在且target不可拓展，则处理程序必须返回一个表示该属性存在的对象</li>\n<li>如果自有的target.property不存在且target不可拓展，则处理程序必须返回undefined表示该属性不存在</li>\n<li>如果target.property不存在，则处理程序不能返回表示该属性可配置的对象</li>\n</ul>\n</li>\n</ul>\n<h3>deleteProperty</h3>\n<ul>\n<li>deleteProperty会在delete操作符中被调用，对应的反射API为Reflect.deleteProperty()</li>\n<li>返回值必须为布尔值，表示删除属性是否成功。返回非布尔值会被转为布尔值</li>\n<li>\n<p>拦截的操作</p>\n<ul>\n<li>delete proxy.property</li>\n<li>delete proxy[property]</li>\n<li>Reflect.deleteProperty(proxy, property)</li>\n</ul>\n</li>\n<li>\n<p>捕获器处理程序参数</p>\n<ul>\n<li>target: 目标对象</li>\n<li>property: 引用的目标对象上的字符串键值</li>\n</ul>\n</li>\n<li>\n<p>捕获器不变式</p>\n<ul>\n<li>如果自有的target.property存在且不可配置，则处理程序不能删除这个属性</li>\n</ul>\n</li>\n</ul>\n<h3>ownKeys</h3>\n<ul>\n<li>ownKeys会在Object.keys()及类似方法中被调用，对应的反射API为Reflect.ownKeys()</li>\n<li>返回值必须返回包含字符串或符号的可枚举对象</li>\n<li>\n<p>拦截的操作</p>\n<ul>\n<li>Object.getOwnPropertyNames(proxy)</li>\n<li>Object.getOwnPropertySymbols(proxy)</li>\n<li>Object.keys()</li>\n<li>Reflect.ownKeys(proxy)</li>\n</ul>\n</li>\n<li>\n<p>捕获器处理程序参数</p>\n<ul>\n<li>target: 目标对象</li>\n</ul>\n</li>\n<li>\n<p>捕获器不定式</p>\n<ul>\n<li>返回的可枚举对象必须包含target的所有不可配置的自有属性</li>\n<li>如果target不可拓展，则返回可枚举对象必须军却包含自有属性键</li>\n</ul>\n</li>\n</ul>\n<h3>getPrototypeOf()</h3>\n<ul>\n<li>getPrototypeOf()会在Object.getPrototypeOf()中被调用，对应的反射API为Reflect.getPrototypeOf()</li>\n<li>返回值必须返回对象或者null</li>\n<li>\n<p>拦截的操作</p>\n<ul>\n<li>Object.getPrototypeOf(proxy)</li>\n<li>Reflect.getPrototypeOf(proxy)</li>\n<li>proxy.<strong>proto</strong></li>\n<li>Object.prototype.isPrototypeOf(proxy)</li>\n<li>proxy instanceof Object</li>\n</ul>\n</li>\n<li>\n<p>捕获器处理程序参数</p>\n<ul>\n<li>target: 目标对象</li>\n</ul>\n</li>\n<li>\n<p>捕获器不定式</p>\n<ul>\n<li>如果target不可拓展，则Object.getPrototypeOf(proxy)唯一有效的返回值就是Object.getPrototypeOf(target)的返回值</li>\n</ul>\n</li>\n</ul>\n<h3>setPrototypeOf()</h3>\n<ul>\n<li>setPrototypeOf()会在Object.setPrototypeOf()中被调用，对应的反射API为Reflect.setPrototypeOf()</li>\n<li>返回值必须返回布尔值，表示原型赋值是否成功，非布尔值会被转为布尔值</li>\n<li>\n<p>拦截的操作</p>\n<ul>\n<li>Object.setPrototypeOf(proxy)</li>\n<li>Reflect.setPrototypeOf(proxy)</li>\n</ul>\n</li>\n<li>\n<p>捕获器处理程序参数</p>\n<ul>\n<li>target: 目标对象</li>\n<li>prototype: target的替代原型，如果是顶级原型则为null</li>\n</ul>\n</li>\n<li>\n<p>捕获器不定式</p>\n<ul>\n<li>如果target不可拓展，则唯一有效的prototype参数就是Object.getPrototypeOf(target)的返回值</li>\n</ul>\n</li>\n</ul>\n<h3>isExtensible()</h3>\n<ul>\n<li>isExtensible()会在Object.isExtensible()中被调用，对应的反射API为Reflect.isExtensible()</li>\n<li>返回值必须为布尔值，表示target是否可拓展，非布尔值会转为布尔值</li>\n<li>\n<p>拦截的操作</p>\n<ul>\n<li>Object.isExtensible(proxy)</li>\n<li>Reflect.isExtensible(proxy)</li>\n</ul>\n</li>\n<li>\n<p>捕获器处理程序参数</p>\n<ul>\n<li>target: 目标对象</li>\n</ul>\n</li>\n<li>\n<p>捕获器不定式</p>\n<ul>\n<li>如果target可拓展，处理程序必须返回true</li>\n<li>如果target不可拓展，处理程序必须返回false</li>\n</ul>\n</li>\n</ul>\n<h3>preventExtensions()</h3>\n<ul>\n<li>preventExtensions()捕获器会在Object.preventExtensions()中被调用，对应的反射API为Reflect.preventExtensions()</li>\n<li>返回值必须为布尔值，表示target是否已经不可拓展，返回非布尔值会被转为布尔值</li>\n<li>\n<p>拦截的操作</p>\n<ul>\n<li>Object.preventExtensions(proxy)</li>\n<li>Relfect.preventExtensions(proxy)</li>\n</ul>\n</li>\n<li>\n<p>捕获器处理程序参数</p>\n<ul>\n<li>target: 目标对象</li>\n</ul>\n</li>\n<li>\n<p>捕获器不定式</p>\n<ul>\n<li>如果Object.isExtensible(proxy)返回false，则处理程序必须返回true</li>\n</ul>\n</li>\n</ul>\n<h3>apply()</h3>\n<ul>\n<li>apply()会在调用函数时被调用，对应的反射API为Reflect.apply()</li>\n<li>返回值无限制</li>\n<li>\n<p>拦截的操作</p>\n<ul>\n<li>proxy(...argumentsList)</li>\n<li>Function.prototype.apply(thisArg, argumentsList)</li>\n<li>Function.prototype.call(thisArg, ...argumentsList)</li>\n<li>Reflect.apply(target, thisArgument, argumentsList)</li>\n</ul>\n</li>\n<li>\n<p>捕获器处理程序参数</p>\n<ul>\n<li>target: 目标对象</li>\n<li>thisArg: 调用此函数时的this参数</li>\n<li>argumentsList: 调用函数时的参数列表</li>\n</ul>\n</li>\n<li>\n<p>捕获器不定式</p>\n<ul>\n<li>target必须是函数对象</li>\n</ul>\n</li>\n</ul>\n<h3>construct()</h3>\n<ul>\n<li>construct()捕获器会在new操作符中被调用，对应的反射API为Reflect.construct()</li>\n<li>返回值必须返回一个对象</li>\n<li>\n<p>拦截的操作</p>\n<ul>\n<li>new Proxy(...argumentsList)</li>\n<li>Reflect.construct(target, argumentsList, newTarget)</li>\n</ul>\n</li>\n<li>\n<p>捕获器处理程序参数</p>\n<ul>\n<li>target: 目标构造函数</li>\n<li>argumentsList: 传给构造函数的参数列表</li>\n<li>最初被调用的构造函数</li>\n</ul>\n</li>\n<li>\n<p>捕获器不定式</p>\n<ul>\n<li>target必须可以用作构造函数</li>\n</ul>\n</li>\n</ul>\n<h2>代理模式</h2>\n<ul>\n<li>利用代理可以做一些有用的编程模式</li>\n<li>可以捕获get、set、has等操作，知道对象属性什么时候被访问</li>\n</ul>\n<pre><code class=\"language-js\">const user = {\n  name: 'jack'\n}\n\nconst proxy = new Proxy(user, {\n  get (target, property, receiver){\n    console.log(`Getting ${property}`)\n    Reflect.get(...arguments)\n  },\n  set (target, property, value, receiver){\n    console.log(`Setting ${property}=${value}`)\n    Reflect.set(...arguments)\n  }\n})\n\nproxy.name  // Getting name\nproxy.age = 27 // Setting age=27\n</code></pre>\n<ul>\n<li>可以用于隐藏属性</li>\n</ul>\n<pre><code class=\"language-js\">const hiddenProperties = ['foo', 'bar']\nconst targetObject = {\n  foo: 1,\n  bar: 2,\n  baz: 3\n}\nconst proxy = new Proxy(targetObject, {\n  get(target, property) {\n    if(hiddenProperties.includes(property)) {\n      return undefined\n    } else {\n      return Reflect.get(...arguments)\n    }\n  },\n  has(target, property){\n    if(hiddenProperties.includes(property)) {\n      return false\n    } else {\n      return Reflect.has(...arguments)\n    }\n  }\n})\n\nconsole.log(proxy.foo) // undefined\nconsole.log(proxy.bar) // undefined\nconsole.log(proxy.baz) // 3\nconsole.log('foo' in proxy) // false\nconsole.log('bar' in proxy) // false\nconsole.log('baz' in proxy) // true\n</code></pre>\n<ul>\n<li>可以根据所赋的值决定是否允许赋值</li>\n</ul>\n<pre><code class=\"language-js\">const target = {\n  onlyNumbersGoHere: 0\n}\n\nconst proxy = new Proxy(target, {\n  set (target, property, value, receiver){\n    if(typeof value !== 'number') {\n      return false\n    } else {\n      return Reflect.set(...arguments)\n    }\n  }\n})\n\nproxy.onlyNumbersGoHere = 1\nconsole.log(proxy.onlyNumbersGoHere) // 1\n\nproxy.onlyNumbersGoHere = '2'\nconsole.log(proxy.onlyNumbersGoHere) // 1\n</code></pre>\n<ul>\n<li>函数跟构造函数参数验证，指定函数只接受某种类型的值</li>\n</ul>\n<pre><code class=\"language-js\">function median(...nums){\n  return nums.sort()[Math.floor(nums.length / 2)]\n}\nconst proxy = new Proxy(median, {\n  apply(target, thisArg, argumentsList) {\n    for(const arg of argumentsList) {\n      if(typeof arg !== 'number') {\n        throw 'Non-number argument provided'\n      }\n    }\n    return Reflect.apply(...arguments)\n  }\n})\n\nconsole.log(proxy(4, 7, 1)) // 4\nconsole.log(proxy(4, '7', 1)) // Uncaught Non-number argument provided\n</code></pre>\n<ul>\n<li>通过代理可以把原来不关联的部分联系到一起。这样就能实现各种模式，让不同的代码互操作</li>\n<li>例如，可以将被代理的类放到一个全局实例集合</li>\n</ul>\n<pre><code class=\"language-js\">const userList = []\nclass User{\n  constructor(name){\n    this._name = name\n  }\n}\n\nconst proxy = new Proxy(User, {\n  construct(){\n    const newUser = Reflect.construct(...arguments)\n    userList.push(newUser)\n    return newUser\n  }\n})\n\nnew proxy('John')\nnew proxy('Jacob')\nnew proxy('Jing')\nconsole.log(userList) // [User, User, User]\n</code></pre>\n<ul>\n<li>可以把集合绑定到一个事件分配程序，每次插入新实例都会发送消息</li>\n</ul>\n<pre><code class=\"language-js\">const userList = []\nfunction emit(newValue) {\n  console.log(newValue)\n}\n\nconst proxy = new Proxy(userList, {\n  set(target, property, value, receiver) {\n    const result = Reflect.set(...arguments)\n    if(result) {\n      emit(Reflect.get(target, property, receiver))\n    }\n    return result\n  }\n})\nproxy.push('John') // John\nproxy.push('Jacob') // Jacob\nproxy.push('Jing') // Jing\n</code></pre>","fields":{"slug":"/proxy/"},"frontmatter":{"title":"代理","tags":["JavaScript回顾"],"categories":"JavaScript"}}},{"node":{"html":"<h1>函数</h1>\n<ul>\n<li>函数实际上是对象，每个函数都是Function类型的实例</li>\n<li>函数通常以函数声明的方式定义</li>\n</ul>\n<pre><code class=\"language-js\">function sum(num1, num2) {\n  return num1 + num2\n}\n</code></pre>\n<ul>\n<li>\n<p>还能以函数表达式来定义</p>\n<!--more-->\n<pre><code class=\"language-js\">let sum = function (num1, num2) {\nreturn num1 + num2\n}\n</code></pre>\n</li>\n<li>箭头函数定义</li>\n</ul>\n<pre><code class=\"language-js\">let sum = (num1, num2) => {\n  return num1 + num2\n}\n</code></pre>\n<ul>\n<li>最后一种以Function构造函数定义函数。此构造函数接收任意个字符串参数，最后一个参数会被当做函数体，前面的参数都是新函数的参数</li>\n<li>此方法不推荐，因为这样会解释两次，第一次是将它当做常规的ECMAScript代码，第二次会解释传给构造函数的字符串</li>\n</ul>\n<pre><code class=\"language-js\">let sum = new Function('num1', 'num2', 'return num1 + num2')\n</code></pre>\n<ul>\n<li>ECMAScript 6的所有函数对象会暴露一个只读的<code>name</code>属性，包含函数的信息。一般情况下保存的就是一个字符串化的变量名</li>\n<li>及时函数没有名称也会变成空字符串，如果是用<code>Function</code>创建的，就会标识成<code>\"anonymous\"</code></li>\n<li>如果函数是一个获取函数、设置函数或者使用bind实例化，name会加上一个前缀</li>\n</ul>\n<pre><code class=\"language-js\">function foo(){}\nlet bar = function(){}\nlet baz = () => {}\n\nconsole.log(foo.name) // foo\nconsole.log(bar.name) // bar\nconsole.log(baz.name) // baz\nconsole.log((() => {}).name) // ''\nconsole.log((new Function()).name) // anonymous\n\n\nlet dog = {\n  years: 1,\n  get age(){\n    return this.year\n  },\n  set age(newVal){\n    this.years = newVal\n  }\n}\nlet propertyDescriptor = Object.getOwnPropertyDescriptor(dog, 'age')\nconsole.log(foo.bind(null).name) // bound foo\nconsole.log(propertyDescriptor.get.name) // get age\nconsole.log(propertyDescriptor.set.name) // set age\n</code></pre>\n<ul>\n<li>函数默认值定义时，参数是按照顺序初始化的，所以后定义的默认值参数可以引用前面定义的参数</li>\n</ul>\n<pre><code class=\"language-js\">function makeKing(name = 'Henry', numerals = name) {\n  return `King ${name} ${numerals}`\n}\nconsole.log(makeKing()) // King Henry Henry\n</code></pre>\n<ul>\n<li>参数初始化顺序遵循“暂时性死区”规则，前面定义的参数，不能引用后面定义的参数，如下就会报错</li>\n</ul>\n<pre><code class=\"language-js\">function makeKing(name = numerals, numerals = 'Henry') {\n  return `King ${name} ${numerals}`\n}\nconsole.log(makeKing()) // Uncaught ReferenceError: Cannot access 'numerals' before initialization\n</code></pre>\n<h2>箭头函数</h2>\n<ul>\n<li>可以使用函数表达式的地方都可以使用箭头函数</li>\n<li>箭头函数不能使用arguments、super和new.target，也不能用作构造函数，并且没有prototype</li>\n</ul>\n<h2>arguments</h2>\n<ul>\n<li>arguments是一个类数组对象，包含函数调用传入的全部参数，这个函数只有一function关键字定义函数时才有 （箭头函数就没有）</li>\n<li>arguments有一个callee属性，始终指向arguments对象所在的函数的指针</li>\n</ul>\n<pre><code class=\"language-js\">function factorial(num){\n  if(num &#x3C;=1) {\n    return 1\n  } else {\n    return num * factorial(num - 1)\n  }\n}\n\nlet trueFactorial = factorial\nfactorial = function(){\n  return 0\n}\ntrueFactorial(5) // 0\nfactorial(5) // 0\n</code></pre>\n<ul>\n<li>这是一个经典的阶乘函数，上面函数要保证正确执行就得保证函数名一定是factorial，一旦我们将函数赋给别的值，就能发现出现问题了，这就导致了紧密耦合，可以使用arguments.callee解耦</li>\n</ul>\n<pre><code class=\"language-js\">function factorial(num){\n  if(num &#x3C;=1) {\n    return 1\n  } else {\n    return num * arguments.callee(num - 1)\n  }\n}\n\n\nlet trueFactorial = factorial\ntrueFactorial(5) // 120\nfactorial = function(){\n  return 0\n}\nfactorial(5) // 0\n</code></pre>\n<ul>\n<li>这样就实现了解耦，修改factorial的引用不会影响递归函数</li>\n<li>arguments对象始终会与对应的命名参数同步</li>\n</ul>\n<pre><code class=\"language-js\">function doAdd(num1, num2) {\n  arguments[1] = 10\n  console.log(arguments[0] + num2)\n}\ndoAdd(10, 30) // 20\n</code></pre>\n<ul>\n<li>这里doAdd函数会把第二个参数的值重写为10。因为arguments对象的值会自动同步到对应的命名参数，所以修改arguments[1]也就是修改了num2</li>\n<li>并不意味着arguments[1]跟num2是同一个内存地址，内存是分开的，但是会同步</li>\n<li>如果只传了一个参数，然后把arguments[1]改为某个值，那这个值并不会反映到第二个命名参数，因为arguments对象的长度是根据传入的参数个数确定，而非定义函数时给出的命名参数确定的</li>\n<li>严格模式下，arguments[1]修改后不再影响num2的值，其次，在函数内重写arguments对象会导致语法错误</li>\n</ul>\n<h2>this</h2>\n<ul>\n<li>this在标准函数与箭头函数中行为不一致</li>\n<li>标准函数中，this引用的是把函数当成方法调用的上下文对象，这时候称其为this值（网页全局调用时，this指向window）</li>\n</ul>\n<pre><code class=\"language-js\">window.color = 'red'\nlet o = {\n  color: 'blue'\n}\nfunction sayColor(){\n  console.log(this.color)\n}\nsayColor() // 'red'\no.sayColor = sayColor\no.sayColor() // 'blue'\n</code></pre>\n<ul>\n<li>定义在全局上下文的sayColor引用了this对象。这个this是那个对象要到函数调用时才能知道。</li>\n<li>全局调sayColor输出red因为this指向window，this.color相当于window.color。</li>\n<li>把sayColor赋值给o再调用，this指向了o，this.color相当于o.color，所以显示\"blue\"</li>\n<li>箭头函数中的this引用的是定义箭头函数的上下文</li>\n</ul>\n<pre><code class=\"language-js\">window.color = 'red'\nlet o = {\n  color: 'blue'\n}\nlet sayColor = () => console.log(this.color)\nsayColor() // 'red'\no.sayColor = sayColor\no.sayColor() // 'red'\n</code></pre>\n<ul>\n<li>所以当我们在事件回调或者定时回调中调用某个函数时，this指向并非我们想要的对象时，我们就可以把函数改为箭头函数即可，因为箭头函数中的this会保留定义该函数的上下文</li>\n</ul>\n<pre><code class=\"language-js\">function King(){\n  this.royaltyName = 'Henry'\n  setTimeout(() => {\n    console.log(this.royaltyName)\n  }, 1000)\n}\n\nfunction Queen(){\n  this.royaltyName = 'Elizabeth'\n  setTimeout(function (){\n    console.log(this.royaltyName)\n  }, 1000)\n}\nnew King() // Henry\nnew Queen() // undefined\n</code></pre>\n<h2>caller</h2>\n<ul>\n<li>ECMAScript 5会给函数对象加一个属性： caller，这个属性引用调用当前函数的函数，如果在全局作用域中调用则为null</li>\n</ul>\n<pre><code class=\"language-js\">function outer(){\n  inner()\n}\nfunction inner(){\n  console.log(inner.caller)\n}\nouter()  // ƒ outer(){\n  inner()\n}\n\n// 降低耦合度的写法\nfunction inner(){\n  console.log(arguments.callee.caller)\n}\n</code></pre>\n<ul>\n<li>严格模式下访问arguments.callee会报错，访问arguments.caller也会报错，非严格模式下访问arguments.caller是undefined，这样是为了分清arguments.caller和函数的caller而做的</li>\n<li>严格模式下不可给caller赋值，否则会报错</li>\n</ul>\n<h2>new.target</h2>\n<ul>\n<li>函数始终可以作为构造函数实例化一个对象，ECMAScript新增了 new.target 检测函数是否使用new关键字调用。函数是正常调用，那new.target就是undefined，如果是new调用，那new.target将引用被调用的构造函数</li>\n</ul>\n<pre><code class=\"language-js\">function King(){\n  if(!new.target) {\n    throw 'King must be instantiated using \"new\"'\n  }\n  console.log('King instantiated using \"new\"')\n}\nnew King() // King instantiated using \"new\"\nKing() // Uncaught King must be instantiated using \"new\"\n</code></pre>","fields":{"slug":"/function/"},"frontmatter":{"title":"函数--高程4","tags":["JavaScript回顾"],"categories":"JavaScript"}}},{"node":{"html":"<h1>函数</h1>\n<h2>递归</h2>\n<ul>\n<li>递归函数通常是一个函数通过名称自己调用自己</li>\n</ul>\n<pre><code class=\"language-js\">// 耦合性太强\nfunction factorial(num){\n  if(num &#x3C;= 1) {\n    return 1\n  } else {\n    return num * factorial(num - 1)\n  }\n}\n\n// 严格模式下报错\nfunction factorial(num){\n  if(num &#x3C;= 1) {\n    return 1\n  } else {\n    return num * arguments.callee(num - 1)\n  }\n}\n</code></pre>\n<ul>\n<li>\n<p>这样是我们的第一感觉，但是上一章说过，这样的话如果把它赋值给其他变量就会出问题，所以上一章我们用的是arguments.callee来进行调用，但是这样在严格模式下报错，所以我们可以使用命名函数表达式来完成，如下</p>\n<!--more-->\n<pre><code class=\"language-js\">const factorial = (function f(num){\nif(num &#x3C;= 1) {\nreturn 1\n} else {\nreturn num * f(num - 1)\n}\n})\n</code></pre>\n</li>\n<li>这样就实现了我们的一个通用递归方式</li>\n</ul>\n<h2>尾调用优化</h2>\n<ul>\n<li>ECMAScript 6新增了一项内存管理优化机制，让JavaScript引擎在满足条件时可以重用栈帧。这个优化很适合“尾调用”，即外部函数的返回值是内部函数的返回值</li>\n</ul>\n<pre><code class=\"language-js\">function outerFunction(){\n  return innerFuntion() // 尾调用\n}\n</code></pre>\n<ul>\n<li>\n<p>ES6优化之前，会有下操作</p>\n<ul>\n<li>执行到outerFunction函数体，第一个栈帧被推倒栈上</li>\n<li>执行outerFunction函数体，到return语句，需要计算innerFunction</li>\n<li>执行到innerFunction函数体，第二个栈帧被推到栈上</li>\n<li>执行innerFunction函数体，计算返回值</li>\n<li>将返回值传回outerFunction，然后再返回</li>\n<li>将栈帧弹出栈</li>\n</ul>\n</li>\n<li>\n<p>优化后</p>\n<ul>\n<li>执行到outerFunction函数体，第一个栈帧被推倒栈上</li>\n<li>执行outerFunction函数体，到return语句，需要计算innerFunction</li>\n<li>引擎发现将第一个栈帧弹出去也不影响，因为outerFunction的返回值跟innerFunction的返回值一直</li>\n<li>弹出outerFunction的栈帧</li>\n<li>执行到innerFunction函数体，栈帧被推到栈上</li>\n<li>执行innerFunction函数体，计算返回值</li>\n<li>将innerFunction的栈帧弹出栈外</li>\n</ul>\n</li>\n<li>能看出，第一种情况下每多一层嵌套就会多一个栈帧。而第二种情况无论多少次嵌套函数，都只有一个栈帧。</li>\n<li>这就是ES6尾调用优化的关键：如果函数的逻辑允许尾调用将其销毁，那引擎就会这么干</li>\n</ul>\n<h3>尾调用优化的条件</h3>\n<ul>\n<li>\n<p>尾调用优化的条件就是确定外部栈帧没必要存在了，条件如下</p>\n<ul>\n<li>代码在严格模式下执行</li>\n<li>外部函数的返回值是对尾调用函数的调用</li>\n<li>尾调用函数返回后不需执行额外操作</li>\n<li>尾调用函数不是引用外部函数作用域中自由变量的闭包</li>\n</ul>\n</li>\n<li>下面是几个违反上述条件的函数</li>\n</ul>\n<pre><code class=\"language-js\">'use strict'\n// 无优化： 尾调用无返回\nfunction outerFunction(){\n  innerFunction()\n}\n\n// 无优化： 尾调用没有直接返回\nfunction outerFunction(){\n  let result = innerFunction()\n  return result\n}\n\n// 无优化： 尾调用后必须转为字符串\nfunction outerFunction(){\n  return innerFunction().toString()\n}\n\n// 无优化： 尾调用是个闭包\nfunction outerFunction(){\n  let foo = 'bar'\n  function innerFunction(){\n    return foo\n  }\n  return innerFunction()\n}\n</code></pre>\n<ul>\n<li>下面是符合条件的例子</li>\n</ul>\n<pre><code class=\"language-js\">'use strict'\n// 有优化：栈帧销毁前执行计算\nfunction outerFunction(a, b){\n  return innerFunction(a + b)\n}\n\n// 有优化：初识返回值不涉及栈帧\nfunction outerFunction(a, b){\n  if(a &#x3C; b) {\n    return a\n  }\n  return innerFunction(a + b)\n}\n\n// 有优化：两个内部函数都在尾部\nfunction outerFunction(condition){\n  return condition ? innerFunctionA() : innerFunctionB()\n}\n</code></pre>\n<ul>\n<li>差异化尾调用跟递归尾调用容易让人混淆，无论递归尾调用还是非递归尾调用，都可以应用优化。这个优化在递归下最明显，因为递归代码最容易在栈内存中产生大量栈帧</li>\n<li>之所以要求严格模式是因为非严格模式下函数调用中允许使用f.arguments跟f.caller，而它们都引用外部函数的栈帧。所以无法使用优化了</li>\n<li>尾调用优化的代码</li>\n</ul>\n<pre><code class=\"language-js\">function fib(n) {\n  if(n &#x3C; 2) {\n    return n\n  }\n  return fib(n - 1) + fib(n - 2)\n}\n</code></pre>\n<ul>\n<li>这里的函数尾部执行了相加操作，所以不符合尾调用优化的原则，所以fib(n)的栈帧数的内存复杂度为o(2^n)，所以简单地调用fib(1000)也会给浏览器带来麻烦</li>\n<li>所以我们可以对其进行优化让其满足条件，为此使用两个函数，外层函数作为基础框架，内部函数执行递归</li>\n</ul>\n<pre><code class=\"language-js\">'use strict'\nfunction fib(n){\n  return fibImpl(0, 1, n)\n}\n\nfunction fibImpl(a, b, n){\n  if(n === 0) {\n    return a\n  }\n  return fibImpl(b, a + b, n - 1)\n}\nfib(1000)\n</code></pre>\n<ul>\n<li>重构之后在执行就不会有这个问题了，可以正常得出结果</li>\n</ul>\n<h2>闭包</h2>\n<ul>\n<li>闭包是指那些引用了另一个函数作用域中变量的函数，通常是在嵌套函数中使用。</li>\n<li>闭包形成的原因，在调用一个函数时，会为函数调用创建一个执行上下文，并创建作用域链。</li>\n<li>然后用arguments和其他参数来初始化这个函数的活动对象。外部函数的活动对象是内部函数作用域链的第二个对象。</li>\n<li>这个作用域链一直向外串起所有包含函数的活动对象，一直到全局执行上下文才终止</li>\n<li>函数执行时，每个执行上下文都会有一个包含其中变量的对象，全局上下文中叫变量对象，会在代码执行期间一直存在。函数局部上下文中的叫活动对象，只在函数执行期间存在。</li>\n</ul>\n<pre><code class=\"language-js\">function compare(value1, value2){\n  if(value1 &#x3C; value2) {\n    return -1\n  } else if (value1 > value2) {\n    return 1\n  } else {\n    return 0\n  }\n}\nlet result = compare(5, 10)\n</code></pre>\n<ul>\n<li>compare函数是在全局上下文中调用的。第一次调用会为它创建一个包含arguments、value1、value2的活动对象，这个对象就是它作用域链的第一个对象</li>\n<li>全局上下文的变量对象则是compare()作用域链上面的第二个对象，包含了this、result、compare</li>\n<li>定义这个函数时，会先为它创建作用域链，然后预先将全局变量对象，并保存在内部的[[Scope]]中。调用这个函数时，会创建相应的上下文，然后通过复制函数的[[Scope]]来创建器作用域链。</li>\n<li>接着会创建函数的活动对象（用作变量对象）并把它放到作用域链的前端。上面这个例子意味着compare()函数执行上下文的作用域链中有两个变量对象：局部变量对象和全局变量对象。作用域链其实是一个包含指针的列表，每个指针分别指向一个变量对象。</li>\n<li>函数内部访问变量时，就会按照给定的名称从作用域中查找变量。函数执行完成后，局部活动对象被销毁，内存中就只剩全局作用域。</li>\n<li>函数内部定义的函数会把它的包含函数的活动对象添加到自己的作用域链中。然后它就可以访问到包含对象的全部变量，因为它有着包含对象的活动对象的引用，所以包含函数执行完成后不能销毁，只有等函数内部定义的函数被销毁它才能销毁</li>\n<li>闭包保留了它的包含函数的作用域，所以比其他函数更占内存，所以除非必要，不然不使用闭包</li>\n</ul>\n<h2>内存泄漏</h2>\n<ul>\n<li>由于IE9之前对JScript对象跟COM对象的垃圾回收机制不一致，所以闭包在旧版本可能会出问你。在部分版本下，将html闭包就会导致它不能被销毁</li>\n</ul>\n<pre><code class=\"language-js\">function assignHandler(){\n  let element = document.getElementById('someElement')\n  element.onclick = () => console.log(element.id)\n}\n</code></pre>\n<ul>\n<li>这里创建了一个闭包，即element元素的事件处理程序。事件处理程序又创建了循环引用。匿名函数引用着assignHandler的活动对象，阻止了对element的引用计数归零。所以只要匿名函数存在，element的引用次数就至少为1，所以内存无法回收</li>\n</ul>\n<pre><code class=\"language-js\">function assignHandler(){\n  let element = document.getElementById('someElement')\n  let id = element.id\n  element.onclick = () => console.log(id)\n  element = null\n}\n</code></pre>\n<ul>\n<li>这样我们把element.id替换为一个新的id字段去除了循环引用，但是还不够，因为匿名函数引用着包含对象的活动对象，活动对象包含了element。</li>\n<li>所以闭包没有直接引用element，但是包含活动对象还存在着它的引用，所以需要把它设为null解除引用</li>\n</ul>\n<h2>私有变量与特权方法</h2>\n<ul>\n<li>JavaScript没有私有成员概念，但是有私有变量的概念，在函数内部的变量都是函数私有的，函数外部无法访问。私有变量包含函数参数、局部变量、函数内部定义的其他函数</li>\n<li>特权方法是能够访问函数私有变量的公有方法。在对象上创建特权方法的方式有两种，一种是构造函数中实现</li>\n</ul>\n<pre><code class=\"language-js\">function MyObject(){\n  let privateVariable = 10\n  function privateFunction(){\n    return false\n  }\n  this.publicMethod = function(){\n    privateVariable++\n    return privateFunction()\n  }\n}\n</code></pre>\n<ul>\n<li>这是将私有变量跟方法都定义在构造函数中，然后创建一个能访问这些私有成员的特权方法，因为特权方法是一个闭包，可以访问构造函数的所有成员，所以可以使用它来访问</li>\n<li>每个特权方法都由自己的privateVariable，因为每次调用构造函数都会重新创建一套变量跟方法，也就导致这种模式有一个缺点：每个实例都会重新创建一遍新方法</li>\n<li>另一种是通过私有作用域定义私有变量跟函数来实现</li>\n</ul>\n<pre><code class=\"language-js\">(function(){\n  let privateVariable = 10\n  function privateFunction(){\n    return false\n  }\n  MyObject = function(){}\n  MyObject.prototype.publicMethod = function(){\n    privateVariable++\n    return privateFunction()\n  }\n})()\n</code></pre>\n<ul>\n<li>这里，匿名函数定义了私有变量和私有方法，然后又定义了构造函数和公有方法。公有方法定义在构造函数原型上。</li>\n<li>这里生命MyObject没有使用关键字，所以会被创建到全局作用域中，所以MyObject可以在外部被访问（严格模式下不使用关键字声明会报错）</li>\n<li>这样的话私有变量跟私有方法是全部实例共享了，因为特权方法是在原型上，所以由全部实例共享</li>\n<li>这样创建的好处就是可以更好地重用代码，但是也导致了每个实例都没有了私有变量</li>\n<li>闭包跟私有变量会让作用域链变长，作用域链越长，查找变量所需时间越长</li>\n</ul>","fields":{"slug":"/function2/"},"frontmatter":{"title":"函数-闭包--高程4","tags":["JavaScript回顾"],"categories":"JavaScript"}}},{"node":{"html":"<h1>深入Promise</h1>\n<ul>\n<li>Promise中执行resolve会有一个内部值，执行reject会有一个内部理由，默认情况下，这个值跟理由都是undefined</li>\n<li>Promise中使用reject进入拒绝态时没有进行捕获会抛出错误</li>\n</ul>\n<pre><code class=\"language-js\">let p1 = Promise.resolve()\nlet p = Promise.reject()\nsetTimeout(console.log, 0, p1) // Promise {&#x3C;resolved>: undefined}\nsetTimeout(console.log, 0, p)\n// Uncaught (in promise) undefined\n// Promise {&#x3C;rejected>: undefined}\n</code></pre>\n<ul>\n<li>Promise.resolve()可以将任何值转为Promise</li>\n</ul>\n<pre><code class=\"language-js\">setTimeout(console.log, 0, Promise.resolve(3))\n// Promise {&#x3C;resolved>: 3}\n</code></pre>\n<!--more-->\n<ul>\n<li>Promise.resolve()是一个幂等方法，这个方法中，传入的参数本身是一个Promise，那么它的行为就是一个空包装</li>\n</ul>\n<pre><code class=\"language-js\">let p2 = Promise.resolve(7)\nsetTimeout(console.log, 0, p2 === Promise.resolve(p2)) // true\nsetTimeout(console.log, 0, p2 === Promise.resolve(Promise.resolve(p2))) // true\n</code></pre>\n<ul>\n<li>Promise.resolve可以包裹一个Promise，这样的话会保留原始Promise的状态</li>\n</ul>\n<pre><code class=\"language-js\">setTimeout(console.log, 0, Promise.resolve(new Promise((resolve, reject) => { }) ))   // Promise {&#x3C;pending>}\nsetTimeout(console.log, 0, Promise.resolve(Promise.resolve(3))) // Promise {&#x3C;resolved>: 3}\nsetTimeout(console.log, 0, Promise.resolve(Promise.reject(4)))  // Promise {&#x3C;rejected>: 4}\n</code></pre>\n<ul>\n<li>通过Promise.resolve可以包装任何非Promise值，包括错误对象，并将其转为解决的期约，这样做可能出现不符合预期的行为</li>\n</ul>\n<pre><code class=\"language-js\">let p3 = Promise.resolve(new Error('foo'))\nsetTimeout(console.log, 0, p3) \nsetTimeout(console.log, 0, Promise.resolve(Promise.reject(3))) \n//Promise {&#x3C;resolved>: Error: foo\n//    at &#x3C;anonymous>:1:26}\n</code></pre>\n<ul>\n<li>Promise.reject实例化一个拒绝Promise并抛出异步错误（此错误不能通过try/catch捕获，只能通过拒绝处理程序捕获）</li>\n<li>Promise.reject没有幂等的概念，给它一个Promise对象，它会自动将该对象变为拒绝的理由</li>\n</ul>\n<pre><code class=\"language-js\">setTimeout(console.log, 0, Promise.reject(new Promise((resolve, reject) => { }) ))   // Promise {&#x3C;rejected>: Promise}\nsetTimeout(console.log, 0, Promise.reject(Promise.resolve(3))) // Promise {&#x3C;rejected>: Promise}\nsetTimeout(console.log, 0, Promise.reject(Promise.reject(4)))  // Promise {&#x3C;rejected>: Promise}\n</code></pre>\n<h2>Promise.prototype.then</h2>\n<ul>\n<li>接收两个程序处理参数，均为可选，非函数类型的参数会被静默忽略</li>\n</ul>\n<pre><code class=\"language-js\">let p4 = new Promise((res, rej) => {\n  rej(4)\n})\n// 第一个参数被静默，可以捕获到异步报错\np4.then('123', (rej) => {\n  console.log(rej)\n})\n</code></pre>\n<ul>\n<li>这里的返回值会通过Promise.resolve()进行包装返回值来生成新的Promise，如果没有显示的返回语句，就包装默认返回值undefined</li>\n<li>调用then不传处理程序，则原样向后传</li>\n</ul>\n<pre><code class=\"language-js\">let p7 = Promise.resolve('foo')\nlet p8 = p7.then(() => 6) \nlet p9 = p7.then(() => {})\nlet p10 = p7.then(() => Promise.resolve())\nsetTimeout(console.log, 0, p8)   // Promise {&#x3C;resolved>: 6}\nsetTimeout(console.log, 0, p9) // Promise {&#x3C;resolved>: undefined}\nsetTimeout(console.log, 0, p10)  // Promise {&#x3C;resolved>: undefined}\n\np7.then().then(res => {\n  console.log(res) // 'foo'\n})\n</code></pre>\n<ul>\n<li>Promise.prototype.then中的onReject捕获的错误也会通过Promise.resolve包装，这样就可以捕获错误，但是不抛出异常</li>\n</ul>\n<pre><code class=\"language-js\">let p11 = Promise.reject('foo')\nlet p12 = p11.then(null, () => undefined)\nlet p13 = p11.then(null, () => {})\nlet p14 = p11.then(null, () => Promise.resolve())\nlet p15 = p11.then(null, () => Promise.reject())\nsetTimeout(console.log, 0, p12)   // Promise {&#x3C;resolved>: undefined}\nsetTimeout(console.log, 0, p13) // Promise {&#x3C;resolved>: undefined}\nsetTimeout(console.log, 0, p14)  // Promise {&#x3C;resolved>: undefined}\nsetTimeout(console.log, 0, p15)  // Promise {&#x3C;resolved>: undefined}\n// Uncaught (in promise) undefined\n</code></pre>\n<h2>Promise.prototype.catch</h2>\n<ul>\n<li>该方法用于给Promise添加拒绝处理程序，只接受一个参数，onRejct处理程序</li>\n<li>此方法是一个语法糖，相当于调用Promise.prototype.then(null, onReject)</li>\n</ul>\n<h2>Promise.prototype.finally</h2>\n<ul>\n<li>此方法在Promise取得终态时触发，无论是onResolve或者onReject，但是无法知道Promise的结果</li>\n<li>所以此代码主要用于清理无用程序，此方法返回一个新的Promise</li>\n<li>因为它与状态无关，所以它会表现为上一个Promise的状态，无论是拒绝或者解决状态</li>\n</ul>\n<pre><code class=\"language-js\">let p1 = new Promise(() => {})\nlet p2 = p1.finally()\nsetTimeout(console.log, 0, p1)  // Promise {&#x3C;pending>}\nsetTimeout(console.log, 0, p2)  // Promise {&#x3C;pending>}\nsetTimeout(console.log, 0, p1 === p2)  // false\n\nlet p3 = Promise.resolve(1)\nlet p4 = Promise.reject(2)\nlet p5 = new Promise(() => {})\n\n// 原样后传\nlet p6 = p3.finally()\nlet p7 = p3.finally(() => {})\nlet p8 = p3.finally(() => undefined)\nlet p9 = p3.finally(() => Promise.resolve(3))\nlet p10 = p3.finally(() => Error('bar'))\nlet p11 = p4.finally()\nlet p12 = p5.finally()\n\nsetTimeout(console.log, 0, p6)  // Promise {&#x3C;resolved>: 1}\nsetTimeout(console.log, 0, p7)  // Promise {&#x3C;resolved>: 1}\nsetTimeout(console.log, 0, p8)  // Promise {&#x3C;resolved>: 1}\nsetTimeout(console.log, 0, p9)  // Promise {&#x3C;resolved>: 1}\nsetTimeout(console.log, 0, p10)  // Promise {&#x3C;resolved>: 1}\nsetTimeout(console.log, 0, p11)  // Promise {&#x3C;rejected>: 2}\nsetTimeout(console.log, 0, p12)  // Promise {&#x3C;pending>}\n</code></pre>\n<ul>\n<li>如果返回了一个待定的Promise或者在onFinally中抛出了错误（显式抛出或者返回拒绝Promise），则会返回拒绝态的Promise</li>\n</ul>\n<pre><code class=\"language-js\">let p1 = new Promise((resolve) => { resolve('foo') })\nlet p2 = p1.finally(() => Promise.reject())\nlet p3 = p1.finally(() => { throw 'bar' })\nsetTimeout(console.log, 0, p2)  // Promise {&#x3C;rejected>: undefined}\nsetTimeout(console.log, 0, p3)  // Promise {&#x3C;rejected>: \"bar\"}\n</code></pre>\n<ul>\n<li>Promise获得状态后，与该状态相关的处理程序只是被排期，并非立即执行，跟在添加这个处理程序的代码之后的同步代码一定会在处理程序之前执行</li>\n</ul>\n<pre><code class=\"language-js\">let synchronousResolve\nlet p = new Promise((resolve) => {\n  synchronousResolve = function(){\n    console.log('1: invoking resove')\n    resolve()\n    console.log('2: resolve return')\n  }\n})\np.then(() => console.log('4 then handler execute'))\nsynchronousResolve()\nconsole.log('3 synchronousResolve')\n\n// 1: invoking resove\n// 2: resolve return\n// 3 synchronousResolve\n// 4 then handler execute\n</code></pre>\n<h2>串行Promise合成</h2>\n<ul>\n<li>Promise主要特征还有：异步产生值并传给处理程序，后续处理程序可以使用这个值，很像函数合成</li>\n</ul>\n<pre><code class=\"language-js\">function addTwo(x){\n  return x + 2\n}\nfunction addThree(x){\n  return x + 3\n}\nfunction addFive(x){\n  return x + 5\n}\n\nfunction addTen(x) {\n  return addFive(addThree(addTwo(x)))\n}\n\naddTen(5) // 15\n\n// 使用Promise实现\nfunction addTwo(x){\n  return x + 2\n}\nfunction addThree(x){\n  return x + 3\n}\nfunction addFive(x){\n  return x + 5\n}\n\nfunction addTen(x) {\n  return [addTwo, addThree, addFive].reduce((promise, fn) => promise.then(fn), Promise.resolve(x))\n}\naddTen(8).then(console.log) // 18\n\n\n// 拓展实现\n\nfunction addTwo(x){\n  return x + 2\n}\nfunction addThree(x){\n  return x + 3\n}\nfunction addFive(x){\n  return x + 5\n}\nfunction compose(...fns) {\n  return (x) => fns.reduce((promise, fn) => promise.then(fn), Promise.resolve(x))\n}\nlet addTen = compose(addTwo, addThree, addFive)\naddTen(10).then(console.log) // 20\n</code></pre>\n<h2>async/await</h2>\n<ul>\n<li>async关键字用于声明异步函数。使用async可以让函数具有异步特征，但总体上代码仍然是同步求值</li>\n<li>参数与闭包方面，异步函数跟普通函数有一样的行为</li>\n</ul>\n<pre><code class=\"language-js\">async function foo(){\n  console.log(1)\n}\nconsole.log(2)\n\n// 1\n// 2\n</code></pre>\n<ul>\n<li>如果异步函数使用return关键字返回了值（没有return会返回undefined），这个值会被Promise.resolve()包装成Promise对象。</li>\n<li>异步函数始终返回Promise对象，函数外部调用该函数可以得到它返回的Promise</li>\n</ul>\n<pre><code class=\"language-js\">async function foo(){\n  console.log(1)\n  return 3\n}\nfoo().then(console.log)\nconsole.log(2)\n\n// 1\n// 2\n// 3\n\n// 跟直接返回一个Promise对象效果一致\nasync function foo(){\n  console.log(1)\n  return Promise.resolve(3)\n}\nfoo().then(console.log)\nconsole.log(2)\n\n// 1\n// 2\n// 3\n</code></pre>\n<ul>\n<li>异步函数返回值期待（但不要求）一个实现thenable接口的对象，但是常规的值也可以。如果返回的是实现thenable接口的对象，则这个对象可以由提供给then()的处理程序进行解包。如果不是，返回值就被当做已经解决的Promise</li>\n</ul>\n<pre><code class=\"language-js\">async function foo(){\n  return 'foo'\n}\nfoo().then(console.log) // foo\n\nasync function baz(){\n  const thenable = {\n    then(callback) {\n      callback('baz')\n    }\n  }\n  return thenable\n}\nbaz().then(console.log) // baz\n</code></pre>\n<ul>\n<li>在与Promise中一样，在异步函数中抛出错误会返回拒绝的Promise</li>\n</ul>\n<pre><code class=\"language-js\">async function foo(){\n  console.log(1)\n  throw 3\n}\nfoo().catch(console.log)\nconsole.log(2)\n\n// 1\n// 2\n// 3\n</code></pre>\n<ul>\n<li>拒绝Promise的错误不会被异步函数捕获（catch跟then中都无法取值）</li>\n</ul>\n<pre><code class=\"language-js\">async function foo(){\n  console.log(1)\n  Promise.reject(3)\n}\nfoo().catch(console.log).then(console.log)\nconsole.log(2)\n\n// 1\n// 2\n// VM1328:3 Uncaught (in promise) 3\n</code></pre>\n<ul>\n<li>await可以暂停异步函数代码的执行，等待Promise解决</li>\n<li>await会暂停执行异步函数后面的代码，让出JavaScript运行中的执行线程。这个行为跟生成器函数中的yield关键字是一样的</li>\n<li>await同样会尝试解包对象的值，然后将这个值传给表达式，再异步恢复异步函数的执行</li>\n</ul>\n<pre><code class=\"language-js\">async function foo(){\n  console.log(await Promise.resolve('foo'))\n}\nfoo() // foo\n\nasync function bar(){\n  return await Promise.resolve('bar')\n}\nbar().then(console.log) // bar\n</code></pre>\n<ul>\n<li>await关键字期待（但不要求）一个实现thenable接口的对象，但常规值也可以</li>\n<li>如果是实现了thenable接口的对象，await会由await来解包，如果不是，就当做已经解决的Promise</li>\n</ul>\n<pre><code class=\"language-js\">async function bar(){\n  console.log(await ['bar'])\n}\nbar() // [\"bar\"]\n\nasync function baz(){\n  const thenable = {\n    then(callback){\n      callback('baz')\n    }\n  }\n  console.log(await thenable)\n}\nbaz() // baz\n</code></pre>\n<ul>\n<li>等待会抛出错误的同步操作，返回拒绝的期约</li>\n</ul>\n<pre><code class=\"language-js\">async function foo(){\n  console.log(1)\n  await (() => { throw 3 })()\n}\nfoo().catch(console.log)\nconsole.log(2)\n\n// 1\n// 2\n// 3\n</code></pre>\n<ul>\n<li>async中我们说到，单独的Promise.reject()不会被异步函数捕获，而是抛出未捕获错误。不过，对拒绝Promise使用await会释放错误值（将拒绝Promise返回）</li>\n</ul>\n<pre><code class=\"language-js\">async function foo(){\n  console.log(1)\n  await Promise.reject(3)\n  console.log(4) // 这行代码不执行\n}\nfoo().catch(console.log)\nconsole.log(2)\n\n// 1\n// 2\n// 3\n</code></pre>\n<ul>\n<li>await必须在异步函数中使用，不能在顶级上下文如<code>&#x3C;script></code>标签或者模块中使用，同步函数中使用await会抛出SyntaxError</li>\n<li>使用await还有一些细微之处，看下面的例子</li>\n</ul>\n<pre><code class=\"language-js\">async function foo(){\n  console.log(await Promise.resolve('foo'))\n}\nasync function bar(){\n  console.log(await 'bar')\n}\nasync function baz(){\n  console.log('baz')\n}\nfoo()\nbar()\nbaz()\n\n// baz\n// bar\n// foo\n</code></pre>\n<ul>\n<li>async/await组合中，起作用的都是await，async只是一个标识符</li>\n<li>JavaScript运行时遇到await关键字会记录在哪暂停执行。等待await右边的值可以用了，JavaScript会向消息队列中推送一个任务，任务会恢复异步函数的执行</li>\n<li>所以await后面哪怕跟了可用的值，函数的其他部分也会被异步求值</li>\n</ul>\n<pre><code class=\"language-js\">async function foo(){\n  console.log(2)\n  await null\n  console.log(4)\n}\nconsole.log(1)\nfoo()\nconsole.log(3)\n\n// 1\n// 2\n// 3\n// 4\n</code></pre>\n<ul>\n<li>\n<p>上面的执行过程可以这么解读</p>\n<ul>\n<li>打印1</li>\n<li>调用异步函数foo</li>\n<li>打印2</li>\n<li>await暂停执行，为立即可用的值null向消息队列添加一个任务</li>\n<li>foo退出</li>\n<li>打印3</li>\n<li>同步线程代码执行完成</li>\n<li>JavaScript运行时从消息队列取出任务，恢复异步执行函数</li>\n<li>foo中恢复执行，await取得null值</li>\n<li>打印4</li>\n<li>foo返回</li>\n</ul>\n</li>\n<li>当await后面是一个Promise的时候会复杂一些。这个时候，为了执行异步函数，实际有两个任务被添加到消息队列并异步求值(11TC39对await后面是Promise的情况做过处理，导致只会生成一个异步任务，因此新版浏览器中会打印 123458967)</li>\n</ul>\n<pre><code class=\"language-js\">async function foo(){\n  console.log(2)\n  console.log(await Promise.resolve(8))\n  console.log(9)\n}\n\nasync function bar(){\n  console.log(4)\n  console.log(await 6)\n  console.log(7)\n}\n\nconsole.log(1)\nfoo()\nconsole.log(3)\nbar()\nconsole.log(5)\n\n// 1\n// 2\n// 3\n// 4\n// 5\n// 6\n// 7\n// 8\n// 9\n</code></pre>\n<ul>\n<li>\n<p>运行时步骤如下</p>\n<ul>\n<li>打印1</li>\n<li>调用foo</li>\n<li>打印2</li>\n<li>await暂停执行，向消息队列添加一个Promise在落定后执行的任务</li>\n<li>Promise立即落定，把给await提供值的任务添加到消息队列</li>\n<li>foo退出</li>\n<li>打印3</li>\n<li>调用bar</li>\n<li>打印4</li>\n<li>await关键字暂停执行，为立即可用的值6向消息队列中添加任务</li>\n<li>bar退出</li>\n<li>打印5</li>\n<li>顶级线程执行完成</li>\n<li>JavaScript从消息队列中取出解决awaitPromise的处理程序，将解决值8提供给它</li>\n<li>JavaScript运行时向消息队列中添加一个恢复foo执行的任务</li>\n<li>JavaScript运行时从消息队列中取出恢复执行bar的任务及6</li>\n<li>bar恢复执行，await取得6</li>\n<li>打印7</li>\n<li>bar返回</li>\n<li>异步任务完成，JavaScript从消息队列中取出恢复foo的任务及8</li>\n<li>打印8</li>\n<li>打印9</li>\n<li>foo返回</li>\n</ul>\n</li>\n<li>使用async跟await将上面的串行Promise进行优化</li>\n</ul>\n<pre><code class=\"language-js\">async function addTwo(x){\n  return x + 2\n}\nasync function addThree(x){\n  return x + 3\n}\nasync function addFive(x){\n  return x + 5\n}\n\nasync function addTen(x) {\n  for(const fn of [addTwo, addThree, addFive]) {\n    x = await fn(x)\n  }\n  return x\n}\naddTen(9).then(console.log) // 19\n</code></pre>\n<ul>\n<li>在栈管理与内存管理中，Promise会尽可能的保留完整的调用栈，这样在抛出错误时就会更好地找到错误信息位置，但是这也意味着栈追踪信息会占用内存，带来计算与存储成本。</li>\n<li>而异步函数中JavaScript运行时会简单地在嵌套函数中存储指向包含函数的指针。这个指针存在于内存中，用于出错时追踪信息。这样就不会带来而外的消耗</li>\n<li>所以在重视性能的应用中优先考虑异步函数</li>\n</ul>","fields":{"slug":"/Promise/"},"frontmatter":{"title":"深入Promise--高程4","tags":["JavaScript回顾"],"categories":"JavaScript"}}},{"node":{"html":"<h1>window对象</h1>\n<ul>\n<li>BOM的核心是window对象，表示浏览器的实例。window在浏览器中有两重身份，一个是ECMAScript中的Global对象，一个是浏览器窗口中的JavaScript接口。</li>\n<li>意味着网页中定义的所有对象、变量、函数都以window作为其Global对象</li>\n<li>所有通过var声明的全局变量或函数都会成为window对象的属性和方法</li>\n</ul>\n<h2>窗口关系</h2>\n<ul>\n<li>top对象指向最外层窗口，即浏览器本身。</li>\n<li>parent对象指向当前窗口的父窗口。如果当前窗口是最上层窗口，则parent等于top（都等于window）</li>\n<li>还有self属性，它是终极的window属性，始终指向window。这些都是window的属性，可以通过window.top的方式来访问</li>\n<li>window对象的位置可以通过不同的属性跟方法确定，现代浏览器提供了screenLet跟screentTop属性，用于确定窗口相对于屏幕左侧跟顶部的位置，返回值的单位是css像素</li>\n<li>可以使用moveTo跟moveBy来移动窗口，都接收两个参数</li>\n<li>moveTo接收要移动到的位置的绝对坐标x很y</li>\n<li>moveBy接收相对于当前位置在两个方向上的像素数</li>\n<li>这两个方法在不同的浏览器中可能会被部分或全部禁用</li>\n</ul>\n<pre><code class=\"language-js\">window.moveTo(0, 0) // 移动到左上角\nwindow.moveTo(200, 300) // 移动到坐标 200， 300\nwindow.moveBy(0, 100) // 向下移动100\nwindow.moveBy(-50, 0) // 向左移动50\n</code></pre>\n<!--more-->\n<ul>\n<li>css像素是web开发中的统一像素单位。如果屏幕距离人眼是一臂长，那计算的css像素大小大概是1/96英寸。定义像素大小是为了不同设备统一标准。</li>\n<li>低分辨力平板设备上12像素（css像素）应该跟高清4k屏幕上12像素（css像素）的文字有同样的大小，这就让不同像素密度屏幕下有不同的缩放系数，以便将物理像素转为css像素</li>\n<li>例如：手机屏幕的物理分辨率为1920 * 1080，因为其像素非常小，所以浏览器要将其分辨率将为较低的逻辑分辨率，比如640 * 320。这个物理像素与css像素之间转换比率由window.devicePixelRatio提供。对于分辨率1920 * 1080 转换为640 * 320的设备，window.devicePixelRatio值为3。这样12像素（css像素的文字）就会实际以36像素的物理像素展示</li>\n</ul>\n<h2>窗口大小</h2>\n<ul>\n<li>所有现代浏览器支持的4个属性：innerHeight、innerWidth、outerHeight、outerWidth</li>\n<li>outerWidth跟outerHeight返回浏览器窗口自身的大小（不管在外层window还是窗口frame中）。innerHeight跟innerWidth返回浏览器窗口中页面视图的大小</li>\n<li>document.documentElement.clientHeight和document.documentElement.clientWidth返回页面视口宽度和高度</li>\n<li>浏览器窗口的精确尺寸不好确定，但可以确定页面视口的大小</li>\n</ul>\n<pre><code class=\"language-js\">let pageWidth = window.innerWidth, pageHeight = window.innerHeight\nif(typeof pageWidth !== number) {\n  if(document.compatMode == 'CSS1Compat') {\n    pageWidth = document.documentElement.clientWidth\n    pageHeight = document.documentElement.clientHeight\n  } else {\n    pageWidth = document.body.clientWidth\n    pageHeight = document.body.clientHeight\n  }\n}\n</code></pre>\n<ul>\n<li>上面我们先设置为innerWidth跟innerHeight，然后再检查是否是数值决定有没有拿到，之后再通过document.compatMode来检查是否是标准模式，如果是就使用document.documentElement的方式来获取，不是就采用document.body的形式</li>\n<li>移动设备上，window.innerWidth和window.innerHeight也是返回视口的大小，也就是屏幕上可视区域的大小。Mobile Internet Explorer支持这些属性，但在document.documentElement.clientHeight和document.documentElement.clientWidth中提供了相同的信息。放大缩小页面时，这些值也会变化</li>\n<li>其他移动浏览器中，document.documentElement.clientWidth和document.documentElement.clientHeight返回的布局视口的大小，即渲染页面的实际大小。布局视口是相对于可见视口的一个概念，可见视口只能显示整个页面的一小部分。Mobile Internet Explorer把布局视口的信息保存在document.body.clientWidth和document.body.clientHeight中。放大缩小页面时，这些值也会变。</li>\n<li>可以使用resizeTo()和resizeBy()方法调整窗口大小。接收两个参数，resizeTo接收新的宽度和高度，resizeBy接收宽度和高度各缩放多少</li>\n</ul>\n<pre><code class=\"language-js\">window.resizeTo(100, 100)\nwindow.resizeBy(100, 50)\n</code></pre>\n<ul>\n<li>与移动窗口的方法一致，缩放的方法也可能被浏览器禁用，并且部分浏览器默认禁用。缩放方法只能应用到最上层window</li>\n<li>浏览器窗口尺寸通常无法满足完整显示页面，因此用户需要滚动查看。度量文档相对于视口滚动距离的属性有两对，返回相等的值：window.pageXoffset/window.scrollX和window.pageYoffset/scrollY</li>\n<li>可以使用scoroll()、scrollTo()、scrollBy()滚动页面。三个方法都接收相对视口距离的x和y坐标，前两个方法表示要滚动到的坐标，最后一个方法表示滚动的距离</li>\n</ul>\n<pre><code class=\"language-js\">// 相对当前视口向下滚动100像素跟向右40像素\nwindow.scrollBy(0, 100)\nwindow.scrollBy(40, 0)\n//滚动到页面左上角\nwindow.scrollTo(0, 0) \nwindow.scroll(0, 0)\n</code></pre>\n<ul>\n<li>这几个方法都接收一个ScrollToOptions字典，除了提供偏移值，还可以通过beghavior属性告诉浏览器是否平滑滚动。</li>\n</ul>\n<pre><code class=\"language-js\">// 正常滚动\nwindow.scrollTo({\n  left: 100,\n  top: 100,\n  behavior: 'auto'\n})\n\n// 平滑滚动\nwindow.scrollTo({\n  left: 100,\n  top: 100,\n  behavior: 'smooth'\n})\n</code></pre>\n<h2>导航与打开新窗口</h2>\n<ul>\n<li>window.open()可以用于导航到指定url，也可以用于打开新的浏览器窗口。接收4个参数：要加载的url、目标窗口、特性字符串和表示新窗口在浏览器历史记录中是否代替当前加载页面的布尔值。通常只传前3个参数，最后一个参数只有不打开新窗口才会使用。</li>\n<li>如果第二个参数已经是一个存在的窗口或窗格（frame）的名字，则会在对应的窗口或窗格中打开URL。</li>\n</ul>\n<pre><code class=\"language-js\">window.open('http://www.wrox.com/', 'topFrame')\n</code></pre>\n<ul>\n<li>上面代码跟点击链接的形式一致，如果已经有一个窗口名叫'topFrame'，则这个窗口会打开这个URL，否则就新打开一个窗口并命名为'topFrame'，第二个参数也可以是特殊的窗口名，比如<em>self、</em>parent、<em>top、</em>blank</li>\n<li>如果第二个参数不是已有窗口就会打开新的窗口或标签页。</li>\n<li>第三个窗口为特性字符串，用于指定新窗口的配置。要是不传第三个参数，则带有所有默认的浏览器特性。打开的不是新窗口就忽略第三个参数。</li>\n<li>\n<p>特性选项表</p>\n<ul>\n<li>fullscreen: \"yes\" 或 \"no\"，表示窗口是否最大化</li>\n<li>height: 数值，新窗口高度，不小于100</li>\n<li>left: 数值，窗口x坐标，不能是负值</li>\n<li>location: \"yes\"或\"no\"，是否显示地址栏</li>\n<li>Menubar: \"yes\"或\"no\"，是否显示菜单栏</li>\n<li>resizable: \"yes\"或\"no\"，是否可以拖动改变新窗口大小</li>\n<li>scrollbars: \"yes\"或\"no\"，内容过长时是否可以滚动</li>\n<li>status: \"yes\"或\"no\"，是否显示状态栏</li>\n<li>toolbar: \"yes\"或\"no\"，是否显示工具栏</li>\n<li>top: 数值，新窗口的y值，不能为负值</li>\n<li>width: 数值，新窗口宽度，不能小于100</li>\n</ul>\n</li>\n<li>这些设置需要以逗号分割的键值对出现，特性字符串不能有空格</li>\n</ul>\n<pre><code class=\"language-js\">window.open('http://www.wrop.com/', 'wroxWindow', 'height=400,width=300,top=10,left=10,resizable=yes')\n</code></pre>\n<ul>\n<li>上面会打开一个可缩放的窗口，大小为400 * 300，位于屏幕左边即上面各10像素</li>\n<li>window.open返回一个对新窗口的引用。这个对象跟普通window对象一样，只是为控制新窗口提供了便利。某些浏览器不允许缩放跟移动主窗口，但是允许缩放和移动通过open打开的新窗口。</li>\n</ul>\n<pre><code class=\"language-js\">let worxWin1 = window.open('http://www.wrop.com/', 'wroxWindow1', 'height=400,width=300,top=10,left=10,resizable=yes')\nworxWin1.resizeTo(500, 500)\nworxWin1.moveTo(100, 100)\nworxWin1.close()\nconsole.log(worxWin1.closed) // true\n</code></pre>\n<ul>\n<li>还可以使用close关闭open创建的窗口，关闭窗口后，窗口引用还在，但只能检查closed属性了</li>\n<li>新创建窗口的window对象有一个opener指向打开它的窗口。这个属性只在弹出窗口的最上层window对象有定义，指向调用window.open打开它的窗口的指针</li>\n<li>某些浏览器标签页在独立进程中运行，如果一个标签页打开了另一个，而window对象需要跟另一个标签页通信，那标签便不能运行在独立的进程中。这些浏览器中可以将打开标签页的opener设为null，表示新打开的标签页可以运行在独立的进程中。</li>\n<li>把opener设置为null表示新打开的标签页不需要与打开它的标签页通信，因此可以独立进程运行。这个链接一旦切断无法恢复</li>\n</ul>\n<h2>安全限制</h2>\n<ul>\n<li>弹出窗口刚开始被在线广告给滥用，将广告伪装成系统对话框，诱导用户点击。为了让用户区分，浏览器对弹窗做了限制</li>\n<li>IE7开始，地址栏不能隐藏了，弹窗默认不可缩放不可移动。Firefox禁用了隐藏状态栏的功能，Firefox强制弹窗始终显示地址栏。Opera只能在主窗口打开新窗口，不允许它们出现在系统对话框内。</li>\n<li>浏览器需要在用户允许时才能创建弹窗。网页加载中创建弹窗无效还可能报错。要点击或者按下键才可以打开弹窗</li>\n<li>现在浏览器内置了屏蔽程序，如果屏蔽程序屏蔽了弹窗，那window.open会返回null，可以通过这个来判断弹窗是否被屏蔽</li>\n</ul>\n<pre><code class=\"language-js\">let wroxWin = window.open('http://www.wrox.com', \"_blank\")\nif(wroxWin === null) {\n  console.log('the popup was blocked')\n}\n</code></pre>\n<ul>\n<li>浏览器拓展或者其他程序屏蔽弹窗时，window.open通常会抛出错误，因此要准确检测弹窗是否被屏蔽，除了检测window.open的返回值，还要将它用try/catch包裹</li>\n</ul>\n<pre><code class=\"language-js\">let blocked = false\ntry {\n  let wroxWin = window.open('http://www.wrox.com', \"_blank\")\n  if(wroxWin === null) {\n    console.log('the popup was blocked')\n    blocked = true\n  }\n} catch(e) {\n  blocked = true\n}\n\nblocked &#x26;&#x26; console.log(blocked)\n</code></pre>\n<h2>定时器</h2>\n<ul>\n<li>setTimeout的第二个参数是告诉JavaScript引擎在指定的毫秒数后将任务添加到任务队列，任务队列如何是空的，会立即执行，如果不是空的，需要等前面的任务执行完才能执行</li>\n<li>所有setTimeout执行的代码都会在全局作用域的一个匿名函数中执行，因此函数中的this在非严格模式下都是window，在严格模式下是undefined。要是提供的是箭头函数，this会保留它定义时所在的作用域</li>\n<li>setInterval的第二个参数是向队列添加新任务前的等待时间。它不关心任务什么时候执行或者执行花多长时间，是否有阻塞，只会往队列内添加任务</li>\n<li>setInterval在实践中很少会在生产环境下使用，因为一个任务跟下一个任务之间的时间间隔是无法确定的，有些循环定时任务就可能会被跳过。setTimeout就能确保不出现这种情况</li>\n<li>所以一般来说最好不要用setInterval。我们可以使用setTimeout来替换</li>\n</ul>\n<h2>系统对话框</h2>\n<ul>\n<li>alert接收一个字符串并弹出一个只有确认按钮的弹窗，只接受字符串，非字符串会使用toString转为字符串</li>\n<li>confirm确认框，有两个按钮，取消和确认。返回值为按钮的点击情况，true表示点击了确认，false表示点击了取消</li>\n</ul>\n<pre><code class=\"language-js\">if(confirm('Are you sure')) {\n  console.log('I am sure')\n} else {\n  console.log('I am sorry')\n}\n</code></pre>\n<ul>\n<li>prompt提供一个供用户输入的提示框，也有取消和确认的按钮，还有一个输入文本框。prompt()接收两个参数：要显示给用户的文本，以及文本框的默认值。</li>\n<li>点击确认按钮，该方法返回文本框中的值，点击取消按钮，或者被关闭，该方法返回null</li>\n</ul>\n<pre><code class=\"language-js\">let result = prompt(\"What is your name ?\", \"\")\nif(result !== null) {\n  console.log(`welcome ${ result }`)\n}\n</code></pre>\n<ul>\n<li>很多浏览器对系统对话框加了特殊功能。如果网页中的脚本生成了两个或更多的对话框，则除第一个外的对话框都展示一个复选框，用户选中就会禁用后续的弹窗，直到页面刷新。</li>\n<li>用户选中复选框，那在页面刷新之前，所有系统对话框都被拼比，开发者无法获取弹窗是否显示了。要是用户两次独立的操作产生的警告框，不会显示复选框，要是一次操作产生的就会产生复选框</li>\n<li>find()是异步显示，跟用户在浏览器菜单选择查找时一致</li>\n<li>print()也是异步显示，跟用户在浏览器选择打印时显示的一致，不受用户禁用弹窗的限制</li>\n</ul>","fields":{"slug":"/BOM-window/"},"frontmatter":{"title":"BOM —— window对象","tags":["JavaScript回顾"],"categories":"JavaScript"}}},{"node":{"html":"<h1>location对象与navigator对象</h1>\n<h2>location对象</h2>\n<ul>\n<li>location是常用的BOM对象，提供了当前窗口中加载文档的信息，以及常用的导航功能</li>\n<li>它既是window属性，也是document属性，window.location跟document.location两个指向同一个对象</li>\n<li>location对象保存着当前加载文档的信息，还有URL解析为离散片段后能够属性访问的信息。</li>\n<li>\n<p>以下URL来做实例 \"<a href=\"http://ouser:barpassword@www.wrox.com:80/WileyCDA/?q=javascript#contents\">http://ouser:barpassword@www.wrox.com:80/WileyCDA/?q=javascript#contents</a>\"</p>\n<ul>\n<li>location.hash: '#contents',散列值，#后跟零或者多个字符串，没有就是空字符串</li>\n<li>location.host: 'www.wrox.com:80'，服务器名及端口号</li>\n<li>locaion.hostname: 'www.wrox.com'，服务器名</li>\n<li>location.href: '<a href=\"http://www.wrox.com:80/WileyCDA/?q=javascript#contents&#x27;\">http://www.wrox.com:80/WileyCDA/?q=javascript#contents'</a>, 当前加载页面的完整URL。location.toString就返回这个值</li>\n<li>location.pathname: '/WileyCDA/'，URL中的路径和（或）文件名</li>\n<li>location.port: \"80\"，请求的端口，如果URL中没有端口返回空字符串</li>\n<li>location.portocol: 'http:'，页面使用协议，一般是\"http:\"或\"https:\"</li>\n<li>location.search: \"?q=javascript\"，URL的查询字符串，以问号开头</li>\n<li>location.username: 'ouser'，域名前指定的用户名</li>\n<li>location.password: 'barpassword'，域名前指定的密码</li>\n<li>location.origin: '<a href=\"http://www.wrox.com&#x27;%EF%BC%8CURL%E7%9A%84%E6%BA%90%E5%9C%B0%E5%9D%80%EF%BC%8C%E5%8F%AA%E8%AF%BB\">http://www.wrox.com'，URL的源地址，只读</a></li>\n</ul>\n</li>\n<li>\n<p>URL中的多数信息都能通过以上方法获取，search中的查询字符串就需要我们单独处理了</p>\n<!--more-->\n<pre><code class=\"language-js\">function getQueryStringArgs (search){\nlet qs = (search.length > 0 ? search.substring(1) : '')\nlet args = {}\nfor(let item of qs.split('&#x26;').map(kv => kv.split('='))) {\nlet name = decodeURIComponent(item[0]), value = decodeURIComponent(item[1])\nif(name.length) {\n  args[name] = value\n}\n}\nreturn args\n}\nlet qs = '?q=javascript&#x26;num=10'\nconsole.log(getQueryStringArgs(qs)) // {q: \"javascript\", num: \"10\"}\n</code></pre>\n</li>\n<li>URLSearchParams提供了标准API来检查和修改字符串。给URLSearchParams构造函数传入一个查询字符串，就可以创造一个实例，实例暴露了get()、set()、delete()等方法。</li>\n<li>大多数支持URLSearchParams的浏览器也都支持URLSearchParams作为迭代对象</li>\n</ul>\n<pre><code class=\"language-js\">let qs = '?q=javascript&#x26;num=10'\nlet searchParams = new URLSearchParams(qs)\n\nfor(let params of searchParams) {\n  console.log(params)\n}\n// [\"q\", \"javascript\"]\n// [\"num\", \"10\"]\n\nconsole.log(searchParams.toString()) // q=javascript&#x26;num=10\nconsole.log(searchParams.has(\"num\")) // true\nconsole.log(searchParams.get(\"num\")) // 10\nsearchParams.set(\"page\", \"3\")\nconsole.log(searchParams.toString()) // q=javascript&#x26;num=10&#x26;page=3\nsearchParams.delete(\"q\")\nconsole.log(searchParams.toString()) // num=10&#x26;page=3\n</code></pre>\n<ul>\n<li>可以通过修改location对象修改浏览器地址。常用的是使用assign并传入URL</li>\n</ul>\n<pre><code class=\"language-js\">location.assign('http://www.wrox.com')\n</code></pre>\n<ul>\n<li>这行代码会启动导航到新URL，同时在浏览器历史记录中加一条。给location.href或window.location设置一个url也会以同一个URL来调用assign方法，下面的方法跟显示调用assign一样</li>\n</ul>\n<pre><code class=\"language-js\">window.location = 'http://www.wrox.com'\nlocation.href = 'http://www.wrox.com'\n</code></pre>\n<ul>\n<li>修改location对象的属性也会修改当前加载页面。hash、search、hostname、pathname、port设置后都会修改当前URL，如下例所示</li>\n</ul>\n<pre><code class=\"language-js\">// 假设当前URL为 http://www.wrox.com/WileyCDA/\n// 修改为 http://www.wrox.com/WileyCDA/#section1\nlocation.hash = '#section1'\n// 修改为 http://www.wrox.com/WileyCDA/?q=javascript\nlocation.search = '?q=javascript'\n// 修改为 http://www.somewhere.com/WileCDA/\nlocation.hostname = 'www.somewhere.com'\n// 修改为 http://www.wrox.com/myDir/\nlocation.pathname = 'myDir'\n// 修改为 http://www.wrox.com:8080/WileyCDA/\nlocation.port = 8080\n</code></pre>\n<ul>\n<li>除hash外，只要修改location的属性，就会导致页面重新加载URL</li>\n<li>修改hash的值会在浏览器历史中新增一个记录。早期的IE浏览器点击后退跟前进不会更新hash属性，只有点击包含散列的URL才会更新hash值</li>\n<li>前面的方式修改URL后都会在历史记录中新增URL。点击后退就会返回到前页面，使用replace()方法可以不添加历史记录</li>\n<li>reload()可以重新加载当前的页面，不传参数会议最有效的方式加载，如果页面从上次请求后没有修改过，会从缓存加载。要强制从服务器重新加载，可以传一个true来让它强制从服务器加载，reload之后的代码可能执行可能不执行，取决于当前的网络延迟与系统资源</li>\n</ul>\n<h2>navigator对象</h2>\n<ul>\n<li>navigator是客户端标识浏览器的标准，浏览器启动JavaScript就会存在navigator对象。</li>\n<li>\n<p>每个浏览器都有自己支持的属性。navigator主要实现了下列属性和方法</p>\n<ul>\n<li>activeVrDisplays: 返回数组，包含ispresenting为true的VRDisplay实例</li>\n<li>appCodeName: 非Mozilla也会返回\"Mozilla\"</li>\n<li>appName: 浏览器全名</li>\n<li>appVersion: 浏览器版本，一般跟实际版本不符合</li>\n<li>battery: 返回暴露Battery Status API的BatteryManager对象</li>\n<li>buildId: 浏览器的构建编号</li>\n<li>connection: 返回暴露Network Information API的NetworkInformation对象</li>\n<li>cookieEnable: 布尔值表示是否启用了cookie</li>\n<li>credentials: 返回暴露Credentials Management API的CredentialsContainer对象</li>\n<li>deviceMemory: 返回单位为GB的设备内存容量</li>\n<li>doNotTrack: 返回用户的“不跟踪”(do-not-track)设置</li>\n<li>geolocation: 返回暴露Gelolocation</li>\n<li>getVRDisplays(): 返回数组，包含可用的每个VRDisplay实例</li>\n<li>getUserMedia(): 返回与可用媒体设备硬件关联的流</li>\n<li>hardwareConcurrency: 返回设备的处理器设备核心</li>\n<li>javaEnabled: 返回是否启用java的布尔值</li>\n<li>language: 返回浏览器的主语言</li>\n<li>languages: 返回浏览器偏好的语言数组</li>\n<li>locks: 返回暴露 Web Locks API的LockManager对象</li>\n<li>mediaCapabilities: 返回暴露MediaCapabilities API的MediaCapabilities对象</li>\n<li>mediaDevices: 返回可用的媒体设备</li>\n<li>maxTouchPoints: 返回设备触摸屏支持的最大触点数</li>\n<li>mimeTypes: 返回浏览器注册的MIME类型数组</li>\n<li>onLine: 返回表示浏览器是否联网的布尔值</li>\n<li>oscpu: 返回浏览器运行设备的操作系统和CPU</li>\n<li>permissions: 返回暴露Permissions API的Permissions对象</li>\n<li>platform: 返回浏览器运行的系统平台</li>\n<li>plugins: 返回浏览器中安装的插件数组，IE中包含页面中的所有<embed>元素</li>\n<li>product: 返回产品名称（一般是\"Gecko\"）</li>\n<li>productSub: 返回产品的额外信息（一般是Gecko的版本）</li>\n<li>registerProtocolHandler(): 讲一个网站注册为特定协议的处理程序</li>\n<li>requestMediaKeySystemAccess(): 返回一个Promise，解决为MediaKeySystemAccess对象</li>\n<li>sendBeacon(): 异步传输小数据</li>\n<li>serviceWorker: 返回用来与ServiceWorker实例交互的ServiceWorkerContainer</li>\n<li>share(): 返回当前平台的原生共享机制</li>\n<li>storage: 返回暴露Storage API的StorageManger对象</li>\n<li>userAgent: 返回浏览器的用户代理字符串</li>\n<li>verdor: 返回浏览器的产商名称</li>\n<li>verdorSub: 返回浏览器厂商的更多信息</li>\n<li>vibrate()：触发设备震动</li>\n<li>webdriver:返回浏览器是否能被自动化程序控制</li>\n</ul>\n</li>\n<li>navigator一般用来判断浏览器的类型</li>\n<li>\n<p>检测插件，除IE10以下的浏览器都可以根据plugins数组来确定。数组中的每一项都有如下属性</p>\n<ul>\n<li>name: 插件名称</li>\n<li>description: 插件介绍</li>\n<li>filename: 插件的文件名</li>\n<li>length: 由当前插件处理的MIME类型数量</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"language-js\">function hasPlugin(name){\n  name = name.toLowerCase()\n  for(let plugin of window.navigator.plugins) {\n    if(plugin.name.toLowerCase().indexOf(name) > -1) {\n      return true\n    }\n  }\n  return false\n}\n</code></pre>\n<ul>\n<li>plugins数组中的每个插件对象都有一个MimeType对象，可以通过中括号访问。每个MimeType都有四个属性：descriptor描述MIME类型，enabledPlugin是指向该插件的指针，suffixes是该MIME类型对应拓展名的逗号分割的字符串，type是完整的MIME类型字符串。</li>\n<li>IE11的window.navigator支持plugins和mimeTypes属性。IE11中的ActiveXObject从DOM中隐身，不可再用来检测特性</li>\n<li>IE10及以下的版本检测插件比较麻烦，因为不支持Netscape式的插件。要使用ActiveXObject，并尝试实例化特定插件。</li>\n<li>IE中的插件实习为COM对象，由唯一字符串标识。所以检测插件就必须知道COM标识符。Flah的标识符是\"ShockwaveFlash.ShockwaveFlash\"，有了信息就可以检测插件了</li>\n</ul>\n<pre><code class=\"language-js\">function hasIEPlugin(name){\n  try{\n    new ActiveXObject(name)\n    return true\n  } catch(e) {\n    return false\n  }\n}\n</code></pre>\n<ul>\n<li>plugins有一个refresh()方法，用于刷新plugins属性以反映新安装的插件。接受一个参数布尔值表示刷新时是否重新加载页面。传入true则所有包含插件的页面都会重新加载，否则只刷新plugins，不会从新加载页面</li>\n</ul>\n<h2>注册处理程序</h2>\n<ul>\n<li>现代浏览器支持navigator上的registerProtocolHandler()方法。可以把一个网站注册为处理某种特定类型信息应用程序。在线SSR阅读器跟电子邮件客户端的流行，可以借助这个方法将Web应用程序注册为像桌面软件一样的默认程序。</li>\n<li>使用registerProtocolHandler()方法，必须传入3个参数：要处理的协议（如\"mailto\"或\"ftp\"）、处理该协议的URL、以及应用名称。如下</li>\n</ul>\n<pre><code class=\"language-js\">navigator.registerProtocolHandler('mailto', 'http://www.somemailcient.com?cmd=%s', 'Some Mail Client')\n</code></pre>\n<ul>\n<li>这个例子为\"mailto\"协议注册一个处理程序，这样邮件地址就可以通过指定的Web应用程序打开。第二个参数是负责处理请求的URL，%s表示原始请求</li>\n</ul>\n<h2>screen对象</h2>\n<ul>\n<li>\n<p>screen对象保存纯粹的客户端能力信息，也就是浏览器窗口外面的客户端显示器的信息，比如像素宽度与像素高度。属性如下</p>\n<ul>\n<li>availHeight: 屏幕像素高度减去系统组件高度（只读）</li>\n<li>availLeft: 没有被系统组件占用的屏幕最左侧像素（只读）</li>\n<li>availTop: 没有被系统组件占用的屏幕最顶端像素（只读）</li>\n<li>availWidth: 屏幕像素宽度减去系统组件宽度（只读）</li>\n<li>colorDepth: 屏幕颜色的位数，多数系统是32（只读）</li>\n<li>height: 屏幕像素高度</li>\n<li>left: 当前屏幕左边的像素距离</li>\n<li>pixelDepth: 屏幕的位深（只读）</li>\n<li>top:当前屏幕顶端的像素距离</li>\n<li>width:屏幕像素宽度</li>\n<li>orientation:返回Screen Orientation API中屏幕朝向</li>\n</ul>\n</li>\n</ul>\n<h2>history</h2>\n<ul>\n<li>history对象表示当前窗口建立以来用户的导航历史记录。对象不会对外暴露用户访问过的URL，可以在不知道实际URL的情况下前进和后退</li>\n<li>go()可以在用户历史记录中前进和后退。只接受一个参数，表示前进或后退多少。负值表示后退（类似点击浏览器的后退按钮），正值表示历史记录中前进</li>\n</ul>\n<pre><code class=\"language-js\">history.go(-1) // 后退一页\nhistory.go(1) // 前进一页\nhistory.go(2) // 前进两页\n</code></pre>\n<ul>\n<li>部分旧版浏览器中，go()方法参数可以是一个字符串，这种情况下浏览器会导航到历史中包含该字符串的第一个位置。可能前进也可能后退。如果没有匹配到就什么也不做</li>\n<li>go()有两个简写方法：back()与forward()</li>\n</ul>\n<pre><code class=\"language-js\">history.go('wrox.com')\nhistory.back()\nhistory.forawrd()\n</code></pre>\n<ul>\n<li>history对象还有一个length属性，表示有多个条目，对于第一个页面，history.length为1，通过这个方法可以确定用户浏览起点是不是你的页面</li>\n</ul>\n<h2>历史状态管理</h2>\n<ul>\n<li>hashChange在页面URL散列发生变化时被触发，开发者可以执行部分操作。状态管理API就可以让开发者改变浏览器URL而不用加载新页面。使用history.pushState()方法。接收3个参数：一个state对象、一个新状态的标题和一个（可选的）相对URL：例如</li>\n</ul>\n<pre><code class=\"language-js\">let stateObject = {foo: 'bar'}\nhistory.pushState(stateObject, 'My title', 'baz.html')\n</code></pre>\n<ul>\n<li>pushState方法执行后，状态信息会被推到历史记录中，浏览器地址栏会改变。除了这个变化外，即使location.href返回的是地址栏中的内容，浏览器也不会发送请求。第二个参数并未被当前实现使用，所以可以传一个空字符串或者一个短标题。</li>\n<li>第一个参数应该包含正确初始化页面状态所需的信息。状态大小有限制，通常在500k-1M以内</li>\n<li>pushState()会创建新的历史记录，所以会启用后退按钮，点击后退触发window对象的popstate事件。popstate事件有一个state属性，包含通过pushState第一个参数传入的state对象：</li>\n</ul>\n<pre><code class=\"language-js\">window.addEventListener('popstate', (event) => {\n  let state = event.state\n  if(state) {\n    console.log(state)\n  }\n})\n</code></pre>\n<ul>\n<li>基于这个状态应该把页面重置为状态锁边傲视的状态（浏览器不会为你做这些）。页面初次加载时没有状态，所以点击后退返回到最初页面时，event.state为null</li>\n<li>可以通过history.state获取当前的状态对象，也可以使用replaceState()并传入与pushState同样的前两个参数来更新状态。更新状态不会创建新历史，只会覆盖当前状态：</li>\n</ul>\n<pre><code class=\"language-js\">history.replaceState({ newFoo: 'newBar' }, 'New Title')\n</code></pre>\n<ul>\n<li>传给pushState与replaceState的state对象应该只包含可以被序列化的内容。所以DOM信息不适合放到状态对象里面。</li>\n</ul>","fields":{"slug":"/locationAndNavigator/"},"frontmatter":{"title":"location对象与navigator对象","tags":["JavaScript回顾"],"categories":"JavaScript"}}},{"node":{"html":"<h1>客户端检测</h1>\n<ul>\n<li>客户端在Web开发中是绕不过的话题，浏览器之间的差异与奇异行为，让我们必须使用客户端检测来进行补救，常见的补救方式为先设计最常用的方案，然后针对其他浏览器进行补救</li>\n</ul>\n<h2>能力检测</h2>\n<ul>\n<li>能力检测基于JavaScript测试浏览器是否支持某种特性，不需要知道浏览器的信息，只需要知道这种能力浏览器是否存在即可，常见的IE5之前没有document.getElementById()方法，但可以通过document.all属性实现同样的功能</li>\n</ul>\n<pre><code class=\"language-js\">function getElement(id){\n    if(document.getElementById){\n        return document.getElementById(id)\n    } else if(document.all) {\n        return document.all[id]\n    } else {\n        throw new Error('No way to retrive element')\n    }\n}\n</code></pre>\n<ul>\n<li>能力检测最有效的就是检测属性不仅存在，还要能够有预期的表现，以确定一个对象是否可以排序时</li>\n</ul>\n<pre><code class=\"language-js\">// 错误形式\nfunction isSortable(object) {\n    return !!object.sort\n}\nisSortable({ sort: true })\n\n// 正确形式\nfunction isSortable(object){\n    return typeof object.sort === 'function'\n}\n</code></pre>\n<!--more-->\n<ul>\n<li>恰当的使用能力检测可以分析运行代码的浏览器，一般将这些按照能力归类浏览器的操作集中进行，不用等到执行代码在检测</li>\n</ul>\n<pre><code class=\"language-js\">// 浏览器是否支持Netscape式的插件\nlet hasNSPugins = !!(navigator.plugins &#x26;&#x26; navigator.plugins.length)\n// 是否具有DOM Level 1 能力\nlet hasDom1 = !!(document.getElementById &#x26;&#x26; document.createElenment &#x26;&#x26; document.getElementByTagName)\n</code></pre>\n<ul>\n<li>下面是根据浏览器独特行为判断浏览器身份的方法</li>\n</ul>\n<pre><code class=\"language-js\">class BrowserDetector {\n    constructor(){\n        // IE6 - IE 10\n        this.isIE_Gte6Lte10 = /*@cc_on!@*/false\n        // IE7 - 11支持\n        this.isIEGte7Lte11 = !!document.documentMode\n        // Edge 20及以上\n        this.isEdge_Gte20 = !!window.StyleMedia\n        // 所有Firefox\n        this.isFirefox_Gte1 = typeof InstanllTrigger !== 'undefined'\n        // chrome对象\n        this.isChrome_Gte1 = !!window.chrome &#x26;&#x26; !!window.chrome.webstore\n        // safari 3-9.1\n        this.isSafari_Gte3Lte9_1 = /constructor/i.test(window.Element)\n        // safari 7.1及以上\n        this.isSafari_Gte7_1 = (({ pushNotification = {} } = {}) => pushNotification.toString() == '[object SafariRemoteNotification]')(window.safari)\n        // opera 20及以上\n        this.isOpera_Gte20 = !!window.opr &#x26;&#x26; !!window.opr.addons\n    }\n\n    isIE(){\n        return this.isIE_Gte6Lte10 || this.isIEGte7Lte11\n    }\n    isEdge(){\n        return this.isEdge_Gte20 &#x26;&#x26; !this.isIE()\n    }\n    isFirefox(){\n        return this.isFirefox_Gte1\n    }\n    isChrome(){\n        return this.isChrome_Gte1\n    }\n    isSafari(){\n        return this.isSafari_Gte3Lte9_1 || this.isSafari_Gte7_1\n    }\n    isOpera(){\n        return this.isOpera_Gte20\n    }\n}\n</code></pre>\n<h2>用户代理检测</h2>\n<ul>\n<li>用户代理检测可以通过浏览器的用户代理字符串确定使用的浏览器。用户代理字符串包含在每个http请求头的头部，JavaScript中可以通过navigator.useAgent访问。在服务器端，浏览器通过用户代理字符串确定浏览器并执行操作。</li>\n<li>但在客户端，用户代理字符串都被认为不可靠，因为很长一段时间，浏览器都通过用户代理字符串包含错误或诱导信息欺骗服务器</li>\n<li>http规范（1.0和1.1）要求浏览器要向服务器发送包含浏览器名称和版本信息的简短字符串。一般要求用户代理字符串应该以“标记/版本”形式的产品列表</li>\n<li>为分析代码运行在什么浏览器下，开发者一般会用window.navigator.userAgent返回的字符串值来分析。</li>\n<li>相比于能力检测，用户代理检测的优势在于：能力检测可以保证脚本不必理会浏览器而正常执行。现代浏览器用户代理字符串的过去、现在和未来都是有章可循的，可以准确识别。</li>\n</ul>\n<h2>伪造用户代理</h2>\n<ul>\n<li>通过检测用户代理来识别浏览器并不是完美的方式，因为它可以造假。不过所有实现window.navigator对象的浏览器都提供userAgent只读属性，简单的给它设置其他值不会生效。</li>\n<li>但是有很多简单的方法可以绕过这个限制，有些浏览器提供了<strong>defineGetter</strong>方法，利用它可以篡改用户代理字符串</li>\n</ul>\n<pre><code class=\"language-js\">console.log(window.navigator.userAgent)\n\nwindow.navigator.__defineGetter__('userAgent', () => 'foo')\nconsole.log(window.navigator.userAgent)\n</code></pre>\n<ul>\n<li>所以如果我们相信浏览器返回的用户代理字符串，那就可以用来判断浏览器。如果怀疑脚本或浏览器修改，那还是使用能力检测</li>\n</ul>","fields":{"slug":"/client_detect/"},"frontmatter":{"title":"客户端检测--高程4","tags":["JavaScript回顾"],"categories":"JavaScript"}}},{"node":{"html":"<h1>DOM</h1>\n<ul>\n<li>文档对象类型（DOM,Document Object Model）是HTML和XML文档的编程接口。DOM表示由多层节点构成的文档，通过它开发者可以添加、删除、修改页面部分。DOM现在是真正跨平台、语言无关的表示和操作王爷的方式。</li>\n<li>IE8及以下的DOM都是通过COM对象实现的，也就是这些版本中的DOM对象与原生JavaScript具有不同的行为和功能。</li>\n<li>document为每个文档的根节点。根节点的唯一子节点是html，我们成为文档元素(documentElement)，每个文档只能有一个文档元素。HTML页面中，文档元素始终是<html>元素，XML文档中就没有这个限制。</li>\n<li>DOM中有12中节点类型，这些类型都继承一种基本类型。</li>\n</ul>\n<h2>Node类型</h2>\n<ul>\n<li>DOM Level 1描述了名为Node的接口，这个接口是所有DOM节点类型都必须实现的。Node接口在JavaScript中被实现为Node类型，除IE外的所有浏览器都可以直接访问这个类型。所有节点类型都继承Node类型，因此所有类型都共享相同的基本属性和方法</li>\n<li>\n<p>每个节点都有nodeType属性，表示该节点的类型，类型值如下</p>\n<ul>\n<li>Node.ELEMENT_NODE (1)</li>\n<li>Node.ATTRIBUTE_NODE (2)</li>\n<li>NODE.TEXT_NODE (3)</li>\n<li>NODE.CDATA<em>SECTION</em>NODE (4)</li>\n<li>NODE.ENTITY<em>REFERENCE</em>NODE (5)</li>\n<li>NODE.ENTITY_NODE (6)</li>\n<li>NODE.PROCESSING<em>INSTRUCTION</em>NODE (7)</li>\n<li>NODE.COMMENT_NODE (8)</li>\n<li>NODE.DOCUMENT_NODE (9)</li>\n<li>NODE.DOCUMENT<em>TYPE</em>NODE (10)</li>\n<li>NODE.DOCUMENT<em>FRAGMENT</em>NODE (11)</li>\n<li>NODE.NOTATION_NODE (12)</li>\n</ul>\n</li>\n<li>\n<p>节点类型可以与这些常量对比</p>\n<!--more-->\n<pre><code class=\"language-js\">if(someNode.nodeType == NODE.ELEMENT_NODE) {\nconsole.log(\"Node is an element\")\n}\n</code></pre>\n</li>\n<li>nodeName与nodeValue保存节点的相关信息，使用前最好先检测节点类型，对元素而言，nodeName始终为元素的标签名，nodeValue则为null</li>\n</ul>\n<pre><code class=\"language-js\">if(someNode.nodeType == 1) {\n    value = someNode.nodeName // 元素的标签名\n}\n</code></pre>\n<ul>\n<li>每个节点都有一个childNodes属性，包含一个NodeList的实例。NodeList是一个类数组对象那个，用于存储按位置存储的有序节点。</li>\n<li>NodeList是对DOM的查询，DOM的变动会自动在NodeList中反映出来，我们说的NodeList是实时的活动对象，不是第一次访问时所获得内容的快照</li>\n<li>可以使用中括号或者使用item()方法访问NodeList中的元素</li>\n</ul>\n<pre><code class=\"language-js\">let firstChild = someNode.childNodes[0]\nlet secondChild = someNode.childNodes.item(1)\n</code></pre>\n<ul>\n<li>每个节点都有一个parentNode属性，指向DOM树中的父元素。childNodes所有节点都有一个父元素，所以它们的parentNode都指向同一个节点，而且childNodes列表中的每个节点都是其他节点的同胞节点，可以使用previousSibling和nextSibling可以用来在其中导航。列表第一个元素的previousSibling跟最后一个节点的nextSibling属性都是null</li>\n<li>父节点的firstChild属性与lastChild属性分别指向它的第一个和最后一个子节点。只有一个子节点，firstChild与lastChild指向同一个节点，没有子节点就都是null</li>\n<li>一个节点可以调用hasChildNodes()返回true说明节点有一个或多个子节点。</li>\n<li>所有节点都共享的关系。ownerDocument属性是指向整个文档的文档节点的指针。</li>\n</ul>\n<h2>操纵节点</h2>\n<ul>\n<li>appendChild()用于在childNodes列表尾部添加节点，并更新相关的关系指针（如firstChild等），返回值为新添加的节点</li>\n</ul>\n<pre><code class=\"language-js\">let returnNode = someNode.appendChild(newNode)\nconsole.log(returnNode === newNode) // true\nconsole.log(someNode.lastChild === newNode) // true\n</code></pre>\n<ul>\n<li>如果把文档中已经存在的节点传入appendChild中，那这个节点会被移动到新位置。如果传入了这个节点的第一个子节点，那这个子节点就会变成最后一个子节点</li>\n<li>可以使用insertBefore()将节点放到childNodes中的特定位置，接受两个参数：要插入的节点和参照节点，调用方法后，插入的节点变成参照节点的前一个节点，并被返回，如果参照节点为null，那调用效果与appendChild相同</li>\n<li>replaceChild()接受两个参数：要插入的节点和要替换的节点，要替换的节点会被返回并从文档中移除。</li>\n<li>removeChild()可以移除节点，接收一个参数：要移除的节点，被移除的节点会被返回</li>\n<li>所有节点类型还共享了两个方法</li>\n<li>cloneNode()会返回一个与节点一样的节点。接收一个参数表示是否深复制。为true时执行深复制，即复制节点与整个子DOM树。为false时只会复制调用该方法的节点。返回的节点属于文档所有，但没有指定父节点，也叫做孤儿节点</li>\n</ul>\n<pre><code class=\"language-js\">&#x3C;ul>\n    &#x3C;li>item 1&#x3C;/li>\n    &#x3C;li>item 2&#x3C;/li>\n    &#x3C;li>item 3&#x3C;/li>\n&#x3C;/ul>\n\n// Mylist保存对上面元素的引用\nlet deepList = Mylist.cloneNode(true)\nconsole.log(deepList.childNodes.length) // 3\nlet deepList = Mylist.cloneNode(false)\nconsole.log(deepList.childNodes.length) // 0\n</code></pre>\n<ul>\n<li>cloneNode不会复制添加到DOM节点的JavaScript属性（事件处理程序等），指挥复制HTML属性以及可选的复制子节点。IE在很长时间内会复制事件处理程序，所以推荐在复制前先删除事件处理程序</li>\n<li>另一个是normalize()方法，唯一的作用就是处理文档子树中的文本节点。由于解析器或者DOM等操作导致出现不包含文本的文本节点或者两个相邻的文本节点。调用normalize()方法后会检测这个节点的所有后代，发现空文本节点就删除，相邻文本节点就合并</li>\n</ul>\n<h2>Document类型</h2>\n<ul>\n<li>\n<p>Document类型是JavaScript中表示文档类型的类型。浏览器中，文档对象document是HTMLDocument的实例（HTMLDocument继承Document），表示整个HTML页面。document是window对象的属性，因此是全局对象，有以下特征</p>\n<ul>\n<li>nodeType等于9</li>\n<li>nodeName为\"#document\"</li>\n<li>nodeValue为null</li>\n<li>ownerDocument值为null</li>\n<li>子节点可以为DocumentType(最多一个)、Element(最多一个)、ProcessingInstruction或Comment类型</li>\n</ul>\n</li>\n<li>Document类型可以表示HTML页面或其他XML文档，最常用的还是通过HTMLDocument取得document对象，document对象可以用于获取页面信息和操纵其外观和底层结构</li>\n<li>document.documentElement属性始终指向HTML中的html元素</li>\n<li>document.body始终指向body元素</li>\n<li>Document类型另一种可能的子节点DocumentType，&#x3C;!doctype>标签是文档中独立部分，信息可以通过document.doctype访问</li>\n<li>document.title可用于读写页面的标题</li>\n<li>document.URL包含页面的完整URL</li>\n<li>document.domain获取当前页面的域名</li>\n<li>document.referrer包含链接到当前页面的那个页面的URL，如果当前页面没有来源，那document.referrer包含空字符串。所有这些信息都可以在HTTP头部信息获取。</li>\n<li>这些属性中只有域名是可设置的，出于安全考虑，给domain设置的值有限制，如果URL包含子域名如p2p.wrox.com，则可以设置为\"wrop.com\"，不能设置URL中不包含的值。</li>\n<li>当页面中包含来自不同子域的窗格（<frame>）或内嵌窗格(<iframe>)时，可以设置document.domain来绕过浏览器跨域通信的限制，实现JavaScript通信。在每个页面上把document.domain设置为相同的值，那就可以互相访问对方的JavaScript对象了。比如，一个加载自www.wrox.com的页面包含内嵌窗格，其中页面加载自p2p.wrox.com。两个页面的document.domain包含不同的字符串，内部与外部不能相互访问。要是把document.domain都设为wrox.com后就可以通信了</li>\n<li>浏览器对domain还有一个限制，将document.domain设置为\"wrox.com\"后就不能设置回\"p2p.wrox.com\"</li>\n</ul>\n<h2>定位元素</h2>\n<ul>\n<li>document.getElementById()接收一个参数，获取元素的id，找到了返回元素，没找到返回null，参数区分大小写，有多个相同id时返回文档中出现的第一个元素</li>\n<li>document.getElementsByTagName()接收一个元素的标签名，返回包含一个或多个元素的NodeList。在HTML文档中，返回一个HTMLCollection对象，也是一个实时列表。可以使用中括号或者item()方法取值。</li>\n<li>HTMLCollection对象有一个额外的方法namedItem()，可通过标签的name取得某一项的引用。比如</li>\n<li>对于name属性的元素，也可以直接通过中括号来获取</li>\n</ul>\n<pre><code class=\"language-js\">&#x3C;img src=\"a.gif\" name=\"myImage\"/>\n\nlet images = document.getElementsByTagName('img')\nlet myImage = images.namedItem('myImage')\nlet myImage = images['myImage']\n</code></pre>\n<ul>\n<li>对HTMLCollection对象，中括号可接受数值索引，也可以接受字符串索引，在后台，数值索引会调用item()，字符串索引调用namedItem()</li>\n<li>匹配所有元素可以传入*</li>\n<li>document.getElementsByName()接收一个字符串，返回具有给定name属性的元素</li>\n<li>\n<p>document对象还暴露了几个特殊集合，这些集合也都是HTMLCollection的实例，如下</p>\n<ul>\n<li>document.authors包含文档中所有带name属性的<a>元素</li>\n<li>document.applets包含文档中的所有<applet>元素（applet元素不推荐使用，所以集合已经废弃）</li>\n<li>document.forms包含文档中的所有<form>元素</li>\n<li>document.images包含文档中的所有<img>元素</li>\n<li>document.links包含文档中的所有带href属性的<a>元素</li>\n</ul>\n</li>\n<li>这些特殊集合都存在与HTMLDocument对象上，内容也都是实时更新的</li>\n</ul>\n<h2>DOM兼容性测试</h2>\n<ul>\n<li>由于DOM有多个Level和多个部分，所以需要确定浏览器实现了哪些DOM。</li>\n<li>document.implementation属性是一个对象，提供了浏览器DOM实现的信息与能力。DOM Level 1在document.implementation只定义了一个方法hasFeature()，接受两个参数：特性名称和DOM版本。如果浏览器支持特性和版本就返回true</li>\n</ul>\n<pre><code class=\"language-js\">let hasXmlDom = document.implementation.hasFeature('XML', '1.0')\n</code></pre>\n<ul>\n<li>\n<p>可以用hasFeature()方法检测的特性及版本如下</p>\n<ul>\n<li>Core: 1.0、2.0、3.0，定义属性文档结构的基本DOM</li>\n<li>XML: 1.0、2.0、3.0,Core的XML拓展，增加了对CDATA区块、处理指令和实体的支持</li>\n<li>HTML: 1.0、2.0，XML的HTML拓展，增加了HTML特定的元素和实体</li>\n<li>Views: 2.0，文档基于某些样式的实现格式</li>\n<li>StyleSheets: 2.0，文档的相关样式表</li>\n<li>CSS: 2.0，Cascading Style Sheets Level 1</li>\n<li>CSS2: 2.0，Cascading Style Sheets Level 1</li>\n<li>Events: 2.0、3.0， 通用DOM事件</li>\n<li>UIEvents: 2.0、3.0，用户界面事件</li>\n<li>TextEvents: 3.0，文本输入设备触发的事件</li>\n<li>MouseEvents: 2.0、3.0，鼠标触发的事件</li>\n<li>MutationEvents: 2.0、3.0，DOM树变化时触发的事件</li>\n<li>MutationNameEvents: 3.0，DOM元素或元素属性被重命名时触发的事件</li>\n<li>HTMLEvents: 2.0，HTML 4.01事件</li>\n<li>Range: 2.0，在DOM树中操作一定范围的对象和方法</li>\n<li>Traversal: 2.0，遍历DOM树的方法</li>\n<li>LS:3.0，文件与DOM树之间的同步加载与保存</li>\n<li>LS-Async: 3.0，文件与DOM树之间的异步加载与保存</li>\n<li>Validation: 3.0，修改DOM树并保证其继续有效的方法</li>\n<li>XPath: 3.0，访问XML文档不同部分的语言</li>\n</ul>\n</li>\n<li>由于实现不一致，hasFeature()返回值并不可靠，方法现在已经被废弃。为了向后兼容，目前主流浏览器仍然支持这个方法，但不论检测什么都返回true</li>\n</ul>\n<h2>文档写入</h2>\n<ul>\n<li>document对象早期留存了一个可以向网页输出流写入内容的能力。对应方法：write()、writeln()、open()、close()。</li>\n<li>write与writeln都接受一个字符串参数，可将此字符串写入网页中，write只是写入，writeln写入后还会在字符串尾部加一个换行符。</li>\n</ul>\n<pre><code class=\"language-js\">document.write(\"&#x3C;strong>\" + (new Date()).toStirng() + '&#x3C;/strong>')\n</code></pre>\n<ul>\n<li>write写入html标签时要注意对字符串的转义</li>\n<li>write在页面加载完成后调用会重写整个页面</li>\n<li>open跟close方法用于打开和关闭网页输出流。</li>\n<li>严格的XHTML文档不支持文档写入。对于内容类型为 application/xml+xhtml的页面，这些方法无用</li>\n</ul>\n<h2>Element类型</h2>\n<ul>\n<li>\n<p>Element表示XML或HTML元素，对外暴露访问元素标签名、子节点和属性的能力，特征如下</p>\n<ul>\n<li>nodeType为1</li>\n<li>nodeName值为元素的标签名</li>\n<li>nodeValue为null</li>\n<li>parentNode值为Document或Element对象</li>\n</ul>\n</li>\n<li>子节点可以使Element、Text、Comment、ProcessingInstruction、CDATASection、EntityReference类型</li>\n<li>通过nodeName或tagName获取元素的标签名，两个属性返回同样的值</li>\n<li>HTML中，元素标签名始终以全大写表示；在XML（XHTML）中，标签名始终与源代码中的一致。所以在比较时最好将签名转为小写模式</li>\n<li>\n<p>所有HTML元素都通过HTMLElement类型表示，包括直接实例跟间接实例。HTMLElement直接继承Element并增加了下列属性之一，它们是所有HTML元素上都有的标准属性</p>\n<ul>\n<li>id，元素在文档中的唯一标识符</li>\n<li>title: 元素的额外信息，一般以提示条形式展示</li>\n<li>lang: 元素内容的语言代码</li>\n<li>dir:语言的书写方向（\"ltr\"表示左到右，\"rtl\"表示右到左）</li>\n<li>className: 相当于class属性，用于指定元素的CSS类（class为关键字，不能直接用）</li>\n</ul>\n</li>\n<li>每个元素都有零个或多个属性，与属性相关的DOM方法主要有下三个</li>\n<li>getAttribute()、setAttribute()、removeAttribute()</li>\n</ul>\n<pre><code class=\"language-js\">let div = document.getElementById('myDiv')\n\nconsole.log(div.getAttribute('id'))\nconsole.log(div.getAttribute('class'))\n</code></pre>\n<ul>\n<li>这里传给getAttribute的属性名与实际的属性名是一致的，所以这里传class而不是className，如果属性不存在，返回null</li>\n<li>getAttribute可以获取自定义的属性，在html5规范中，自定义属性名前缀应该是data-的形式</li>\n<li>元素的所有属性也可以通过相应DOM元素对象的属性来获取。包括HTMLElement上得直接映射对象和所有公认的属性（不包括自定义属性）</li>\n<li>\n<p>通过DOM对象访问的属性中有两个属性的返回值跟使用getAttribute获取到的值不一致</p>\n<ul>\n<li>一个是style属性，使用getAttribute获取到的是字符串，通过DOM访问到的是一个（CSSStyleDeclaration）对象。</li>\n<li>第二个属性是事件处理程序，比如onclick，在元素上使用事件属性时，属性值是一段JavaScript代码。使用getAttribute获取到的是字符串形式的源码；通过DOM对象的属性访问事件属性时返回的是一个JavaScript函数。这是因为onclick等事件属性是可以接收函数值的</li>\n</ul>\n</li>\n<li>考虑到上面的差异，开发者一般都会放弃使用getAttribute来获取值，只使用对象属性。getAttribute主要用来获取自定义属性的值。</li>\n<li>setAttribute接收两个参数：要设置的属性名及属性值。属性值已存在会替换原来的值，属性不存在，就会以指定的值进行创建</li>\n<li>使用setAttribute设置的属性名会规范为小写形式，所以\"ID\"会变成\"id\"</li>\n<li>在DOM对象上设置自定义属性，不会自动让它变成元素的属性</li>\n</ul>\n<pre><code class=\"language-js\">div.mycolor = 'red'\nconsole.log(div.getAttribute('mycolor')) // null\n</code></pre>\n<ul>\n<li>removeAttribute用于从元素中删除属性，将整个属性完全从元素中去掉</li>\n<li>\n<p>Element是唯一使用attributes属性的DOM节点类型，attributes属性包含一个NamedNodeMap实例，是一个实时的集合。元素的每个属性都表现为一个Attr节点，并保存在这个NamedNodeMap对象中，NamedNodeMap对象包含下方法</p>\n<ul>\n<li>getNamedItem(name)， 返回nodeName属性等于name的节点</li>\n<li>removeNamedItem(name)，删除nodeName属性等于name的节点</li>\n<li>setNamedItem(node)，向列表中添加node节点，以其nodeName作为索引</li>\n<li>item(pos)，返回索引pos处的节点</li>\n</ul>\n</li>\n<li>attributes属性中的每个节点的nodeName是对应属性的名字，nodeValue是属性的值。比如要取元素id属性的值</li>\n</ul>\n<pre><code class=\"language-js\">let id = element.attributes.getNamedItem('id').nodeValue\n\n// 中括号简写\nlet id = element.attributes['id'].nodeValue\nelement.attribute['id'].nodeValue = 'someOtherId'\nelement.attributes.removeNamedItem('id')\n</code></pre>\n<ul>\n<li>可以使用createElement()方法创建新元素，接收一个参数，即要创建的元素的标签名，使用createElement的同时也会把ownerDocument属性设为document</li>\n<li>元素可以拥有任意多个子元素和后代元素，childNodes包含元素所有的子节点，可能是其他元素、文本节点、注释或处理命令</li>\n</ul>\n<pre><code class=\"language-js\">&#x3C;ul>\n  &#x3C;li>Item 1&#x3C;/li>\n  &#x3C;li>Item 2&#x3C;/li>\n  &#x3C;li>Item 3&#x3C;/li>\n&#x3C;/ul>\n\n&#x3C;ul>&#x3C;li>Item 1&#x3C;/li>&#x3C;li>Item 2&#x3C;/li>&#x3C;li>Item 3&#x3C;/li>&#x3C;/ul>\n</code></pre>\n<ul>\n<li>不同浏览器识别上面的节点时有不同的差异，有些浏览器会返回七个子节点，三个li元素，4个Text节点，要是下面的格式，就统一返回一样的3个节点数。</li>\n<li>所以这种情况下我们会先检查一下节点的nodeType，在执行操作</li>\n</ul>\n<pre><code class=\"language-js\">for (let i = 0; i &#x3C; element.childNodes.length; i++) {\n  if(element.childNodes[i].nodeType === 1) {}\n}\n</code></pre>\n<ul>\n<li>要取得某个元素的子节点可以在元素上调用getElementsByTagName()方法，跟在document上的调用形式是一致的，只不过搜索范围变成了当前节点下</li>\n</ul>\n<h2>Text类型</h2>\n<ul>\n<li>\n<p>Text节点由Text类型表示，包含按字面展示的纯文本，也有可能是转义后的HTML字符串，但不含有HTML代码</p>\n<ul>\n<li>nodeType为3</li>\n<li>nodeName为\"#text\"</li>\n<li>nodeValue值为节点中包含的文本</li>\n<li>parentNode值为Element对象</li>\n<li>不支持子节点</li>\n</ul>\n</li>\n<li>\n<p>Text节点中的文本可以用nodeValue访问，也可以通过data属性访问，修改任意一个值都会反映到另一个值上面，暴露了以下方法</p>\n<ul>\n<li>appendData(text)，向节点末尾加text</li>\n<li>deleteData(offset, count),从offset位置删除count个字符</li>\n<li>insertData(offset, text)，从offset位置插入text</li>\n<li>replaceData(offset, count, text)，用text文本替换从位置offset到offset + count位置的文本</li>\n<li>splitText(offset)，在offset位置将文本拆为两个节点</li>\n<li>substringData(offset, count)，提取从offset到offset + count的文本</li>\n<li>还可以通过length获取文本节点中包含的字符数量</li>\n</ul>\n</li>\n<li>默认情况下，包含文本内容的每个元素最多只能有一个文本节点</li>\n<li>修改文本值时注意HTML或XML代码会被转为实体编码，即小于号、大于号或引号会被转义，如下</li>\n</ul>\n<pre><code class=\"language-js\">div.firstChild.nodeValue = \"some &#x3C;strong>other&#x3C;/strong> message\"\n// 输出为 \"some &#x26;lt;strong&#x26;gt;other&#x26;lt;/strong&#x26;gt;message\"\n</code></pre>\n<ul>\n<li>document.createTextNode()可以用来创建文本节点，接受一个参数，就是要插入节点的文本，跟上面的规则一样，这些要插入的值也会被转义</li>\n</ul>\n<h2>Comment类型</h2>\n<ul>\n<li>\n<p>DOM中的注释通过Comment类型实现，特征如下</p>\n<ul>\n<li>nodeType为8</li>\n<li>nodeName值为\"#comment\"</li>\n<li>nodeValue的值为注释的内容</li>\n<li>parentNode值为Document或者Element对象</li>\n<li>不支持子节点</li>\n</ul>\n</li>\n<li>Comment类型与Text类型继承自同一个基类(CharacterData)，所以有除了splitText方法外的所有Text节点操作字符串方法</li>\n<li>可以使用createComment方法创造注释节点，参数为注释文本</li>\n</ul>\n<h2>CDATASection类型</h2>\n<ul>\n<li>\n<p>CDATASection类型表示XML中特有的CDATA区块。CDATASection类型继承Text类型，因此有包括splitText方法在内的所有字符串操作方法，特点如下</p>\n<ul>\n<li>nodeType为4</li>\n<li>nodeName为\"#cdata-section\"</li>\n<li>nodeValue值为CDATA区块的内容</li>\n<li>parentNode值为Document或Element对象</li>\n<li>不支持子节点</li>\n</ul>\n</li>\n<li>CDATA只会在XML文档中有效，有些旧的浏览器会将CDATA区块解析为Comment或Element</li>\n</ul>\n<pre><code class=\"language-js\">&#x3C;div id=\"myDiv\">&#x3C;![CDATA[This is some conent.]]>&#x3C;/div>\n</code></pre>\n<ul>\n<li>这里div的第一个子节点应该是CDATASection节点，但主流的浏览器没有一个将其识别为CDATASection。在有效的XHTML文档中，这些浏览器也不能恰当的支持嵌入的CDATA区块</li>\n</ul>\n<h2>DocumentType类型</h2>\n<ul>\n<li>\n<p>DocumentType类型的节点包含文档的文档类型(doctype)信息，特征如下</p>\n<ul>\n<li>nodeType为10</li>\n<li>nodeName值为文档类型的名称</li>\n<li>nodeValue值为null</li>\n<li>parentNode值为Document对象</li>\n<li>不支持子节点</li>\n</ul>\n</li>\n<li>DocumentType在DOM Level 1中不支持动态创建，只能在解析文档时创建。对于支持此类型的浏览器，DocumentType对象保存在document.doctype中</li>\n<li>\n<p>DOM Level 1规定了DocumentType类型的三个属性：name、entities、notations。</p>\n<ul>\n<li>name为文档类型的名称</li>\n<li>entities是文档类型描述的实体的NamedNodeMap</li>\n<li>notations是文档类型描述的表示法的NamedNodeMap。</li>\n</ul>\n</li>\n<li>因为浏览器中文档类型通常为HTML或者XHTML类型，所以entities跟notations列表为空</li>\n<li>所以只有name属性是有用的，这个属性包含文档类型的名称，即紧跟&#x3C;!DOCTYPE 后面的文本</li>\n</ul>\n<pre><code class=\"language-js\">&#x3C;!DOCTYPE HTML PUBLIC \"-//W3C// DTD HTML 4.01// EN\" \"http:// www.w3.org/TR/html4/strict.dtd\">\nconsole.log(document.doctype.name)  // 'html'\n</code></pre>\n<h2>DocumentFragment类型</h2>\n<ul>\n<li>\n<p>DocumentFragment类型是唯一在标记中没有对应表示的类型。DOM将文档片段定义为\"轻量级\"文档，能够包含和操作节点，却没有完整文档那样的消耗，特点如下</p>\n<ul>\n<li>NodeType为11</li>\n<li>nodeName值为\"#document-fragment\"</li>\n<li>nodeValue值为null</li>\n<li>parentNode值为null</li>\n<li>子节点可以是Element、ProcessingInstruction、Comment、Text、CDATASection或EntityReference</li>\n</ul>\n</li>\n<li>不能直接将文档碎片添加到文档。文档碎片充当其他要被添加到文档的节点的仓库。</li>\n<li>可以使用document.createDocumentFragment()方法创建文档</li>\n<li>文档类型从Node继承了所有文档类型具备的可以执行DOM操作的方法。如果文档中一个节点被添加到文档片段，那该节点会从文档树删除，不在被渲染</li>\n<li>添加到文档片段的新节点也不属于文档数，也不会被渲染，可以使用appendChild方法将文档片段内容添加到文档，将文档片段当做参数传给这些方法时，文档片段的所有子节点都会被添加到文档数</li>\n</ul>\n<pre><code class=\"language-js\">let fragment = document.createDocumentFragment()\nfor(let i = 0; i &#x3C; 3; i++){\n  let li = document.createElement('li')\n  li.appendChild(document.createTextNode(`Item ${ i }`))\n  fragment.appendChild(li)\n}\ndocument.body.appendChild(fragment)\n</code></pre>\n<h2>Attr类型</h2>\n<ul>\n<li>\n<p>元素数据在DOM中通过Attr类型表示。Attr类型构造函数和原型在所有浏览器都可以直接访问。技术上来说，属性是存在于元素attributes属性中的节点，特征如下</p>\n<ul>\n<li>nodeType为2</li>\n<li>nodeName等于属性名</li>\n<li>nodeValue为属性值</li>\n<li>parentNode值为null</li>\n<li>HTML中不支持子节点</li>\n<li>XML中子节点可以是Text或EntityReference</li>\n</ul>\n</li>\n<li>属性节点虽然是节点，但不被认为是DOM文档树的一部分，Attr节点很少被直接引用，一般更喜欢getAttribute、removeAttribute、setAttribute方法</li>\n<li>Attr对象有三个属性：name、value和specified。name包含属性名，value包含属性值，specified是布尔值，表示属性使用的是默认值还是指定值</li>\n<li>可以使用document.createAttribute()方法创建新的Attr节点，参数为属性名。</li>\n</ul>\n<pre><code class=\"language-js\">let attr = document.createAttribute('align')\nattr.value = 'left'\nelement.setAttributeNode(attr)\n\nconsole.log(element.attributes['align']) // left\nconsole.log(element.attributeNode('align').value)  // left\nconsole.log(element.getAttribute('align')) // left\n</code></pre>","fields":{"slug":"/DOM/"},"frontmatter":{"title":"DOM--高程4","tags":["JavaScript回顾"],"categories":"JavaScript"}}},{"node":{"html":"<h1>DOM编程</h1>\n<ul>\n<li>下面是我们常见的DOM编程方法</li>\n<li>动态插入script标签</li>\n</ul>\n<pre><code class=\"language-js\">function loadScript(code){\n  var script = document.createElement('script')\n  try {\n    // 旧版本IE中有问题，IE对script做了特殊处理，不允许常规DOM访问子节点，所以可以在\n    script.appendChild(document.createTextNode(code))\n  } catch () {\n    script.text = code\n  }\n  document.body.appendChild(script)\n}\nloadScript('function sayHi(){alert(\"hi\")}')\n</code></pre>\n<ul>\n<li>这种方法会在返回后立即生效，通过innerHTML创建的 script 元素不会执行，会创建但不会执行</li>\n<li>\n<p>动态插入CSS样式</p>\n<!--more-->\n<pre><code class=\"language-js\">// 所有主流浏览器都支持\nfunction loadStyles(url) {\nlet link = document.createElement('link')\nlink.rel = 'stylesheet'\nlink.type = 'text/css'\nlink.href = url\nlet head = document.getElementsByTagName('head')[0]\nhead.appendChild(link)\n}\n</code></pre>\n</li>\n</ul>\n<p>// 插入动态语句\nfunction loadStyleString(css) {\nlet style = document.createElement('style')\nstyle.type = 'text/css'\ntry{\nstyle.appendChild(document.createTextNode(css))\n} catch() {\nstyle.styleSheet.cssText = css\n}\nlet head = document.getElementsByTagName('head')[0]\nhead.appendChild(style)\n}</p>\n<p>loadStyleString(\"body{background:#fff}\")</p>\n<pre><code>- 这样添加也会立即生效，在IE中要注意使用styleSheet.cssText，如果重用同一个 style 元素并设置该属性超一次，会导致浏览器奔溃，设置cssText为空也会导致奔溃\n\n## 操作表格\n\n- 下面是按常规DOM形式创建的表格\n\n```js\n// 创建表格\nlet table = document.createElement('table')\ntable.border = 1\ntable.width = '100%'\n// 创建表体\nlet tbody = document.createElement('tbody')\ntable.appendChild(tbody)\n\n// 创建行\nlet row1 = document.createElement('tr')\ntbody.appendChild(row1)\nlet cell_1 = document.createElement('td')\ncell_1.appendChild(document.createTextNode('Cell_1'))\nrow1.appendChild(cell_1)\n\nlet cell_2 = document.createElement('td')\ncell_2.appendChild(document.createTextNode('Cell_2'))\nrow1.appendChild(cell_2)\n\ndocument.body.appendChild(table)\n</code></pre>\n<ul>\n<li>上面创建的形式太过繁琐，所以新增了以下属性</li>\n<li>\n<p>table新增的属性</p>\n<ul>\n<li>caption，指向<caption>元素的指针</li>\n<li>tBodies，包含<tbody>的HTMLCollection</li>\n<li>tFoot，指向<tfoot>元素</li>\n<li>tHead，指向<thead>元素</li>\n<li>rows：包含所有行的HTMLCollection</li>\n<li>createTHead()：创建<thead>标签，插入表格，返回引用</li>\n<li>createTFoot()：创建<tfoot>元素，插入表格，返回引用</li>\n<li>createCaption()：创建<caption>元素，插入表格，返回引用</li>\n<li>deleteTHead()：删除<thead>元素</li>\n<li>deleteTFoot()：删除<tfoot>元素</li>\n<li>deleteCaption()：删除<caption>元素</li>\n<li>deleteRow(pos): 删除给定的行</li>\n<li>insertRow(pos)，在给定位置插入一行</li>\n</ul>\n</li>\n<li>\n<p>tbody元素添加以下方法</p>\n<ul>\n<li>rows，包含<tbody>中所有行的HTMLCollection</li>\n<li>deleteRow(pos)，删除指定位置行</li>\n<li>insertRow(pos)，指定位置插入一行，返回改行的引用</li>\n</ul>\n</li>\n<li>\n<p>tr元素新增以下属性和方法</p>\n<ul>\n<li>cells，包含<tr>元素所有表元的HTMLCollection</li>\n<li>deleteCell(pos)，删除指定位置表元</li>\n<li>insertCell(pos)，指定位置插入表元返回引用</li>\n</ul>\n</li>\n<li>重写上面代码</li>\n</ul>\n<pre><code class=\"language-js\">let table = document.createElement('table')\ntable.border = 1\ntable.width = '100%'\n// 创建表体\nlet tbody = document.createElement('tbody')\ntable.appendChild(tbody)\n\ntbody.insertRow(0)\ntbody.rows[0].insertCell(0)\ntbody.rows[0].cells[0].appendChild(document.createTextNode('Cell_1'))\ntbody.rows[0].insertCell(1)\ntbody.rows[0].cells[1].appendChild(document.createTextNode('Cell_2'))\n</code></pre>\n<ul>\n<li>NodeList、NamedNodeMap、HTMLCollection三个集合类型都是实时的，文档结构变化会实时反应，所以下面代码会死循环</li>\n</ul>\n<pre><code class=\"language-js\">let divs = document.getElementsByTagName('div')\nfor(let i = 0 ; i &#x3C; divs.length; i++) {\n  let div = document.createElement('div')\n  document.body.appendChild(div)\n}\n</code></pre>\n<h2>MutationObserver接口</h2>\n<ul>\n<li>DOM规范中的MutationObserver接口可以在DOM被修改时异步执行回调，使用它能够观察整个文档、DOM树的一部分，或某个元素。还能观察元素属性、子节点、文本或者它们的任意组合</li>\n<li>MutationObserver是为了替代废弃的MutationEvent</li>\n<li>基本用法如下</li>\n</ul>\n<pre><code class=\"language-js\">let observer = new MutationObserver(() => {\n  console.log('&#x3C;body> attributes changed')\n})\n\nobserver.observe(document.body, { attributes: true })\ndocument.body.className = 'foo'\nconsole.log('Changed body')\n\n// Changed body\n// &#x3C;body> attributes changed\n</code></pre>\n<ul>\n<li>创建后使用observer()方法关联DOM对象，接收两个参数为：要观察变化的DOM节点，以及一个MutationObserverInit对象</li>\n<li>MutationObserverInit对象用于控制观察哪些方面的变化，是一个键/值形式配置选项的字典。上述代码就是观察body上attributes的变化</li>\n<li>从上面能看出来，观察的回调执行在后面，所以是一个异步函数</li>\n<li>每个回调都会收到一个MutationRecord实例的数组，实例包含的信息包括发生了什么变化，以及DOM的哪一部分受影响了。回调执行之前可能同时发生多个满足条件的事件，所以每次执行回调都会传入一个包含按顺序入队的MutationRecord实例的数组</li>\n</ul>\n<pre><code class=\"language-js\">let observer = new MutationObserver((mutationRecord) => { console.log(mutationRecord) })\nobserver.observe(document.body, { attributes:true })\ndocument.body.setAttribute('foo', 'bar')\n// [\n//   {\n//     addedNodes: NodeList []\n//     attributeName: \"foo\"\n//     attributeNamespace: null\n//     nextSibling: null\n//     oldValue: null\n//     previousSibling: null\n//     removedNodes: NodeList []\n//     target: body.page-v3.eye-protector-processed\n//     type: \"attributes\"\n//   }\n// ]\ndocument.body.setAttributeNS('baz', 'foo', 'bar')\n// [\n//   {\n//     addedNodes: NodeList []\n//     attributeName: \"foo\"\n//     attributeNamespace: \"baz\"\n//     nextSibling: null\n//     oldValue: null\n//     previousSibling: null\n//     removedNodes: NodeList []\n//     target: body.page-v3.eye-protector-processed\n//     type: \"attributes\"\n//   }\n// ]\n</code></pre>\n<ul>\n<li>连续修改会生成多个MutationRecord实例，下次回调就会收到所有包含这些实例的数组，顺序为变化事件发生的顺序</li>\n</ul>\n<pre><code class=\"language-js\">let observer = new MutationObserver((mutationRecords) => { console.log(mutationRecords) })\nobserver.observe(document.body, { attributes:true })\ndocument.body.className = 'foo'\ndocument.body.className = 'bar'\ndocument.body.className = 'baz'\n// [MutationRecord, MutationRecord, MutationRecord]\n</code></pre>\n<ul>\n<li>\n<p>下面是MutationRecord实例的属性</p>\n<ul>\n<li>target: 被修改影响的目标节点</li>\n<li>type: 字符串，表示变化的类型：\"attributes\"、\"characterData\"、\"childList\"</li>\n<li>oldValue: 如果在MutationObserverInit中启用（attributeOldValue或characterData oldValue为true）\"attributes\"或\"characterData\"的事件变化会设置这个属性为被替代的值，\"childList\"类型的变化始终将这个属性设置为null</li>\n<li>attributeName: 对于\"attributes\"类型的变化，这里保存被修改属性的名字，其他变化事件为null</li>\n<li>attributeNameSpace: 对于使用命名空间的\"attributes\"类型变化，这里保存被修改属性的名字，其他事件为null</li>\n<li>addedNodes: 对于\"childList\"类型的变化，返回包含变化中添加节点的NodeList，默认为空NodeList</li>\n<li>removeNodes: 对于\"childList\"类型的变化，返回包含变化中删除节点的NodeList，默认为空NodeList</li>\n<li>previousSibling: 对于\"childList\"类型的变化，返回变化节点的前一个同胞Node，默认为null</li>\n<li>nextSibling: 对于\"childList\"类型的变化，返回变化后节点的后一个同胞Node，默认为null</li>\n</ul>\n</li>\n<li>传给回调的第二个参数是观察变化的MutationObserver的实例</li>\n</ul>\n<pre><code class=\"language-js\">let observer = new MutationObserver((mutationRecords, mutationObserver) => { console.log(mutationRecords, mutationObserver) })\nobserver.observe(document.body, { attributes:true })\ndocument.body.className = 'foo'\n//[MutationRecord] MutationObserver {}\n</code></pre>\n<ul>\n<li>disconnect()方法：默认情况下，只要被观察的元素不被垃圾回收，MutationObserver回调就会响应DOM变化，从而被执行。要提前终止执行回调，调用disconnect()方法。</li>\n</ul>\n<pre><code class=\"language-js\">let observer = new MutationObserver((mutationRecords, mutationObserver) => { console.log(mutationRecords, mutationObserver) })\nobserver.observe(document.body, { attributes:true })\ndocument.body.className = 'foo'\nobserver.disconnect()\ndocument.body.className = 'bar'\n// 没有输出日志\n</code></pre>\n<ul>\n<li>上面可以看出，当调用了disconnect之后，不仅之后变化事件的回调不会执行，已经加入到任务队列的事件也不会执行</li>\n<li>所以想要被加入的事件可以被执行，在调用disconnect方法的时候加一个setTimeout(() => {}, 0)</li>\n<li>多次调用observer()方法，可以复用一个MutationObserver对象观察多个不同的目标节点。</li>\n</ul>\n<pre><code class=\"language-js\">let observer = new MutationObserver((mutationRecords) => console.log(mutationRecords.map(x => x.target)))\n\nlet childA = document.createElement('div'), childB = document.createElement('span')\ndocument.body.appendChild(childA)\ndocument.body.appendChild(childB)\n\n// 观察两个元素\nobserver.observe(childA, { attributes: true })\nobserver.observe(childB, { attributes: true })\n\n// 修改子节点属性\nchildA.setAttribute('foo', 'bar')\nchildB.setAttribute('foo', 'bar')\n\n// [div, span]\n\nobserver.disconnect()\nchildA.setAttribute('a', 'b')\nchildB.setAttribute('a', 'b')\n// 没有日志\n</code></pre>\n<ul>\n<li>disconnect()方法是一刀切的方案，会停止观察所有目标</li>\n<li>调用disconnect只是断开连接，没有结束MutationObserver的声明，可以重新用这个观察者关联新的目标节点</li>\n</ul>\n<pre><code class=\"language-js\">let observer = new MutationObserver((mutationRecords) => console.log('&#x3C;body> attributes changed'))\nobserver.observe(document.body, { attributes: true })\ndocument.body.setAttribute('foo', 'bar')\nsetTimeout(() => {\n  observer.disconnect()\n  document.body.setAttribute('baz', 'baz')\n}, 0)\nsetTimeout(() => {\n  observer.observe(document.body, { attributes: true })\n  document.body.setAttribute('qux', 'qux')\n}, 0)\n// &#x3C;body> attributes changed\n// &#x3C;body> attributes changed\n</code></pre>\n<ul>\n<li>\n<p>MutationObserverInit用于控制目标节点的观察范围。可观察的值如下</p>\n<ul>\n<li>subtree: 布尔值，表示除了目标对象，是否观察目标节点的子节点，为true表示观察节点及子节点</li>\n<li>attributes: 布尔值，表示是否观察目标节点的属性变化</li>\n<li>attributeFilter: 字符串数组，表示要观察哪些属性的变化，这个值设为true会将attributes也转换为true，默认观察所有属性</li>\n<li>attributeOldValue: 布尔值，表示MutaionRecord是否记录变化之前的属性值，将这个值设为true也会导致attributes转换为true，默认为false</li>\n<li>characterData: 布尔值，表示修改字符数据是否触发变化事件，默认false</li>\n<li>characterDataOldValue: 布尔值，表示MutationRecord是否记录变化之前的字符数据，这个值设为true会将characterData值也转为true，默认false</li>\n<li>childList: 布尔值，表示修改目标节点的子节点是否触发变化事件，默认false</li>\n</ul>\n</li>\n<li>调用observe()时，MutationObserverInit对象中的attribute、characterData、childList必须至少有一项为true（直接设置或者通过设置attributeOldValue等设置）。否则会报错</li>\n<li>MutationObserver可以观察节点属性的添加、移除、修改。为属性注册回调，需要在MutationObserverInit对象中将attributes设为true</li>\n</ul>\n<pre><code class=\"language-js\">let observer = new MutationObserver((mutationRecords) => console.log(mutationRecords))\nobserver.observe(document.body, { attributeFilter: ['foo'] })\ndocument.body.setAttribute('foo', 'bar')\ndocument.body.setAttribute('bar', 'baz')\ndocument.body.setAttribute('baz', 'qux')\n\n// 只记录了foo的属性变化\n// [MutationRecord]\n</code></pre>\n<ul>\n<li>要想在记录中保存属性原来的值，将attributeOldValue属性设为true</li>\n</ul>\n<pre><code class=\"language-js\">let observer = new MutationObserver((mutationRecords) => console.log(mutationRecords.map(x => x.oldValue)))\nobserver.observe(document.body, { attributeOldValue: true })\ndocument.body.setAttribute('foo', 'bar')\ndocument.body.setAttribute('foo', 'baz')\ndocument.body.setAttribute('foo', 'qux')\n\n// [null, \"bar\", \"baz\"]\n</code></pre>\n<ul>\n<li>MutationObserver可以观察文本节点（Text、Comment、ProcessingInstruction）中字符串的添加、删除、修改。需要为字符数据注册回调，然后将MutatioObserverInit对象中的characterData属性设置为true</li>\n</ul>\n<pre><code class=\"language-js\">let observer = new MutationObserver((mutationRecord) => console.log(mutationRecord))\ndocument.body.innerText = 'foo'\nobserver.observe(document.body.firstChild, { characterData: true })\n\ndocument.body.innerText = 'foo'\ndocument.body.innerText = 'bar'\ndocument.body.innerText = 'baz'\n\n// [MutationRecord, MutationRecord, MutationRecord]\n</code></pre>\n<ul>\n<li>想要在MutationRecord中保村原始数据可以设置characterDataOldValue为true</li>\n<li>MutationObserver观察子节点</li>\n</ul>\n<pre><code class=\"language-js\">let observer = new MutationObserver((mutationRecord) => console.log(mutationRecord))\ndocument.body.innerText = ''\nobserver.observe(document.body, { childList: true })\ndocument.body.appendChild(document.createElement('div'))\n// [\n//   {\n//     addedNodes: NodeList [div]\n//     attributeName: null\n//     attributeNamespace: null\n//     nextSibling: null\n//     oldValue: null\n//     previousSibling: null\n//     removedNodes: NodeList []\n//     target: body.page-v3.eye-protector-processed\n//     type: \"childList\"\n//   }\n// ]\n\nlet observer = new MutationObserver((mutationRecord) => console.log(mutationRecord))\ndocument.body.innerText = ''\ndocument.body.appendChild(document.createElement('span'))\ndocument.body.appendChild(document.createElement('div'))\nobserver.observe(document.body, { childList: true })\ndocument.body.insertBefore(document.body.lastChild, document.body.firstChild)\n\n//[MutationRecord, MutationRecord]\n</code></pre>\n<ul>\n<li>上面进行子节点的交换会发生两次变化，一次是节点被删除，一次是节点被添加</li>\n<li>将MutationObserverInit对象中的subtree设置为true就能观察节点及其所有子节点</li>\n</ul>\n<pre><code class=\"language-js\">let observer = new MutationObserver((mutationRecord) => console.log(mutationRecord))\ndocument.body.innerText = ''\ndocument.body.appendChild(document.createElement('div'))\nobserver.observe(document.body, { attributes: true, subtree: true })\ndocument.body.firstChild.setAttribute('foo', 'bar')\n// [MutationRecord]\n</code></pre>\n<ul>\n<li>这里要注意，被观察子树中的节点在被移出子树后仍然能够触发变化事件。</li>\n<li>MutationObserver接口出于性能考虑，核心是异步回调与记录队列模型。为了在大量变化事件发生时不影响性能，每次变化的信息会保存在MutationRecord实例中，然后添加到记录队列，这个队列对每个MutationObserver实例都是唯一的，是所有DOM变化事件的有序列表</li>\n<li>每次MutationRecord被添加到MutationObserver记录队列时，只有之前没有已排期的微任务回调时，才会将观察者注册的回调作为作为微任务加到任务队列上，这样能保证记录队列的内容不会被回调处理两次</li>\n<li>在回调的微任务异步执行时，可能发生更多变化事件。因此被调用的回调会接收到一个MutationRecord实例的数组，顺序为它们进入记录队列的顺序。回调负责处理这个数组的没一个实例，函数退出之后这些实现就不存在了，回调执行后，这些MutationRecord就用不到了，记录队列会被清空，内容会被丢弃</li>\n<li>调用MutationObserver的takeRecords()方法可以清空记录队列，取出并返回所有的MutationRecord实例</li>\n</ul>\n<pre><code class=\"language-js\">let observer = new MutationObserver((mutationRecord) => console.log(mutationRecord))\nobserver.observe(document.body, { attributes: true })\ndocument.body.className = 'foo'\ndocument.body.className = 'bar'\ndocument.body.className = 'baz'\nconsole.log(observer.takeRecords()) // [MutationRecord, MutationRecord, MutationRecord]\nconsole.log(observer.takeRecords()) // []\n</code></pre>\n<ul>\n<li>在希望断开与观察目标的联系，但是希望处理由于disconnect而被抛弃的记录队列中的MutationRecord时比较有用</li>\n</ul>\n<h2>性能、垃圾回收</h2>\n<ul>\n<li>DOM Level 2中的MutationEvent定义了会在各种DOM变化时触发的事件。由于浏览器的实现机制，接口有严重的性能问题，因此DOM3废弃了这些事件</li>\n<li>使用MutationObserver将变化回调委托给微任务避免事件同步触发，记录队列可以保证变化事件爆发式的触发时，也不会显著拖慢浏览器，但无论如何，使用MutationObserver都是有代价的</li>\n<li>MutationObserver实例与目标节点是非对称引用，MutationObserver对目标节点是弱引用，所以不会妨碍垃圾回收程序回收节点</li>\n<li>目标节点对MutationObserver是强引用，如果目标节点从DOM被移除，随后垃圾回收，那关联的MutationObserver实例也被回收</li>\n<li>MutationRecord实例至少包含对已有DOM节点的一个引用。如果变化是childList类型，会包含多个节点的引用。记录队列和回调处理的默认行为是耗尽这个队列，处理每个MutationRecord，然后让它们超出作用域，之后被垃圾回收</li>\n<li>记录某个观察者的完整变化记录（MutationRecord）时就会保存它们引用的节点，从而妨碍这些节点的回收。如果需要尽快释放内存，建议从每个MutationRecord中抽取有用的信心保存到新对象，然后抛弃MutationRecord</li>\n</ul>","fields":{"slug":"/DOM_programming/"},"frontmatter":{"title":"DOM编程--高程4","tags":["JavaScript回顾"],"categories":"JavaScript"}}},{"node":{"html":"<h1>DOM拓展</h1>\n<h2>Selectors API</h2>\n<ul>\n<li>jQuery可以根据CSS选择符查询获取DOM元素，所以Selector API规定了浏览器原生支持的CSS查询API</li>\n<li>Selector API Level 1核心方法是 querySelector()跟querySelectorAll()，兼容浏览器中，Document类型跟Element类型的实例都会暴露这两个方法</li>\n<li>Selector API Level 2在Element类型上新增了matches()、find()、findAll()等方法，目前还没有浏览器实现find()跟findAll()</li>\n<li>querySelector()接收CSS选择符，返回匹配该模式的第一个后代元素，没有匹配项就返回null</li>\n</ul>\n<pre><code class=\"language-js\">let body = document.querySelector('body')\nlet div = document.querySelector('#div')\nlet img = document.querySelector('img.button')\n</code></pre>\n<ul>\n<li>在Document上使用querySelector会从文档元素开始搜索，在Element元素上使用会从当前元素的后代开始查询</li>\n<li>查询的CSS繁琐度由用户决定，如果选择符有错误或碰到不支持的选择符，querySelector会抛错</li>\n<li>querySelectorAll()跟querySelector接收参数一致，但是会返回所有的匹配项，返回的是NodeList的静态实例，也就是只是静态的快照，不是实时的查询，这么做是为了避免NodeList可能造成的性能问题</li>\n<li>用有效的CSS选择符调用该方法都会返回NodeList，无论匹配多少个，没有匹配项，返回空NodeList实例</li>\n</ul>\n<pre><code class=\"language-js\">let ems = document.getElementById('div').querySelectorAll('em')\nlet selecteds = document.querySelectorAll('.selected')\nlet strongs = document.querySelectorAll('p strong')\n</code></pre>\n<ul>\n<li>\n<p>返回的NodeList可以通过for-of循环，item()方法或中括号取得个别元素</p>\n<!--more-->\n<pre><code class=\"language-js\">let strongElement = document.querySelectorAll('strong')\n// 下面的三种循环效果一样\nfor(let strong of strongElement) {\nstrong.className = 'important'\n}\nfor(let i = 0; i &#x3C; strongElement.length; ++i) {\nstrongElement.item(i).className = 'important'\n}\nfor(let i = 0; i &#x3C; strongElement.length; ++i) {\nstrongElement[i].className = 'important'\n}\n</code></pre>\n</li>\n<li>跟querySelector方法一样，碰到不支持的或者错的选择符会报错</li>\n</ul>\n<h2>matches()</h2>\n<ul>\n<li>matches()方法（规范中叫matchesSelector()）接受一个CSS选择符，如果元素匹配该选择符，返回true，否则返回false</li>\n</ul>\n<pre><code class=\"language-js\">if(document.body.matches('body.page1')) {\n  // true\n}\n</code></pre>\n<ul>\n<li>这个方法可以方便的检测元素会不会被querySelector或querySelectorAll()返回</li>\n<li>所有主流浏览器都支持matches()。Egde、Chrome、Firefox、Safari和Opera完全支持，IE9-11及移动浏览器支持带前缀的方法</li>\n<li>IE9之前的版本不会把元素键的空格当成空白节点，其他浏览器会。导致了childNodes跟firstChild等属性的差异，为了弥补这个差异，W3C通过新的Element Traversal规范定义了一组新属性</li>\n<li>\n<p>Element TraversalAPI为DOM添加了5个属性</p>\n<ul>\n<li>childElementCount，返回子节点数量（不包含文本节点和注释）</li>\n<li>firstElementChild，指向第一个Element类型的子元素</li>\n<li>lastElementChild，指向最后一个Element类型的子元素</li>\n<li>previousElementSibling，指向前一个Element类型的同胞元素</li>\n<li>nextElementSibling，指向后一个Element类型的同胞元素</li>\n</ul>\n</li>\n<li>在支持的浏览器中，所有DOM都会有这些属性，这样就不会担心空白蚊子节点的问题</li>\n<li>比如以前跨浏览器遍历元素特定所有子元素，代码如下</li>\n</ul>\n<pre><code class=\"language-js\">let parentElement = document.getElementById('parent')\nlet currentChildNode = parentElement.firstChild\nwhile(currentChildNode) {\n  if(currentChildNode.nodeType === 1) {\n    processChild(currentChildNode)\n  }\n  if(currentChildeNode === parentElement.lastChild){\n    break\n  }\n  currentChildNode = currentChildNode.nextSibling\n}\n</code></pre>\n<ul>\n<li>使用Element Traversal后，代码如下</li>\n</ul>\n<pre><code class=\"language-js\">let parentElement = document.getElementById('parent')\nlet currentChildElement = parentElement.firstElementChild\nwhile(currentChildElement) {\n  process(currentChildElement)\n  if(currentChildElement == parentElement.lastElementChild) {\n    break\n  }\n  currentCHildElement = currentChildElement.nextElementSibling\n}\n</code></pre>\n<ul>\n<li>IE9及以上版本，以及所有现代浏览器都支持Element Traversal属性</li>\n</ul>\n<h2>HTML5</h2>\n<ul>\n<li>HTML5规范包括了与标记有关的JavaScript API定义，有的API与DOM重合，定义了浏览器应该提供的DOM扩展</li>\n<li>CSS类拓展，新增了下特性方便使用CSS类</li>\n<li>getElementsByClassName()，是HTML5新增的最受欢迎的方法，暴露在document对象及所有HTML元素上，提供了性能更好地原生实现</li>\n<li>该方法接受一个参数，既包含一个或多个类名的字符串，返回类名中包含对应类的元素的NodeList。提供了多个类名，顺序就无所谓了</li>\n</ul>\n<pre><code class=\"language-js\">let allCurrentUsernames = document.getElementsByClassName('username current')\nlet selected = docuement.getElementById('myDiv').getElementsByClassName('selected')\n</code></pre>\n<ul>\n<li>该方法返回以调用它的对象为根元素的子树中所有匹配的元素</li>\n<li>因为返回的是NodeList，所以会有跟getElementsByTagName还有其他返回的NodeList对象的DOM方法同样的问题 （DOM节点是实时查询的，可能出现死循环）</li>\n<li>IE9及以上浏览器及所有现代浏览器都支持getElementsByClassName方法</li>\n<li>操作类名可以使用className属性实现添加、删除和替换。由于它是一个字符串，所以操作完都要重新设置这个值，如下</li>\n</ul>\n<pre><code class=\"language-js\">&#x3C;div class=\"bd user disabled\">&#x3C;/div>\n// 删除user类\nlet targetClass = 'user'\nlet classNames = div.className.split(/\\s+/)\nlet idx = classNames.indexOf(targetClass)\nif(idx > -1) {\n  classNames.splice(i, 1)\n}\ndiv.className = classNames.join(' ')\n</code></pre>\n<ul>\n<li>这里就是对类名字符串做操作的步骤，替换跟检测类名也要有类似的操作</li>\n<li>\n<p>所以classList提供了更安全简单地实现方式，classList是一个新的集合类型DOMTokenList的实例。DOMTokenList也有length属性标识自己多少项，也能通过item()或中括号取得个别元素，DOMTokenList还增加了以下方法</p>\n<ul>\n<li>add(value)，向类名中添加指定的字符串值value，若已经存在就什么都不做</li>\n<li>contains(value)，返回布尔值，表示指定的value是否存在</li>\n<li>remove(value)，从类名列表中删除指定的字符串值</li>\n<li>toggle(value)，如果类名中存在就删除，不存在就添加</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"language-js\">// 上面的删除一行代码就可以\ndiv.classList.remove('user')\nif(div.classList.contains('bd') &#x26;&#x26; !div.classList.contains(disbaled)) {\n  // 操作\n}\nfor(let class of div.classList) {\n  doStuff(class)\n}\n</code></pre>\n<ul>\n<li>添加了classList属性后，除非完全删除或完全重写class属性，否则就不再使用className属性了。IE10及以上版本（部分）跟主流浏览器（全部）都实现了classList属性</li>\n<li>HTML5新增了辅助DOM焦点管理的功能，document.activeElement始终包含当前拥有焦点的元素</li>\n</ul>\n<pre><code class=\"language-js\">let button = document.getElementById('btn')\nbutton.focus()\nconsole.log(document.activeElement === button)\n</code></pre>\n<ul>\n<li>默认情况下，页面加载完成时document.activeElement设置为document.body。页面加载完成之前，document.activeElement是null</li>\n<li>document.hasFocus()方法，该方法返回布尔值，表示文档是否拥有焦点</li>\n</ul>\n<pre><code class=\"language-js\">let button = document.getElementById('btn')\nbutton.focus()\nconsole.log(document.hasFocus()) // true\n</code></pre>\n<ul>\n<li>确定文档是否获取焦点，就可以帮助确定用户是否在操作界面</li>\n<li>HTML5拓展了HTMLDocument类型，增加了以下功能</li>\n<li>\n<p>readyState是IE4早期添加到document对象上的属性，document.readyState属性有两个可能的值</p>\n<ul>\n<li>loading，文档正在加载</li>\n<li>complete，文档加载完成</li>\n</ul>\n</li>\n<li>开发中，最好将document.readyState当做指示器，判断文档是否加载完成，在这个属性得到支持之前，需要使用onLoad来添加标记，表示加载完成了</li>\n</ul>\n<pre><code class=\"language-js\">if(document.readyState === 'complete') {\n  // 操作\n}\n</code></pre>\n<ul>\n<li>IE6提供了以标准或混杂模式渲染页面的功能后，检测页面渲染模式就是一个必要的需求。IE为document添加了compatMode属性，该属性唯一的作用就是指示当前浏览器出于什么渲染模式下</li>\n<li>标准模式下，document.compatMode值时\"CSS1Compat\"，混杂模式下值为\"BackCompet\"</li>\n</ul>\n<pre><code class=\"language-js\">if(document.competMode === 'CSS1Compat') {\n  console.log('standard mode')\n} else {\n  console.log('quirk mode')\n}\n</code></pre>\n<ul>\n<li>新增了document.head属性指向文档的head元素</li>\n<li>HTML5新增了characterSet属性来表示文档实际使用的字符集，也可以用来指定新的字符集。默认值是\"UTF-16\"，可以通过<meta>元素或响应头，以及新增的characterSet属性来修改</li>\n</ul>\n<pre><code class=\"language-js\">let head = document.head\nconsole.log(document.characterSet) // 'UTF-16'\ndocument.characterSet = 'UTF-8'\n</code></pre>\n<ul>\n<li>HTML5允许给元素指定非标准的属性，但是要用data-前缀告诉浏览器，这些属性不包含预渲染有关的信息，也不包含元素的语义信息。除了前缀，没有限制</li>\n<li>定义了自定义数据后，可以通过元素的dataset属性来访问。dataset属性是一个DOMStringMap实例，包含键值对映射</li>\n<li>元素的每个data-name的属性在dataset中都可以通过data-后面的字符串作为键来访问（例如，属性data-myName、data-myname可以通过myname访问，注意：data-my-name、data-My-Name要通过myName来访问）</li>\n</ul>\n<pre><code class=\"language-js\">&#x3C;div id=\"myDiv\" data-appId=\"123\" data-myname=\"Nicholas\" data-my-data=\"23\">&#x3C;/div>\nlet div = document.getElementById('myDiv')\nconsole.log(div.dataset.appId) // undefined\nconsole.log(div.dataset.appid) // 123\nconsole.log(div.dataset.myname) // Nicholas\nconsole.log(div.dataset.myName) // undefined\nconsole.log(div.dataset.mydata) // undefined\nconsole.log(div.dataset.myDame) // 23\n</code></pre>\n<ul>\n<li>DOM提供了便利的操作节点的API，但是一次性插入大量节点还是很麻烦，所以HTML5实现了将一个HTML字符串插入的能力</li>\n<li>innerHTML，读取innerHTML时，会返回元素所有后代的HTML字符串，包括元素、注释和文本节点。写入时会根据提供的字符串值以新的DOM完全替代元素中的所有节点</li>\n<li>读取innerHTML时，返回的文本内容根据浏览器返回的值也不同，IE和Opera会把所有元素标签转为大写，而Safari、Chrome和Firefox则会按照源码返回，包含空格与锁紧。</li>\n<li>写入时，赋给innerHTML的值会被解析为DOM树，并替代之前的所有节点。因此所赋的值默认都是HTML，所有的标签都会以浏览器处理HTML的形式转为元素（转换结果也会因浏览器而不同）。赋值中没有HTML就直接生成文本节点</li>\n<li>因为浏览器会解析设置的值，所以innerHTML设置包含HTML的字符串时，结果会不一样</li>\n</ul>\n<pre><code class=\"language-js\">dib.innerHTML = 'Hello &#x26; welcome,&#x3C;b>\\\"reader\\\"!&#x3C;/b>'\n// 结果相当于\n\n&#x3C;div>Hello &#x26;amp; welcome, &#x3C;b>&#x26;quot;reader$quot;!&#x3C;/b>&#x3C;/div>\n</code></pre>\n<ul>\n<li>设置完innerHTML就可以访问对应的新节点了</li>\n<li>现代浏览器通过innerHTML插入script标签是不会执行的，在IE8之前，要是插入的script标签设置了defer属性，且script之前是“受控元素”，那就可以执行。script跟style或注释都是非受控元素，页面看不到它们。</li>\n<li>读取outerHTML属性会返回调用它的元素（及所有后代元素）的HTML字符串，写入outerHTML时，调用它的元素会被传入的HTML字符串经解释后生成的DOM子树替代</li>\n<li>\n<p>insertAdjacentHTML()与insertAdjacentText()都接受两个参数，要插入标记的位置和要插入的HTML或文本。第一个参数必须是下列值之一</p>\n<ul>\n<li>\"beforebegin\": 插入当前元素前面，作为前一个同胞节点</li>\n<li>\"afterbegin\":插入当前元素内部，作为新的子节点或放在第一个子节点之前</li>\n<li>\"beforeend\": 插入当前元素内部，作为新的子节点或放在最后一个子节点之后</li>\n<li>\"afterend\": 插入当前元素后面，作为下一个同胞节点</li>\n</ul>\n</li>\n<li>这几个值是不区分大小写的，第二个参数会作为HTML字符串解析或作为纯文本解析，如果是HTML，就会在解析出错时抛出错误</li>\n<li>HTML5标准化了控制页面滚动的方法：scrollIntoView()</li>\n<li>\n<p>scrollIntoView方法存在于所有HTML元素上，可以滚动浏览窗口或视图容器元素方便包含元素进入视口，参数如下</p>\n<ul>\n<li>alignToTop是一个布尔值</li>\n<li>true: 窗口滚动后元素的顶部与视口顶部对齐</li>\n<li>false: 窗口滚动后元素底部与视口底部对齐</li>\n<li>scrollIntoViewOptions是可选对象</li>\n<li>behavior: 定义过渡动画，可取值为\"smooth\"和\"auto\"，默认为\"auto\"</li>\n<li>block:定义垂直方向的对齐，可取值为\"start\"，\"center\",\"end\",\"nearest\"，默认为\"start\"</li>\n<li>inline: 定义水平方向的对齐，可取值为\"start\"，\"center\",\"end\",\"nearest\"，默认为\"start\"</li>\n<li>不传参数等价于alignToTop为true</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"language-js\">// 元素可见\ndocument.forms[0].scrollIntoView()\ndocument.forms[0].scrollIntoView(true)\ndocument.forms[0].scrollIntoView({ block: 'start', behavior: 'smooth' }) // 平滑滚动\n</code></pre>\n<h2>专有拓展</h2>\n<ul>\n<li>浏览器也实现了一些专有拓展，这些拓展有可能以后会被标准化，只是在这个阶段还是专有的</li>\n<li>IE9之前的版本与其他浏览器处理空白节点的不一致导致了children属性的出现，children是一个HTMLCollection，只包含元素的Element类型的自己诶单</li>\n<li>IE引入了contains()方法用于让开发者在不便利DOM的情况下知道一个元素是否是另一个元素的后代，在要被搜索的祖先元素上调用，如果目标节点是被搜索节点的后代，就返回true，否则返回false</li>\n</ul>\n<pre><code class=\"language-js\">console.log(document.documentElement.contains(document.body))\n</code></pre>\n<ul>\n<li>\n<p>DOM Level 3中的compareDocumentPosition()方法也可以确定节点间的关系，返回关系的位掩码</p>\n<ul>\n<li>0x1: 断开，传入接点不在文档中</li>\n<li>0x2: 领先（传入接点在DOM树中位于参考节点之前）</li>\n<li>0x4: 落后（传入接点在DOM树中位于参考节点之后）</li>\n<li>0x8: 包含（传入接点是参考节点的祖先）</li>\n<li>0x10: 被包含（传入接点是参考节点的后代）</li>\n</ul>\n</li>\n<li>可以使用compareDocumentPosition()来模仿contains</li>\n</ul>\n<pre><code class=\"language-js\">let result = document.documentElement.compareDocumentPosition(document.body)\nconsole.log(!!(result &#x26; 0x10))\n</code></pre>\n<ul>\n<li>上面代码执行后result值为20（或0x14，0x4表示随后，加上0x10“被包含”）。对result和0x10应用按位与会返回非零值，然后将其转为对应布尔值</li>\n<li>IE9及以后版本以及现代浏览器都支持contains跟compareDocumentPosition方法</li>\n<li>innerText与outerText未进入标准，innerText属性对应元素中包含的所有文本内容，无论文本在子树中哪个层级。在取值时都会按照深度优先的方式把子树中的所有文本节点的值拼起来</li>\n<li>写入时，会移除元素的所有后代并插入一个包含该值的文本节点</li>\n</ul>\n<pre><code class=\"language-js\">div.innerText = div.innerText // 可用于去除所有html标签\n</code></pre>\n<ul>\n<li>innerText获得所有浏览器的支持，取得或设置文本内容时应该作为首选采用</li>\n<li>outerText在取值时跟innerText返回值一样，但是在写入时，outerText不止移除所有后代，还会替换整个元素</li>\n<li>outerText是一个非标准化的属性，不推荐使用这个属性，除Firefox外所有主流浏览器都支持outerText</li>\n<li>HTML5实现了scrollIntoView()方法，但其他浏览器也有专有方法，比如scrollIntoViewIfNeeded()作为HTMLElement类型的拓展在所有元素上使用。</li>\n<li>scrollIntoViewIfNeeded(alingCenter)会在元素不可见得情况下将其滚动到窗口或者包含窗口中，使其可见，如果已经在可见窗口就什么都不会做。如果将可选的参数alingCenter设为true，浏览器会尝试将它放到视口中央，Safari、Chrome、Opera都实现了这个方法</li>\n</ul>\n<h2>内存与性能</h2>\n<ul>\n<li>本节介绍的方法替换子节点可能在浏览器（IE）中导致内存问题，比如被移除的字数元素中有关联的事件处理程序或其他JavaScript对象（作为元素的属性），那它们的存在关系就会留在内存中。这种操作频繁发生，页面的内存就会飙升，所以使用innerHTML、outerHTML、inertAdjacentHTML之前最好手动删除要替换的元素上关联的事件处理程序与JavaScript对象</li>\n<li>使用inerHTML比DOM操作更快是因为HTML解析器会解析设置给innerHTML的值，解析器一般在浏览器中是底层代码，比JavaScript要快很多</li>\n<li>但是使用innerHTML也是有代价的，所以最好限制使用innerHTML的次数，将批量的操作统一处理</li>\n<li>尽管innerHTML不会执行自己创建的script标签，但仍然向恶意用户暴露了很大的攻击面，通过它可以毫不费力的创建元素并执行click等属性，如果页面要使用用户提供的信息，建议不使用innerHTML。防止XSS攻击，所以需要隔离插入的数据，插入页面前使用相关库进行转义</li>\n</ul>","fields":{"slug":"/DOM_API/"},"frontmatter":{"title":"DOM拓展","tags":["JavaScript回顾"],"categories":"JavaScript"}}},{"node":{"html":"<h1>从零搭建一个react-hooks项目（六）</h1>\n<ul>\n<li>最近项目比较忙，所以有段时间没有补充新内容了，直到github提示有人给我提了issue才抽时间补了一下这个内容</li>\n<li>之前已经完成了webpack的搭建与优化，可以完成项目的基本使用，这位热心的伙伴也是提出了一些关于eslint的建议，所以这次补充一下ESLint的引入</li>\n<li>我们的项目使用了react与typescript，有typescript的存在看起来应该使用TSLint，但是官方提出以后会弃用TSLint，转而使用ESLint，声明也说了ESLint对TS的支持很完善，所以我们就引入一下ESLint</li>\n</ul>\n<h2>在项目中安装ESLint</h2>\n<ul>\n<li>首先安装ESLint与TS的相关依赖</li>\n</ul>\n<pre><code class=\"language-js\">// yarn add eslint @typescript-eslint/eslint-plugin @typescript-eslint/parser\nnpm install eslint @typescript-eslint/eslint-plugin @typescript-eslint/parser --save-dev\n</code></pre>\n<ul>\n<li>\n<p>然后在项目的根目录创建 .eslintrc.json 文件，然后补充下面选项进入</p>\n<!--more-->\n<pre><code class=\"language-js\">// .eslintrc.json\n{\n\"parser\": \"@typescript-eslint/parser\",\n\"parserOptions\": {\n\"jsx\": true,\n\"useJSXTextNode\": true\n},\n\"extends\": [\n\"plugin:@typescript-eslint/recommended\"\n],\n\"plugins\": [\"@typescript-eslint\"]\n}\n</code></pre>\n</li>\n<li>parser告诉ESLint使用typescript模式解析，parserOpions告诉ESLint我们想要使用jsx语法</li>\n<li>extends是表明我们想要使用ESLint中typescript的推荐语法</li>\n<li>plugins中是我们要用到的ESLint包含的详细typescript的解析规则</li>\n</ul>\n<h2>使用prettier</h2>\n<ul>\n<li>使用prettier就是告诉ESLint我们已经在本地校验过代码格式了，你可以不用关心代码的格式怎么样，下面是安装的依赖</li>\n</ul>\n<pre><code class=\"language-js\">// yarn add prettier eslint-config-prettier\nnpm install prettier eslint-config-prettier --save-dev\n</code></pre>\n<ul>\n<li>然后就需要在ESLint的配置规则中进行拓展，拓展之后能给我们更好看的代码格式校验，修改 .eslintrc.json 文件如下</li>\n</ul>\n<pre><code class=\"language-js\">{\n  \"parser\": \"@typescript-eslint/parser\",\n  \"parserOptions\": {\n    \"jsx\": true,\n    \"useJSXTextNode\": true\n  },\n  \"extends\": [\n    \"plugin:@typescript-eslint/recommended\",\n    \"prettier\",\n    \"prettier/@typescript-eslint\"\n  ],\n  \"plugins\": [\"@typescript-eslint\"]\n}\n</code></pre>\n<h2>使用VSCode优化编码体验</h2>\n<ul>\n<li>上面添加了基本的校验规则，但是不会在我们编码的时候主动为我们执行检查，所以我们可以通过配置VSCode插件来让编辑器实时为我们检查</li>\n<li>先在VSCode的插件库里搜索ESlint，然后安装并重启</li>\n<li>之后在 文件 -> 首选项 -> 设置中搜索 setting.json ，然后在 setting.json 最外层补充</li>\n</ul>\n<pre><code class=\"language-js\">// setting.json\n{\n  // otherSetting\n  \"eslint.validate\": [\n    \"javascript\",\n    \"javascriptreact\",\n    {\n        \"language\": \"typescript\",\n        \"autoFix\": true\n    },\n    {\n        \"language\": \"typescriptreact\",\n        \"autoFix\": true\n    }\n  ],\n}\n</code></pre>\n<ul>\n<li>之后再打开我们的代码就发现可以在每个页面提醒我们代码中的格式问题</li>\n</ul>\n<h2>配置hooks</h2>\n<ul>\n<li>因为我们的项目使用了hooks，所以我们需要添加hooks的解析规则帮助我们修复hooks编写中的问题</li>\n<li>首先安装相关的依赖</li>\n</ul>\n<pre><code class=\"language-js\">// yarn add eslint-plugin-react-hooks\nnpm install eslint-plugin-react-hooks --save-dev\n</code></pre>\n<ul>\n<li>然后在 .eslintrc.json 中补充相关的配置，配置如下</li>\n</ul>\n<pre><code class=\"language-js\">// .eslintrc.json\n{\n  \"parser\": \"@typescript-eslint/parser\",\n  \"parserOptions\": {\n    \"jsx\": true,\n    \"useJSXTextNode\": true\n  },\n  \"extends\": [\n    \"plugin:@typescript-eslint/recommended\",\n    \"prettier\",\n    \"prettier/@typescript-eslint\"\n  ],\n  \"plugins\": [\"@typescript-eslint\", \"react-hooks\"],\n  \"rules\": {\n    \"@typescript-eslint/explicit-function-return-type\": \"off\",\n    \"react-hooks/rules-of-hooks\": \"error\",\n    \"react-hooks/exhaustive-deps\": \"warn\"\n  }\n}\n</code></pre>\n<ul>\n<li>这样引入了hooks的校验之后就会帮我们提示一些类似于在非react组件中使用hooks语法这样的语法错误</li>\n<li>好了，上面就是引入代码规范ESLint的步骤了，有什么问题也可以私我啊</li>\n</ul>","fields":{"slug":"/react_md_6/"},"frontmatter":{"title":"从零搭建一个react-hooks项目（六）","tags":["react","react hooks","redux","webpack","esLint"],"categories":"Webpack"}}}]}},"pageContext":{}},"staticQueryHashes":["2566592090"]}