{"componentChunkName":"component---src-pages-index-js","path":"/","result":{"data":{"allMarkdownRemark":{"totalCount":40,"edges":[{"node":{"html":"<h1>字符串排列 (No repeats please)</h1>\n<h2>题目链接</h2>\n<ul>\n<li><a href=\"https://freecodecamp.cn/challenges/no-repeats-please\">中文链接</a></li>\n<li><a href=\"https://freecodecamp.com/challenges/no-repeats-please\">英文链接</a></li>\n</ul>\n<h2>问题解释</h2>\n<ul>\n<li>这个 <code>function</code> 接收一个字符串参数 <code>str</code>。返回值为参数 <code>str</code> 没有连续重复字符串的排列个数</li>\n<li>如果 <code>str</code> 为 <code>\"aab\"</code>，则返回值应为 <code>2</code>，因为全排列后，会出现两个 <code>\"aba\"</code>，不含连续重复字符串 (排除 <code>\"aab\"</code> 和 <code>\"baa\"</code>)</li>\n</ul>\n<!--more-->\n<h1>解题思路</h1>\n<ul>\n<li>这道题应该是高级算法题目中难度稍大的一道题。题目的难点在于获取字符串的全排列。我觉得这里有必要先说一下，如何获取全排列</li>\n<li>只要我们可以获取字符串的全排列，那就至少有两种方式判断字符串是否含有连续重复的字符。可以遍历，也可以用正则</li>\n<li><a href=\"https://zh.wikipedia.org/wiki/%E7%BD%AE%E6%8F%9B\">排列 (也叫置换)，Permutation</a> 与 <a href=\"https://zh.wikipedia.org/wiki/%E7%B5%84%E5%90%88\">组合，Combination</a>，高中数学就已经涉及到。比如，对于 <code>123</code>，从中取出两个数有三种组合，分别是 <code>12</code>、<code>13</code> 和 <code>23</code>。同样是取出两个数，有六种排列，分别是 <code>12</code>、<code>21</code>、<code>13</code>、<code>31</code>、<code>23</code> 和 <code>32</code></li>\n<li>再说一下什么是全排列 (Full Permutation)，全排列的意思是，从 <code>n</code> 个中取出 <code>n</code> 个的排列。对于 <code>123</code>，取出三个数的排列，就是 <code>123</code> 的全排列。<code>123</code> 的全排列总共有六种，分别是 <code>123</code>、<code>132</code>、<code>213</code>、<code>231</code>、<code>312</code> 和 <code>321</code>。计算数量方式很简单，就是 <code>n!</code>，<code>n</code> 的阶乘。对于 <code>123</code> 来说，也就是 <code>3!</code>，得 <code>6</code></li>\n</ul>\n<h2>全排列的实现 - 封装，循环</h2>\n<ul>\n<li>\n<p>我们可以先根据这个实际的例子想想，怎样才能无遗漏的输出全排列</p>\n<ul>\n<li>两个数就不用说了，对于 <code>12</code>，只有 <code>12</code> 和 <code>21</code> 两种</li>\n<li>\n<p>三个数，比如 <code>123</code>，我们先分为三种情况，就是 <code>1</code> 开头，<code>2</code> 开头和 <code>3</code> 开头</p>\n<ul>\n<li>对于 <code>1</code> 开头的情况，剩下 <code>2</code> 和 <code>3</code>，这就回到了两个数的排列</li>\n<li>对于 <code>2</code> 开头的情况，剩下 <code>1</code> 和 <code>3</code>，这也回到了两个数的排列</li>\n<li><code>3</code> 开头的情况同理</li>\n</ul>\n</li>\n<li>四个数，先按照开头分为四种情况，然后按照三个数的排列去处理</li>\n<li>......</li>\n<li>以此类推</li>\n</ul>\n</li>\n<li>你可能已经看出来了，这就是一个递归。就好像求斐波那契数列的某一个元素，我们要先求出前面的；要想求出前面的，我们就要求出更前面的。记 \"斐波那契数列的第 <code>n</code> 位\" 这件事为 <code>F(n)</code>，则有 <code>F(n) = F(n - 1) + F(n - 2)</code></li>\n<li>类似地，记 \"求出 <code>n</code> 个字符串的全排列\" 这件事为 <code>P(n)</code>，则有 <code>P(n) = 分别以这n个字符之一开头 + P(n - 1)</code>。其中，<code>P(n - 1)</code> 表示去掉那个开头字符的剩余字符串的全排列。哪怕只有两个字符，比如对于上面例子中的 <code>12</code>，同样符合这一条结论</li>\n<li>以 <code>'abc'</code> 为例，执行步骤如下：</li>\n</ul>\n<pre><code>给出 abc\n\n1. a 作为开头 -> 求 bc 全排列 -> 得到 bc 和 cb -> 与 a 合并 -> 得到 abc 和 acb\n2. b 作为开头 -> 求 ac 全排列 -> 得到 ac 和 ca -> 与 b 合并 -> 得到 bac 和 bca\n3. c 作为开头 -> 求 ab 全排列 -> 得到 ab 和 ba -> 与 c 合并 -> 得到 cab 和 cba\n</code></pre>\n<ul>\n<li>注意，这只是其中一种实现方式。后面我们还会看到另一种实现</li>\n<li>首先我们来想一下公共逻辑是什么。对于一个字符串，我们取出一个字符作为开头，然后对去掉这个开头字符的剩余字符串继续求全排列。求出来之后，与取到的字符合并起来就行</li>\n<li>对于 <code>P(n)</code> 来说，我们要取出一个字符作为开头，而且原始的字符串可能本身就含有重复的字符。在代码中，我们可以通过开头字符在原字符串中的索引来区分</li>\n<li>对于我们封装的函数，可以直接使用字符串作为参数。这是因为，在获取剩余字符串全排列，即 <code>P(n - 1)</code> 时，我们并不关心去掉的那个，用作开头的字符是什么，只需要关心现在我们要生成谁的全排列就好</li>\n<li>因此，我们需要在递归调用时，传入去掉那个用作开头的字符之后的，剩余字符串。这个很容易实现，如果我们知道了去掉的那个字符的索引，那我们就可以用 <code>str.slice(0, i)</code> 来获取这个字符之前的字符串，用 <code>str.slice(i + 1, str.length)</code> 来获取这个字符之后的字符串 (注意，<code>slice</code> 方法的第一个参数是包含的，第二个不包含。如果 <code>i</code> 本身就是 <code>0</code>，那么取到的是 <strong>空字符串</strong>)，拼接在一起就可以作为递归调用的参数</li>\n<li>跳出条件也不难想，只要传入的参数长度为 <code>1</code> 或 <code>0</code>，直接返回即可</li>\n<li>另外，每次调用，我们都需要一个数组来保存根据当前参数生成的全排列。代码如下</li>\n</ul>\n<pre><code class=\"language-js\">function permAlone(string) {\n    function _perm(str) {\n        // 跳出条件\n        if (str.length &#x3C; 2) return str;\n        var permutations = [];\n\n        for (var i = 0; i &#x3C; str.length; i++) {\n            // 获取开头的字符串和剩余字符串\n            var start = str[i];\n            var remaining = str.slice(0, i) + str.slice(i + 1, str.length);\n\n            // 根据通过剩余字符串的全排列，生成前一次的全排列。注意 _perm(remaining) 是一个数组\n            for (var permutation of _perm(remaining)) {\n                permutations.push(start + permutation);\n            }\n        }\n        return permutations;\n    }\n}\n</code></pre>\n<h2>判断连续重复字符</h2>\n<h3>遍历</h3>\n<ul>\n<li>判断是否有连续重复的字符，最简单的方式是遍历。只需要在外面用一个变量记录上一个字符就可以</li>\n<li>只要当前的和上一个相同，直接跳出就可以，不需要继续判断。代码如下：</li>\n</ul>\n<pre><code class=\"language-js\">function hasRepeatChar(str) {\n    var previous = '';\n    for (var i = 0; i &#x3C; str.length; i++) {\n        if (previous === str[i]) {\n            return true;\n        } else {\n            // 赋值，用于下次判断\n            previous = str[i];\n        }\n    }\n    // 不存在连续重复字符\n    return false;\n}\n</code></pre>\n<h3>递归</h3>\n<ul>\n<li>递归也是很容易写的。跟上面的思路一样，调用的时候传入两个参数，分别是上一个字符，和剩余字符串。其中，剩余字符串可以通过 <code>str.slice(1)</code> 获取</li>\n<li>为避免 <code>str</code> 本身就是空字符串，需要多一次判断，即如果 <code>prevChar</code> 不是空的 (这说明 <code>prevChar</code> 被赋过值，而并非初始的空值)，我们才可以认为 <code>str</code> 不含连续重复字符，则返回 <code>false</code>。因此，跳出条件是 <code>str</code> 为空且 <code>prevChar</code> 有值。如果这时候 <code>prevChar</code> 也是空的，那就证明传入的 <code>str</code> 本身就是空的。为了防止混淆，我们直接给它返回 <code>\"Empty string\"</code>。事实上，这种 corner case 在这道题目中不会遇到。代码如下：</li>\n</ul>\n<pre><code class=\"language-js\">function hasRepeatChar(str, prevChar) {\n    if (str.length === 0) return prevChar ? false : 'Empty string';\n    if (prevChar === str[0]) return true;\n\n    return hasRepeatChar(str.slice(1), str[0]);\n}\n</code></pre>\n<h3>正则表达式</h3>\n<ul>\n<li>正则是个好东西。在正则里，有一中写法叫做 <code>back reference</code>，就是 <code>\\\\</code> 后面加一个正整数。请参考 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions\">文档</a> 中 <code>\\\\n</code> 的那一行</li>\n<li>简单来说，<code>\\\\x</code> 就是匹配之前，正数第 <code>x</code> 个 matched group (匹配组，也叫捕获组，其实就是小括号包含的内容)</li>\n<li>对于判断一个字符串是否含有连续重复字符，我们并不关注它重复了几次，也不需要关注它有几组重复的。因此，这里不需要 <code>global</code> flag <code>/g</code></li>\n<li>那么，对于字符串中的任意字符，只要这个字符右边的字符和它相同，那就匹配到，并且返回 <code>false</code>。听起来像是句废话，只是，如果你看不懂后面的正则，记得回来再读读这句话。代码如下：</li>\n</ul>\n<pre><code class=\"language-js\">function hasRepeatChar(str) {\n    return !/(\\w)\\1/.test(str);\n}\n</code></pre>\n<h1>基本解法</h1>\n<h2>思路提示</h2>\n<ul>\n<li>思路上面已经说得很清楚。通过上面的递归调用，我们可以得到了一个包含字符串全排列的数组，只需要通过上面的正则过滤一下，保留不含连续重复字符的字符串，并返回它的 <code>length</code></li>\n</ul>\n<h2>代码</h2>\n<pre><code class=\"language-js\">function permAlone(string) {\n    function _perm(str) {\n        if (str.length &#x3C; 2) return str;\n        var permutations = [];\n\n        for (var i = 0; i &#x3C; str.length; i++) {\n            var start = str[i];\n            var remaining = str.slice(0, i) + str.slice(i + 1, str.length);\n\n            for (var permutation of _perm(remaining)) {\n                permutations.push(start + permutation);\n            }\n        }\n        return permutations;\n    }\n    return _perm(string).filter(function(str) {\n        return !/(\\w)\\1/.test(str);\n    }).length;\n}\n</code></pre>\n<h1>数组方法 - 思路的优化</h1>\n<h2>思路提示</h2>\n<ul>\n<li>上面的方式是把子问题 (剩余字符串的全排列) 添加到之前取出的开头字符后面，这也就意味着，对于长度为 <code>n</code> 的字符串 <code>string</code>，开头的字符我们要获取 <code>n</code> 次。每一次取了开头，我们又要再对子问题进行 <code>n - 1</code> 次取开头的操作，因此这时候的时间复杂度会是 <code>n!</code>。效率很低</li>\n<li>如果我们换一个思路，采用 \"插值\" 的方法，会让整体操作变少一些。注意，这个思路并不一定需要用数组去实现。确切的说，如果不用数组去实现，效率会更高。只是个人觉得，用数组会比较容易写，也比较容易理解</li>\n<li>之前的方式，如果我们说它是 \"从前往后\" 实现的，那现在我们来试试从后往前实现</li>\n<li>对于字符串 <code>'abc'</code>，给出子串 <code>'bc'</code>，剩余 <code>'a'</code>。我们可以通过把 <code>'a'</code> 放到 <code>'bc'</code> 里面，不同的位置来实现排列。注意到 <code>'bc'</code> 有三个位置可以插入 <code>'a'</code>，分别是：</li>\n</ul>\n<pre><code> b c\n↑ ↑ ↑\n1 2 3\n</code></pre>\n<ul>\n<li>如果把 <code>'a'</code> 分别插入上面说的位置 <code>1</code>、<code>2</code> 和 <code>3</code>，我们就可以得到 <code>'abc'</code>、<code>'bac'</code> 和 <code>'bca</code></li>\n<li><code>'bc'</code> 排列还有一种情况 <code>'cb'</code>。再把 <code>'a'</code> 插入到 <code>'cb'</code> 的三个位置，我们就可以得到另外三种排列</li>\n<li>注意到，<code>'bc'</code> 和 <code>'cb'</code>，其实就是在子串 <code>'c'</code> 中插入 <code>'b'</code> 产生的。因为 <code>'c'</code> 只有两个位置可以插入 <code>'b'</code>：</li>\n</ul>\n<pre><code> c\n↑ ↑\n1 2\n</code></pre>\n<ul>\n<li>这样，我们就得到了一个新的递归思路，如下 (左边的竖线只是为了方便看清递归弹出的时候对应上面的哪一步，弹出步骤中的插入值与上面取出的第一个字符相对应)：</li>\n</ul>\n<pre><code>给出 'abc'\n\n|- 取出第一个字符 a，剩余 bc\n|  |- 取出第一个字符 b，剩余 c\n|  |  |- 取出第一个字符 c，剩余空字符串 (划重点，这个就是弹出的条件)\n|  |  |- 在上次剩余值中插入 c，只能得到一种情况 c\n|  |- 在上次剩余值 (c) 中插入 b，得到 bc 和 cb\n|- 在上次剩余值 (bc 和 cb) 中插入 a，得到 abc, bac, bca 和 acb, cab, cba\n</code></pre>\n<ul>\n<li>这个思路很像是，先一直走到底 (即长度为 0 的时候)，弹出的过程中，我们再来生成需要的结果</li>\n<li>这段代码加注释不太方便，详细解释还是写到代码之后吧</li>\n<li>如果你还是不知道如何写代码，不要怕麻烦，试着写出来 <code>'abcd'</code> 的详细过程，写完你就能理解了</li>\n</ul>\n<h2>代码</h2>\n<pre><code class=\"language-js\">function permAlone(string) {\n    return _perm(string.split('')).filter(function(str) {\n        return !/(\\w)\\1/.test(str);\n    }).length;\n\n    function _perm(arr) {\n        return arr.length === 0 ? [[]] : _perm(arr.slice(1)).reduce(function(accum, curr) {\n            // 插值的实现\n            for (var i = 0; i &#x3C; arr.length; i++) {\n                accum.push([curr.slice(0, i), arr[0], curr.slice(i)].join(''));\n            }\n            return accum;\n        }, []);\n    }\n}\n</code></pre>\n<h2>解释</h2>\n<ul>\n<li>先说一句，上面的代码，尽管思路优化了，但速度理论上会比之前的慢，因为咱们用了数组</li>\n<li>外面那层应该没啥疑问，既然决定了用数组去处理，那就干脆直接传入数组，一个 <code>split</code> 的事儿而已</li>\n<li>封装的 <code>_perm</code>，其实还是要进行递归调用的。当外面的 <code>string</code> 是空字符串时，返回值是 <code>[[]]</code>，而不可以是 <code>[]</code>。原因很简单，如果是 <code>[]</code>，那么 <code>reduce</code> 就不会执行了，因为没有元素。你可以试试以下的代码片段，就理解了：</li>\n</ul>\n<pre><code class=\"language-js\">// 不会输出 '执行了'，返回值是 []\n[].reduce((accum, curr) => {\n    console.log('执行了');\n    return accum;\n}, []);\n\n// 会输出 '执行了'，返回值也是 []\n[[]].reduce((accum, curr) => {\n    console.log('执行了');\n    return accum;\n}, []);\n</code></pre>\n<ul>\n<li>只要 <code>arr</code> 长度不为 <code>0</code>，那我们就递归调用 <code>_perm(arr.slice(1))</code>，直到遇到传入的 <code>arr</code> 长度为 <code>0</code>，才开始执行 <code>reduce</code> 弹出的过程。详情请看上面的思路分析</li>\n<li>里面的 <code>for</code> 循环很重要，\"插值\" 这个核心步骤就是在这里实现的。如果看不懂这个过程，请去了解一下 <code>slice</code> 方法是怎么回事，然后举几个例子带进去试一试就明白了</li>\n</ul>\n<h1>算法优化 - Heap's algorithm</h1>\n<h2>思路提示</h2>\n<ul>\n<li>注意，这里的 Heap 不是指数据结构的 \"堆\"，而是发明者的名字。如果你从来没听说过这个算法，那只靠自己想可能有些困难</li>\n<li>\n<p>给出字符串 <code>'abc'</code>，我们可以按照先确定结尾字符的思路来这样推一下：</p>\n<ul>\n<li>\n<p><code>'c'</code> 作为结尾：</p>\n<ul>\n<li>我们得到第一个排列 <code>'abc'</code></li>\n<li>通过交换 <code>'a'</code> 和 <code>'b'</code>，我们可以得到另一种排列 <code>'bac'</code></li>\n</ul>\n</li>\n<li>\n<p>交换开头结尾，这时候 <code>'b'</code> 作为结尾：</p>\n<ul>\n<li>得到 <code>'cab'</code></li>\n<li>通过交换 <code>'c'</code> 和 <code>'a'</code>，得到 <code>'acb'</code></li>\n</ul>\n</li>\n<li>\n<p>交换开头结尾，这时候 <code>'a'</code> 作为结尾：</p>\n<ul>\n<li>得到 <code>'bca'</code></li>\n<li>通过交换 <code>'b'</code> 和 <code>'c'</code>，得到 <code>'cba'</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>思路大致上是这样，通过交换去实现。交换的好处在于，我们不需要额外的空间去存储。值得注意的是，在 JavaScript 中，字符串可以通过 index 访问某一个位置的字符，但不可以修改它的值。因此，想要换位，我们还是要通过数组来实现的</li>\n<li>事实上，真正实现起来还与上面的例子有区别。在 <code>Heap's Algorithm</code> 的 <a href=\"https://en.wikipedia.org/wiki/Heap%27s_algorithm\">维基百科页面</a> 有详细的解释，也有四个元素的详细步骤示例。其实，并不是 \"交换开头结尾\" 这么简单的</li>\n<li>实现数组中元素交换的方式也非常多。有朋友可能首先想到的是用 <code>splice</code>，但这样做效率会很低，我会比较推荐用变量缓存一个值的做法，很容易写。比如，我们需要交换 index 为 <code>2</code> 和 <code>4</code> 的元素：</li>\n</ul>\n<pre><code class=\"language-js\">var arr = [1, 2, 3, 4, 5, 6];\n\nvar temp = arr[2];\narr[2] = arr[4];\narr[4] = temp;\n\nconsole.log(arr);  // [1, 2, 5, 4, 3, 6]\n</code></pre>\n<ul>\n<li>当然，还有一种比较好玩儿的黑科技：</li>\n</ul>\n<pre><code class=\"language-js\">var arr = [1, 2, 3, 4, 5, 6];\narr[2] = [arr[4], arr[4] = arr[2]][0]\n\nconsole.log(arr);  // [1, 2, 5, 4, 3, 6]\n</code></pre>\n<ul>\n<li>如果你听说过 ES6 的解构赋值，也可以这么写。注意这个在不支持 ES6 的浏览器里是不行的：</li>\n</ul>\n<pre><code class=\"language-js\">var arr = [1, 2, 3, 4, 5, 6];\n[arr[2], arr[4]] = [arr[4], arr[2]]\n\nconsole.log(arr);  // [1, 2, 5, 4, 3, 6]\n</code></pre>\n<ul>\n<li>维基百科页面也提供了伪代码，而且提供了递归和非递归的两个版本。两个版本都用到了两个参数，但我们只需要一个 <code>n</code> 就够了，不需要第二个 <code>A</code>，因为我们的数组可以通过 <code>var arr = str.split('');</code> 将它定义到函数 <code>generate</code> 外面。这样，伪代码如下：</li>\n</ul>\n<pre><code class=\"language-js\">函数 generate\n参数 num\n\n如果 num 等于 1:\n    arr.join('')，并添加到结果数组\n否则:\n    循环，0 至 num:\n        递归调用 generate(num - 1)\n        如果 num 为偶数:\n            交换 strArr[i] 与 strArr[num - 1]\n        如果 num 为奇数:\n            交换 strArr[0] 与 strArr[num - 1]\n</code></pre>\n<h2>代码</h2>\n<pre><code class=\"language-js\">function permAlone(str) {\n    var arr = str.split('');\n    var result = [];\n    // 声明需要放在这里，因为赋值是在弹出的时候执行的\n    var tempIndex;\n\n    function generate(num) {\n        if (num === 1) {\n            result.push(arr.join(''));\n        } else {\n            for (var i = 0; i &#x3C; num; i++) {\n                generate(num - 1);\n                tempIndex = num % 2 ? 0 : i;\n                arr[tempIndex] = [arr[num - 1], arr[num - 1] = arr[tempIndex]][0];\n            }\n        }\n    }\n    \n    generate(arr.length);\n    \n    return result.filter(function(str) {\n        return !/(\\w)\\1/.test(str);\n    }).length;\n}\n</code></pre>","fields":{"slug":"/advanced-no-repeats-please/"},"frontmatter":{"title":"FreeCodeCamp 高级算法题 - 字符串排列","tags":["FreeCodeCamp","高级","算法"],"categories":"FCC"}}},{"node":{"html":"<h1>类型</h1>\n<h2>内置类型</h2>\n<ul>\n<li>内置类型有哪些？如何校验？</li>\n<li>特殊类型有哪些？注意事项是？</li>\n</ul>\n<h2>问题解释</h2>\n<ul>\n<li>内置类型为空值<code>(null)</code>，未定义<code>(undefined)</code>，布尔值<code>(boolean)</code>，数字<code>(number)</code>，字符串<code>(string)</code>，对象<code>(object)</code>，符号<code>(symbol,ES6新增)</code></li>\n<li>\n<p>特殊类型为空值(特殊对象)，数组(特殊对象)，函数(特殊对象)</p>\n<!--more-->\n</li>\n<li>类型校验</li>\n</ul>\n<pre><code class=\"language-js\">typeof undefined === 'undefined' //true\ntypeof true === 'boolean' //true\ntypeof 42 === 'number' //true\ntypeof '42' === 'string' //true\ntypeof {a:2} === 'object' //true\ntypeof Symbol() === 'symbol' //true\n// 特殊情况\ntypeof null === 'object' //true\ntypeof [1,2,3] === 'object' //true\ntypeof function(){} === 'function' // true\n</code></pre>\n<h2>校验方式</h2>\n<ul>\n<li>校验null (!a &#x26;&#x26; typeof a ==='object') //true</li>\n<li>校验数组 arr.constructor === Array 或 arr instanceof Array</li>\n</ul>\n<h2>数组</h2>\n<ul>\n<li>数组可以容纳任何类型的值，无需设定大小</li>\n<li>delete运算符可以将单元从数组中删除，但，删除后，数组length属性不会发生变化</li>\n<li>数组通过数组进行索引，但因为它是对象的本质，所以也可以包含字符串键值与属性<code>(但并不计算在数组长度内)</code></li>\n</ul>\n<pre><code class=\"language-js\">    var a = []\n    a[0] = 1\n    a['foo'] = 2\n    a.length; // 1\n    a['foo']; // 2\n    a.foo;    // 2\n</code></pre>\n<ul>\n<li>注意点：若字符串键值能强制转换为数字的话，会被当作数字索引来处理</li>\n</ul>\n<pre><code class=\"language-js\">      var a = []\n      a['13'] = 42\n      a.length; // 14\n</code></pre>\n<ul>\n<li>Array.from()可将类数组对象转为数组对象，例（arguments,dom列表）</li>\n</ul>\n<h2>字符串与字符串数组</h2>\n<ul>\n<li>都具有<code>length</code>属性与<code>indexOf</code>方法和<code>concat</code>方法</li>\n</ul>\n<pre><code class=\"language-js\">    var a = 'foo'\n    var b = ['f','o','o']\n\n    a.length; // 3\n    b.length; //3\n\n    a.indexOf('o') // 1\n    b.indexOf('o') // 1\n    var c = a.concat('bar') //foobar\n    var d = b.concat(['b', 'a', 'r']) // ['f', 'o', 'o', 'b', 'a', 'r']\n</code></pre>\n<ul>\n<li>字符串没有数组函数，但可以借用数组的非变更方法来处理</li>\n</ul>\n<pre><code class=\"language-js\">    var c = Array.prototype.join.call(a, '-')\n    var d = Array.prototype.map.call(a, function(v) {\n      return v.toUpperCase() + '.'\n    }).join(\"\")\n    c; //\"f-o-o\"\n    d: //\"f.o.o\"\n</code></pre>\n<ul>\n<li>不可借用数组的可变成员函数reverse,因为字符串是不可变的<code>Array.prototype.reserve.call(a)</code>无效</li>\n<li>处理方法：</li>\n</ul>\n<pre><code class=\"language-js\">    var c = a.split(\"\").reverse().join(\"\")\n</code></pre>\n<h2>数字</h2>\n<ul>\n<li>检测是否是整数 <code>Number.isInteger()</code></li>\n<li>检测是狗是安全整数 <code>Number.isSafeInteger()</code></li>\n<li>检测是否是NaN <code>Number.isNaN()</code></li>\n<li>检测两个值是否绝对相等 <code>Object.is(a, b)</code></li>\n</ul>\n<h2>奇特的小技巧</h2>\n<ul>\n<li>~运算符可将结果强制类型转换为真值/假值</li>\n</ul>\n<pre><code class=\"language-js\">    var a = \"Hello world\"\n    if(~a.indexOf('lo')) { // true\n      // 找到匹配\n    }\n    // 相应的 !~a.indexOf('lo')为未找到匹配\n</code></pre>","fields":{"slug":"/type/"},"frontmatter":{"title":"你不知道的javascript-类型","tags":["JavaScript","入门"],"categories":"JavaScript"}}},{"node":{"html":"<h1>TCP协议的3次握手与4次分手</h1>\n<h2>TCP协议的连接与断开</h2>\n<ul>\n<li>什么是<code>TCP</code>协议的<code>三次握手</code>？为什么会有<code>三次握手</code>？</li>\n<li>什么是<code>TCP</code>协议的四次分手？为什么会有四次分手？</li>\n</ul>\n<h2>问题解释</h2>\n<ul>\n<li>TCP的<code>三次握手</code>其实是在<code>客户端</code>与<code>服务端</code>建立一个TCP连接，在<code>TCP/IP</code>协议中，采用三次握手可建立可靠的连接服务</li>\n<li>TCP的<code>四次分手</code>用来断开客户端与服务端的连接</li>\n</ul>\n<!--more-->\n<h2>详解</h2>\n<h3>TCP报文重要字段解释</h3>\n<ul>\n<li>序号：<code>seq</code>序号，标识从TCP源向目的端发送字节流，并由发送端对其标记</li>\n<li>确认序号：<code>ack</code>序号，只有<code>ACK</code>标志位为1时确认序号字段才有效，<code>ack=seq+1</code>（注意：<code>ack</code>序号与<code>ACK</code>标志位不是同一个东西）</li>\n<li>注意：确认放<code>ack</code>=发起方<code>req+1</code>时两者配对成功</li>\n<li>\n<p>标志位：共六个，即<code>URG</code>,<code>ACK</code>,<code>PSH</code>,<code>RST</code>,<code>SYN</code>,<code>FIN</code></p>\n<ul>\n<li><code>ACK</code>:确认序号有效</li>\n<li><code>PSH</code>:接收方尽快将报文提交应用层</li>\n<li><code>RST</code>:连接重置</li>\n<li><code>URG</code>:紧急指针有效</li>\n<li><code>SYN</code>:发起一个新连接</li>\n<li><code>FIN</code>:释放一个链接</li>\n</ul>\n</li>\n</ul>\n<h3>三次握手</h3>\n<ul>\n<li>\n<p>三次握手是为了在客户端与服务端建立可靠安全的连接服务，所以需要三次握手确认</p>\n<ul>\n<li>第一次：客户端将标志位<code>SYN</code>设置为<code>1</code>，产生一个随机值<code>seq=J</code>并将其发送给server,等待server确认，自己进入<code>SYN_SENT</code>状态（我要跟你连接了，你看看你听得到吗）</li>\n<li>第二次：server收到数据包由<code>SYN=1</code>知道客户端建立请求，server将标志位<code>SYN</code>与<code>ACK</code>都设置为1，随机产生一个值<code>seq=K</code>，并将该数据发回客户端确认连接请求，server进入<code>SYN_RCVD</code>状态（我听到了，你看看你听得到我吗）</li>\n<li>第三次：客户端收到确认后检查<code>ack</code>是否为<code>J+1</code>,<code>ACK</code>是否为<code>1</code>，如果正确则将标志位<code>ACK</code>设置为<code>1</code>，<code>ack=K+1</code>,并将数据包发给server，server检查<code>ack</code>是否为<code>K+1</code>,<code>ACK</code>是否为<code>1</code>，如果正确则连接建立成功，客户端与服务端进入<code>ESTABLISHED</code>状态，完成三次握手，此后客户端与服务端即可开始传输数据了（我也能听到了，咱们来交流吧）</li>\n</ul>\n</li>\n</ul>\n<h3>四次分手</h3>\n<ul>\n<li>\n<p>当我们用三次握手建立连接后数据传输完成要断开TCP链接啊，所以就有了四次分手</p>\n<ul>\n<li>由于TCP连接是双全工的，每个方向都需要单独关闭，当一方发送数据完成后需要发送一个<code>FIN</code>来终止这一方向连接，收到FIN只是表示对方不会有数据流动了，但是接收方依然可以发送数据，直到接收方也发送了<code>FIN</code></li>\n<li>第一次：客户端发送一个FIN，用来关闭客户端到服务端的数据传输，客户端进入<code>FIN_WAIT_1</code>状态（我没有要说的了，我想关闭连接了）</li>\n<li>第二次：服务端收到<code>FIN</code>后，发送一个<code>ACK</code>给客户端，确认序号为收到序号+1，服务端进入<code>CLOSE_WAIT</code>状态（我知道你不想说了，我不确定我还有没有要说的）</li>\n<li>第三次：服务端向客户端发送一个<code>FIN</code>，用来关闭服务端到客户端的数据传输，服务端进入<code>LAST_ACK</code>状态（我也没有要说的了，咱关闭连接吧）</li>\n<li>第四次：客户端收到<code>FIN</code>后，客户端进入<code>TIME_WAIT</code>状态，接着发送一个<code>ACK</code>给服务端，确认序号为收到序号+1，服务端进入<code>CLOSED</code>状态，完成四次分手（好的，我知道了，咱关闭吧，你听不到我的声音就说明关闭了）</li>\n</ul>\n</li>\n<li>\n<p>为什么建立连接是三次而分手要四次呐？</p>\n<ul>\n<li>因为服务端在<code>LISTEN</code>状态下，收到建立请求的<code>SYN</code>报文后，把<code>ACK</code>与<code>SYN</code>都放在一个报文里发给了客户端。关闭连接时当收到对方的<code>FIn</code>报文仅仅表示对方不再发数据了，但还能接数据，自己也未必把所有数据发送给对方了，所以己方可以立即关闭也可以发送数据后再发送<code>FIn</code>报文给对方同意现在关闭，因此<code>ACK</code>与<code>FIN</code>都会分开发送</li>\n</ul>\n</li>\n</ul>","fields":{"slug":"/TCP-IP-ThreeHandShake/"},"frontmatter":{"title":"HTTP与TCP/IP了解","tags":["HTTP","TCP/IP"],"categories":"HTTP"}}},{"node":{"html":"<h1>call,apply,bind详解</h1>\n<h2>call,apply,bind的使用</h2>\n<ul>\n<li>call,apply,bind的作用是什么？用法是什么？</li>\n<li>call,apply,bind之间有什么联系？区别是什么？</li>\n</ul>\n<h2>问题详解</h2>\n<ul>\n<li>功能上，call，apply，bind都可以用来改变函数内部this的指向</li>\n<li>用法上，三者都是函数调用对应的call,apply,bind方法，传入不同的参数实现函数内部this指向改变</li>\n</ul>\n<!--more-->\n<h2>apply与call</h2>\n<ul>\n<li><code>call</code>与<code>apply</code>在功能上是完全一致的，都是为了改变函数运行的上下文，即this的指向</li>\n<li>用法上，<code>apply</code>接受两个参数，第一个是重新定义的this对象，第二个则是想要传递给函数的参数列表的集合，是一个数组</li>\n<li><code>call</code>接受多个参数，第一个参数为重新定义的this对象，第二个及以后的各个参数即为传递给函数的参数列表</li>\n<li>综上，当函数的参数数量确定的情况下，可以使用<code>call</code>，当函数参数数量不确定的情况下应该使用<code>apply</code>,可以将参数push进数组，然后将数组作为第二个参数，或者可以在函数内部通过<code>arguments</code>来获取所有参数列表</li>\n</ul>\n<h2>apply与call妙用</h2>\n<ul>\n<li>当我们一个对象没有某个方法，但是别的对象有的情况下我们就可以使用call或者apply来“借用”别的对象的方法，例：</li>\n</ul>\n<pre><code class=\"language-js\">  \nvar apple = {\n  color: 'red',\n  say: function(){\n    console.log(this.color)\n  }\n}\nvar banana = {\n  color: 'yellow'\n}\napple.say.call(banana) // yellow\n</code></pre>\n<ul>\n<li>这里banana本来是没有say这个方法的，但是apple有这个方法，所以我们暂时借用他的方法来说出自己的颜色</li>\n<li>\n<p>call与apply的常用妙法</p>\n<ul>\n<li>数组之间追加</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"language-js\">  var arr1 = [12,'foo',{a:1}]\n  var arr2 = ['a', 23, {b:2}]\n  Array.prototype.push.apply(arr1, arr2)\n  console.log(arr1) // [ 12, 'foo', { a: 1 }, 'a', 23, { b: 2 } ]\n</code></pre>\n<ul>\n<li>这里利用了<code>apply</code>会将数组分解为各个参数的效果配合数组的push方法，将第二个数组分别添加到第一个数组实现数组的追加</li>\n<li>获取数组的最大值</li>\n</ul>\n<pre><code class=\"language-js\">  var numbers = [13, 14,5,34,-38,56]\n  var maxNumbers = Math.max.apply(Math, numbers)\n  console.log(maxNumbers)\n</code></pre>\n<ul>\n<li>这里数组本身没有max方法，但是Math对象有，所以我们就通过apply将其借用</li>\n<li>伪类数组调用数组方法实现自定义log方法，代理consolelog方法，并在每个打印之前添加一个（app）前缀</li>\n</ul>\n<pre><code class=\"language-js\">  function log(){\n    var args = Array.prototype.slice.apply(arguments)\n    args.unshift('(app)')\n    console.log.apply(console, args) \n  }\n  log(1) // (app) 1\n  log(1,2,3) // (app) 1 2 3\n</code></pre>\n<ul>\n<li>这里的话可能有点难懂，其实实现这个功能我们先是获取到我们需要打印的数据，因为<code>console.log()</code>可以接受多个参数，所以我们采用<code>arguments</code>来获取所有参数，因为要在打印之前添加前缀,其实就是添加一个打印内容，所以我们要在传递给<code>console.log</code>的参数列表里面新增一个，但因为参数列表是一个类数组对象，并没有数组方法，所以我们通过借用数组的slice方法将类数组对象转为数组对象，然后再传递给<code>console.log</code></li>\n</ul>\n<h2>bind方法</h2>\n<ul>\n<li>bind方法其实会创建一个新的函数，称为绑定函数，当调用这个函数的时候，绑定函数会以创建它时传入的第一个参数作为this，第二个及以后的参数按顺序作为原函数的参数来调用原函数</li>\n<li>bind常用用法</li>\n<li>改变系统函数this指向</li>\n</ul>\n<pre><code class=\"language-js\">var foo = {\n  bar: '哈哈',\n  eventBind: function(){\n    setTimeout(function(){\n      console.log(this)\n      console.log(this.bar)\n    }, 20)\n  }\n}\nfoo.eventBind() // window对象   undefined\nvar foo1 = {\n  bar: '哈哈',\n  eventBind: function(){\n    setTimeout(function(){\n      console.log(this)\n      console.log(this.bar)\n    }.bind(this), 20)\n  }\n}\nfoo1.eventBind() // 对象foo1   '哈哈'\n</code></pre>\n<ul>\n<li>这里我们想要的是打印出对象<code>foo</code>与它下面<code>bar</code>的值，但是在<code>setTimeout</code>里面，定时器函数内部的this是指向window对象的，所以<code>this.bar</code>会是一个<code>undefined</code>，所以在这里我们可以使用<code>bind</code>来改变<code>this</code>的指向，当我们在函数后面挂载<code>bind</code>并传递当前<code>this</code>进入时，函数内部的<code>this</code>就被我们偏转回了我们想要的对象<code>foo1</code>,所以正确的输出了我们想要的结果</li>\n<li>那如果我们联系bind会发生什么呐？</li>\n</ul>\n<pre><code class=\"language-js\">  var bar = function(){\n    console.log(this.x)\n  }\n  var foo = {\n    x:3\n  }\n  var sed = {\n    x: 4\n  }\n  var func = bar.bind(foo).bind(sed)\n  func() // ?\n  var fiv = {\n    x: 5\n  }\n  var func1 = bar.bind(foo).bind(sed).bind(fiv)\n  func() // ?\n</code></pre>\n<ul>\n<li>答案其实是两个3，并不是我们想象的4，5原因是在javascript中，多次bind是无效的。</li>\n</ul>\n<h2>apply,call,bind比较</h2>\n<ul>\n<li>看下面代码</li>\n</ul>\n<pre><code class=\"language-js\">  var obj = {\n    x: 81\n  }\n  var foo = {\n    getX: function(){\n      return this.x\n    }\n  }\n  console.log(foo.getX.bind(obj)()) // 81\n  console.log(foo.getX.call(obj)) // 81\n  console.log(foo.getX.apply(obj)) // 81\n</code></pre>\n<ul>\n<li>虽然三个都输出81，但是注意，bind方法之后我们又加了一个括号对其调用，所以这里bind在改变this之后并没有马上执行，而是在执行的时候才使用bind方法，而call与apply则是会立即执行</li>\n</ul>","fields":{"slug":"/call-apply/"},"frontmatter":{"title":"javascript回顾","tags":["JavaScript回顾","回顾","入门"],"categories":"JavaScript"}}},{"node":{"html":"<h1>生成器详解</h1>\n<h2>生成器</h2>\n<ul>\n<li>生成器是什么？为什么会需要生成器？</li>\n</ul>\n<h2>生成器的由来</h2>\n<ul>\n<li>传统异步流程对程序员并不友好，设定回调函数的方式不符合大脑对任务步骤的规划</li>\n<li>生成器就是实现看似同步的异步流程控制</li>\n</ul>\n<!--more-->\n<h1>生成器的奇特之处</h1>\n<h2>打破完整运行</h2>\n<ul>\n<li>传统意义上，<code>javascript</code>函数一旦开始运行，那么在结束之前将没有别的代码可以打断并插入运行</li>\n<li>ES6引入了新的函数类型，并不符合从始到终不可打断的原则，这类新的函数就是生成器</li>\n</ul>\n<pre><code class=\"language-js\">  var x = 1;\n  function foo() {\n    x++\n    bar();\n    console.log( \"x:\", x )\n  }\n  function bar() {\n    x++\n  }\n  foo(); // x: 3 \n</code></pre>\n<ul>\n<li>这里因为<code>bar</code>存在于<code>foo</code>内部，所以可以实现<code>x</code>的改变，那如过在外面调用<code>bar</code>有没有可能改变<code>x</code>的输出呐？</li>\n<li>如果在多线程语言中，这个自然可以通过抢占线程来实现，但javascript是一个单线程的语言。但是，要是我们通过让<code>foo</code>暂停然后先执行<code>bar</code>会怎么样呐？</li>\n<li>下面就是我们用生成器来实现的效果</li>\n</ul>\n<pre><code class=\"language-js\">  var x = 1;\n  function *foo() {\n    x++;\n    yield; // 暂停！\n    console.log( \"x:\", x );\n  }\n  function bar() {\n    x++;\n  } \n  // 构造一个迭代器it来控制这个生成器\n  var it = foo();\n  // 这里启动foo()！\n  it.next();\n  x; // 2\n  bar();\n  x; // 3\n  it.next(); // x: 3\n</code></pre>\n<ul>\n<li><code>it=foo()</code> 运算其实只是生成了一个迭代器，并没有执行生成器（迭代器在下面会介绍）</li>\n<li>第一个<code>it.next()</code>执行了生成器，也就运行了<code>*foo</code>代码里的<code>x++</code>这一句，停在了<code>yield</code></li>\n<li><code>*foo</code>停在了<code>yield</code>这里，第一个<code>it.next</code>调用结束，暂停了<code>foo</code>,此时<code>x</code>值变为<code>2</code></li>\n<li>暂停<code>foo</code>后我们执行了<code>bar</code>函数使<code>x</code>变为<code>3</code></li>\n<li>最后一个<code>it.next</code>将生成器恢复了，使其完成代码块的执行，打印了<code>3</code></li>\n<li>这里我们也能发现，生成器函数与普通函数相比函数名之前会多一个<code>*</code>,并且函数执行过程碰到<code>yield</code>会被暂停</li>\n</ul>\n<h2>输入与输出</h2>\n<ul>\n<li>生成器作为一个函数，除了有新的执行模式，还具备一般函数的基本特性，可接受参数与返回值</li>\n</ul>\n<pre><code class=\"language-js\">function *foo(x,y) {\n  return x * y;\n}\nvar it = foo( 6, 7 ); \nvar res = it.next();\nres.value; // 42 \n</code></pre>\n<ul>\n<li>生成器的传参，返回值与传统函数一致</li>\n<li>注意：这里我们能看到<code>foo(6,7)</code>并没有像普通函数一样执行，是因为这一步只是执行了迭代器的生成并赋值给了it,然后我们才可以对其进行暂停与恢复</li>\n<li><code>it.next</code>是让生成器从当前位置继续运行，直到碰到下一个yield或者生成器代码执行结束</li>\n<li><code>it.next</code>调用的结果是一个对象，有<code>value</code>属性，值为生成器返回的值(如果有的话)</li>\n</ul>\n<h2>迭代器消息传递</h2>\n<ul>\n<li>迭代器除了控制生成器之外，还提供了消息的输入与输出，通过yield与next(..)实现</li>\n</ul>\n<pre><code class=\"language-js\">function *foo(x) {\n  var y = x * (yield);\n  return y;\n}\nvar it = foo( 6 );\n// 启动foo(..)\nit.next();\nvar res = it.next( 7 );\nres.value; // 42 \n</code></pre>\n<ul>\n<li>这里是外部消息的输入，<code>foo</code>函数接受原始参数6，之后执行到了<code>yield</code>这一步暂停，并要求调用代码即<code>it.next</code>为<code>yield</code>提供一个结果值</li>\n<li>第二个<code>it.next</code>作为<code>yield</code>的恢复调用理所当然的需要提供一个值，也就是我们的7</li>\n<li>所以函数内部<code>y = x * (yield)</code> 其实就是<code>y = 6 * 7</code>即<code>42</code></li>\n<li>这里我们要注意，迭代器的<code>next</code>总要比生成器的<code>yield</code>多一个，因为它需要第一个<code>next</code>来启动生成器，其后才是每次遇到<code>yield</code>暂停，<code>next</code>恢复</li>\n</ul>\n<pre><code class=\"language-js\">function *foo(x) {\n  var y = x * (yield \"Hello\"); // &#x3C;-- yield一个值！\n  return y;\n}\nvar it = foo( 6 );\nvar res = it.next(); // 第一个next()，并不传入任何东西\nres.value // \"Hello\"\nres = it.next( 7 ); // 向等待的yield传入7\nres.value; // 42 \n</code></pre>\n<ul>\n<li>这里与上面的改动在于<code>yield</code>之后跟了一个数据'Hello'，它其实是<code>yield</code>传给外面的数据，用来响应<code>next</code>的调用，可以理解为我启动了你要是暂停得给我个解释啊，抛出的一个返回值</li>\n<li>上面也就是我们生成器的消息互通，通过yield与next构成消息的双向传递</li>\n</ul>\n<h1>迭代器</h1>\n<h2>为什么需要迭代器</h2>\n<ul>\n<li>生成器是对函数的暂停与恢复执行，那么在多次暂停时就需要有东西来保存其暂停时的值，而迭代器的作用也就凸现出来了</li>\n<li>迭代器是一个定义良好的接口，可以从一个生产者一步步得到一系列的值</li>\n</ul>\n<pre><code class=\"language-js\">  var something = (function(){\n    var nextVal;\n    return {\n      // for..of循环需要\n      [Symbol.iterator]: function(){ return this; },\n      // 标准迭代器接口方法\n      next: function(){\n        if (nextVal === undefined) {\n          nextVal = 1;\n        }\n        else {\n          nextVal = (3 * nextVal) + 6;\n        }\n        return { done:false, value:nextVal };\n      }\n    };\n  })();\n  something.next().value; // 1\n  something.next().value; // 9\n  something.next().value; // 33\n  something.next().value; // 105 \n</code></pre>\n<ul>\n<li>上面就是一个标准的数字生产迭代器，<code>Symbol.iterator</code>存在的原因是ES6开始要想从一个可迭代对象中提取迭代器，则该对象必须是ES6符号值<code>Symbol.iterator</code>,调用这个函数会返回一个迭代器</li>\n<li>这里我们可以通过<code>next</code>方法返回一个对象，该对象有两个属性值：<code>done</code>为boolean值，标识迭代器的完成状态，<code>value</code>返回迭代值</li>\n</ul>\n<h2>生成器与迭代器</h2>\n<ul>\n<li>上面就是迭代器的作用与简单实现，这里我们就可以知道当我们执行<code>it=foo()</code>这一步时为什么会返回一个迭代器了</li>\n<li>严格来说生成器本身并不是一个<code>iterable(可迭代对象)</code>,但当你执行一个生成器时，就得到了一个迭代器</li>\n</ul>\n<pre><code class=\"language-js\">function *foo(){ .. }\nvar it = foo(); \n</code></pre>\n<ul>\n<li>生成器通过执行返回一个迭代器也就可以实现生成器的无限次暂停与恢复</li>\n</ul>\n<h1>生成器与异步编程模式</h1>\n<h2>生成器与异步回调</h2>\n<ul>\n<li>在传统的异步函数ajax中，我们为了实现异步数据获取通常会使用异步回调的方法，如下</li>\n</ul>\n<pre><code class=\"language-js\">function foo(x,y,cb) {\n  ajax(\n  \"http://some.url.1/?x=\" + x + \"&#x26;y=\" + y,\n  cb\n  );\n}\nfoo( 11, 31, function(err,text) {\n  if (err) {\n    console.error( err );\n  }\n  else {\n    console.log( text );\n  }\n} ); \n</code></pre>\n<ul>\n<li>但是有了生成器之后我们就可以这么实现了</li>\n</ul>\n<pre><code class=\"language-js\">function foo(x,y) {\n  ajax(\n    \"http://some.url.1/?x=\" + x + \"&#x26;y=\" + y,\n    function(err,data){\n      if (err) {\n        // 向*main()抛出一个错误\n        it.throw( err );\n      }\n      else {\n        // 用收到的data恢复*main()\n        it.next( data );\n      }\n    }\n  );\n}\nfunction *main() {\n  try {\n    var text = yield foo( 11, 31 ); \n    console.log( text );\n  }\n  catch (err) {\n    console.error( err );\n  }\n}\nvar it = main();\n// 这里启动！\nit.next(); \n</code></pre>\n<ul>\n<li>这里的代码看上去比上面的好像要长一点，但是这段代码比上面的代码要好得多</li>\n<li>这段代码好像变成了之前的同步代码，在有异步请求的时候还能运行吗？当然是可以的，主要原因就在<code>yield</code>身上，当我们执行生成器<code>main</code>的时候，遇到<code>yield</code>后暂停了<code>foo(11,31)</code>后面的其他代码，等待迭代器的下一个next来恢复它的执行</li>\n<li>当我们的<code>ajax</code>执行完成后，调用了<code>next</code>方法来恢复它，并把ajax的返回值传递给了生成器，使其赋值给了<code>text</code>，接着让<code>main</code>继续执行</li>\n</ul>\n<h2>总结</h2>\n<ul>\n<li>生成器其实就是可以暂停执行与继续执行的函数，暂停与执行使用过迭代器来实现的</li>\n<li>生成器的主要作用就是解决传统异步编码回调问题，实现原理就是暂停后需要next来恢复，<code>next</code>与<code>yield</code>可以双向通信传递数据，可借此传递异步请求的数据</li>\n</ul>","fields":{"slug":"/yield/"},"frontmatter":{"title":"ES2015生成器","tags":["JavaScript","ES2015","进修"],"categories":"JavaScript"}}},{"node":{"html":"<h1>深入字符串模板</h1>\n<h2>字符串模板</h2>\n<ul>\n<li><code>ES5</code>之前我们连接字符串与变量还需要使用js的<code>+</code>运算符进行连接</li>\n<li><code>ES6</code>中我们新增了<code>字符串模板</code>这个概念，<code>字符串模板</code>使用`作为定界符</li>\n<li>大家对他的认识可能只停留在<code>拼接字符串与变量</code>并在调用的地方进行<code>变量解析</code></li>\n<li>其实<code>字符串模板</code>有很多我们还不熟知的强大功能</li>\n</ul>\n<!--more-->\n<h1>常用形式</h1>\n<h2>插入表达式</h2>\n<pre><code class=\"language-js\">  function upper(s) {\n    return s.toUpperCase()\n  }\n  var who = 'reader'\n\n  // 使用字符串模板\n  var text = \n  `A very ${upper('warm')} welcome\n  to all of you ${upper(`${who}s`)}!\n  `\n  console.log(text) \n  // A very WARM welcome\n  // to all of you READERS!\n\n\n  // 使用ES5之前\n   var text = \"A very \" + upper('warm') + \" welcome \\r\\n to all of you \" + upper(who + \"s\")\n  console.log(text) \n</code></pre>\n<ul>\n<li>上面是我们想要实现的字符串片段部分单词转大写需求，可以看出字符串模板帮我们进行了<code>字符串的解析与换行符的保留</code></li>\n<li>传统的js则需要我们自己对<code>js表达式</code>进行拼接</li>\n</ul>\n<h1>高级用法</h1>\n<h2>标签模板字面量</h2>\n<ul>\n<li>其实在<code>你不知道的JavaScript</code>中将<code>字符串模板</code>称为<code>标签字符串字面量</code></li>\n<li>看一下下面比较酷炫的用法</li>\n</ul>\n<pre><code class=\"language-js\">  function foo(strings, ...values){\n    console.log(strings)\n    console.log(values)\n  }\n\n  var desc = 'awesome'\n  foo`Everything is ${desc}!`\n  // strings [ 'Everything is ', '!' ]   \n  // values  [ 'awesome' ]\n</code></pre>\n<ul>\n<li>看到这里可能都有点懵，这还是函数吗？又没有函数调用的小括号</li>\n<li>本质上说这是一类不需要<code>()</code>的函数调用，<code>字符串字面量</code>之前是一个要调用的函数</li>\n<li>那二者组合的<code>字符串字面量作为标签调用的函数</code>会变成什么？参数又是什么含义？</li>\n<li>第一个参数<code>strings</code>，由所有普通字符串组成的数组，在这里即为： <code>'Everything is '</code>跟 <code>'!'</code></li>\n<li>第二个参数<code>values</code>则是使用了<code>...gather/rest</code>运算符将其他的所有参数收集到了名为<code>values</code>的数组中，所以这里只能是<code>'awesome'</code></li>\n</ul>\n<h2>数字格式化为美元表示</h2>\n<pre><code class=\"language-js\">  function dollabillsyall(strings, ...values) {\n    return strings.reduce(function (s, v, idx){\n      if (idx > 0) {\n        if(typeof values[idx - 1] == 'number') {\n          s += `$${values[idx - 1].toFixed(2)}`\n        } else {\n          s += values[idx - 1]\n        }\n      }\n      return s + v\n    }, \"\")\n  }\n\n  var amt1 = 11.99, amt2 = amt1 * 1.88, name=\"Kyle\"\n  var text = dollabillsyall\n  `Thanks for your purchase, ${name}! your product cost was ${amt1}, which with tax comes out to ${amt2}.`\n  console.log(text)\n  // Thanks for your purchase, Kyle! your product cost was $11.99, which with tax comes out to $22.54.\n</code></pre>\n<ul>\n<li>这里我们使用<code>reduce</code>进行字符串拼接，对每一个数字变量都进行美元符拼接并转化为两位小数保留</li>\n</ul>","fields":{"slug":"/js_template/"},"frontmatter":{"title":"ES2016字符串模板","tags":["JavaScript","ES2015","进修"],"categories":"JavaScript"}}},{"node":{"html":"<h1>一脸懵逼的迭代器</h1>\n<h2>迭代器</h2>\n<ul>\n<li>迭代器：<code>迭代器</code>是一个结构化的模式，用于从一个源一次一个的方式获取数据</li>\n<li><code>JavaScript</code>开发中从来不缺乏它的出现，总有各种各样的方法来实现它</li>\n<li><code>ES6</code>中为<code>迭代器</code>提供了一个<code>隐式的标准化接口</code>，并在一些内建数据结构中都实现了它</li>\n</ul>\n<!--more-->\n<h1>内置数据结构迭代器</h1>\n<h2>数组</h2>\n<ul>\n<li><code>数组</code>中的迭代器</li>\n</ul>\n<pre><code class=\"language-js\">  let arr = [1,2,3]\n  let it = arr[Symbol.iterator]()\n  it.next() // { value: 1, done: false }\n  it.next() // { value: 2, done: false }\n  it.next() // { value: 3, done: false }\n  it.next() // { value: undefined, done: true }\n</code></pre>\n<ul>\n<li>每次在数祖上调用<code>Symbol.iterator</code>方法时都会产生一个新的迭代器</li>\n<li>当数组迭代完成并不会立即将<code>done</code>设置为<code>true</code>,而是在迭代完所有之后再迭代一次才会将其改变</li>\n</ul>\n<h2>字符串</h2>\n<ul>\n<li><code>字符串</code>中的迭代器</li>\n</ul>\n<pre><code class=\"language-js\">  let str = 'hello'\n  let it = arr[Symbol.iterator]()\n  console.log(it.next()) // { value: 'h', done: false }\n  console.log(it.next()) // { value: 'e', done: false }\n  console.log(it.next()) // { value: 'l', done: false }\n  console.log(it.next()) // { value: 'l', done: false }\n  console.log(it.next()) // { value: 'o', done: false }\n  console.log(it.next()) // { value: undefined, done: true }\n</code></pre>\n<ul>\n<li>严格来说<code>字符串</code>本身并不是<code>iterator</code>,但是这里被强制转换为<code>String对象</code>封装形式，从而变成一个<code>iterator</code></li>\n</ul>\n<h2>map</h2>\n<ul>\n<li><code>map</code>中的迭代器</li>\n</ul>\n<pre><code class=\"language-js\">  let map = new Map()\n  map.set({name: '张三'}, {age: 24})\n  map.set('foo', 42)\n  let it = map[Symbol.iterator]()\n  console.log(it.next()) // { value: [ { name: '张三' }, { age: 24 } ], done: false }\n  console.log(it.next()) // { value: [ 'foo', 42 ], done: false }\n  console.log(it.next()) // { value: undefined, done: true }\n  let arr = [1,2,3]\n  let str = 'hello'\n  let map = new Map()\n  map.set({name: '张三'}, {age: 24})\n  map.set('foo', 42)\n  for(let v of map) {\n    console.log(v)\n  }\n</code></pre>\n<h2>for...of循环迭代器</h2>\n<ul>\n<li><code>for...of</code>可用于消耗迭代器，也就是<code>循环调用迭代器</code>，形式如下</li>\n</ul>\n<pre><code class=\"language-js\">  let map = new Map()\n  map.set({name: '张三'}, {age: 24})\n  map.set('foo', 42)\n  for(let v of map) {\n    console.log(v)\n  }\n  // [ { name: '张三' }, { age: 24 } ], [ 'foo', 42 ]\n</code></pre>\n<ul>\n<li><code>for...of</code>会将迭代器中的内容返回</li>\n</ul>\n<h1>自定义迭代器</h1>\n<ul>\n<li>利用<code>Symbol.itertor</code>我们可以构造可以与<code>ES6</code>交互的属于自己的<code>迭代器</code></li>\n<li>下面是构造一个<code>无限斐波纳契序列</code></li>\n</ul>\n<pre><code class=\"language-js\">  var Fib = {\n    [Symbol.iterator](){\n      let n1 = 1, n2 = 1\n      return {\n        [Symbol.iterator](){return this},\n        next(){\n          let current = n2\n          n2 = n1\n          n1 = current + n1\n          return {value: current, done: false}\n        },\n        return (v){\n          console.log(\n          \"Fibonacci sequence abandoned.\"\n          );\n          return { value: v, done: true }; \n        }\n      }\n    }\n  }\n  for(let v of Fib) {\n    console.log(v)\n    if(v > 500) break\n  }\n  // 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610\n</code></pre>\n<ul>\n<li>这里当我们调用<code>Fib</code>的<code>Symbol.iterator</code>方法会返回一个带有<code>next</code>跟<code>return</code>方法的迭代器</li>\n<li>通过闭包里面的<code>n1</code>与<code>n2</code>来维护数据</li>\n</ul>\n<h1>迭代器其他用法</h1>\n<h2>模拟事件队列机制</h2>\n<ul>\n<li>下面实现一个<code>运行一系列事件</code>的迭代器</li>\n</ul>\n<pre><code class=\"language-js\">  let tasks = {\n    [Symbol.iterator](){\n      let steps = this.options.slice()\n      return {\n        [Symbol.iteratro](){return this},\n        next(...args){\n          if(steps.length > 0) {\n            let res = steps.shift()(...args)\n            return {value: res, done: false}\n          } else {\n            return { done: true }\n          }\n        }\n      }\n    },\n    options: []\n  }\n  tasks.options.push(\n    function(x){\n      return x * 2\n    },\n    function(x, y){\n      return x + y * 2\n    },\n    function(x, y, z) {\n      return x * y + z\n    }\n  )\n  let it = tasks[Symbol.iterator]()\n  console.log(it.next(10)) //{ value: 20, done: false } \n  console.log(it.next(10, 20)) //{ value: 50, done: false }\n  console.log(it.next(10, 20, 30)) //{ value: 230, done: false }\n  console.log(it.next()) //{ done: true }\n</code></pre>\n<ul>\n<li>其中可以看到，我们将要运行的事件都传入我们的<code>数组集合options</code>中，然后便可以迭代运行了</li>\n</ul>\n<h2>模拟数字生成数组</h2>\n<ul>\n<li>我们可以将数字构造为一个迭代器，使其拥有迭代器的一些操作，用来<code>生成数组</code>或<code>一定次数的循环</code></li>\n</ul>\n<pre><code class=\"language-js\">  if(!Number.prototype[Symbol.iterator]){\n    Object.defineProperty(\n      Number.prototype,\n      Symbol.iterator,\n      {\n        writable: true,\n        configurable: true,\n        enumerable: false,\n        value: function iterator(){\n          var i, inc, done = false, top = +this\n          inc = 1 * (top &#x3C; 0 ? -1 : 1)\n          return {\n            [Symbol.iterator](){return this},\n            next(){\n              if(!done) {\n                if(i == null) {\n                  i = 0\n                } else if (top >= 0) {\n                  i = Math.min(top, i + inc)\n                } else {\n                  i = Math.max(top, i + inc)\n                }\n                if(i == top) {done = true}\n                return {value: i, done: false}\n              } else {\n                return {done: true}\n              }\n            }\n          }\n        }\n      }\n    )\n  }\n  for(let v of 3) {\n    console.log(v)\n  }\n  // 0 1 2 3\n\n  [...3] // [0,1,2,3]\n</code></pre>\n<ul>\n<li>第一个<code>for...of</code>循环可以使我们循环指定次数来完成我们的操作</li>\n<li>因为我们<code>ES6</code>的<code>解构符</code>本来就可以<code>消耗</code>或者说是<code>解读</code>我们的迭代器，所以会帮助我们直接生成指定长度的纯数字数组</li>\n</ul>","fields":{"slug":"/iterator/"},"frontmatter":{"title":"ES2015迭代器","tags":["JavaScript","ES2015","进修"],"categories":"JavaScript"}}},{"node":{"html":"<h1>JavaScript中的对象</h1>\n<h2>原型</h2>\n<ul>\n<li>每个对象都连接到一个原型对象，并且可以继承原型对象的属性</li>\n<li>通过字面量创建的对象都会连接到Object.prototype，它是JavaScript中的标配对象</li>\n<li>我们可以在创建对象的时候选择另一个对象作为它的原型</li>\n<li>\n<p>ES5中提供的Object.create可以帮我们实现原型对象的绑定（绑定至指定对象）</p>\n<!--more-->\n</li>\n</ul>\n<h1>原型绑定</h1>\n<ul>\n<li>下列代码就实现了对象stog绑定原型至stooge的过程</li>\n</ul>\n<pre><code class=\"language-js\">  var stooge = {\n    a: 1,\n    b: 2\n  }\n  var stog = Object.create(stooge)\n  console.log(stog.a)   // 1\n  console.log(stog.b)   // 2\n  stooge.c = 3\n  console.log(stog.c)   // 3\n  stog.d = 4\n  console.log(stooge.d) // 4\n</code></pre>\n<ul>\n<li>这里我们就实现了将stog的原型绑定至stooge，所以当从自身没找到改属性值时会沿原型链往上找，找到原型对象中的属性值</li>\n<li>若原型对象中也没有，则会返回undefined</li>\n</ul>\n<h2>手动实现Object.create</h2>\n<pre><code class=\"language-js\">  Object.createPrototype = function(o){\n    var F = function(){}\n    F.prototype = o\n    return new F()\n  }\n  var stooge = {\n    a: 1\n  }\n  var stog = Object.createPrototype(stooge)\n  console.log(stog.a) // 1\n</code></pre>\n<ul>\n<li>这里我们自己构造一个对象属性，接受一个对象作为参数，并在函数内部新建一个构造函数</li>\n<li>将改构造函数的原型指定为我们传入的对象实现原型绑定，并将新对象返回</li>\n</ul>\n<h2>属性枚举</h2>\n<ul>\n<li>有时候我们需要获取一个对象的私有属性，而不是其原型链上的属性</li>\n<li>这时我们就需要使用for...in循环跟hasOwnProperty函数来进行筛选</li>\n</ul>\n<pre><code class=\"language-js\">  var obj1 = {\n    a: 1,\n    b: 2\n  }\n  var obj2 = Object.create(obj1)\n  obj2.c = 3\n  for(var key in obj2) {\n    console.log(key) // c a b\n    if(obj2.hasOwnProperty(key)) {\n      console.log(key) // c\n    }\n  }\n</code></pre>\n<ul>\n<li>这里for...in会获取对象及其原型链上的属性值，所以我们需要hasOwnProperty()来获取独属于它的属性</li>\n</ul>\n<h2>删除对象属性</h2>\n<ul>\n<li>删除对象的制定属性需要使用delete操作符</li>\n<li>delete 对象.属性即可删除该属性</li>\n</ul>\n<pre><code class=\"language-js\">  var testDelete = {\n    canDelete: '我是原型属性'\n  }\n  var testDelete1 = Object.create(testDelete)\n  testDelete1.canDelete = '我是私有属性'\n  console.log(testDelete1.canDelete) // 我是私有属性\n  delete testDelete1.canDelete\n  console.log(testDelete1.canDelete) // 我是原型属性\n</code></pre>\n<ul>\n<li>这里删除之前打印的为我们展示的是该对象的私有属性</li>\n<li>删除之后对象本身找不到该属性，便回到原型链查找，从而返回原型对象的该属性</li>\n</ul>","fields":{"slug":"/goodJavaScript_object/"},"frontmatter":{"title":"JavaScript语言精粹-对象","tags":["JavaScript","进修"],"categories":"JavaScript"}}},{"node":{"html":"<h1>继承的实现与原理</h1>\n<h2>继承</h2>\n<ul>\n<li><code>继承</code>是面向对象中的一个特性，与<code>多态</code>，<code>封装</code>称为面向对象的三个基本特征</li>\n<li>使用<code>继承</code>可以使一个对象快速拥有另一个对象的属性与方法，并能够重新定义自己的方法</li>\n<li>\n<p><code>JavaScript</code>中并没有真正的类，所以实现<code>继承</code>可以通过<code>原型链</code>或者通过改变<code>this</code>来实现<code>伪造对象继承</code></p>\n<!--more-->\n</li>\n</ul>\n<h2>ES5中的实现</h2>\n<ul>\n<li><code>es5</code>中的继承实现一般有三种方式</li>\n<li>\n<p>构造继承</p>\n<ul>\n<li>构造继承是在子类的内部调用超类的构造函数，并将<code>this</code>的指向替换为子类</li>\n<li>可以通过<code>bind</code>,<code>apply</code>,<code>bind</code>来实现</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"language-js\">  function Person(name, age) {\n    this.name = name\n    this.age = age\n    this.say = function(){\n      console.log(`我是${this.name},我${this.age}岁了`)\n    }\n  }\n  function Child(name, age){\n    // bind方法\n    Person.bind(this)(name, age)\n    // call方法\n    Person.call(this, name, age)\n\n    // apply方法\n    Person.apply(this, [name, age])\n  }\n  var child = new Child('张三',24)\n  child.say() // 我是张三,我24岁了\n</code></pre>\n<ul>\n<li>上面三种方法都可以实现子类的继承，但是缺点是未共享父类方法，内存浪费</li>\n<li>\n<p>原型链继承</p>\n<ul>\n<li><code>原型链继承</code>其实就是将超类的一个实例作为子类的原型，从而实现子类共享父类属性与方法</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"language-js\">  function Person1(name, age){\n    this.name = [name]\n    this.age = age\n    this.rename = function(){\n      this.name.push(name)\n    }\n    this.say = function(){\n      console.log(`我是${this.name},我${this.age}岁了`)\n    }\n  }\n  function Child1(){}\n  Child1.prototype = new Person1('李四', 27)\n  var child = new Child1() \n  child.rename()\n  console.log(child.name) // [\"李四\", \"李四\"]\n  var child1 =  new Child1() \n  console.log(child1.name)   // [\"李四\", \"李四\"]\n</code></pre>\n<ul>\n<li>这里我们也发现在继承的同时我们失去了向超类传递参数的可能</li>\n<li>这里我们实现了两个子类共享了超类的<code>方法</code>，但是却也共享了<code>属性</code>，从而导致实例一调用rename方法则实例二的name属性也会变化</li>\n<li>\n<p>组合继承</p>\n<ul>\n<li><code>组合继承</code>就是将上述两种方法结合到一起，实现的属性继承且不会互相影响，并能向超类传递参数</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"language-js\">  function Person2(name, age){\n    this.name = [name]\n    this.age = age\n    this.rename = function(){\n      this.name.push(name)\n    }\n    this.say = function(){\n      console.log(`我是${this.name},我${this.age}岁了`)\n    }\n  }\n  function Child2(name, age){\n    Person2.call(this, name, age)\n  }\n  Child2.prototype = new Person2()\n  Child2.prototype.constructor = Child2\n  var child = new Child2('王五', 30)\n  child.rename()\n  child.say()  // 我是王五,王五,我30岁了   rename只改变了我自己的实例\n  var child1 = new Child2('孙刘', 40)\n  child1.say() // 并不受另一个实例的影响\n</code></pre>\n<ul>\n<li>这里我们使用<code>Child2.prototype = new Person2()</code>的时候将<code>Child2</code>的原型的构造函数给指向了<code>Person2</code>，他应该指向<code>Child2</code>的</li>\n<li>所以我们添加了<code>Child2.prototype.constructor = Child2</code>来将其指向偏转回来</li>\n<li><code>组合继承</code>相对来说比较优秀，但是<code>超类</code>构造函数被调用两次，子类实例的属性存在两份，造成内存浪费</li>\n<li>\n<p>寄生继承</p>\n<ul>\n<li>寄生继承就是利用<code>Object.create</code>方法来取得超类的<code>原型对象</code>并构造成为子类的<code>原型</code>，从而实现子类继承父类属性与方法</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"language-js\">  function Person3(name, age){\n    this.name = [name]\n    this.age = age\n    this.say = function(){\n      console.log(`我是${this.name},我${this.age}岁了`)\n    }\n  }\n  Person3.prototype.rename = function(name){\n    this.name.push(name)\n  }\n  function Child3(name, age){\n    Person3.call(this, name, age)\n  }\n  Child3.prototype = Object.create(Person3.prototype)\n  var child1 = new Child3('刘琦', 34)\n  child1.rename('小孩')\n  child1.say() // 我是刘琦,小孩,我34岁了\n  var child2 = new Child3('王八', 35)\n  child2.rename('大人')\n  child2.say() // 我是王八,大人,我35岁了\n</code></pre>\n<ul>\n<li><code>Person3.prototype</code>其实可以看作<code>Person3</code>的一个实例，这里我们使用<code>Object.create</code>创建了一个原型对象为<code>Person3.prototype</code>的对象作为<code>Child3</code>的原型对象</li>\n<li>从而实现<code>Person3</code>的实例共享同一属性与方法</li>\n</ul>\n<h2>ES6中的继承</h2>\n<ul>\n<li>\n<p>ES6中我们可以通过extends来实现继承</p>\n<pre><code class=\"language-js\">class Person {\nconstructor(name, age){\n  this.name = name\n  this.age = age\n}\nsay(){\n  console.log(`我是${this.name},我${this.age}岁了`)\n}\n}\nclass Child extends Person {\nconstructor(name, age){\n  super(name, age)\n}\n}\nvar child = new Child('张三', 18)\nchild.say() // 我是张三,我18岁了\n</code></pre>\n</li>\n<li><code>ES6</code>中的继承就跟传统语言中的一样了，只需要定义方法与私有方法即可</li>\n</ul>","fields":{"slug":"/extends/"},"frontmatter":{"title":"JavaScript中的继承","tags":["JavaScript","进修","ES2015"],"categories":"JavaScript"}}},{"node":{"html":"<h1>js中的继承（一）</h1>\n<ul>\n<li>之前也写过一篇关于js继承的一篇文章，不过是在刚开始了解继承的时候写的一篇，看了很多别人的博客，似懂非懂的情况下写了那篇，最近再看js设计模式的时候再次看到了它，也想比较详细的再写一篇</li>\n<li>因为js中没有类，所以一般会以函数内部使用this赋值属性与方法的形式使函数具有类的功能，作为与普通函数的区分，我们会将这一类函数的首字母大写来表明这是一个类</li>\n<li>继承就是让继承类具有被继承类的属性与方法，一般用于对某类的拓展</li>\n<li>既然js都没有类的，自然更不会有继承存在了，这里我们就要用一些比较灵活的方法来实现类的继承了，传统的方法有以下几种</li>\n</ul>\n<h2>继承的实现</h2>\n<h2>原型链继承</h2>\n<ul>\n<li>原型链继承的原理：继承实现的效果其实就是子类的实例具有父类的属性与方法，所以根据对象属性沿原型链查找的原理实现了原型链继承（对象查找某方法或属性时，会先在对象自身上找，当自身查找不到时，就会在<strong>proto</strong>指向的对象上面找，如果第一个<strong>proto</strong>对象上面也没有就会继续沿着<strong>proto</strong>往上找，一直到找到该属性或者null为止，这也就是原型链，对这一块感兴趣的话，可以先了解一下原型与原型链）</li>\n<li>所以实现这一继承方法的话我们只需要使子类的原型对象为父类的实例即可，这样，子类实例查找属性时便会查找到子类的原型对象也就是父类的实例，便能获取到父类的构造函数内的属性与方法，若父类实例未查找到便会查找到父类的原型对象上面，这样也就实现了继承父类原型对象的方法，具体实现如下</li>\n</ul>\n<!--more-->\n<pre><code class=\"language-js\">  function Super(){\n    this.name = '张三'\n    this.age = 24\n    this.favite = ['烧烤', '桑拿']\n    this.showName = function(){\n      console.log(this.name)\n    }\n  }\n  Super.prototype.showAge = function(){\n    console.log(this.age)\n  }\n  Super.prototype.showFavite = function(){\n    console.log(this.favite)\n  }\n\n  function Sub(){}\n  Sub.prototype = new Super()\n\n  var a = new Sub()\n  var b = new Sub()\n  a.showName()  // 张三\n  a.showAge()   // 24\n  b.showFavite() // [\"烧烤\", \"桑拿\"]\n  a.favite.push('看书')\n  b.showFavite() // [\"烧烤\", \"桑拿\", \"看书\"]\n</code></pre>\n<ul>\n<li>这里我们也能发现此方法的弊端，所有子类共用一个原型对象，若该对象上面存在引用类型的属性，则任意子类修改所有子类都会改变，而且，子类实例化的时候不能接受参数</li>\n</ul>\n<h2>构造函数继承</h2>\n<ul>\n<li>构造函数继承：这里就要理解实例化的过程（也就是new的原理），可以参考另一篇博客（<a href=\"https://blog.csdn.net/weixin_41900457/article/details/102557358\">js中new的原理与实现</a>）。类实例化其实就是生成一个对象，并将this指向该对象，所以我们可以在子类的构造函数内调用父类的构造函数并将this指向子类，如此一来子类的实例对象就可以拥有父类构造函数内的属性与方法，实现方法如下</li>\n</ul>\n<pre><code class=\"language-js\">  function SuperClass(name){\n    this.name = name\n    this.books = ['js', 'css', 'html']\n    this.showBooks = function(){\n        console.log(this.books)\n    }\n  }\n\n  // showName为原型对象方法\n  SuperClass.prototype.showName = function(){\n      console.log(this.name)\n  }\n\n\n  function SubClass(name){\n      SuperClass.call(this, name)\n  }\n\n  // 原理为使用call或apply在子类内部执行父类的构造函数，只不过将this的指向改为了子类，\n  // 所以只能继承父类的属性方法，并不能继承父类原型的方法，所以showBooks可正常工作，showName会报错\n  let a = new SubClass('张胜男')\n  let b = new SubClass('江玉成')\n  b.showBooks() // ['js', 'css', 'html']\n  a.books.push('php')\n  b.showBooks() // ['js', 'css', 'html']\n  b.showName()  // TypeError()\n</code></pre>\n<ul>\n<li>该继承方式只能继承父类的属性方法，并不能继承父类原型的方法</li>\n</ul>\n<h2>组合继承</h2>\n<ul>\n<li>组合继承就是兼顾了上两种继承的优势与劣势进行的继承方式，既可以完整继承父类，也可以对子类初始化入参， 实现如下</li>\n</ul>\n<pre><code class=\"language-js\">  function SuperClass(name){\n    this.name = name\n    this.books = ['js', 'css', 'html']\n    console.log('我执行了')\n    this.showBooks = function(){\n        console.log(this.books)\n    }\n  }\n\n  SuperClass.prototype.showName = function(){\n      console.log(this.name)\n  }\n\n  function SubClass(name){\n      SuperClass.call(this, name)\n  }\n  SubClass.prototype = new SuperClass()\n  // 这里我们需要了解，任何原型对象的constructor属性都会指向自己的构造函数\n  console.log(SubClass.prototype.constructor) // [Function: SuperClass] 这里子类的constructor属性指向了父类的构造函数，需要进行偏转\n  SubClass.prototype.constructor = SubClass\n  console.log(SubClass.prototype.constructor) // [Function: SubClass] 正常\n  // 组合式继承，call或apply继承父类属性方法，设置子类原型为父类实例继承父类原型方法，即可实现功能完备的继承\n  // 缺点：生成子类实例会调用两次父类构造函数，若父类原型对象上存在引用类型仍会出现所有子类共享该属性的问题\n  let a = new SubClass('张三')\n  let b = new SubClass('李四')\n  b.showBooks() // ['js', 'css', 'html']\n  b.showName()  // 李四\n  a.books.push('php')\n  b.showBooks() // ['js', 'css', 'html']\n  console.log(a instanceof SuperClass)\n</code></pre>\n<ul>\n<li>这里是比较常用的继承方式，但仍不是最优解，上面我们可以看到生成子类实例会调用两次父类构造函数，若父类原型对象上存在引用类型仍会出现所有子类共享该属性的问题</li>\n<li>这一篇先介绍这三种继承方式，下一篇带来剩下几种继承的形式</li>\n</ul>","fields":{"slug":"/extends_new/"},"frontmatter":{"title":"JavaScript中的继承","tags":["JavaScript回顾","设计模式","进修"],"categories":"JavaScript"}}},{"node":{"html":"<h1>new的原理与实现</h1>\n<ul>\n<li>在javascript中我们经常看到在实例化某个类的时候都会在构造函数前面加一个new调用函数来获取我们的实例，但却没有想过new这个操作符在这里面做了什么，是如何生成的实例，所以这段时间我也大概了解了下new的工作原理，并随手写一下自己的感悟</li>\n</ul>\n<h2>原理</h2>\n<ul>\n<li>构造函数实例都具有该构造函数内的共用属性与方法，同时也会拥有构造函数原型对象上的方法，所以构造函数生成实例其实会经历三个步骤</li>\n<li>第一步，构造一个实例 空对象</li>\n<li>第二步，将构造函数的this值赋给这个对象，并执行构造函数内的赋值操作，这样该实例就有了构造函数相应的属性值</li>\n<li>第三步，使实例拥有构造函数原型链上的方法，这就需要我们将该对象的<strong>proto</strong>属性指向我们的构造函数的原型对象上（涉及到对象属性的查找原理，对象查找某方法或属性时，会先在对象自身上找，当自身查找不到时，就会在<strong>proto</strong>指向的对象上面找，如果第一个<strong>proto</strong>对象上面也没有就会继续沿着<strong>proto</strong>往上找，一直到找到该属性或者null为止，对这一块感兴趣的话，可以先了解一下原型与原型链）</li>\n</ul>\n<!--more-->\n<h2>实现</h2>\n<ul>\n<li>知道了原理其实实现一个相同的方法也就简单了</li>\n</ul>\n<pre><code class=\"language-js\">  // 这里使用ES6的结构来获取构造函数所需的参数\n  // 因为结构之后获取的是一个数组结构，所以使用apply来进行构造函数this的赋值\n  // 也可以使用arguments来获取，不过ES6中不这么建议了，要用的话进行arguments[0]的提取与裁剪就可以了\n  function New(Fn, ...args){\n    var obj = {} // 构造空对象\n    Fn.apply(obj, args) // 构造函数赋值与this指向的修改\n    obj.__proto__ = Fn.prototype // 对该对象赋值构造函数原型对象上的方法\n    return obj // 返回该实例\n  }\n\n  function Person(name){\n    this.name = name\n  }\n  Person.prototype.showName = function(){\n    console.log(this.name)\n  }\n\n  var p1 = New(Person, '张三')\n  p1.showName() // 张三\n</code></pre>","fields":{"slug":"/new/"},"frontmatter":{"title":"JavaScript中new的原理与手动实现一个new","tags":["JavaScript回顾","设计模式","进修"],"categories":"JavaScript"}}},{"node":{"html":"<h1>js中的继承（二）</h1>\n<h2>原型式继承</h2>\n<ul>\n<li>原型式继承：原型式继承可以根据现有对象创建一个新的对象，并且不用显式的创建一个新的自定义类型对象（道格拉斯说的）。这也就是原型式继承的作用，创建一个继承某对象属性并可进行拓展的的新对象。</li>\n<li>原型式继承采用的其实还是类式继承的原理，只不过不会显式的构建一个对象子类，而是用一个空的构造函数类来做过渡类，然后把被继承的对象设置为过渡类的原型对象，然后返回一个过渡类的实例，这样这个返回的对象就有了被继承对象的属性与方法，具体实现见下代码</li>\n</ul>\n<!--more-->\n<pre><code class=\"language-js\">  function inheritObject(obj){\n    function F(){} // 过渡类，一般为空\n    F.prototype = obj // 设置过渡类原型对象\n    return new F() // 返回新的实例\n  }\n\n  let book = {\n    books: ['css', 'js', 'html'],\n    name: 'css book',\n    showBooks: function(){\n      console.log(this.books, this.name)\n    }\n  }\n\n  let b1 = inheritObject(book)\n  let b2 = inheritObject(book)\n  b1.name = 'js book'\n  b2.name = 'html book'\n  b2.showBooks() // [\"css\", \"js\", \"html\"]  \"html book\"\n  b1.books.push('php')\n  // 这里可以看到对b1的books属性进行操作会影响到b2的books属性\n  b2.showBooks() // [\"css\", \"js\", \"html\", \"php\"]  \"html book\"\n  b1.showBooks() // [\"css\", \"js\", \"html\", \"php\"]  \"js book\"\n</code></pre>\n<ul>\n<li>原型式继承其实就是对类式继承的另类使用，只不过使用一个空构造函数的过渡类来替代子类减少开销，用于创建对象是一个蛮不错的选择，也是后来Object.create()的实现思想来源。</li>\n</ul>\n<h2>寄生式继承</h2>\n<ul>\n<li>寄生式继承：就是对原型式继承的二次封装，并且在二次封装中对继承的对象进行了拓展，这样对象不仅拥有了父类中的对象与属性，也有了新的属性与方法</li>\n</ul>\n<pre><code class=\"language-js\">  function inheritObject(obj){\n    function F(){} // 过渡类，一般为空\n    F.prototype = obj // 设置过渡类原型对象\n    return new F() // 返回新的实例\n  }\n  function createBook(obj){\n    var o = inheritObject(obj) // 获取原型式继承的对象\n    // 对该对象进行拓展\n    o.getName = function(){ \n      console.log(this.name)\n    }\n    return o\n  }\n  let book = {\n    books: ['css', 'js', 'html'],\n    name: 'css book',\n    showBooks: function(){\n      console.log(this.books, this.name)\n    }\n  }\n\n  let b1 = createBook(book)\n  b1.getName() // css book\n</code></pre>\n<ul>\n<li>只是比原型式继承多了一个函数封装，使其拥有了自己的属性与方法，产生这个继承方式的目的也是为了寄生组合式继承模型的实现</li>\n</ul>\n<h2>完美的继承模式——寄生组合式继承</h2>\n<ul>\n<li>寄生组合式继承：是寄生式继承与构造函数继承的组合形式，取了两个继承的优点产生的目前最完美的继承形式</li>\n<li>构造函数继承使子类具有父类构造函数内的属性与方法，寄生式继承获取一个继承自父类原型对象的子对象，避免了父类原型对象的二次调用，因为该对象可获取父类原型对象上的属性与方法，设置该对象为子类原型对象继承父类原型对象上的属性与方法，最后对该对象进行属性增强修正其constructor不指向子类的错误</li>\n</ul>\n<pre><code class=\"language-js\">  function inheritObject(obj){\n    function F(){}\n    F.prototype = obj\n    return new F()\n  }\n\n  function inherit(Subclass, Superclass){\n    // 生成一个继承父类原型对象的子对象\n    let sup = inheritObject(Superclass.prototype) \n    // 该对象的constructor并不是指向子类，所以要对其进行属性拓展，修改其constructor属性至子类\n    sup.constructor = Subclass\n    // 将这个拓展过后的对象作为子类的原型对象\n    Subclass.prototype = sup\n  }\n\n  function SuperClass(name){\n    this.name = name\n    this.favite = ['吃饭', '喝酒', '打篮球']\n  }\n  // 原型对象方法\n  SuperClass.prototype.showFavite = function(){\n    console.log(this.favite)\n  }\n\n  function SubClass(name){\n    SuperClass.call(this, name)\n  }\n  // 实现继承\n  inherit(SubClass, SuperClass)\n\n  let s1 = new SubClass('张三')\n  let s2 = new SubClass('李四')\n  s2.showFavite() //  [\"吃饭\", \"喝酒\", \"打篮球\"]\n  s1.favite.push('打豆豆')\n  s2.showFavite() //  [\"吃饭\", \"喝酒\", \"打篮球\"]\n  s1.showFavite() //  [\"吃饭\", \"喝酒\", \"打篮球\", \"打豆豆\"]\n</code></pre>\n<ul>\n<li>原型链与构造函数的组合继承中子类的原型对象为父类的一个实例，也就导致在对子类实现继承的时候会执行两次父类的构造函数（一次子类构造函数调用父类构造函数，一次生成父类实例时调用）。</li>\n<li>而在寄生组合式继承中，每次继承都会由过渡类继承父类原型对象返回一个新的实例，而且由于过渡类的空构造函数并不会导致有太大的内存开销，就避免了父类构造函数的二次调用，所以这也是当下最完美的继承形式</li>\n</ul>","fields":{"slug":"/extends_new_2/"},"frontmatter":{"title":"JavaScript中的继承（二）","tags":["JavaScript回顾","设计模式","进修"],"categories":"JavaScript"}}},{"node":{"html":"<h1>JavaScript中的设计模式——工厂模式</h1>\n<ul>\n<li>在我们的项目开发中会定义很多的类，当协作开发时，每个人都有可能定义很多的类，若是不对每个人或者每一种类进行管理的话，开发中对类的使用将会极其困难，而工厂模式就是对类进行管理的一种模式</li>\n<li>工厂模式一般有以下几种，分别对应不同的使用场景</li>\n</ul>\n<!--more-->\n<h2>简易工厂模式</h2>\n<ul>\n<li>简易工厂模式：不去关心子类的创建过程，只是提供一个函数向外提供他们想要的子类即可</li>\n<li>该模式就是单纯的对同一类型的类进行管理，使用者只需要传入每一个类的别名或简称即可获取该类</li>\n</ul>\n<pre><code class=\"language-js\">    function LoginClass(){\n        console.log('我是登录模块类')\n    }\n    function RegisterClass(){\n        console.log('我是注册模块类')\n    }\n    function LogoutClass(){\n        console.log('我是退出登录模块类')\n    }\n\n    function createUserClass(name){\n        switch(name) {\n            case 'login':\n                return new LoginClass()\n            case 'register':\n                return new RegisterClass()\n            case 'logout':\n                return new LogoutClass()\n        }\n    }\n    let login = createUserClass('login') // 构建登录模块\n    let register = createUserClass('register') // 构建注册模块\n    let logout = createUserClass('logout') // 构建退出登录模块\n</code></pre>\n<ul>\n<li>上面就是一个简易的工厂模式，一般用于管理同类型的类，对外提供每个类型的别名即可使用</li>\n</ul>\n<h2>工厂模式</h2>\n<ul>\n<li>工厂模式：工厂模式一般用于会不断创建新类时使用，比如我初始提供了三个类，突然需求变化新增了一个类，如果还使用建议工厂模式的话就需要先创建这个新类，然后在对外暴露的函数中再加一条case语句，会比较繁琐，所以就产生了工厂模式</li>\n<li>工厂模式是对一个工厂类的拓展，在该类的原型对象上面绑定工厂内所能提供的子类，调用者通过传入不同的类名可获取相应的实例</li>\n<li>工厂模式由于对外提供的是一个工厂类，若是项目新成员或者不熟悉开发的成员在调用过程中将其当做普通函数处理可能会出现异常并且会在全局对象上挂载太多全局变量，所以我们这里要对工厂类进行安全模式</li>\n</ul>\n<pre><code class=\"language-js\">    function Factory(name){\n        // 是否是类式调用，即有没有使用new方法来调用，若是按普通函数来调用则this会指向window，若以new的形式来调用，则会指向当前类\n        if(this instanceof Factory) {\n            // 采用new的形式调用则直接返回他想要的类\n            return new Factory[name]()\n        } else {\n            // 若是不熟悉或者忘了new的调用则我们帮他们调用一下工厂类，最终还是返回他们想要的类\n            return new Factory(name)\n        }\n    }\n</code></pre>\n<ul>\n<li>上面就是对工厂类的安全模式，可防止意外调用导致的一系列问题</li>\n<li>对安全模式的工厂类进行原型对象绑定即可实现我们最终的工厂模式，按需创建类，按需获取类</li>\n</ul>\n<pre><code class=\"language-js\">    function Factory(name){\n        // 是否是类式调用，即有没有使用new方法来调用，若是按普通函数来调用则this会指向window，若以new的形式来调用，则会指向当前类\n        if(this instanceof Factory) {\n            // 采用new的形式调用则直接返回他想要的类，会获取原型对象上的属性，从而获取所需类的构造函数\n            return new this[name]()\n        } else {\n            // 若是不熟悉或者忘了new的调用则我们帮他们调用一下工厂类，最终还是返回他们想要的类\n            return new Factory(name)\n        }\n    }\n    // 通过对工厂类原型对象的修改来获取工厂内存在的各个类，从而可以在工厂内提供人们需要的类\n    Factory.prototype = {\n        JS: function(){\n            this.name = 'js'\n        },\n        PHP: function(){\n            this.name = 'php'\n            this.age = 16\n            this.say = function(){\n                console.log('php是世界上最好的语言')\n            }\n        },\n        JAVA: function(){\n            this.name = 'java'\n            this.advantage = '我是最稳定的'\n            this.say = function(){\n                console.log(this.advantage)\n            }\n        }\n    }\n\n    var js = new Factory('JS')          \n    var php = Factory('PHP')        // 异常调用，可正常返回所需实例\n    var java = new Factory('JAVA')  // 正常调用\n    php.say()   // php是世界上最好的语言\n    java.say()  // 我是最稳定的\n</code></pre>\n<ul>\n<li>上面就是最终的工厂模式，可以看到，当我们需要添加新类的时候只需要在工厂类的原型对象上添加即可，添加完成便可以在别的地方传入名称直接由工厂类生成，需求变化也只需要修改一个地方即可</li>\n</ul>\n<h2>抽象类</h2>\n<ul>\n<li>了解抽象工厂类之前我们需要先了解抽象类，抽象类就是只能继承，无法实例化的一种类，实例化时会抛出异常，且继承抽象类的子类必须重写抽象类的方法。js中abstract仍然只是一个保留字，并没有实现抽象类，所以抽象类需要我们模拟实现</li>\n<li>抽象类在实现上与普通类相似，只是对其方法进行了限制，下面的Car就是一个抽象类</li>\n</ul>\n<pre><code class=\"language-js\">    let Car = function(){\n        this.name = 'Car'\n    }\n    // 如果对Car直接进行实例化或者继承类没有重写下面的方法，则调用时会弹出报错\n    Car.prototype = {\n        getSpeed: function(){\n            throw new Error('不可调用抽象方法')\n        },\n        getPrice: function(){\n            throw new Error('不可调用抽象方法')\n        }\n    }\n</code></pre>\n<h2>抽象工厂类</h2>\n<ul>\n<li>抽象工厂类是对外提供抽象类的工厂模式，下面就是一个抽象工厂模式</li>\n</ul>\n<pre><code class=\"language-js\">    function VehicleFactory(SubClass, SuperClass){\n        // 判断工厂内是否存在该抽象类，存在则进行子类的继承\n        if(typeof VehicleFactory[SuperClass] === 'function'){\n            function F(){}\n            F.prototype = new VehicleFactory[SuperClass]()\n            SubClass.prototype = new F()\n            SubClass.prototype.constructor = SubClass\n        } else {\n            // 若不存在，则抛出异常\n            throw new Error('未创建该抽象类')\n        }\n    }\n    // 抽象小汽车类\n    VehicleFactory.Car = function(){\n        this.name = 'Car'\n    }\n    VehicleFactory.Car.prototype = {\n        getSpeed: function(){\n            throw new Error('不可调用抽象方法')\n        },\n        getPrice: function(){\n            throw new Error('不可调用抽象方法')\n        }\n    }\n\n    // 抽象公交车类\n    VehicleFactory.Bus = function(){\n        this.name = 'Bus'\n    }\n    VehicleFactory.Bus.prototype = {\n        getSpeed: function(){\n            throw new Error('不可调用抽象方法')\n        },\n        getPrice: function(){\n            throw new Error('不可调用抽象方法')\n        }\n    }\n    // 实体类\n    function BWM(price, speed){\n        this.price = price\n        this.speed = speed\n    }\n    // 实现BWM对抽象类Car的继承,但不重写抽象方法\n    VehicleFactory(BWM, 'Car')\n    var b = new BWM(500000, 100)\n    b.getPrice()    // Uncaught Error: 不可调用抽象方法\n    b.getSpeed()    // Uncaught Error: 不可调用抽象方法\n    // 实体类\n    function BRT(price, speed){\n        this.price = price\n        this.speed = speed\n    }\n    // 实现BRT对抽象类Bus的继承\n    VehicleFactory(BRT, 'Bus')\n    // 重写抽象类中的方法\n    BRT.prototype.getPrice = function(){\n        console.log(this.price)\n    }\n    BRT.prototype.getSpeed = function(){\n        console.log(this.speed)\n    }\n    var t = new BRT(300000, 80)\n    t.getPrice()    // 300000\n    t.getSpeed()    // 80\n</code></pre>\n<ul>\n<li>这里我们的抽象工厂可以实现一个实体类对其想要的抽象类的继承，注意点就是要重写抽象类的方法再调用，否则会抛出异常</li>\n</ul>","fields":{"slug":"/factory_mode/"},"frontmatter":{"title":"JavaScript中的设计模式——工厂模式","tags":["JavaScript回顾","设计模式","进修"],"categories":"JavaScript"}}},{"node":{"html":"<h1>采用迭代器形式封装轮播图对象</h1>\n<ul>\n<li>轮播图是我们开发中经常需要实现的一个小功能，但是应用于不同的场景需要对应不同的效果，有的需要淡入淡出，有的需要左侧划入，有的则需要上一张下一张的按钮</li>\n<li>如果针对每个效果都要重新实现的话就会做太多的无用功，所以我们可以看看轮播图的共同点，然后封装一个迭代函数来帮助我们处理轮播图</li>\n<li>轮播图都会接收一个数组作为图片的来源，轮播中我们可能会遇到上一张下一张的显示，所以我们对上一张下一张还有第一张与最后一张做特殊处理，也有可能会对轮播对象中的几个图片不做显示</li>\n<li>所以我们可以提供一个迭代器对象，能对外提供操作数据的方法，包括next、pre、first、last的获取，包括对所有元素的初始化方法，包括对个别元素的操作方法</li>\n</ul>\n<!--more-->\n<pre><code class=\"language-js\">function Iterator(item) {\n  let container = document.querySelector('.container')\n  let items = container.getElementsByTagName(item)\n  let length = items.length\n  let index = 0\n  return {\n    // 获取下一张\n    next: function(){\n      if(index === length - 1) {\n        index = length - 1\n        return null\n      } else {\n        return items[++index]\n      }\n    },\n    // 获取下一张\n    pre: function(){\n      if(index === 0) {\n        index = 0\n        return null\n      } else {\n        return items[--index]\n      }\n    },\n    // 获取第一张\n    first: function(){\n      return items[0]\n    },\n    // 获取最后一张\n    last: function(){\n      return items[length - 1]\n    },\n    // 获取指定序号一张\n    get: function(index){\n      index = index >= 0 ? index % length : index % length + length\n      return items[index]\n    },\n    // 所有图片统一处理方式\n    dealEach: function(fn){\n      Array.prototype.slice.call(items).forEach(item => {\n        fn.call(item)\n      })\n    },\n    // 单张图片特殊处理函数\n    dealItem: function(index, fn){\n      fn.call(items[index])\n    },\n    // 部分图片的排他处理\n    exclusive: function(num, allFn, itemFn){\n      this.dealEach(allFn)\n      if(Object.prototype.toString.call(num) === '[object Array]') {\n        num.forEach(item => {\n          this.dealItem(item, itemFn)\n        })\n      } else {\n        this.dealItem(num, itemFn)\n      }\n    }\n  }\n}\n</code></pre>\n<ul>\n<li>上面我们提供了一个处理轮播图对象的迭代器函数，分别对外暴露了pre,next,last,first,get,dealEach,dealItem,exlusive几个功能函数，使用时只需要指定轮播对象就可以正常使用了，使用方法如下</li>\n</ul>\n<pre><code class=\"language-js\">  var it = Iterator('li')\n  console.log(it.first()) // 获取第一个对象\n  console.log(it.next())  // 获取下一个对象\n  console.log(it.pre())   // 获取上一个对象\n  console.log(it.last())  // 获取最后一个对象\n\n  // 为元素统一设置背景色\n  it.dealEach(function(){\n    this.style.background = 'red'\n  })\n  // 单个元素修改其内容\n  it.dealItem([2], function(){\n      this.innerHTML = 'dealItem'\n  })\n  // 修改其他元素内容\n  it.exclusive([1,3], function(){\n      this.innerHTML = 'exclusive'\n  }, function(){\n      console.log(234, this)\n      this.innerHTML = 'each'\n  })\n</code></pre>\n<ul>\n<li>这样就提供了轮播图的操作对象，具体的轮播实现还要看各自的需求，借助这个轮播对象应该都会比较轻松</li>\n</ul>","fields":{"slug":"/iterator_loop/"},"frontmatter":{"title":"迭代器在轮播图中的应用","tags":["JavaScript回顾","设计模式","进修"],"categories":"JavaScript"}}},{"node":{"html":"<h1>jQuery选择器的简单实现</h1>\n<ul>\n<li>jQuery是前几年前端开发中的老大哥了，而我们最喜欢的也是他提供的选择器跟链式调用的方法了，最近在看了原型与原型链之后也是有点简单的想法，想尝试着实现以下jquery的选择器</li>\n<li>首先需要构建一个函数A可以接受一个id名，返回一个新的对象，而且对象具有jquery提供的一系列方法，所以我们可以构造一个拥有这些方法的B对象并返回</li>\n</ul>\n<pre><code class=\"language-js\">  function A(selector){\n    return B\n  }\n  let B = {\n    length: 3,\n    size: function(){\n      return this.length\n    }\n  }\n</code></pre>\n<!--more-->\n<ul>\n<li>但是单纯的B对象的没办法接收选择器名称，所以我们可以给B添加一个初始化函数init，接收一个选择器名称，并返回最后的对象，因为返回的对象需要拥有B上面的方法，所以我们还是选择将B对象返回，但是我们也需要获取到的dom元素，所以，参照jquery的方法，我们可以将B对象的0属性设置为获取到的dom元素,并且更新B对象的length属性。那如何在函数内返回B对象那？因为init方法是挂载在对象身上的，所以，我们需要返回B对象的时候只需要返回this就可以了</li>\n</ul>\n<pre><code class=\"language-js\">  function A(selector){\n    return B.init(selector)\n  }\n  let B = {\n    init: function(selector){\n      let dom = document.getElementById(selector)\n      this[0] = dom\n      this.length = 1\n      return this\n    },\n    length: 3,\n    size: function(){\n      return this.length\n    }\n  }\n</code></pre>\n<ul>\n<li>这里的话我们需要手动实现一个B对象，过于繁琐，其实我们可以将A函数的fn属性设置为这个对象，这样就省去了显式的创建B对象</li>\n</ul>\n<pre><code class=\"language-js\">  function A(selector){\n    return A.fn.init(selector)\n  }\n  A.fn = {\n    init: function(selector){\n      let dom = document.getElementById(selector)\n      this[0] = dom\n      this.length = 1\n      return this\n    },\n    length: 3,\n    size: function(){\n      return this.length\n    }\n  }\n\n  var a = A('demo') // Object {0: #demo, init: f, length: 1, size: f}\n  var t = A('test') // Object {0: #test, init: f, length: 1, size: f}\n  console.log(a)    // Object {0: #test, init: f, length: 1, size: f}\n</code></pre>\n<ul>\n<li>上面我们能发现，如果直接返回A.fn这个对象的话则所有通过A函数获取到的对象会公用一个对象，包括属性，这样的话就会相互影响，取不到我们想要的dom，所以我们可以在返回前使用new进行修饰，但是new的特性导致返回的对象中的this将不再指向我们的A.fn，也就意味这我们不能使用size()方法，所以我们可以指定A.fn.init的prototype到A.fn从而获取size方法</li>\n</ul>\n<pre><code class=\"language-js\">  function A(selector){\n    return new A.fn.init(selector)\n  }\n  A.fn = {\n    init: function(selector){\n      let dom = document.getElementById(selector)\n      this[0] = dom\n      this.length = 1\n      return this\n    },\n    length: 3,\n    size: function(){\n      return this.length\n    }\n  }\n\n  A.fn.init.prototype = A.fn\n\n  var a = A('demo')         // Object {0: #demo, init: f, length: 1, size: f}\n  var t = A('test')         // Object {0: #test, init: f, length: 1, size: f}\n  console.log(a.size())     // 1\n</code></pre>\n<h2>extend方法实现</h2>\n<ul>\n<li>上面我们就简单的实现了一个id选择器，下面的话我们需要实现一下jQuery拓展插件的方式extend，extend方法其实就是对对象的整合并返回新的对象，所以要根据参数进行拓展，单对象则在当前对象拓展，多对象则融合并返回</li>\n</ul>\n<pre><code class=\"language-js\">  A.extend = A.fn.extend = function(...args){\n    let len = args.length, target\n    if(len === 0) {\n      return\n    }\n    if(len === 1) {\n      target = this\n      for(let key in args[0]) {\n        target[key] = args[0][key]\n      }\n    } else {\n      target = args[0]\n      for(let i = 1; i &#x3C; len; i++) {\n        for(let key in args[i]) {\n          target[key] = args[i][key]\n        }\n      }\n    }\n    return target\n  }\n\n  var a = A('demo')\n  a.extend({b: 3, d: 4})\n  console.log(a) // Object {0: #demo, length: 1, b:3, d: 4}\n\n  A.extend(a, {e: 4})\n\n  console.log(a) // Object {0: #demo, length: 1, b:3, d: 4, e:4}\n</code></pre>\n<ul>\n<li>上面就是拓展插件extend方法的实现，利用这个方法，可以在A函数或者选择之后的对象进行拓展</li>\n</ul>\n<h2>链式调用的实现</h2>\n<ul>\n<li>链式调用就是在每个方法执行完成之后都将当前this放回，这样接下来的方法便都可以拿到这个对象并接着调用，所以我们可以先拓展几个常用的jquery的方法</li>\n<li>on方法的实现，由于各浏览器的兼容性问题，所以我们对事件绑定方式on进行一个简单的实现，还是要用到我们的extend方法，因为选择器返回的对象都可以调用这个方法，所以我们将其拓展到A.fn对象上面</li>\n</ul>\n<pre><code class=\"language-js\">A.fn.extend({\n  // 立即执行函数获取各浏览器下的绑定方式并绑定到on方法上，避免每次调用都要判断浏览器环境\n  on: (function(){\n    if(document.addEventListener) {\n      return function(type, fn){\n        for(let i = 0; i &#x3C; this.length; i++) {\n          this[i].addEventListener(type, fn, false)\n        }\n      }\n    } else if(document.addEvent) {\n      return function(type, fn){\n        for(let i = 0; i &#x3C; this.length; i++) {\n          this[i].addEvent('on'+type, fn)\n        }\n      }\n    } else {\n      return function(type, fn){\n        for(let i = 0; i &#x3C; this.length; i++) {\n          this[i]['on' + type] = fn\n        }\n      }\n    }\n  })()\n})\n\na.on('click', function(){\n  console.log(this.innerHTML) // 1\n})\n</code></pre>\n<ul>\n<li>上面我们对A.fn进行了拓展，使所有选择器返回的对象都可以进行数据绑定，并且可以成功打印1</li>\n<li>接下来我们依次对其进行attr,css,html方法的拓展，在对css方法进行拓展的时候我们先对A进行了拓展，使其拥有可以将-连接的css属性转为驼峰命名的css属性，从而实现我们的赋值</li>\n</ul>\n<pre><code class=\"language-js\">A.extend({\n  // 常用css转驼峰\n  cameName: function(str){\n    return str.replace(/\\-(\\w)/g, function(all, letter){\n      return letter.toUpperCase()\n    })\n  }\n})\n\nA.fn.extend({\n  attr: function(...args){\n    if(args.length &#x3C; 1) {\n      return\n    }\n    if(args.length === 1) {\n      if(typeof args[0] === 'string') {\n        return this[0].getAttribute(args[0])\n      } else {\n        for(let i = 0; i &#x3C; this.length; i++) {\n          for(let key in args[0]) {\n            this[i].setAttribute(key, args[0][key])\n          }\n        }\n      }\n    } else {\n      for(let i = 0; i &#x3C; this.length; i++) {\n        this[i].setAttribute(args[0], args[1])\n      }\n    }\n    return this\n  },\n  html: function(...args){\n    console.log(args)\n    if(args.length) {\n      for(let i = 0; i &#x3C; this.length; i++) {\n        this[i].innerHTML = args[0]\n      }\n      return this\n    } else {\n      return this[0].innerHTML\n    }\n  },\n  css: function(...args){\n    if(args.length &#x3C; 1) {\n      return\n    }\n    if(args.length === 1) {\n      const name = args[0]\n      if(typeof args[0] === 'string') {\n        if(this[0].currentStyle){\n          return this[0].currentStyle[name]\n        } else {\n          return getComputedStyle(this[0], false)[name]\n        }\n      }else if(typeof args[0] === 'object') {\n        for(let i = 0; i &#x3C; this.length; i++) {\n          for(let key in args[0]) {\n            this[i].style[A.cameName(key)] = args[0][key]\n          }\n        }\n      }\n    } else {\n      const name = args[0]\n      for(let i = 0; i &#x3C; this.length; i++) {\n        this[i].style[A.cameName(name)] = args[1]\n      }\n    }\n    return this\n  }\n})\n</code></pre>\n<ul>\n<li>上面我们就实现了jquery常用的几个方法与链式调用，下面我们就可以使用上面的方法进行调用</li>\n</ul>\n<pre><code class=\"language-js\">a.css('background-color', '#0f0').html('我是链式调用').attr('data-tag', 'div').on('click', function(){\n    alert(this.innerHTML)\n})\n</code></pre>","fields":{"slug":"/jQuery/"},"frontmatter":{"title":"jquery选择器的实现","tags":["JavaScript回顾","设计模式","进修"],"categories":"JavaScript"}}},{"node":{"html":"<h1>事件绑定的两种优化方式</h1>\n<ul>\n<li>事件绑定在我们的项目中是经常存在的，但因为各浏览器对事件绑定的支持度不同，使我们不得不写一个兼容函数来实现事件绑定，常规的写法如下</li>\n</ul>\n<pre><code class=\"language-js\">function on(dom, type, fn){\n  if(document.addEventListener) { // IE9以上及主流浏览器\n    dom.addEventListener(type, fn, false)\n  } else if(document.attachEvent) { // IE8一下浏览器\n    dom.attachEvent('on' + type, fn)\n  } else { // dom0级支持浏览器\n    dom['on' + type] = fn\n  }\n}\n</code></pre>\n<ul>\n<li>上面的写法虽然能解决我们的问题，但是在页面中使用时，每绑定一次就要走一次逻辑判断，而这一部分其实是可以优化的，优化的方式一般有两种，一种是页面加载完毕便执行一个立即执行函数完成on的赋值，另一个则是在第一次调用的时候完成on的重新赋值</li>\n<li>页面加载完成赋值的实现如下</li>\n</ul>\n<!--more-->\n<pre><code class=\"language-js\">var on = (function(){\n  if(document.addEventListener) {\n    return function(dom, type, fn){\n      dom.addEventListener(type, fn)\n    }\n  } else if(document.attachEvent) {\n    return function(dom, type, fn){\n      dom.attachEvent('on' + type, fn)\n    }\n  } else {\n    return function(dom, type, fn){\n      dom['on' + type] = fn\n    }\n  }\n})()\n</code></pre>\n<ul>\n<li>通过开始的立即执行函数完成条件判断，并重新返回一个符合该浏览器兼容的绑定函数给on，这样在之后的函数绑定时就会使用这个返回的函数而不用再去判断一次浏览器情况</li>\n<li>缺陷就是在页面开始加载的时候就会执行，如果页面依赖比较多的情况下建议使用第二种方式</li>\n<li>第一次调用时绑定，也就是利用懒性模式实现绑定，实现方式如下</li>\n</ul>\n<pre><code class=\"language-js\">function on(dom, type, fn){\n  if(document.addEventListener) {\n    on = function(dom, type, fn){\n      dom.addEventListener(type, fn, false)\n    }\n  }else if(document.attachEvent) {\n    on = function(dom, type, fn){\n      dom.attachEvent('on' + type, fn)\n    }\n  } else {\n    on = function(dom, type, fn){\n      dom['on' + type] = fn\n    }\n  }\n  on(dom, type, fn)\n}\n</code></pre>\n<ul>\n<li>这种方式的实现是在浏览器判断条件完成之后对on重新赋值，并且在赋值之后进行函数的调用，这样在第一次执行之后on就被重新赋值，下次绑定就不会再走条件判断了，适用于首屏加载依赖比较多的情况</li>\n</ul>","fields":{"slug":"/lazy_event/"},"frontmatter":{"title":"事件绑定的两种优化方式","tags":["JavaScript回顾","设计模式","进修"],"categories":"JavaScript"}}},{"node":{"html":"<h1>Storage工具类的封装</h1>\n<ul>\n<li>日常开发中我们都会涉及到前端数据的存储，对一些需要长期保存在客户端的数据，我们通常会采用浏览器提供的localStorage对象，简称Storage对象。</li>\n<li>由于所有的页面处于同一个浏览器环境下，所以各个开发工程师所存储的Storage数据可能会出现同名情况，这样就会相互覆盖相互影响，所以为了解决这一问题，我们需要每个开发者都对自己的存储数据进行前缀命名好避免数据的污染</li>\n<li>Storage的存储api提供的比较简单，所以要实现这个功能就要我们进行进一步的封装与拓展，以实现我们的需求，首先我们构建一个Storage类，接收一个开发者id与数据分隔符（用于区分内容值与内容有效时间），并初始化状态对象</li>\n</ul>\n<!--more-->  \n<pre><code class=\"language-js\">function Storage(userId, sep){\n  this.userId = userId  // 开发者标识\n  this.sep = sep || '|_|'       // 数据分隔符\n  this.Storage = localStorage || window.localStorage\n  this.status = { // 操作状态值\n    FAILUER: 0,   // 失败\n    SUCCESS: 1,   // 成功\n    TIMEOUT: 2,   // 过期\n    OVERFLOW: 3   // 溢出\n  }\n}\n</code></pre>\n<ul>\n<li>之后我们需要对这个类提供操作方法，常用的方法为get,set,remove，get方法一般接受键名与一个回调函数，set接受键名，键值，有限期与回调函数，remove接收一个键名与一个回调函数，下面我们分别来实现这几个方法</li>\n<li>为了Storage实例可以调用这几个方法，所以我们将其绑定到Storage的原型上面</li>\n</ul>\n<pre><code class=\"language-js\">Storage.prototype = {\n  // 方便后续获取键名\n  getKey: function(key){\n    return this.userId + key\n  },\n  get: function(userKey, cb){\n    let key = this.getKey(userKey)\n    let status = this.status.SUCCESS\n    let value, sepIndex, time, result\n    try {\n      value = this.Storage.getItem(key)\n    } catch(e) {\n      value = null\n      status = this.status.FAILURE\n      result = {\n        value,\n        status\n      }\n      cb &#x26;&#x26; cb(result)\n      return result\n    }\n    if(value) {\n      sepIndex = value.indexOf(this.sep)\n      time = value.slice(0, sepIndex)\n      // 查看内容是否过期\n      if(new Date().getTime() &#x3C; new Date(time).getTime() || +time === 0){\n        value = value.slice(sepIndex + this.sep.length)\n      } else {\n        status = this.status.TIMEOUT\n        value = null\n        this.remove(key)\n      }\n    } else {\n      value = null\n    }\n    result = {\n      value,\n      status\n    }\n    cb &#x26;&#x26; cb(result)\n    return result\n  },\n  set: function(userKey, value, time, time = 0, cb){\n    let key = this.getKey(userKey)\n    let status = this.status.FAILURE\n    let result\n    // 是否设置时间，未设置默认一个月\n    try {\n      time = new Date(time).getTime()\n    } catch (e) {\n      time = new Date().getTime() + 30 * 24 * 60 * 60 * 1000\n    }\n    const realValue = time + this.sep + value\n    // 检查是否数据过多溢出\n    try {\n      this.Storage.setItem(key, realValue)\n    } catch (e) {\n      status = this.status.OVERFLOW\n    }\n    result = {\n      status\n    }\n    cb &#x26;&#x26; cb(result)\n    return result\n  },\n  remove: function(userKey, cb){\n    let status = this.status.FAILUER\n    let key = this.getKey(userKey)\n    let result\n    try {\n      this.Storage.removeItem(key)\n      status = this.status.SUCCESS\n    } catch(e) {\n    }\n    result = {\n      status\n    }\n    cb &#x26;&#x26; cb(result)\n    return result\n  }\n}\n</code></pre>\n<ul>\n<li>上面就是我们对Storage操作方法的实现，实现很简单，主要是处理一下各个情况下的状态值还有错误屏蔽，防止意外报错</li>\n<li>下面我们可以尝试一下为张三设置一下存储信息</li>\n</ul>\n<pre><code class=\"language-js\">let zsStorage = new Storage('zhangsan-')\nmyStorage.set('name', '张三')  // zhangsan-name: 0|_|张三\nmyStorage.get('name')         // {value: '张三', status: 1}\nmyStorage.remove('name')\n</code></pre>\n<ul>\n<li>这样一来就可以实现了一个适合我们使用的Storage的工具类</li>\n</ul>","fields":{"slug":"/storage/"},"frontmatter":{"title":"storage工具类的封装","tags":["JavaScript回顾","设计模式","进修"],"categories":"JavaScript"}}},{"node":{"html":"<h1>字符串模板的实现</h1>\n<ul>\n<li>字符串模板是针对大批量、多频率操作dom的解决方案，比如我们要根据数据动态创建一个多嵌套的元素并将其插入到页面中，如果我们采用常规创建dom元素的方式进行插，代码量会极其庞大，下面就是常规方式实现的功能</li>\n</ul>\n<!--more-->\n<pre><code class=\"language-js\">// 源数据\nlet data = {\n  data: {\n    li: [\n      {\n        span: '我是span',\n        strong: '我是strong'\n      },\n      {\n        span: '我是span',\n        strong: '我是strong'\n      },\n      {\n        span: '我是span',\n        strong: '我是strong'\n      }\n    ],\n    h2: '我是第二标题',\n    p: '我是p标签'\n  },\n  id: 'containter',\n}\n\nfunction createDom(data){\n  let div = document.createElement('div')\n  div.id = data.id\n  let ul = document.createElement('ul')\n  let p = document.createElement('p')\n  let pt = document.createTextNode(data.data.p)\n  let h2 = document.createElement('h2')\n  let ph = document.createTextNode(data.data.h2)\n  p.appendChild(pt)\n  h2.appendChild(ph)\n  let liData = data.data.li\n  for(let i = 0, len = liData.length; i &#x3C; len; i++) {\n    let li = document.createElement('li')\n    let span = document.createElement('span')\n    let strong = document.createElement('strong')\n    let t = document.createTextNode(liData[i].strong)\n    let p = document.createTextNode(liData[i].span)\n    span.appendChild(p)\n    strong.appendChild(t)\n    li.appendChild(span)\n    li.appendChild(strong)\n    ul.appendChild(li)\n  }\n\n  div.appendChild(ul)\n  div.appendChild(p)\n  div.appendChild(h2)\n  document.body.appendChild(div)\n}\n</code></pre>\n<ul>\n<li>上面的方式可以看到在大批量的创造dom，然后不停地嵌套添加，代码量大，并且效率低下</li>\n<li>所以这里我们提供了一个模板字符串的函数来生成这个模板并最后插入到页面中，首先我们要提供一个字符串替换的一个函数用来将数据替换到页面中</li>\n</ul>\n<pre><code class=\"language-js\">// 替换字符串模板中的数据\nfunction formatString(str, data){\n  return str.replace(/\\{\\{(\\w+)\\}\\}/g, function(all, key){\n    return data[key]\n  })\n}\n</code></pre>\n<ul>\n<li>然后根据数据结构创建我们的模板字符串与生成模板字符串的函数</li>\n</ul>\n<pre><code class=\"language-js\">// 生成数据的函数\nfunction createStrTemplate(data){\n  let div = document.createElement('div')\n  div.id = data.id\n  // 获取li遍历的数据\n  let liData = data.data.li\n  let ulStr = ''\n  // 根元素div的子元素模板\n  let divStr = [\n    '&#x3C;p>{{p}}&#x3C;/p>',\n    '&#x3C;h2>{{h2}}&#x3C;/h2>',\n    '&#x3C;ul>{{ul}}&#x3C;/ul>'\n  ].join('')\n  // li的模板\n  let liStr = [\n    '&#x3C;li>',\n    '&#x3C;span>{{span}}&#x3C;/span>',\n    '&#x3C;strong>{{strong}}&#x3C;/strong>',\n    '&#x3C;/li>'\n  ].join('')\n  for(let i = 0, len = liData.length; i &#x3C; len; i++) {\n    // 遍历li数组生成li元素并将内里的数据进行填充\n    ulStr += formatString(liStr, liData[i])\n  }\n  // 将填充好的字符串作为ul的源数据进行赋值\n  data.data.ul = ulStr\n  // 对div模板内的数据进行替换，并作为html内容进行赋值\n  let divStrTemplate = formatString(divStr, data.data)\n  div.innerHTML = divStrTemplate\n  document.body.appendChild(div)\n}\n\ncreateStrTemplate(data)\n</code></pre>\n<ul>\n<li>这样便实现了我们的模板字符串函数，只操作了一次dom创建与一次添加便完成了功能，能极大地提升我们的执行效率</li>\n<li>上面得代码可以看到创建的模板字符串都是同名标签加同名变量，我们可以对其进行进一步的处理</li>\n<li>构造一个生产标签加变量的函数</li>\n</ul>\n<pre><code class=\"language-js\">// 此函数可以接收字符串或者数组来生产对应的标签加变量\nfunction view(name){\n  if(Object.prototype.toString.call(name) === '[object Array]') {\n    let str = ''\n    for(let i = 0, len = name.length; i &#x3C; len; i++) {\n      str += view(name[i])\n    }\n    return str\n  } else {\n    return `&#x3C;${name}>{{${name}}}&#x3C;/${name}>`\n  }\n}\n</code></pre>\n<ul>\n<li>有了这个函数之后我们就可以对上面得代码进行进一步的优化</li>\n</ul>\n<pre><code class=\"language-js\">function createStringTemplate(data){\n  let div = document.createElement('div')\n  div.id = data.id\n  // 生成div子元素模板\n  let divStr = view(['p', 'h2', 'ul'])\n  let ulStr = ''\n  let liData = data.data.li\n  // 这一句先是生成了li子元素的模板，生成了li模板，然后又将li子元素模板作为模板数据填充进li中\n  let liTpl = formatString(view('li'), {li: view(['span', 'strong'])})\n  for(let i = 0, len = liData.length; i &#x3C; len; i++) {\n    // 遍历li数组生成li元素并将内里的数据进行填充\n    ulStr += formatString(liTpl, liData[i])\n  }\n  data.data.ul = ulStr\n  // 对div模板内的数据进行替换，并作为html内容进行赋值\n  let divStrTemplate = formatString(divStr, data.data)\n  div.innerHTML = divStrTemplate\n  document.body.appendChild(div)\n}\n\ncreateStringTemplate(data)\n</code></pre>\n<ul>\n<li>以上便是我们最终版的利用模板字符串替换频繁的dom操作，极大程度的提升我们的执行效率</li>\n</ul>","fields":{"slug":"/string_template/"},"frontmatter":{"title":"字符串模板的实现","tags":["JavaScript回顾","设计模式","进修"],"categories":"JavaScript"}}},{"node":{"html":"<h1>栈</h1>\n<ul>\n<li>栈是我们经常听到的数据结构，拥有后入先出的特性，可以理解为存放箱子的过程，存的时候后来的都放到先来的上面，取得时候也是从上面往下取，因为上面都是后来的箱子，所以会被先取出来</li>\n<li>JavaScript并没有栈这个数据类型，所以需要我们手动来实现，因为要涉及到一堆数据的存储，并且有先后顺序，还能实现存入与取出，最理想的实现数据类型自然就是我们的数组了，下面我们来实现一下栈</li>\n<li>首先定义一个栈类，应该拥有一个存放数据的数组，以及标记最上面元素的一个标记</li>\n</ul>\n<pre><code class=\"language-js\">function Stack(){\n  this.top = 0\n  this.dataStore = []\n}\n</code></pre>\n<!--more-->\n<ul>\n<li>上面就是一个栈的基本属性了，接下来就是栈拥有的方法，分别为存入，取出,因为所有的栈都有这些方法，所以我们定义在Stack的原型上</li>\n</ul>\n<pre><code class=\"language-js\">Stack.prototype = {\n  insert: function(data){\n    // 因为top初始值为0，所以我们可以采用后加加的方式实现赋值后对top的加一来标识下一个位置\n    this.dataStore[this.top++] = data\n  },\n  pop: function(){\n    // 这里要移除最后一个元素并返回，这里top已经指向了下一个位置，所以我们返回元素需要前减减来返回我们最顶部的元素。而且我们并没有用数组pop的方式对数组进行改变，因为我们的插入方式是针对下标赋值的，只需要将下标改到最后一个元素，这样下次插入就会直接改变最后一个值了\n    return this.dataStore[--this.top] \n  },\n  peek: function(){\n    // 这里我们只是要获取栈顶元素，并不是要从栈中移除元素，所以我们不改变top值\n    return this.dataStore[this.top - 1]\n  },\n  length: function(){\n    return this.top\n  }\n}\n</code></pre>\n<ul>\n<li>上面就是一个完整的数据类型栈的实现，我们可以拿来尝试一下栈的经典案例</li>\n</ul>\n<h2>栈实现进制转换</h2>\n<ul>\n<li>进制转换的方式，对一个数值，不停的整除以要转换的进制，取余数后继续整除以，直到最后整除以后为0截至，然后将所有余数倒置拼接即可拿到转换后的数值，按照这个规则，我们可利用栈来进行进制转换</li>\n</ul>\n<pre><code class=\"language-js\">function toFixed(number, fix){\n  let stack = new Stack()\n  let str = ''\n  while(number > 0) {\n    stack.insert(number % fix)\n    number = Math.floor(number / fix)\n  }\n  while(stack.length() > 0) {\n    str += stack.pop()\n  }\n  return str\n}\n\ntoFixed(12, 2) // 1100\n</code></pre>","fields":{"slug":"/stack/"},"frontmatter":{"title":"JavaScript中实现数据结构栈","tags":["JavaScript回顾","数据结构","进修"],"categories":"数据结构"}}},{"node":{"html":"<h1>队列</h1>\n<ul>\n<li>队列也是我们编程当中经常用到的一个数据结构，具有先入先出的特性，跟平时我们的排队一样，先进来先走</li>\n<li>同样，JavaScript并没有队列这个数据类型，所以需要我们自己来实现，因为队列同样具有顺序，且可以存入与去除，所以我们采用数组来做一个简单的实现</li>\n<li>首先定义一个队列类，因为只涉及到数据的存储，所以初始设置一个容器就可以</li>\n</ul>\n<pre><code class=\"language-js\">function Quene(){\n  this.dataStore = []\n}\n</code></pre>\n<ul>\n<li>上面就是一个队列的基本属性了，接下来就是队列拥有的方法，分别为入队，出队,获取队首元素，队尾元素，队列是否为空</li>\n</ul>\n<!--more-->\n<pre><code class=\"language-js\">Quene.prototype = {\n  enquene: function(data){\n    // 队列元素只能添加到队列最后面，所以我们直接使用数组push方法即可\n    this.dataStore.push(data)\n  },\n  dequene: function(){\n    // 队列元素出队是移除第一个元素，可以使用数组的shift方法移除数组的第一个元素\n    return this.dataStore.shift()\n  },\n  front: function(){\n    // 查询队首的元素\n    return this.dataStore[0]\n  },\n  back: function(){\n    // 查询队尾的元素\n    return this.dataStore[this.dataStore.length - 1]\n  },\n  isEmpty: function(){\n    return this.dataStore.length === 0 ? true : false\n  },\n  toString: function(){\n    // 用于遍历展示队列的元素\n    let str = ''\n    for(let i = 0; i &#x3C; this.dataStore.length; i++) {\n      str += '下一个是: ' + this.dataStore[i] + ' ,'\n    }\n    return str\n  }\n}\n</code></pre>\n<ul>\n<li>上面就是一个完整的数据类型队列的实现，我们可以拿来尝试一下队列的经典案例</li>\n</ul>\n<h2>队列实现舞池效果</h2>\n<ul>\n<li>舞池效果，舞池可供男女组队跳舞，但是男女的人数都不固定，所以需要一套匹配系统，当同时有男生女生排队时则播报入场男生名字与女方入场名字，若是只有男生或者女生，则播报男生或者女生的等待名称</li>\n<li>根据这个需求，我们需要确立一个舞者的类，具有性别与姓名的属性</li>\n</ul>\n<pre><code class=\"language-js\">// 舞者类\nfunction Dancer(name, sex){\n  this.name = name\n  this.sex = sex\n}\n\n// 跳舞者的文档资料，前面为性别，后面为名称\nlet dancers = `\nF A\nM B\nF C\nM D\nF E\nM F\nM G\n`\n// 用于存储男女舞者\nlet M = new Quene()\nlet F = new Quene()\n\nfunction initDancer(){\n  let dancerArr = dancers.split('\\n')\n  // 剔除空字符串\n  dancerArr = dancerArr.filter(item => {\n    if(item.trim()) {\n      return item.trim()\n    }\n  })\n  // 对所有舞者进行分组排列\n  dancerArr.forEach(item => {\n    let name = item.split(' ')[1], sex = item.split(' ')[0]\n    if(sex === 'F') {\n      F.enquene(new Dancer(name, sex))\n    } else {\n      M.enquene(new Dancer(name, sex))\n    }\n  })\n}\n\ninitDancer()\n\nfunction dancer(){\n  console.log('The dancer parters are \\n')\n  while(!M.isEmpty() &#x26;&#x26; !F.isEmpty()) {\n    console.log(`男方入场者为：${ M.dequene().name }，女方入场者为${ F.dequene().name }`)\n  }\n  if(!M.isEmpty()){\n    console.log(`男方等待区为：${ M.dequene().name }`)\n  }\n  if(!F.isEmpty()){\n    console.log(`女方等待区为: ${ F.dequene().name }`)\n  }\n}\n\ndancer()\n// The dancer parters are \n// 男方入场者为：B，女方入场者为A\n// 男方入场者为：D，女方入场者为C\n// 男方入场者为：F，女方入场者为E\n// 男方等待区为：G\n</code></pre>","fields":{"slug":"/quene/"},"frontmatter":{"title":"JavaScript中实现数据结构队列","tags":["JavaScript回顾","数据结构","进修"],"categories":"数据结构"}}},{"node":{"html":"<h1>react hooks 下使用redux</h1>\n<h2>redux</h2>\n<ul>\n<li>redux是近年来javascript中火热的状态管理容器，提供可预测的全局状态管理。在大型的应用中我们常采用redux来进行状态管理，redux的基本使用方式如下</li>\n<li>使用redux，我们先要进行action的编写，action一般由type与其他相关数据构成，下面就是简单的两个action</li>\n</ul>\n<pre><code class=\"language-js\">const INCREMENT = 'INCREMENT'\nconst DECREMENT = 'DECREMENT'\n\n// 数字增加action\n{ type: INCREMENT, payload: number }\n\n// 数字减少action\n{ type: DECREMENT, payload: number }\n</code></pre>\n<!--more-->\n<ul>\n<li>接下来，我们就要根据action来进行我们的reducer编写,reducer是一个函数，具有两个初始值，一个是当前的状态值state，一个是当前的操作模式action</li>\n<li>我们要根据当前的操作模式进行相应的逻辑处理，并返回新的state,这里我们为state设置一个初始值 0，对应INCREMENT与DECREMENT分别进行加减操作</li>\n</ul>\n<pre><code class=\"language-js\">const initialState = 0\n\nconst numberReducer = (state = initialState, action) => {\n  switch(action.type) {\n    case INCREMENT:\n      return state + action.payload\n    case DECREMENT:\n      return state - action.payload\n    default:\n      return state\n  }\n}\n</code></pre>\n<ul>\n<li>上面只是定义了操作形式与如何响应该操作，并没有实际的进行触发，触发状态改变需要redux提供的dispatch,dispatch接收一个action并将这个action传递给reducer，从而触发最后的状态改变，如下</li>\n</ul>\n<pre><code class=\"language-js\">dispatch({ type: DECREMENT, payload: number })\n</code></pre>\n<h2>react中使用redux</h2>\n<ul>\n<li>react hooks出来之前，redux几乎是所有react项目的不二只选，但是其复杂的使用方式让许多开发者都头疼，对萌新来说更是要命，上网查了都不知道是怎么回事</li>\n<li>hooks的出现，解放了一大批的react的开发者，易上手的开发模式让开发者使用极其简单，而react-redux自然也不会放过hooks的这波狂潮，下面就让我们对比一下hooks前后的两种redux使用形式</li>\n</ul>\n<h3>react中使用redux</h3>\n<ul>\n<li>react中使用redux需要借助三方库react-redux，react-redux提供了connect来让我们在组件中使用redux，如下使用</li>\n</ul>\n<pre><code class=\"language-js\">import React from 'react'\nimport { connect } from 'react-redux'\n\nclass Test extends React.Component {\n  constructor(){\n    super()\n  }\n  mapStateToProps(state) {\n    return {\n      number: state.number\n    }\n  }\n\n  mapDispatchToProps(dispatch) {\n    return {\n      increment: (number) => dispatch({ type: 'INCREMENT', payload: number }),\n      decrement: (number) => dispatch({ type: 'DECREMMENT', payload: number }),\n    }\n  }\n\n  render() {\n    return (\n      &#x3C;div>\n        &#x3C;div>{ this.props.number }&#x3C;/div>\n        &#x3C;button onClick={() => { this.props.increment(10) }}>增加10&#x3C;/button>\n        &#x3C;button onClick={() => { this.props.decrement(5) }}>减少5&#x3C;/button>\n      &#x3C;/div>\n    )\n  }\n\n}\n\nexport default connect(mapStateToProps, mapDispatchToProps)(Test)\n</code></pre>\n<h2>react hooks中使用redux</h2>\n<ul>\n<li>hooks中使用redux需要依靠react-redux提供的 useSelector 与 useDispatch进行state取值与dispatch执行修改操作</li>\n<li>useSelector会根据接受的函数返回需要的状态值，如下面的number</li>\n<li>useDispatch会返回一个操作函数，返回的操作函数可以接收一个action执行状态值的修改</li>\n</ul>\n<pre><code class=\"language-js\">import * as React from 'react'\nimport { useSelector, useDispatch } from 'react-redux'\n\nconst Test = () => {\n  const number = useSelector(state => state.number)\n  const dispatch = useDispatch()\n  return (\n      &#x3C;div>\n        &#x3C;div>{ this.props.number }&#x3C;/div>\n        &#x3C;button onClick={() => { dispatch({ type: 'INCREMENT', payload: 10 }) }}>增加10&#x3C;/button>\n        &#x3C;button onClick={() => { dispatch({ type: 'DECREMMENT', payload: 5 }) }}>减少5&#x3C;/button>\n      &#x3C;/div>\n    )\n}\n\nexport default Test\n</code></pre>","fields":{"slug":"/redux-hooks/"},"frontmatter":{"title":"react hooks下使用react-redux","tags":["react","react hooks","redux"],"categories":"React"}}},{"node":{"html":"<h1>从零搭建一个react-hooks项目（一）</h1>\n<ul>\n<li>最近有打算仿vue-admin项目构造一个react的项目，不引用官方脚手架，从webpack开始配置一套基于react,redux,typescript的项目，并实时记录一下项目中的一些配置情况</li>\n<li>首先搭建一个基本的webpack环境</li>\n</ul>\n<h2>webpack项目搭建</h2>\n<ul>\n<li>前置基础，电脑有安装node环境，可以使用npm工具</li>\n<li>新建文件夹，命名项目名称（react-admin）,进入文件夹，使用命令 npm init ，然后一路确定生成package.json文件</li>\n<li>webpack需要安装基本依赖 webpack webpack-cli webpack-dev-server, 命令为 npm i webpack webpack-cli webpack-dev-server -D</li>\n<li>安装依赖完成，则需要进行webpack的基本配置，我们在根目录构建 webpack.config.js 文件用于配置webpack</li>\n<li>然后在根目录创建一个index.js作为入口文件，我们先构造index.js这个入口文件，代码如下</li>\n</ul>\n<!--more-->\n<pre><code class=\"language-js\">function a(number){\n  console.log(number)\n}\na(12)\n</code></pre>\n<ul>\n<li>然后开始配置我们的webpack，webpack需要配置入口及输出位置，分别对应entry与output属性</li>\n<li>entry可以接收一个字符串作为主入口的文件路径，但只能用于单入口项目。也可以接收一个对象作为入口的文件路径，如下所示</li>\n<li>output用来描述打包后的文件应该放到哪，叫什么名字，也有两个基本属性，一个是打包后的文件名，一个是打包后的文件路径，这里我们通过[name].js来获取他在入口文件中的对应名称并生成文件名，如果是单入口并且直接用字符串指定的文件路径，比如entry: './index.js'，这样最后生成的文件名就是main.js，如果采用对象形式设定的entry属性，比如entry: { app: './index.js' }，则最后生成的文件就是对应的键值app.js。 路径使用path.resolve()来在根目录下生成dist文件夹并将打包文件放到其中</li>\n</ul>\n<pre><code class=\"language-js\">const path = require('path') // node环境自带，无需下载\n// 单入口文件\nmodule.exports = {\n  entry: './index.js', // 入口为index.js\n  output: {  // 输出就是 dist/main.js\n    filename: '[name].js',\n    path: path.resolve(__dirname, 'dist')\n  }\n}\n\n// 多入口文件\nmodule.exports = {\n  entry: { // 入口也是index.js\n    app: './index.js'\n  }, \n  output: {  // 输出为dist/app.js\n    filename: '[name].js',\n    path: path.resolve(__dirname, 'dist')\n  }\n}\n</code></pre>\n<ul>\n<li>配置到这就算完成了最基本的配置，我们可以来测试一下，先在package.json中的 scripts 下新建指令 \"start\": \"webpack --config webpack.config.js\"</li>\n<li>然后再执行npm run start 就可以看到执行了打包过程，生成了dist文件夹</li>\n<li>这里我们完成了基本的配置，但是这里还有一个问题，当我们修改entry对应的文件名时，重新执行打包，会发现之前的打包文件还存在，这样就会导致我们的dist文件夹会包含很多之前打包的跟当前代码无关的文件，这样其实对我们的项目并不友好，这里我们想要在每次打包的时候都把dist给移除了，并重新生成</li>\n<li>clean-webpack-plugin 插件可以帮助我们实现这个需求，先下载这个包  npm i clean-webpack-plugin -D</li>\n<li>然后在webpack.config.js中进行配置，如下，plugins用于我们配置我们想要的相关插件，接收一个数组值，这样我们的项目就可以在每次打包前都将dist清空了，就不会存在无用文件在内了</li>\n</ul>\n<pre><code class=\"language-js\">const path = require('path')\nconst { CleanWebpackPlugin } = require('clean-webpack-plugin');\n\nmodule.exports = {\n  entry: {\n    app: './index.js'\n  },\n  output: {\n    filename: '[name].js',\n    path: path.resolve(__dirname, 'dist'),\n    chunkFilename: '[name].bundle.js'\n  },\n  plugins: [\n    new CleanWebpackPlugin()\n  ]\n}\n</code></pre>\n<ul>\n<li>接下来就让我们开始配置react相关吧，react开发中我们会用到jsx或者es6的语法，而这些语法在低版本浏览器都是不兼容的，所以我们需要配置babel来实现低版本浏览器的兼容</li>\n<li>这里我们需要下载 babel-loader @babel/preset-env(根据环境转换代码) @babel/preset-react(react使用) @babel/preset-polyfill(Babel默认只转换新的JavaScript语法，但是不转换新的API，比如 <code>Iterator</code>、<code>Generator</code>、<code>Set</code>、<code>Maps</code>、<code>Proxy</code>、<code>Reflect</code>、<code>Symbol</code>、<code>Promise</code> 等全局对象，以及一些定义在全局对象上的方法（比如<code>Object.assign</code> ）都不会转码。而<code>@babel/preset-polyfill</code>可以转码。) @babel/proposal-object-rest-spread(处理react中对象的rest写法) @babel/proposal-object-rest-spread (处理类里面的箭头函数this绑定，static属性等 ), 依赖下载完成后就需要进行babel配置了</li>\n<li>我们在根目录构建 .babelrc 文件，内里配置如下</li>\n</ul>\n<pre><code class=\"language-js\">{\n  \"presets\": [\n    \"@babel/preset-env\",\n    \"@babel/preset-react\"\n  ],\n  \"plugins\": [\n    \"@babel/proposal-object-rest-spread\", // 处理对象的rest写法\n    \"@babel/proposal-class-properties\" // 处理类里面的箭头函数绑定，static属性等 \n  ]\n}\n</code></pre>\n<ul>\n<li>然后就需要在webpack里面配置编译规则了，还是在webpack.config.js里面，新增module模块，添加不同文件的解析规则，如下</li>\n</ul>\n<pre><code class=\"language-js\">module.exports = {\n  entry: {\n    app: './index.js'\n  },\n  output: {\n    filename: '[name].js',\n    path: path.resolve(__dirname, 'dist'),\n    chunkFilename: '[name].bundle.js'\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.(js)x?$/,\n        use: ['babel-loader'],\n        exclude: /node-modules/ // 不解析node_modules中的文件\n      }\n    ]\n  },\n  plugins: [\n    new CleanWebpackPlugin()\n  ]\n}\n</code></pre>\n<ul>\n<li>然后我们可以写代码来测试一下，react 要基于 dom 展示，所以我们新建一个index.html用于dom展示，index.jsx用于执行react挂载，新建一个文件夹src用于放置react相关的组件及内里逻辑，并在里面新建一个app.jsx用于做初始组件，代码分别如下</li>\n</ul>\n<pre><code class=\"language-js\">// index.html\n&#x3C;!DOCTYPE html>\n&#x3C;html lang=\"en\">\n&#x3C;head>\n  &#x3C;meta charset=\"UTF-8\">\n  &#x3C;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  &#x3C;title>Document&#x3C;/title>\n&#x3C;/head>\n&#x3C;body>\n  \n&#x3C;div id=\"app\">&#x3C;/div>\n&#x3C;script src=\"./dist/app.js\">&#x3C;/script>\n&#x3C;script src=\"./dist/test.js\">&#x3C;/script>\n&#x3C;/body>\n&#x3C;/html>\n</code></pre>\n<pre><code class=\"language-js\">// index.jsx\nimport * as React from 'react'\nimport * as ReactDOM from 'react-dom'\nimport App from './src/app.jsx'\nReactDOM.render(\n  &#x3C;App/>\n  ,document.querySelector('#app')\n)\n</code></pre>\n<pre><code class=\"language-js\">// app.jsx\nimport * as React from 'react'\nclass App extends React.Component{\n  render(){\n    return (\n      &#x3C;div>123&#x3C;/div>\n    )\n  }\n}\nexport default App\n</code></pre>\n<ul>\n<li>然后需要在我们的webpack配置中新增加一个入口文件，如我们在html中的引入一样，需要命名为test，配置如下</li>\n</ul>\n<pre><code class=\"language-js\">module.exports = {\n  entry: {\n    app: './index.js',\n    test: './index.jsx'\n  },\n  ...// 省略\n}\n</code></pre>\n<ul>\n<li>接下来执行npm run start 执行打包，打包完成后打开页面 index.html 查看就可以发现已经插入了123进去</li>\n<li>这里我们可以发现我们需要新建一个index.html然后再主动根据生成的文件路径将其引入进去，要是生成的文件比较多则会很麻烦，所以我们接下来使用插件让其自动生成</li>\n<li>首先下载插件 html-webpack-plugin，命令为 npm i html-webpack-plugin</li>\n<li>然后再webpack.config.js里进行相关配置，还是用在plugins模块中，如下所示</li>\n</ul>\n<pre><code class=\"language-js\">const path = require('path')\nconst webpack = require('webpack')\nconst { CleanWebpackPlugin } = require('clean-webpack-plugin');\nconst HTMLWebpackPlugin = require('html-webpack-plugin')\n\nmodule.exports = {\n  entry: {\n    app: './index.js',\n    test: './index.jsx'\n  },\n  output: {\n    filename: '[name].js',\n    path: path.resolve(__dirname, 'dist'),\n    chunkFilename: '[name].bundle.js'\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.(js)x?$/,\n        use: ['babel-loader'],\n        exclude: /node-modules/\n      }\n    ]\n  },\n  plugins: [\n    new HTMLWebpackPlugin({\n      inject: true, // 所有js脚本放于body之后\n      hash: true, // 为静态资源生成hash，用于清楚缓存\n      cache: true, // 仅在文件被更改时发出文件\n      title: 'react admin',\n      filename: 'index.html',\n      template: path.resolve(__dirname, 'index.html'),\n      minify: {\n        collapseWhitespace: true, // 折叠空白\n        removeComments: true, // 删除注释\n        removeRedundantAttributes: true,\n        removeScriptTypeAttributes: true,\n        removeStyleLinkTypeAttributes: true\n      }\n    }),\n    new CleanWebpackPlugin()\n  ]\n}\n</code></pre>\n<ul>\n<li>然后在根目录放置我们的模板index.html，不需要主动引入js文件了，内容如下</li>\n</ul>\n<pre><code class=\"language-js\">// index.html\n&#x3C;!DOCTYPE html>\n&#x3C;html lang=\"en\">\n&#x3C;head>\n  &#x3C;meta charset=\"UTF-8\">\n  &#x3C;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  &#x3C;title>react admin&#x3C;/title>\n&#x3C;/head>\n&#x3C;body>\n  \n&#x3C;div id=\"app\">&#x3C;/div>\n&#x3C;/body>\n&#x3C;/html>\n</code></pre>\n<ul>\n<li>之后再执行我们的npm run start 就可以在dist中自动生成我们的index.html文件了，直接打开就能发现已经有我们要渲染的内容了</li>\n<li>react相关的就配置完成了，接下来我们需要配置一下css部分，开发中以less作为示例配置一下</li>\n<li>首先安装相关的依赖 less-loader style-loader postcss-loader css-loader autoprefixer，命令为 npm i less-loader style-loader postcss-loader css-loader autoprefixer -D</li>\n<li>接下来进行webpack配置，用以处理less文件的解析及处理</li>\n<li>还是在 module 下面的 rules 中配置规则，如下</li>\n</ul>\n<pre><code class=\"language-js\">const path = require('path')\nconst webpack = require('webpack')\nconst { CleanWebpackPlugin } = require('clean-webpack-plugin');\nconst HTMLWebpackPlugin = require('html-webpack-plugin')\n\nmodule.exports = {\n  entry: {\n    app: './index.js',\n    test: './index.jsx'\n  },\n  output: {\n    filename: '[name].js',\n    path: path.resolve(__dirname, 'dist'),\n    chunkFilename: '[name].bundle.js'\n  },\n  module: {\n    rules: [\n      { \n        test: /\\.(le|c)ss$/,\n        use: [ // 解析规则为从右向左，即 less-loader, postcss-loader, css-loader, style-loader\n          'style-loader',\n          {\n            loader: 'css-loader',\n            options: {\n              sourceMap: true //是否打开样式查找\n            }\n          },\n          {\n            loader: 'postcss-loader', // 为浏览器加前缀\n            options: {\n              ident: 'postcss',\n              sourceMap: true,\n              plugins: loaders => [\n                require('autoprefixer')({\n                })\n              ]\n            }\n          },\n          {\n            loader: 'less-loader', // 解析样式文件\n            options: {\n              sourceMap: true\n            }\n          }\n        ]\n      },\n      {\n        test: /\\.(js)x?$/,\n        use: ['babel-loader'],\n        exclude: /node-modules/\n      }\n    ]\n  },\n  plugins: [\n    new HTMLWebpackPlugin({\n      inject: true, // 所有js脚本放于body之后\n      hash: true, // 为静态资源生成hash，用于清楚缓存\n      cache: true, // 仅在文件被更改时发出文件\n      title: 'react admin',\n      filename: 'index.html',\n      template: path.resolve(__dirname, 'index.html'),\n      minify: {\n        collapseWhitespace: true, // 折叠空白\n        removeComments: true, // 删除注释\n        removeRedundantAttributes: true,\n        removeScriptTypeAttributes: true,\n        removeStyleLinkTypeAttributes: true\n      }\n    }),\n    new CleanWebpackPlugin()\n  ]\n}\n</code></pre>\n<ul>\n<li>配置完成之后我们简单做个测试，在app.jsx目录下新建app.less文件，并简单书写样式</li>\n</ul>\n<pre><code class=\"language-css\">.red{\n  color: red;\n  .blue{\n    background: blue;\n  }\n  .orange{\n    background: orange;\n  }\n}\n</code></pre>\n<ul>\n<li>修改app.jsx中的渲染内容为</li>\n</ul>\n<pre><code class=\"language-js\">import * as React from 'react'\nimport './app.less'\n\nclass App extends React.Component{\n  render(){\n    return (\n      &#x3C;div className=\"red\">\n        &#x3C;div className=\"blue\">123&#x3C;/div>\n        &#x3C;div className=\"orange\">345&#x3C;/div>\n      &#x3C;/div>\n    )\n  }\n}\n\nexport default App\n</code></pre>\n<ul>\n<li>然后执行npm run start,之后打开dist中的index.html，就发现样式已经生效了，然后F12打开开发者工具调试，能查找到对应的div生效样式的所在位置</li>\n<li>上面就完成了一个简单的demo，接下来就是要针对项目做一些配置化了</li>\n</ul>","fields":{"slug":"/react_md_1/"},"frontmatter":{"title":"从零搭建一个react-hooks项目（一）","tags":["react","react hooks","redux","webpack"],"categories":"Webpack"}}},{"node":{"html":"<h1>从零搭建一个react-hooks项目（二）</h1>\n<ul>\n<li>上一篇搭建了基本的webpack项目，可以支持react，less的基本使用，但是没有考虑到项目中的实际情况，例如生产环境的代码混淆，代码压缩，开发环境的热启动等。</li>\n<li>下面我们就针对开发与生产环境的不同需求，对webpack进行下一步的配置</li>\n<li>生产环境的配置与开发环境的配置有很多的不同点，所以我们需要分别建对应的配置文件，在根目录下分别创建 webpack.prod.js（生产配置） 与webpack.dev.js（开发配置）</li>\n<li>然后在package.json中的scripts里新建两个命令，分别是 \"build\": \"webpack --config webpack.prod.js\", \"dev\": \"webpack --config webpack.dev.js\"</li>\n</ul>\n<h2>开发环境的配置</h2>\n<ul>\n<li>先将webpack.config.js中的配置复制到webpack.dev.js中，然后进行我们的基本配置修改</li>\n<li>首先开发中需要对错误进行一个精准定位，所以在配置中开启 devtool: \"inline-source-map\"，如下所示</li>\n<li>css的样式覆盖关系在我们之前的开发中就已经使用了source: map的属性，所以可以在开发环境中继续使用</li>\n</ul>\n<!--more-->\n<pre><code class=\"language-js\">const path = require('path')\nconst webpack = require('webpack')\nconst { CleanWebpackPlugin } = require('clean-webpack-plugin');\nconst HTMLWebpackPlugin = require('html-webpack-plugin')\n\nmodule.exports = {\n  entry: {\n    app: './index.js',\n    test: './index.jsx'\n  },\n  output: {\n    filename: '[name].js',\n    path: path.resolve(__dirname, 'dist'),\n    chunkFilename: '[name].bundle.js'\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.(le|c)ss$/,\n        use: [\n          'style-loader',\n          {\n            loader: 'css-loader',\n            options: {\n              sourceMap: true //是否打开样式查找\n            }\n          },\n          {\n            loader: 'postcss-loader', // 为浏览器加前缀\n            options: {\n              ident: 'postcss',\n              sourceMap: true,\n              plugins: loaders => [\n                require('autoprefixer')({\n                })\n              ]\n            }\n          },\n          {\n            loader: 'less-loader', // 解析样式文件\n            options: {\n              sourceMap: true\n            }\n          }\n        ]\n      },\n      {\n        test: /\\.(js)x?$/,\n        use: ['babel-loader'],\n        exclude: /node-modules/\n      }\n    ]\n  },\n  devtool: 'inline-source-map',\n  plugins: [\n    new HTMLWebpackPlugin({\n      inject: true, // 所有js脚本放于body之后\n      hash: true, // 为静态资源生成hash，用于清楚缓存\n      cache: true, // 仅在文件被更改时发出文件\n      title: 'react admin',\n      filename: 'index.html',\n      template: path.resolve(__dirname, 'index.html'),\n      minify: {\n        collapseWhitespace: true, // 折叠空白\n        removeComments: true, // 删除注释\n        removeRedundantAttributes: true,\n        removeScriptTypeAttributes: true,\n        removeStyleLinkTypeAttributes: true\n      }\n    }),\n    new CleanWebpackPlugin()\n  ]\n}\n</code></pre>\n<ul>\n<li>接着在我们的开发过程中我们不希望每做一次改动都需要手动的执行一次npm run dev，所以我们这里使用我们的webpack-dev-server来为我们提供node的静态服务，配合webpack的打包可以让我们实现实时更新，实时显示，不需要手动触发npm run dev命令来进行刷新</li>\n<li>首先我们修改package.json中的dev命令为:\"webpack-dev-server --open --config webpack.dev.js\"</li>\n<li>接下来就需要对该静态服务进行配置，配置项放在配置中的devServer下面，如下</li>\n</ul>\n<pre><code class=\"language-js\">const path = require('path')\nconst webpack = require('webpack')\nconst { CleanWebpackPlugin } = require('clean-webpack-plugin');\nconst HTMLWebpackPlugin = require('html-webpack-plugin')\n\nmodule.exports = {\n  entry: {\n    ...\n  },\n  output: {\n    ...\n  },\n  module: {\n    ...\n  },\n  devtool: 'inline-source-map',\n  plugins: [\n    ...\n  ],\n  devServer: {\n    contentBase: './dist', // 静态文件目录，用于浏览器显示\n    clientLogLevel: 'warning',  // 输出日志级别\n    hot: true, // 启动热更新\n    publicPath: '/', // 浏览器访问路径\n    compress: true, // 启用gzip压缩\n    port: 9998,\n    open: true, // 自动调起浏览器\n    overlay: { // 出现错误或警告是否覆盖页面线上错误信息\n      warnings: true,\n      errors: true\n    },\n    quiet: true,\n    proxy: { // 代理\n    },\n    watchOptions: { // 监控文件相关配置\n      poll: true,\n      ignored: /node_modules/,\n      aggregateTimeout: 300  // 默认值, 当你连续改动时候, webpack可以设置构建延迟时间(防抖)\n    }\n  }\n}\n</code></pre>\n<ul>\n<li>然后在执行我们的npm run dev就可以发现会自动帮我们打开浏览器，然后当我们修改主要文件的时候也会重新帮我们刷新页面</li>\n<li>上面的自动刷新在某些场景下会有一些问题，当依赖的模块发生改变时可能当前的页面绑定关系不能即时刷新，所以我们需要引入新的模块来进行问题修复</li>\n<li>webpack 自带模块热替换插件 HotModuleReplacementPlugin ，使用时只需要引入webpack，然后在plugin中添加 new webpack.HotModuleReplacementPlugin()即可解决部分依赖刷新不及时的问题，如下</li>\n</ul>\n<pre><code class=\"language-js\">...\nconst webpack = require('webpack')\n\nmodule.exports = {\n  entry: {\n    ...\n  },\n  output: {\n    ...\n  },\n  module: {\n    ...\n  },\n  devtool: 'inline-source-map',\n  plugins: [\n    new webpack.HotModuleReplacementPlugin(),\n    ...\n  ],\n  devServer: {\n    ...\n  }\n}\n</code></pre>\n<ul>\n<li>再次执行npm run dev就能实时的更改代码并实时刷新了，至此，开发环境的基本配置就完成了</li>\n</ul>\n<h2>生产环境的构建</h2>\n<ul>\n<li>生产环境为了客户的体验与代码的隐私性，我们一般都会对代码进行混淆压缩，包括css与js代码的压缩，下面我们就来进行相关的配置</li>\n<li>首先还是将我们之前的webpack.config.js中的基本配置复制到webpack.prod.js中，然后在此基础上进行相关的修改</li>\n<li>上一章中我们将output中的filename命名为[name].js与入口文件一致，在生产环境中，为了避免名称一致导致的缓存问题，我们要对其进行修改</li>\n<li>修改为[name].[chunkhash].js，这样在生成文件的时候会默认添加一个hash值，避免缓存问题的出现，修改如下</li>\n</ul>\n<pre><code class=\"language-js\">// 先贴一下上一章最后的配置内容，后续不再完整展示\nconst path = require('path')\nconst webpack = require('webpack')\nconst { CleanWebpackPlugin } = require('clean-webpack-plugin');\nconst HTMLWebpackPlugin = require('html-webpack-plugin')\n\nmodule.exports = {\n  entry: {\n    app: './index.js',\n    test: './index.jsx'\n  },\n  output: {\n    filename: '[name].[chunkhash].js',\n    path: path.resolve(__dirname, 'dist'),\n    chunkFilename: '[name].bundle.js'\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.(le|c)ss$/,\n        use: [\n          'style-loader',\n          {\n            loader: 'css-loader',\n            options: {\n              sourceMap: true //是否打开样式查找\n            }\n          },\n          {\n            loader: 'postcss-loader', // 为浏览器加前缀\n            options: {\n              ident: 'postcss',\n              sourceMap: true,\n              plugins: loaders => [\n                require('autoprefixer')({\n                })\n              ]\n            }\n          },\n          {\n            loader: 'less-loader', // 解析样式文件\n            options: {\n              sourceMap: true\n            }\n          }\n        ]\n      },\n      {\n        test: /\\.(js)x?$/,\n        use: ['babel-loader'],\n        exclude: /node-modules/\n      }\n    ]\n  },\n  plugins: [\n    new HTMLWebpackPlugin({\n      inject: true, // 所有js脚本放于body之后\n      hash: true, // 为静态资源生成hash，用于清楚缓存\n      cache: true, // 仅在文件被更改时发出文件\n      title: 'react admin',\n      filename: 'index.html',\n      template: path.resolve(__dirname, 'index.html'),\n      minify: {\n        collapseWhitespace: true, // 折叠空白\n        removeComments: true, // 删除注释\n        removeRedundantAttributes: true,\n        removeScriptTypeAttributes: true,\n        removeStyleLinkTypeAttributes: true\n      }\n    }),\n    new CleanWebpackPlugin()\n  ]\n}\n</code></pre>\n<ul>\n<li>执行npm run build之后打开dist文件夹发现生成的文件都会带一串乱码，这样就避免了线上缓存的问题</li>\n<li>接下来我们需要打开完整的错误调试，方便线上查找问题，还是修改devtool为source-map即可，如下</li>\n</ul>\n<pre><code class=\"language-js\">...\n\nmodule.exports = {\n  entry: {\n    ...\n  },\n  devtool: 'source-map',\n  output: {\n    ...\n  },\n  ...\n}\n</code></pre>\n<ul>\n<li>然后我们尝试在index.js中主动抛出错误，执行npm run build后在浏览器点击错误就可以定位到相关错误的地方，便于错误排查</li>\n<li>然后我们就需要进行代码的压缩混淆，减少代码体积，先对js进行代码压缩，这里我们需要引用插件 terser-webpack-plugin ，先进行下载，命令为： cnpm i terser-webpack-plugin -D ，然后在配置文件中进行相关配置，如下</li>\n</ul>\n<pre><code class=\"language-js\">const path = require('path')\nconst webpack = require('webpack')\nconst { CleanWebpackPlugin } = require('clean-webpack-plugin');\nconst HTMLWebpackPlugin = require('html-webpack-plugin')\nconst TerserWebpackPlugin = require('terser-webpack-plugin')\n\nmodule.exports = {\n  entry: {\n    ...\n  },\n  devtool: 'source-map',\n  output: {\n    ...\n  },\n  module: {\n    ...\n  },\n  plugins: [\n    ...\n  ],\n  optimization: {\n    minimizer: [\n      // js压缩\n      new TerserWebpackPlugin({\n        cache: true, // 启用文件缓存\n        parallel: true, // 多线程调用\n        sourceMap: true // 错误排查\n      }),\n    ]\n  }\n}\n</code></pre>\n<ul>\n<li>接下来就是对css文件的打包进行处理，首先我们要将css文件给单独打包出来，我们可以观察到之前打包出来的文件其实是没有css文件的，因为webpack把所有的文件都打到一个文件里面了，所以我们没办法看到它，这其实对最后的生成的项目并不友好，所以我们先要在打包中将css抽离出来，这里我们就需要一个新的包 mini-css-extract-plugin ，还是使用npm下载此包： npm i mini-css-extract-plugin -D，然后在loader中将其配置起来</li>\n<li>首先我们在页面中引用该插件，然后将style-loader替换为它提供的loader，然后在plugins中进行css抽离的命名规则配置，为避免缓存问题，我们还是采用hash值进行命名，配置如下</li>\n</ul>\n<pre><code class=\"language-js\">...\nconst MiniCssExtractPlugin = require('mini-css-extract-plugin')\n\nmodule.exports = {\n  entry: {\n    ...\n  },\n  devtool: 'source-map',\n  output: {\n    ...\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.(le|c)ss$/,\n        use: [\n          MiniCssExtractPlugin.loader, // 替换了原来的style-loader\n          {\n            loader: 'css-loader',\n            options: {\n              sourceMap: true //是否打开样式查找\n            }\n          },\n          {\n            loader: 'postcss-loader', // 为浏览器加前缀\n            options: {\n              ident: 'postcss',\n              sourceMap: true,\n              plugins: loaders => [\n                require('autoprefixer')({\n                })\n              ]\n            }\n          },\n          {\n            loader: 'less-loader', // 解析样式文件\n            options: {\n              sourceMap: true\n            }\n          }\n        ]\n      },\n      ...\n    ]\n  },\n  plugins: [\n    new MiniCssExtractPlugin({// 将css打包成单独的css文件\n      filename: '[name].[hash:5].css',\n      chunkFilename: '[id].[hash:5].css'\n    }),\n    ...\n  ]\n  \n}\n</code></pre>\n<ul>\n<li>然后在运行npm run build就可以发现我们打出来的文件中出现了app.xxxxx.css的文件</li>\n<li>接下来我们就要对css进行压缩了，css的压缩需要使用 optimize-css-assets-webpack-plugin 插件，还是npm下载该插件 npm i optimize-css-assets-webpack-plugin -D，然后在webpack中进行相关配置，跟js的配置一样，需要放置在optimization 下的 minimizer 中，如下</li>\n</ul>\n<pre><code class=\"language-js\">const path = require('path')\nconst webpack = require('webpack')\nconst { CleanWebpackPlugin } = require('clean-webpack-plugin');\nconst HTMLWebpackPlugin = require('html-webpack-plugin')\nconst TerserWebpackPlugin = require('terser-webpack-plugin')\nconst MiniCssExtractPlugin = require('mini-css-extract-plugin')\nconst OptimizeCssAssetsWebpackPlugin = require('optimize-css-assets-webpack-plugin')\n\nmodule.exports = {\n  entry: {\n    ...\n  },\n  devtool: 'source-map',\n  output: {\n    ...\n  },\n  module: {\n    ...\n  },\n  plugins: [\n    ...\n  ],\n  optimization: {\n    minimizer: [\n      // js压缩\n      new TerserWebpackPlugin({\n        cache: true, // 启用文件缓存\n        parallel: true, // 多线程调用\n        sourceMap: true // 错误排查\n      }),\n      new OptimizeCssAssetsWebpackPlugin({}) // css压缩\n    ]\n  }\n}\n</code></pre>\n<ul>\n<li>到这我们就基本完成了开发与生产环境的各自配置，接下来我们就继续对项目需要进行相应的处理</li>\n<li>观察上面的开发与生产配置，其实还是有一部分的公用配置可以抽离出来，这里我们采用webpack-merge包来将其公共配置分离出来</li>\n<li>还是先下载该包：npm i webpack-merge -D</li>\n<li>然后在根目录新建一个webpack.common.js用来放置我们的公共配置</li>\n<li>观察开发与生产配置，抽离公共的配置如下</li>\n</ul>\n<pre><code class=\"language-js\">// webpack.common.js\nconst path = require('path')\nconst HtmlWebpackPlugin = require('html-webpack-plugin')\nconst { CleanWebpackPlugin } = require('clean-webpack-plugin')\nmodule.exports = {\n  entry: {\n    app: './index.js',\n    test: './index.jsx'\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.(|js)x?$/,\n        use: ['babel-loader'],\n        exclude: /node-modules/\n      }\n    ]\n  },\n  plugins: [\n    new HtmlWebpackPlugin({\n      inject: true, // 所有js脚本放于body之后\n      hash: true, // 为静态资源生成hash，用于清楚缓存\n      cache: true, // 仅在文件被更改时发出文件\n      title: 'react admin',\n      filename: 'index.html',\n      template: path.resolve(__dirname, 'index.html'),\n      minify: {\n        collapseWhitespace: true, // 折叠空白\n        removeComments: true, // 删除注释\n        removeRedundantAttributes: true,\n        removeScriptTypeAttributes: true,\n        removeStyleLinkTypeAttributes: true\n      }\n    }),\n    new CleanWebpackPlugin(),\n  ]\n}\n</code></pre>\n<ul>\n<li>之前我们的配置中没有进行代码块的抽离，这里我们也简单的进行一下补充，加一组配置即可，这个是开发与生产公用的，所以我们也加到上面的配置中，如下</li>\n</ul>\n<pre><code class=\"language-js\">// webpack.common.js\nconst path = require('path')\nconst HtmlWebpackPlugin = require('html-webpack-plugin')\nconst { CleanWebpackPlugin } = require('clean-webpack-plugin')\nmodule.exports = {\n  entry: {\n    app: './index.js',\n    test: './index.jsx'\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.(|js)x?$/,\n        use: ['babel-loader'],\n        exclude: /node-modules/\n      }\n    ]\n  },\n  plugins: [\n    new HtmlWebpackPlugin({\n      inject: true, // 所有js脚本放于body之后\n      hash: true, // 为静态资源生成hash，用于清楚缓存\n      cache: true, // 仅在文件被更改时发出文件\n      title: 'react admin',\n      filename: 'index.html',\n      template: path.resolve(__dirname, 'index.html'),\n      minify: {\n        collapseWhitespace: true, // 折叠空白\n        removeComments: true, // 删除注释\n        removeRedundantAttributes: true,\n        removeScriptTypeAttributes: true,\n        removeStyleLinkTypeAttributes: true\n      }\n    }),\n    new CleanWebpackPlugin(),\n  ],\n  optimization: { // 公共代码抽离\n    splitChunks:{ //启动代码分割，有默认配置项\n      chunks: 'all'\n    }\n  }\n}\n</code></pre>\n<ul>\n<li>这样便配置了我们的代码分割功能，然后就开始继续配置我们的生产与开发配置了</li>\n<li>然后修改webpack.dev.js，先在webpack.dev.js中引入webpack-merge与webpack.common.js，然后进行合并，因为css中的loader与生产环境不一致所以没有抽离，现在的webpack还需要给配置指定mode，取值为production或者deveopment，我们这里为开发配置，所以新增一个字段mode: 'development',最终如下</li>\n</ul>\n<pre><code class=\"language-js\">// webpack.dev.js\nconst path = require('path')\nconst webpack = require('webpack')\nconst merge = require('webpack-merge')\nconst common = require('./webpack.common.js')\n\nmodule.exports = merge(common, {\n  mode: 'development',\n  output: {\n    filename: '[name].js',\n    path: path.resolve(__dirname, 'dist'),\n    chunkFilename: '[name].bundle.js'\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.(le|c)ss$/,\n        use: [\n          'style-loader',\n          {\n            loader: 'css-loader',\n            options: {\n              sourceMap: true //是否打开样式查找\n            }\n          },\n          {\n            loader: 'postcss-loader', // 为浏览器加前缀\n            options: {\n              ident: 'postcss',\n              sourceMap: true,\n              plugins: loaders => [\n                require('autoprefixer')({\n                })\n              ]\n            }\n          },\n          {\n            loader: 'less-loader', // 解析样式文件\n            options: {\n              sourceMap: true\n            }\n          }\n        ]\n      }\n    ]\n  },\n  devtool: 'inline-source-map',\n  plugins: [\n    new webpack.HotModuleReplacementPlugin(), // 模块热替换\n    new webpack.NamedModulesPlugin() // 热更新时返回文件名而不是文件id\n  ],\n  devServer: {\n    contentBase: './dist', // 静态文件目录，用于浏览器显示\n    clientLogLevel: 'warning',  // 输出日志级别\n    hot: true, // 启动热更新\n    publicPath: '/', // 浏览器访问路径\n    compress: true, // 启用gzip压缩\n    port: 8822,\n    open: true, // 自动调起浏览器\n    overlay: { // 出现错误或警告是否覆盖页面线上错误信息\n      warnings: true,\n      errors: true\n    },\n    quiet: true,\n    proxy: { // 代理\n    },\n    watchOptions: { // 监控文件相关配置\n      poll: true,\n      ignored: /node_modules/,\n      aggregateTimeout: 300  // 默认值, 当你连续改动时候, webpack可以设置构建延迟时间(防抖)\n    }\n  }\n})\n</code></pre>\n<ul>\n<li>再运行npm run dev能够发现跟抽离之前的配置是一样的，接下来我们对生产配置也进行一个合并，然后新增一个mode: production</li>\n<li>同样是引入webpack-merge与webpack.common.js，然后进行合并，如下</li>\n</ul>\n<pre><code class=\"language-js\">// webpack.prod.js\nconst path = require('path')\nconst TerserWebpackPlugin = require('terser-webpack-plugin')\nconst MiniCssExtractPlugin = require('mini-css-extract-plugin')\nconst OptimizeCssAssetsWebpackPlugin = require('optimize-css-assets-webpack-plugin')\nconst merge = require('webpack-merge')\nconst common = require('./webpack.common.js')\n\nmodule.exports = merge(common, {\n  mode: 'production',\n  devtool: 'source-map',\n  output: {\n    filename: '[name].[chunkhash].js',\n    path: path.resolve(__dirname, 'dist'),\n    chunkFilename: '[name].bundle.js'\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.(le|c)ss$/,\n        use: [\n          MiniCssExtractPlugin.loader,\n          {\n            loader: 'css-loader',\n            options: {\n              sourceMap: true //是否打开样式查找\n            }\n          },\n          {\n            loader: 'postcss-loader', // 为浏览器加前缀\n            options: {\n              ident: 'postcss',\n              sourceMap: true,\n              plugins: loaders => [\n                require('autoprefixer')({\n                })\n              ]\n            }\n          },\n          {\n            loader: 'less-loader', // 解析样式文件\n            options: {\n              sourceMap: true\n            }\n          }\n        ]\n      }\n    ]\n  },\n  plugins: [\n    new MiniCssExtractPlugin({// 将css打包成单独的css文件\n      filename: '[name].[hash:5].css',\n      chunkFilename: '[id].[hash:5].css'\n    }),\n  ],\n  optimization: {\n    minimizer: [\n      // js压缩\n      new TerserWebpackPlugin({\n        cache: true, // 启用文件缓存\n        parallel: true, // 多线程调用\n        sourceMap: true // 错误排查\n      }),\n      new OptimizeCssAssetsWebpackPlugin({}) // css压缩\n    ]\n  }\n})\n</code></pre>\n<ul>\n<li>上面就完成了生产与开发环境的配置，但是之前的配置还有部分遗漏，一个是在开发环境没有配置css的抽离规则，一个是没有配置react开发中的图片资源加载跟字体库与icon</li>\n<li>下面我们就先针对开发环境的css进行一个处理，之前我们在运行webpack的时候是没办法区分开发与生产环境的，所以我们现在在webpack的命令中设置环境变量，用以区分开发还是生产环境，我们先引用cross-env的包，用于各平台设置环境变量的兼容，命令为 npm i cross-env -D</li>\n<li>然后修改package.json中的启动命令为 \"dev\": \"cross-env NODE<em>ENV=development webpack-dev-server --open --config webpack.dev.js\",  \"build\": \"cross-env NODE</em>ENV=production webpack --config webpack.prod.js\" 然后在webpack.common.js中打印process.env.NODE<em>ENV，然后可以观察到在npm run dev的命令下process.env.NODE</em>ENV是'development'， npm run build 的命令下 process.env.NODE_ENV是'production'，由此，我们来配置css的抽离规则，先将之前配置在webpack.prod.js中的css打包配置删除，然后在webpack.common.js中新增如下配置</li>\n</ul>\n<pre><code class=\"language-js\">// webpack.common.js\nconst path = require('path')\nconst HtmlWebpackPlugin = require('html-webpack-plugin')\nconst { CleanWebpackPlugin } = require('clean-webpack-plugin')\nconst MiniCssExtractPlugin = require('mini-css-extract-plugin')\nconst devMode = process.env.NODE_ENV === 'development' // 命令行设置的值\nconsole.log(devMode)\nmodule.exports = {\n  entry: {\n    ...\n  },\n  module: {\n    ...\n  },\n  plugins: [\n    new MiniCssExtractPlugin({// 将css打包成单独的css文件，在开发与生成生成不同的css\n      filename: devMode ? '[name].css' : '[name].[hash:5].css',\n      chunkFilename: devMode ? '[id].css' : '[id].[hash:5].css'\n    }),\n    ...\n  ]\n}\n</code></pre>\n<ul>\n<li>接下来我们要对图片进行处理，在开发中我们会经常根据当前文件的相对路径来引入图片资源，但是我们的打包又是基于入口文件的，所以经常会导致最后的图片引用路径错误，这里我们就要使用url-loader来帮我们进行图片路径处理，会将我们的引用路径替换为打包后的文件路径。</li>\n<li>url-loader还对我们提供了图片转dataUrl的功能，这样就可以将图片转为dataUrl的路径直接引入，避免了网络请求，但是图片过大的时候会影响我们的编码速率，这种时候还是应该使用网络图片请求。url-loader中的limit就是控制多大的图片以内转为dataUrl，大于该限制的就引用图片地址访问。</li>\n<li>同样，我们还是先下载url-loader的相关包， npm i url-loader file-loader -D</li>\n<li>下面我们就对各格式的图片进行配置，这部分配置生产与开发都要使用，因此在webpack.common.js下配置，配置如下</li>\n</ul>\n<pre><code class=\"language-js\">// webpack.common.js\n...\nmodule.exports = {\n  entry: {\n    ...\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.(jpg|png|gif|svg)$/,\n        use: [\n          {\n            loader: 'url-loader',\n            options: {\n              limit: 10000,\n              name: '[name]-[hash:5].[ext]',\n              outputPath: 'img/'\n            }\n          }\n        ]\n      }\n      ...\n    ]\n  },\n  plugins: [\n    ...\n  ]\n}\n</code></pre>\n<ul>\n<li>这样当图片在10k以内的时候我们就会将其转为dataUrl的路径引入，并且将图片统一放到img文件夹下</li>\n<li>webpack还为我们提供了图片的压缩功能，方便缩小我们的项目体积，需要使用 image-webpack-loader 来进行配置，还是先下载该包 npm i image-webpack-loader -D</li>\n<li>然后在开发与生产都需要进行相关的配置，所以还是在 webpack.common.js 进行配置，配置如下</li>\n</ul>\n<pre><code class=\"language-js\">// webpack.common.js\n...\nmodule.exports = {\n  entry: {\n    ...\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.(jpg|png|gif|svg)$/,\n        use: [\n          {\n            loader: 'url-loader',\n            options: {\n              limit: 10000,\n              name: '[name]-[hash:5].[ext]',\n              outputPath: 'img/'\n            }\n          },\n          {\n            loader: 'image-webpack-loader',\n            options: {\n              mozjpeg: {\n                progressive: true,\n                quality: 65\n              },\n              optipng: {\n                enabled: false\n              },\n              pngquant: {\n                quality: [0.65, 0.9],\n                speed: 4\n              },\n              gifsicle: {\n                interlaced: false\n              },\n              webp: {\n                quality: 75\n              }\n            }\n          }\n        ]\n      }\n    ]\n  },\n  plugins: [\n    ...\n  ]\n}\n</code></pre>\n<ul>\n<li>上面就完成了开发中图片的相关配置，接下来配置一下字体库，还是使用url-loader，配置规则跟图片的一致，如下</li>\n</ul>\n<pre><code class=\"language-js\">...\nmodule.exports = {\n  entry: {\n    ...\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.(woff2?|eot|ttf|otf)(\\?.*)?$/,\n        use: [\n          {\n            loader: 'url-loader',\n            options: {\n              // 文件大小小于limit参数，url-loader将会把文件转为DataUR\n              limit: 10000,\n              name: '[name]-[hash:5].[ext]',\n              ourput: 'fonts/'\n            }\n          }\n        ],\n      },\n    ]\n  },\n  plugins: [\n    ...\n  ]\n}\n</code></pre>\n<ul>\n<li>如上就完成了咱们项目的前期配置，单纯使用react已经没有什么问题了，这一章的配置就到这吧，下面把各个配置文件都贴一下，当然也可以选择源码查看，地址是 <a href=\"https://github.com/mf950511/react-admin\">react-admin</a></li>\n<li>下一章我们进行typeScript的配置，之后就开始正式进行项目开发</li>\n</ul>\n<pre><code class=\"language-js\">// webpack.common.js\nconst path = require('path')\nconst HtmlWebpackPlugin = require('html-webpack-plugin')\nconst { CleanWebpackPlugin } = require('clean-webpack-plugin')\nconst MiniCssExtractPlugin = require('mini-css-extract-plugin')\nconst devMode = process.env.NODE_ENV === 'development'\nconsole.log(devMode)\nmodule.exports = {\n  entry: {\n    app: './index.js',\n    test: './index.jsx'\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.(jpg|png|gif|svg)$/,\n        use: [\n          {\n            loader: 'url-loader',\n            options: {\n              limit: 10000,\n              name: '[name]-[hash:5].[ext]',\n              outputPath: 'img/'\n            }\n          },\n          {\n            loader: 'image-webpack-loader',\n            options: {\n              mozjpeg: {\n                progressive: true,\n                quality: 65\n              },\n              optipng: {\n                enabled: false\n              },\n              pngquant: {\n                quality: [0.65, 0.9],\n                speed: 4\n              },\n              gifsicle: {\n                interlaced: false\n              },\n              webp: {\n                quality: 75\n              }\n            }\n          }\n        ]\n      },\n      {\n        test: /\\.(woff2?|eot|ttf|otf)(\\?.*)?$/,\n        use: [\n          {\n            loader: 'url-loader',\n            options: {\n              // 文件大小小于limit参数，url-loader将会把文件转为DataUR\n              limit: 10000,\n              name: '[name]-[hash:5].[ext]',\n              ourput: 'fonts/'\n            }\n          }\n        ],\n      },\n      {\n        test: /\\.(js)x?$/,\n        use: ['babel-loader'],\n        exclude: /node-modules/\n      }\n    ]\n  },\n  plugins: [\n    new MiniCssExtractPlugin({// 将css打包成单独的css文件\n      filename: devMode ? '[name].css' : '[name].[hash:5].css',\n      chunkFilename: devMode ? '[id].css' : '[id].[hash:5].css'\n    }),\n    new HtmlWebpackPlugin({\n      inject: true, // 所有js脚本放于body之后\n      hash: true, // 为静态资源生成hash，用于清楚缓存\n      cache: true, // 仅在文件被更改时发出文件\n      title: 'react admin',\n      filename: 'index.html',\n      template: path.resolve(__dirname, 'index.html'),\n      minify: {\n        collapseWhitespace: true, // 折叠空白\n        removeComments: true, // 删除注释\n        removeRedundantAttributes: true,\n        removeScriptTypeAttributes: true,\n        removeStyleLinkTypeAttributes: true\n      }\n    }),\n    new CleanWebpackPlugin(),\n  ],\n  optimization: { // 公共代码抽离\n    splitChunks:{ //启动代码分割，有默认配置项\n      chunks: 'all'\n    }\n  }\n}\n\n// webpack.dev.js\nconst path = require('path')\nconst webpack = require('webpack')\nconst merge = require('webpack-merge')\nconst common = require('./webpack.common.js')\n\nmodule.exports = merge(common, {\n  output: {\n    filename: '[name].js',\n    path: path.resolve(__dirname, 'dist'),\n    chunkFilename: '[name].bundle.js'\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.(le|c)ss$/,\n        use: [\n          'style-loader',\n          {\n            loader: 'css-loader',\n            options: {\n              sourceMap: true //是否打开样式查找\n            }\n          },\n          {\n            loader: 'postcss-loader', // 为浏览器加前缀\n            options: {\n              ident: 'postcss',\n              sourceMap: true,\n              plugins: loaders => [\n                require('autoprefixer')({\n                })\n              ]\n            }\n          },\n          {\n            loader: 'less-loader', // 解析样式文件\n            options: {\n              sourceMap: true\n            }\n          }\n        ]\n      }\n    ]\n  },\n  devtool: 'inline-source-map',\n  plugins: [\n    new webpack.HotModuleReplacementPlugin(),\n    new webpack.NamedModulesPlugin()\n  ],\n  devServer: {\n    contentBase: './dist', // 静态文件目录，用于浏览器显示\n    // clientLogLevel: 'warning',  // 输出日志级别\n    hot: true, // 启动热更新\n    publicPath: '/', // 浏览器访问路径\n    compress: true, // 启用gzip压缩\n    port: 8822,\n    open: true, // 自动调起浏览器\n    overlay: { // 出现错误或警告是否覆盖页面线上错误信息\n      warnings: true,\n      errors: true\n    },\n    quiet: true,\n    proxy: { // 代理\n    },\n    watchOptions: { // 监控文件相关配置\n      poll: true,\n      ignored: /node_modules/,\n      aggregateTimeout: 300  // 默认值, 当你连续改动时候, webpack可以设置构建延迟时间(防抖)\n    }\n  }\n})\n\n// webpack.prod.js\nconst path = require('path')\nconst TerserWebpackPlugin = require('terser-webpack-plugin')\nconst OptimizeCssAssetsWebpackPlugin = require('optimize-css-assets-webpack-plugin')\nconst merge = require('webpack-merge')\nconst common = require('./webpack.common.js')\nconst BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin;\nconst MiniCssExtractPlugin = require('mini-css-extract-plugin')\n\nmodule.exports = merge(common, {\n  devtool: 'source-map',\n  output: {\n    filename: '[name].[chunkhash].js',\n    path: path.resolve(__dirname, 'dist'),\n    chunkFilename: '[name].bundle.js'\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.(le|c)ss$/,\n        use: [\n          MiniCssExtractPlugin.loader,\n          {\n            loader: 'css-loader',\n            options: {\n              sourceMap: true //是否打开样式查找\n            }\n          },\n          {\n            loader: 'postcss-loader', // 为浏览器加前缀\n            options: {\n              ident: 'postcss',\n              sourceMap: true,\n              plugins: loaders => [\n                require('autoprefixer')({\n                })\n              ]\n            }\n          },\n          {\n            loader: 'less-loader', // 解析样式文件\n            options: {\n              sourceMap: true\n            }\n          }\n        ]\n      }\n    ]\n  },\n  plugins: [\n    new BundleAnalyzerPlugin({\n      analyzerMode: 'server',\n      analyzerHost: '127.0.0.1',\n      analyzerPort: 7778,\n      reportFilename: 'report.html',\n      defaultSizes: 'parsed',\n      openAnalyzer: true,\n      generateStatsFile: false,\n      statsFilename: 'stats.json',\n      statsOptions: null,\n      logLevel: 'info'\n    }),\n  ],\n  optimization: {\n    minimizer: [\n      // js压缩\n      new TerserWebpackPlugin({\n        cache: true, // 启用文件缓存\n        parallel: true, // 多线程调用\n        sourceMap: true // 错误排查\n      }),\n      new OptimizeCssAssetsWebpackPlugin({}) // css压缩\n    ]\n  }\n})\n</code></pre>","fields":{"slug":"/react_md_2/"},"frontmatter":{"title":"从零搭建一个react-hooks项目（二）","tags":["react","react hooks","redux","webpack"],"categories":"Webpack"}}},{"node":{"html":"<h1>从零搭建一个react-hooks项目（三）</h1>\n<ul>\n<li>上一篇我们配置了项目相关，包括代码压缩混淆，开发生产配置抽离，图片与文字的引入使用等</li>\n<li>接下来我们就配置一下react-router，react-redux与typescript</li>\n<li>配置之前我们先补充一下webpack的部分配置，用于方便我们的开发</li>\n<li>在webpack.common.js中配置webpack的查找规则，也就是resolve，如下</li>\n</ul>\n<!--more-->\n<pre><code class=\"language-js\">...\nmodule.exports = {\n  entry: {\n    ...\n  },\n  module: {\n    ...\n  },\n  resolve: {\n    extensions: ['.jsx', '.js', '.json'],\n    alias: {\n      \"@\": path.resolve(__dirname, 'src')\n    }\n  },\n  plugins: [\n    ...\n  ],\n  optimization: { // 公共代码抽离\n    ...\n  }\n}\n</code></pre>\n<ul>\n<li>上面新增了一个resolve的解析规则，使webpack方便查找，第一个extensions中的配置表示我们在引入后缀为.jsx,.js,.json的文件时，可以直接写文件名而不用加后缀，比如引入'./index.jsx'，我们就可以直接写为'./index'</li>\n<li>下面的alias就是别名配置，用于在引入路径时方便使用，比如我们在项目中有如下的代码结构</li>\n</ul>\n<pre><code class=\"language-js\">src \n├── lib \n│ └── utils.js \n└── pages \n└── demo \n└── index.js\n</code></pre>\n<ul>\n<li>在 src/pages/demo/index.js 中如果要引用 src/lib/utils.js 那么可以通过：import utils from '../../lib/utils' ，如果目录更深一些，会越来越难看，这时可以通过设置 alias 来缩短这种写法，例如：</li>\n</ul>\n<pre><code class=\"language-js\">module.exports = {\n  resolve: {\n      '@': path.resolve(__dirname, 'src'),\n      '@lib': path.resolve(__dirname, 'src/lib')\n  }\n}\n</code></pre>\n<ul>\n<li>这样我们就可以直接使用 '@lib/utils'来进行文件的引入了</li>\n</ul>\n<h2>react-router的使用</h2>\n<ul>\n<li>配置完resolve之后我们就开始进行react-router的配置了，还是先下载react-router-dom模块，命令为： npm i react-router-dom -S</li>\n<li>然后在src下新建两个页面，pages/login.jsx与pages/home.jsx作为我们的路由页面</li>\n</ul>\n<pre><code class=\"language-js\">// pages/home.jsx\nimport React from 'react'\nconst Home = () => {\n  return (\n    &#x3C;div>我是首页&#x3C;/div>\n  )\n}\nexport default Home\n\n// pages/login.jsx\nimport React from 'react'\nconst Login = () => {\n  return (\n    &#x3C;div>我是登录页&#x3C;/div>\n  )\n}\nexport default Login\n</code></pre>\n<ul>\n<li>接着在src下新建routes/index.jsx文件作为我们的路由管理页面</li>\n<li>在文件内引入react与react-router-dom,然后引入新建的login页面与home页面</li>\n<li>页面代码如下</li>\n</ul>\n<pre><code class=\"language-js\">// routes/index.jsx\nimport React from 'react'\nimport { HashRouter as Router, Route, Switch, Redirect } from 'react-router-dom'\nimport Login from '@/pages/login'\nimport Home from '@/pages/home'\nconst RouteConfig = () => {\n  return (\n    &#x3C;Router>\n      &#x3C;Switch>\n        &#x3C;Route path=\"/home\" component={ Home }>&#x3C;/Route>\n        &#x3C;Route path=\"/login\" component={ Login }>&#x3C;/Route>\n        &#x3C;Redirect to=\"/home\" from=\"/\">&#x3C;/Redirect>\n      &#x3C;/Switch>\n    &#x3C;/Router>\n  )\n}\nexport default RouteConfig\n</code></pre>\n<ul>\n<li>然后在app.jsx里面以组件的形式引入我们的路由即可，如下</li>\n</ul>\n<pre><code class=\"language-js\">// app.jsx\nimport * as React from 'react'\nimport './app.less'\nimport RouteConfig from '@/route/index'\nclass App extends React.Component{\n  render(){\n    return (\n      &#x3C;RouteConfig>&#x3C;/RouteConfig>\n    )\n  }\n}\nexport default App\n</code></pre>\n<ul>\n<li>然后运行npm run dev就能发现自动帮我们定位到/home页面，我们手动修改路由为/login就可以发现页面跳转到了login页面</li>\n<li>至此，我们的react-router就配置完成了</li>\n</ul>\n<h2>react-redux的使用</h2>\n<ul>\n<li>redux是常用的状态管理组件，用于维护全局的数据变量，react项目中自然也需要它的存在，下面我们就配置一下redux</li>\n<li>在react中使用redux需要引入redux与react-redux，还是先安装包： npm i redux react-redux -S</li>\n<li>然后在src下新建文件夹store用于放置我们的redux相关文件</li>\n<li>redux在数据比较复杂的时候会按照模块来放置文件，最后再用redux提供的api组合起来，方便后续的维护，这里我们创立数字模块number与聊天模块chat，分别在store下面建立两个文件夹store/chat与store/number</li>\n<li>在每个文件夹下面建立我们会用到的操作该数据的操作类型与该操作类型下的数据变化情况，分别对应types.js与reducers.js</li>\n<li>先构建store/number下的types与reducers，对外提供加减两个方法，先在types下构建常量用于标识对应的方法</li>\n</ul>\n<pre><code class=\"language-js\">// store/number/types\nexport const INCREMENT = 'INCREMENT'\nexport const DECREMENT = 'DECREMENT'\n</code></pre>\n<ul>\n<li>然后再编写该方法下的数据变化情况reducers，并为这个数字模块设立初始值0，当执行方法为加减的时候就在原基础上加减对应的值，否则就原样返回</li>\n</ul>\n<pre><code class=\"language-js\">// store/number/reducers.js\nimport { INCREMENT, DECREMENT } from './types'\nconst initialState = 0\nconst numberReducer = (state = initialState, action) => {\n  switch(action.type) {\n    case INCREMENT:\n      return state + action.payload\n    case DECREMENT:\n      return state - action.payload\n    default:\n      return state\n  }\n}\nexport default numberReducer\n</code></pre>\n<ul>\n<li>上面就是简单的数字模块的两个方法了，然后我们同样实现一下chat模块的方法</li>\n</ul>\n<pre><code class=\"language-js\">// store/chat/types\nexport const SEND = 'SEND'\nexport const DELETE = 'DELETE'\n\n// store/chat/reducers\nimport { SEND, DELETE } from './types'\n\nconst initialState = []\nconst chatReducer = (state = initialState, action) => {\n  switch(action.type) {\n    case SEND:\n      return [...state, action.payload]\n    case DELETE:\n      return state.length ? state.slice(0, state.length - 1) : []\n    default:\n      return state\n  }\n}\nexport default chatReducer\n</code></pre>\n<ul>\n<li>chat模块提供了一个发送方法与删除方法用于操作聊天列表</li>\n<li>接下来我们就要使用redux提供的combineReducers方法将其合并起来</li>\n<li>在store下新建index.js文件用于最后的导出</li>\n<li>在index.js中引入combineReducers，chat模块，number模块，然后合并并导出，如下</li>\n</ul>\n<pre><code class=\"language-js\">// store/index.js\nimport { combineReducers } from 'redux'\nimport ChatReducer from './chat/reducers'\nimport NumberReducer from './number/reducer'\n\nconst rootReducer = combineReducers({\n  number: NumberReducer,\n  chat: ChatReducer\n})\n\nexport default rootReducer\n</code></pre>\n<ul>\n<li>上面就完成了redux的编写，接下来就要在react根组件上将其使用</li>\n<li>在index.jsx中引入store/index.js，引入redux提供的方法createStore创建全局状态，引入react-redux中的Provider包装根组件，如下</li>\n</ul>\n<pre><code class=\"language-js\">// index.jsx\nimport * as React from 'react'\nimport * as ReactDOM from 'react-dom'\nimport App from './src/app.jsx'\nimport { createStore } from 'redux'\nimport { Provider } from 'react-redux'\nimport RootReducer from '@/store/index'\nconst store = createStore(RootReducer)\nReactDOM.render(\n  &#x3C;Provider store={ store }>\n    &#x3C;App/>\n  &#x3C;/Provider>\n  ,document.querySelector('#app')\n)\n</code></pre>\n<ul>\n<li>上面就在我们的项目中引入了redux，接下来就是使用，我们在login组件中尝试使用number并修改</li>\n<li>在login组件中引入对应的操作方法与react-redux提供的connect方法，然后修改我们的login组件如下</li>\n</ul>\n<pre><code class=\"language-js\">// src/pages/login.jsx\nimport React from 'react'\nimport { connect } from 'react-redux'\nimport { INCREMENT, DECREMENT } from '@/store/number/types'\nconst Login = (props) => {\n  const { number, increment, decrement } = props\n  return (\n    &#x3C;div>\n      &#x3C;button>我是数字{ number }&#x3C;/button>\n      &#x3C;button onClick={() => { increment() } }>点我加10&#x3C;/button>\n      &#x3C;button onClick={() => { decrement() } }>点我减10&#x3C;/button>\n    &#x3C;/div>\n  )\n}\nfunction mapStateToProps(state){ // 将redux中的state整合到props中\n  return {\n    number: state.number \n  }\n}\n\nfunction mapDispatchToProps(dispatch){ // 将操作state的函数整合到props中\n  return {\n    increment: () => dispatch({ type: INCREMENT, payload: 10 }),\n    decrement: () => dispatch({ type: DECREMENT, payload: 10 })\n  }\n}\nexport default connect(mapStateToProps, mapDispatchToProps)(Login)\n</code></pre>\n<ul>\n<li>connect中的第一个参数接受两个函数，分别用于整合state到props中跟整合操作方法到props中，这样我们就可以在页面中使用该方法与该值了</li>\n<li>修改之后我们点击两个按钮就可以看到对应值的变化了</li>\n</ul>\n<h2>react中引入typescript</h2>\n<ul>\n<li>typescript当下如此潮流我们自然也要接入一下啦，下面就是简单的接入过程</li>\n<li>得益于我们强大的babel-7，我们不再需要去单独的使用ts-loader或者awesome-typescript-loader解析ts文件，只需要在babel中进行typescript的相关配置即可</li>\n<li>首先还是先安装我们的typescript与@babel/preset-typescript，命令为： npm i typescript @babel/preset-typescript -D</li>\n<li>然后再.babelrc文件中进行typescript的配置，如下</li>\n</ul>\n<pre><code class=\"language-js\">// .babelrc\n{\n  \"presets\": [\n    \"@babel/preset-env\",\n    \"@babel/preset-react\",\n    \"@babel/preset-rtpescript\", // 处理typescript\n  ],\n  \"plugins\": [\n    \"@babel/proposal-object-rest-spread\", // 处理对象的rest写法\n    \"@babel/proposal-class-properties\" // 处理类里面的箭头函数绑定，static属性等 \n  ]\n}\n</code></pre>\n<ul>\n<li>然后在webpack中对typescript文件配置babel解析即可，这是一个通用配置，所以还是在webpack.common.js上修改，如下</li>\n</ul>\n<pre><code class=\"language-js\">// webpack.common.js\nmodule.exports = {\n  entry: {\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.(js|ts)x?$/, // tsx或者ts文件也使用babel解析\n        use: ['babel-loader'],\n        exclude: /node-modules/\n      }\n    ]\n  },\n  resolve: {\n    extensions: ['.tsx', '.ts', '.jsx', '.js', '.json'], // 添加.tsx与.ts后缀解析\n    alias: {\n      \"@\": path.resolve(__dirname, 'src')\n    }\n  },\n  plugins: [\n    ...\n  ],\n  optimization: { // 公共代码抽离\n    ...\n  }\n}\n</code></pre>\n<ul>\n<li>然后就要配置typescript中的编译规则，在根目录下新建tsconfig.json文件，然后添加如下配置</li>\n</ul>\n<pre><code class=\"language-js\">{\n  \"compilerOptions\": {\n    \"allowSyntheticDefaultImports\": true, // 允许从没有设置默认导出的模块中默认导入。这并不影响代码的输出，仅为了类型检查。\n    \"outDir\": \"./dist/\", // 重定向输出目录\n    \"noImplicitAny\": true,// 在表达式和声明上有隐含的 any类型时报错。（默认为false，个人建议也为false，可以兼容之前的js代码，这里改为true是为了我自己检测哪些类型需要处理）\n    \"module\": \"es6\", // 模块引入方式\n    \"target\": \"esnext\",// 指定ECMAScript目标版本\n    \"jsx\": \"react\", // 在 .tsx文件里支持JSX\n    \"allowJs\": true,\n    \"sourceMap\": true, // 生成相应的 .map文件\n    \"lib\": [\n      \"es2015\",\n      \"dom.iterable\",\n      \"es2016.array.include\",\n      \"es2017.object\",\n      \"dom\"\n    ], // 编译过程中需要引入的库文件的列表。\n    \"moduleResolution\": \"node\",// 用于解析一些加载器，如css-type, source-map \n    \"baseUrl\": \"./src\", // typescript的模块解析基础路径\n    \"paths\": { // 对应的模块解析路径\n      \"store/*\": [\"store/*\"],\n    },\n  },\n  \"include\": [\n    \"src\"\n  ],\n  \"exclude\": [\n    \"./node_modules\"\n  ]\n}\n</code></pre>\n<ul>\n<li>因为我们之前配置了别名，所以需要加上后面的配置中的baseUrl与paths保证typescript能够找到对应的配置，其他的都是typescript的基本配置</li>\n<li>接下来我们尝试将入口文件修改为tsx尝试一下，在webpack.common.js中将入口文件改为app:'index.tsx'，然后再将index.jsx后缀改为tsx，之后运行npm run dev发现报错 can not find module 'react'，就说明我们的typescript已经配置完成了，可以正常检查错误</li>\n<li>上述错误是因为我们在TS中进行的开发，TS并不知道我们的react是什么类型，导出了什么，所以就报错了，这里我们就需要安装react相关的类型文件</li>\n<li>项目中我们使用了react,react-dom,react-redux,react-router-dom这四个依赖，所以我们就需要安装依赖包，命令为：npm i @types/react @types/react-dom @types/react-redux @types/react-router-dom -S</li>\n<li>之后我们再次编译，就发现项目可以正常运行了。</li>\n<li>但是使用上面的配置之后发现，在我们编译过程中类型出错webpack并不会提示我们出错，这是因为babel7中在编译过程会移除typescript，完全以javascript的形式进行打包，详见<a href=\"https://iamturns.com/typescript-babel\">(https://iamturns.com/typescript-babel)</a>。因为，要把babel跟typescript同时编译，两个编译器会导致过程十分缓慢，这可是开发者不能容忍的。针对这种情况，我们可以新建一个命令 \"check\": \"tsc -watch\"，然后使用vscode带给我们的终端启用两个终端，一个运行命令 npm run check，另一个运行命令npm run dev，这样就发现我们在开发中出现的类型错误都会在check的终端对我们进行提示。</li>\n<li>接下来我们只需要将所有的jsx文件转为tsx文件就可以进行typescript的开发了，项目地址<a href=\"https://github.com/mf950511/react-admin\">react-admin</a>，可以自行获取配置进行修改</li>\n</ul>","fields":{"slug":"/react_md_3/"},"frontmatter":{"title":"从零搭建一个react-hooks项目（三）","tags":["react","react hooks","redux","webpack"],"categories":"Webpack"}}},{"node":{"html":"<h1>从零搭建一个react-hooks项目（四）</h1>\n<ul>\n<li>前面我们搭建了基于react与typescript的开发环境，接下来就是我们项目开发中遇到的一些问题处理了</li>\n</ul>\n<h2>图片引入申明报错问题处理</h2>\n<ul>\n<li>之前我们配置了图片引入并且在页面中进行了图片引入，当我们把页面变为ts之后会发现图片引入的地方被标红了，报错为 Cannot find module './image/img.png' or its corresponding type declarations，这里是因为图片类型我们没有为其设定类型文件，所以报错，这种情况下，我们可以在src目录下新建image.d.ts文件来为其进行声名，声明文件如下</li>\n</ul>\n<pre><code class=\"language-js\">// image.d.ts\ndeclare module '*.svg'\ndeclare module '*.png'\ndeclare module '*.jpg'\ndeclare module '*.jpeg'\ndeclare module '*.gif'\ndeclare module '*.bmp'\ndeclare module '*.tiff'\n</code></pre>\n<!--more-->\n<ul>\n<li>这样就能发现我们的ts类型错误消失了</li>\n</ul>\n<h2>非组件页面进行页面跳转</h2>\n<ul>\n<li>传统中使用react-router-dom进行页面跳转需要在页面中获取props，然后props中获取history，然后采用history.push('/home')的形式进行页面跳转</li>\n<li>要是想在别的非组件页面，如request文件或者入口index.tsx中进行页面跳转就需要依赖三方库如history进行页面路由跳转，如下</li>\n</ul>\n<pre><code class=\"language-js\">// index.tsx 这样就实现了在非组件页面中的跳转，页面打开后两秒自动跳转登录\n// 需安装依赖history：npm i history -S\nimport { createHashHistory  } from 'history'\nconst history = createHashHistory() \nsetTimeout(() =>{\n  history.push('/login')\n}, 2000)\n</code></pre>\n<ul>\n<li>我们简单的将该方法封装一下，方便后续的使用，在src文件夹下创建lib/untils.ts文件用于我们的工具函数封装，如下</li>\n</ul>\n<pre><code class=\"language-js\">// src/lib/untils.js\nimport { createHashHistory  } from 'history'\nconst history = createHashHistory() \nexport {\n  history\n}\n\n// index.tsx\nimport { history } from './src/lib/untils'\nsetTimeout(() =>{\n  history.push('/home')\n}, 2000)\n</code></pre>\n<ul>\n<li>这样就可以实现在其他工具页面进行页面跳转了</li>\n</ul>\n<h2>ant4使用icon与动态渲染问题</h2>\n<ul>\n<li>ant4中icon的引用方式发生了变化，需要我们单独引入 @ant-design/icons 包，然后获取Icon名以组件的形式进行引入，这样就存在了一个问题，如何动态的引入icon，比如在后台配置icon名称，在前端进行对应的展示，如首页菜单栏，权限不一，展现不一致</li>\n<li>这种情况我们就只能全量引入icon，如下</li>\n</ul>\n<pre><code class=\"language-js\">import * as Icons from '@ant-design/icons';\n</code></pre>\n<ul>\n<li>然后再指定返回reactNode的方法</li>\n</ul>\n<pre><code class=\"language-js\">interface Icons { // 处理icon的类型\n  [PropName: string]: any\n}\nconst getIcons = (str: string, Icons: Icons) => {\n  const TestBankOutlined = Icons[str]\n  return &#x3C;TestBankOutlined />\n}\n</code></pre>\n<ul>\n<li>之后就是我们的菜单渲染函数</li>\n</ul>\n<pre><code class=\"language-js\">interface SideBar{ // 菜单栏\n  name: string;\n  children?: Array&#x3C;SideBar>,\n  [propName: string]: any;\n}\nconst sideBarTree = (menuArr: SideBar[]) => {\n  if(menuArr &#x26;&#x26; menuArr.length) {\n    return menuArr.map((item, index) => {\n      return (\n        item.children \n        ? \n        &#x3C;SubMenu className=\"home-menu\" popupClassName=\"home-sider\" key={ item.path } icon={ item.icon ? getIcons(item.icon, Icons) : '' } title={ item.name }>\n          { sideBarTree(item.children) }\n        &#x3C;/SubMenu> : &#x3C;Menu.Item className=\"home-menu-item\" icon={ item.icon ? getIcons(item.icon, Icons) : '' } key={ item.path }>{ item.name }&#x3C;/Menu.Item>\n      )\n    })\n  } else {\n    return null\n  }\n}\n</code></pre>\n<ul>\n<li>这样就完成了我们菜单与icon的可配置化</li>\n</ul>","fields":{"slug":"/react_md_4/"},"frontmatter":{"title":"从零搭建一个react-hooks项目（四）","tags":["react","react hooks","redux","webpack"],"categories":"Webpack"}}},{"node":{"html":"<h1>react hooks下封装通用redux</h1>\n<p>redux我们常用来做全局状态管理，一般我们都会按功能模块来新建相关的action，reducer然后再使用combineReducers来将其组合导出，这样的话就实现了模块的划分，让我们更方便项目的管理。但是在某些情况下，我们想要一个通用的redux管理，比如一些特别小，但是又必须要用到的场景，比如我们现在新建了一个chat模块用来管理聊天相关的redux，新建了一个menu模块来管理我们的菜单模块，新建了一个number模块用来管理我们的数据状态，但是这时候我想要对顶部导航栏的显示与隐藏添加一个reducer用来与其他组件交互，这种情况下还要单独再开一个nav模块吗？肯定是不愿意的，所以针对我们这些比较小的功能模块，我们想封装一个通用的reducer，这个通用的reducer共享一个normal数据，dispatch时接受一组数据key,value用于进行数据的改变，下面就是我们的封装过程</p>\n<!--more-->\n<ul>\n<li>首先我们需要创建一个normalReducer，如下</li>\n</ul>\n<pre><code class=\"language-js\">// store/normal/reducer.js\n\nexport const normalReducer = (state = {}, action) => {\n  if(action.type === 'normal') { // 用于标识走通用的reducer\n    const { payload: { key, value } } = action\n    return {\n      ...state,\n      [key]: value\n    }\n  } else {\n    return state\n  }\n}\n\n// store/index.js\n\nimport { normalReducer } from './normal/reducer.js'\n\nconst rootReducer = combineReducer({\n  normal: normalReducer,\n  ...\n})\n</code></pre>\n<ul>\n<li>这样我们就简单实现了一个通用的normal模块，在页面中我们可以这样使用</li>\n</ul>\n<pre><code class=\"language-js\">import * as React from 'react'\nimport { useSelector, useDispatch } from 'react-redux'\n\nconst Home = () => {\n  const normalState = useSelector((state) => state.normal) // 获取到了相应的normal状态值\n  const dispatch = useDispatch() // 获取dispatch函数\n\n  const changeOk = () => {\n    dispatch({\n      type: 'normal',\n      payload: {\n        key: 'isOk',\n        value: !normalState.isOk\n      }\n    })\n  }\n\n  return (\n    &#x3C;div className=\"home\">\n      &#x3C;div>{ normalState.isOk }&#x3C;/div>\n      &#x3C;button onClick={ changeOk }>点我切换状态&#x3C;/button>\n    &#x3C;/div>\n  )\n}\n</code></pre>\n<ul>\n<li>这样就更新了我们的数据状态，这样我们每次都需要写dispatch相关部分，还是有点繁琐，所以我们可以参考useState的写法，接收一个键值，返回数据值与数据操作函数，如下</li>\n</ul>\n<pre><code class=\"language-js\">// src/effect/reducer\nimport * as React from 'react'\nimport { useSelector, useDispatch } from 'react-redux'\n\nexport const normalReducerDispatch = (key) => {\n  const dispatch = useDispatch()\n  const normalInfo = useSelector(state => state.normal)\n  const stateValue = normalInfo[key]\n  const setNormalInfo = (value) => {\n    dispatch({\n      type: 'normal',\n      payload: {\n        key,\n        value\n      }\n    })\n  }\n  return [stateValue, setNormalInfo]\n}\n</code></pre>\n<p>// 上面封装之后我们就可以像使用useState一样来使用我们的normal模块了，在需要使用的页面引入使用即可，如下</p>\n<pre><code class=\"language-js\">// src/home.jsx\nimport * as React from 'react'\nimport { normalReducerDispatch } from 'src/effect/reducer'\n\nconst Home = () => {\n  const [isOk, setIsOk] = normalReducerDispatch('isOk')\n\n  return (\n    &#x3C;div className=\"home\">\n      &#x3C;div>{ isOk }&#x3C;/div>\n      &#x3C;button onClick={ setIsOk(!isOk) }>点我切换状态&#x3C;/button>\n    &#x3C;/div>\n  )\n}\n</code></pre>\n<ul>\n<li>这样就实现了我们上面代码同样的功能，其他需要使用redux的小模块也可以同样使用了</li>\n</ul>","fields":{"slug":"/react_hooks/"},"frontmatter":{"title":"react hooks下封装通用redux","tags":["react","react hooks","redux"],"categories":"React"}}},{"node":{"html":"<h1>对象类型与基本方法</h1>\n<ul>\n<li>对象的创建我们可以采用 new 关键字加对象类型的名称来进行创建，比如创建一个基本对象，就是</li>\n</ul>\n<pre><code class=\"language-js\">let o = new Object()\n</code></pre>\n<ul>\n<li>需要注意的是，后面的括号并不是必须的，当我们创建对象不需要传参则不需要后面的括号也不会报错，但是不推荐，如下</li>\n</ul>\n<pre><code class=\"language-js\">let o = new Object // 不推荐\n</code></pre>\n<ul>\n<li>Object类型是所有其他对象类型的基础，其他对象类型都基于它进行的衍生，所以所有的对象都具有下面这些Object的基本方法</li>\n</ul>\n<pre><code class=\"language-js\">isPropertyof(object) // 决定一个对象是否是另一个对象的原型\npropertyIsEnumerable(propertyName) // 决定一个对象属性是否可枚举\n</code></pre>","fields":{"slug":"/object-type/"},"frontmatter":{"title":"遗忘的对象基本属性","tags":["JavaScript回顾"],"categories":"JavaScript"}}},{"node":{"html":"<h1>不常用的一元操作符</h1>\n<h2>位操作符</h2>\n<ul>\n<li>ECMAScript中数值都是已64位格式存储，但是位操作符不能直接在64位中操作，要把值转为32位整数，操作完成后再转为64位整数。</li>\n<li>对开发者来说，是不用关注64位整数的，我们感知不到，我们只需要知道32位整数的工作原理即可</li>\n<li>有符号整数由一位符号位与31位二进制数值位来表示。第一位的符号位0表示正数，1表示负数。其他的数决定这个数的大小，数值跟二进制转十进制的方式相同，从最后一位开始，第一个代表2的0次方，第二个代表2的一次方，没有实际值的按0来填充。比如18按32位来表示为</li>\n</ul>\n<pre><code class=\"language-js\">00000000000000000000000000010010 // 32位表示18\n//转换方式\n(Math.pow(2, 0)) * 0 + (Math.pow(2, 1)) * 1 + (Math.pow(2, 2)) * 0 + (Math.pow(2, 3)) * 0 + (Math.pow(2, 4)) * 1\n</code></pre>\n<ul>\n<li>负数也是用二进制来表示，但是跟正数不一样，负数的表示是对应32位正数的补码。有三个步骤</li>\n<li>第一步，写出该负数的绝对值对应的32位数</li>\n<li>第二步，将32位数中的0变为1，1变为0</li>\n<li>\n<p>第三步，在第二步得到的数上加1，然后逢二进一，比如-18的表示</p>\n<!--more-->\n<pre><code class=\"language-js\">// 1.写出绝对值，也就是18的32位数\n00000000000000000000000000010010\n// 2.将0变为1，1变为0\n11111111111111111111111111101101\n// 3.在第二步的基础上加1\n11111111111111111111111111101110 // -18的32位表现形式\n</code></pre>\n</li>\n</ul>\n<pre><code>- ECMAScript会尽量的将这些数据都给你保留，当你使用toString并指定二进制数值时，会返回'-10010'来给你\n\n```js\nlet num = -18\nconsole.log(num.toString(2)) // '-10010'\n</code></pre>\n<ul>\n<li>上面是有符号正数，当我们用来表示无符号整数是，第一位就不再是符号位，也是真正的数值位，所以无符号整数可以比有符号整数大一点</li>\n<li>在ECMAScript中使用位运算时，会先将64位整数转为32位正数，然后进行位运算，然后转为64位整数，这也就给我们一个错觉，我们在操作真正的32位正数。这也使得对二进制的操作与其他语言相似。</li>\n<li>在这个处理中有两个特殊值NaN跟Infinity会跟0的处理方式一样</li>\n<li>如果为非数值类型使用位操作符则会使用Number()强制转为数值，然后计算</li>\n</ul>\n<h2>Not操作符(~)</h2>\n<ul>\n<li>简单的返回一个数对应32位数的补码（即0变为1，1变为0）</li>\n</ul>\n<pre><code class=\"language-js\">let num = 25 \n// 对应的32位数\n000000000000000000000000000011001\n// 使用位操作符\n111111111111111111111111111100110\n// 然后将32位数转为对应的负数，将之前的三步倒过来\n// 1.减1\n111111111111111111111111111100101\n// 2. 取补码\n000000000000000000000000000011010\n// 3.计算值并加负号\n-26\n</code></pre>\n<ul>\n<li>所以我们在对25进行了~操作后就得到了-26</li>\n<li>其实，~操作的结果就是我们对要操作的数进行取反，然后减1即可</li>\n<li>位操作符因为操作数值的最低级别，所以速度极快</li>\n</ul>\n<h2>AND操作符(&#x26;)</h2>\n<ul>\n<li>该符号工作于两个值，将两个值对应的位进行操作，只有当两个值对应位都是1才返回1，否则返回0，如下</li>\n</ul>\n<pre><code class=\"language-js\">let result = 25 &#x26; 3\n// 25的32位数\n000000000000000000000000000011001\n// 3的32位数\n000000000000000000000000000000011\n// 对应值\n000000000000000000000000000000001\n// 转为整数就是1\nconsole.log(result) // 1\n</code></pre>\n<h2>OR操作符(|)</h2>\n<ul>\n<li>该符号同样作用于两个值，对两个值的为进行操作，只有当两个值对应位都是0才返回0，否则返回1，如下</li>\n</ul>\n<pre><code class=\"language-js\">let result = 25 | 3\n// 25的32位数\n000000000000000000000000000011001\n// 3的32位数\n000000000000000000000000000000011\n// 对应值\n000000000000000000000000000011011\n// 转换为整数就是 27\nconsole.log(result) // 27\n</code></pre>\n<h2>XOR操作符(^)</h2>\n<ul>\n<li>同样作用与两个值，将两个数的32位数进行比较，当相同时返回0，不同时返回1，比如 0跟0返回0，1跟1返回0， 1跟0返回1，0跟1返回1，如下</li>\n</ul>\n<pre><code class=\"language-js\">let result = 25 | 3\n// 25的32位数\n000000000000000000000000000011001\n// 3的32位数\n000000000000000000000000000000011\n// 对应值\n000000000000000000000000000011010\n// 转换为整数就是 26\nconsole.log(result) // 26\n</code></pre>\n<h2>左移操作</h2>\n<ul>\n<li>左移操作由两个 &#x3C; 表示，并且将除符号位之外所有的位数向左移动指定的位数，比如对2进行左移5操作，如下</li>\n</ul>\n<pre><code class=\"language-js\">let val = 2\nlet newVal = val &#x3C;&#x3C; 5\n// 首先将2转为32位数\n000000000000000000000000000000010\n// 然后将除符号位的数向左移动5位\n0000000000000000000000000010\n// 然后把后面空出来的用0补起来\n000000000000000000000000001000000\n// 最终得到  64\nconsole.log(newVal) // 64\n</code></pre>\n<ul>\n<li>左移操作不会修改符号位，所以对-2进行左移5位得到的是-64而不是64</li>\n</ul>\n<h2>有符号右移操作</h2>\n<ul>\n<li>有符号右移使用两个 > 然后跟一个移动数量来表示，比如对64进行右移5操作，如下</li>\n</ul>\n<pre><code class=\"language-js\">let val = 64\nlet newVal = val >> 5\n// 首先将64转为32位数\n000000000000000000000000001000000\n// 然后将除符号位的数向右移动5位\n0     000000000000000000000000010\n// 然后把前面空出来的用0补起来\n000000000000000000000000000000010\n// 最终得到  2\nconsole.log(newVal) // 2\n</code></pre>\n<ul>\n<li>有符号右移操作同样不会修改符号位，所以对-64进行右移5位得到的是-2而不是2</li>\n</ul>\n<h2>无符号右移操作</h2>\n<ul>\n<li>无符号右移操作是使用三个 > 然后跟一个右移数量表示，因为是无符号数，所以32位都表示数值，也就不会对第一位进行保留了</li>\n<li>这种情况下对正数进行右移并不会改变原来的值，因为符号位本来就是0，如下</li>\n</ul>\n<pre><code class=\"language-js\">let val = 64\nlet newVal = val >> 5\n// 首先将64转为32位数\n000000000000000000000000001000000\n// 然后将所有数向右移动5位\n     0000000000000000000000000010\n// 然后把前面空出来的用0补起来\n000000000000000000000000000000010\n// 最终得到  2\nconsole.log(newVal) // 2\n</code></pre>\n<ul>\n<li>但是针对负数就不一样了，因为负数是对应正数取补码加1，所以表现形式不一致，比如-64，如下</li>\n</ul>\n<pre><code class=\"language-js\">let val = -64\nlet newVal = val >>> 5\n// 首先将-64转为32位数\n111111111111111111111111111000000\n// 然后将所有数向右移动5位\n     1111111111111111111111111110\n// 然后把前面空出来的用0补起来\n000001111111111111111111111111110\n// 最终得到  134217726\nconsole.log(newVal) // 134217726\n</code></pre>\n<h2>逻辑与(&#x26;&#x26;)</h2>\n<ul>\n<li>同样作用于两个值，类型无要求返回逻辑如下</li>\n<li>两个都是boolean值，则只有两个都是true才返回true，否则返回false</li>\n<li>如果第一个是对象，则一定返回第二个值</li>\n<li>如果第二个是对象，则只有第一个为true时才返回这个对象</li>\n<li>两个都是对象，则返回第二个对象</li>\n<li>两个中有一个null，返回null</li>\n<li>两个中有一个NaN，返回NaN</li>\n<li>两个中有一个undefined，返回undefined</li>\n<li>如果两个为undefined、null、NaN中的两个则第一个是什么就返回什么</li>\n<li>&#x26;&#x26;为短路操作符，第一个为false，则第二个永远不会执行，如下</li>\n</ul>\n<h2>逻辑或(||)</h2>\n<ul>\n<li>同样作用与两个值，类型无要求</li>\n<li>两个都是boolean值，则只有两个都是false才返回false，否则返回true</li>\n<li>如果第一个是对象，则返回第一个</li>\n<li>如果第一个是false，则返回第二个</li>\n<li>两个都是对象，返回第一个</li>\n<li>两个都是null，返回null</li>\n<li>两个都是undefined，返回undefined</li>\n<li>两个都是NaN，返回NaN</li>\n<li>||也是短路操作符，第一个为true，则第二个不执行</li>\n</ul>","fields":{"slug":"/unary-operators/"},"frontmatter":{"title":"不常用的一元操作符","tags":["JavaScript回顾"],"categories":"JavaScript"}}},{"node":{"html":"<h1>从零搭建一个react-hooks项目（五）</h1>\n<ul>\n<li>项目完成大概建起来了，但是当我打个生产包的时候都快哭了，一开始使用的devtool: \"source-map\"，用时高达 34 s，这当然是不可容忍的</li>\n<li>然后我们先将devtool改为\"none\"，然后发现变为了29s</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1075px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/0cf0800b8cd1b8010f7ea92caf0742f3/38a65/webpack.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 22.6%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAIAAADKYVtkAAAACXBIWXMAAAsSAAALEgHS3X78AAAA4klEQVQY03WO227DIBBE/TOJL8G3AIY1wQJjgh2HWFWdPKWN2v//iBK1UvtS6Wi00u7MbDT5l2FZ+skzaQlXjTAgjwc1CjWpwTNhUkSSf4hO8zr763y5Hd2CShbvcFBU8TSnQbOyiRFO8udpSAnbwK/5od2nPd+4fBw0A1MQucn2acHymm8zvE32cRoUP+cdCXGogpD7Yy4qXmFAJaWEL/Mou5430GvDhaVdR1UbACdpy6EBZb2yl7yG7/6oPUn1qvSqxzczv2sYBG8Na1WcNXZ108fg7oO56pqxomQE9N+3vwD8i0Hf7uZxMwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"图片\"\n        title=\"图片\"\n        src=\"/static/0cf0800b8cd1b8010f7ea92caf0742f3/38a65/webpack.png\"\n        srcset=\"/static/0cf0800b8cd1b8010f7ea92caf0742f3/0b533/webpack.png 500w,\n/static/0cf0800b8cd1b8010f7ea92caf0742f3/00d43/webpack.png 1000w,\n/static/0cf0800b8cd1b8010f7ea92caf0742f3/38a65/webpack.png 1075w\"\n        sizes=\"(max-width: 1075px) 100vw, 1075px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<h2>分析打包速度</h2>\n<ul>\n<li>通过 <code>speed-measure-webpack-plugin</code> 分析 <code>webpack</code> 构建期间各个阶段花费的时间，使用方法如下</li>\n</ul>\n<pre><code class=\"language-js\">const SpeedMeasurePlugin = require(\"speed-measure-webpack-plugin\");\nconst smp = new SpeedMeasurePlugin();\nmodule.exports = smp.wrap(webpackConfig)\n</code></pre>\n<ul>\n<li>然后在打包时就会显示打包中各阶段花费的时间，显示如下</li>\n</ul>\n<!--more-->\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 846px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/9d1709d15c5d6c27b8da868781ebfb3f/5b481/speed_measure.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 77.8%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAYAAAAWGF8bAAAACXBIWXMAABJ0AAASdAHeZh94AAAB4ElEQVQ4y5WUWW/aQBSF+S9VE4Lx7rE93vCGgUCBAKEli9pEVbe3/v+HrwNUTdpKiXm4Gmt0/emec66mYzoxtsjoWyGWl2CockRKYAZktkTXBWeaS7fvcf77fKk6ZhASlSVZcYkb5hiGj9EXGJqHtm9SkLc99w/sNWgnq2fcPX7n9uM33q1vGVcz5oOaRZbjOCF9Q2BZAk1vOWE1uuLx609291+4f/jB9e1nxsst0+2catkQSEno+ZjWk/QXgVE2Zr19YLrYsX7/icl8i5vkpMuMdJ6iC583Xae1jx07lqSjgqJRHsoS25RYmqCvHX++eNbcSnJQDJjfbZhcLxR4RFlVDGSKa8njVFp72AEoiojhjZpwo2SOS7w8QQ8lPTNUDSrdE2BHYB7TfGioNjVJ1ZDKAZnvoxteqxD+A+puSL24JBkOiZIRaRQRB8Ffa7I/z9sC3SxidDOkXFdERY2uvNtLPcjVnha6+/y7teS6ochzCpX8fu/2CV/oJ3poSRXKakpcqwlVwuEwZX9nugmRHyBVdU+R7CRK8q6hXNUHoB3Jg2zLFAhb0PvHy1eBXhYz2c2oVyOqKxVMMzg8EmEekZYxuoKe9U6QrNkBwUDtX5whkkw9XyE99eJo7rG6J3r4C5XEAqIGpU5aAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"图片\"\n        title=\"图片\"\n        src=\"/static/9d1709d15c5d6c27b8da868781ebfb3f/5b481/speed_measure.png\"\n        srcset=\"/static/9d1709d15c5d6c27b8da868781ebfb3f/0b533/speed_measure.png 500w,\n/static/9d1709d15c5d6c27b8da868781ebfb3f/5b481/speed_measure.png 846w\"\n        sizes=\"(max-width: 846px) 100vw, 846px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<ul>\n<li>不要在开发模式下使用这个分析插件，否则每次对代码进行修改都会导致webpack异常退出，报错 <code>Running webpack throws 'Callback was already called' error</code></li>\n</ul>\n<h2>优化一 优化解析速度 - 多进程打包</h2>\n<ul>\n<li>正常的webpack打包是单线程的，文件只能挨个处理，针对大量文件就会很慢，所以官方推荐了 thread_loader ，这个loader放在其他loader之前，，那么它后面的loader就会在单独的worker进程（node.js process）中进行</li>\n<li>thread_loader使用很简单，将它引入并放到其他loader之前即可</li>\n<li>注意：thread-loader 需要 style-loader 之后，这是因为 thread-loader 后的 loader 没法存取文件也没法获取 webpack 的选项设置。</li>\n</ul>\n<pre><code class=\"language-js\">module.exports = {\n  ...\n  module: {\n    rules: [\n      {\n        test: /\\.(ts|js)x?$/,\n        use: [\n          'thread-loader',\n          'babel-loader'\n        ],\n        exclude: /node-modules/\n      }\n    ]\n  }\n}\n</code></pre>\n<ul>\n<li>由于每个worker启动要600ms，为了防止worker启动的高延迟，我们可以进行预热</li>\n</ul>\n<pre><code class=\"language-js\">const threadLoader = require('thread-loader');\nconst jsWorkerPool = {\n  // options\n  \n  // 产生的 worker 的数量，默认是 (cpu 核心数 - 1)\n  // 当 require('os').cpus() 是 undefined 时，则为 1\n  workers: 2,\n  \n  // 闲置时定时删除 worker 进程\n  // 默认为 500ms\n  // 可以设置为无穷大， 这样在监视模式(--watch)下可以保持 worker 持续存在\n  poolTimeout: 2000\n};\nthreadLoader.warmup(jsWorkerPool, ['babel-loader']);\n\nmodule.exports = {\n  ...\n  module: {\n    rules: [\n      {\n        test: /\\.(ts|js)x?$/,\n        use: [\n          {\n            loader: 'thread-loader',\n            options: jsWorkerPool\n          },\n          'babel-loader'\n        ],\n        exclude: /node-modules/\n      }\n    ]\n  }\n}\n</code></pre>\n<ul>\n<li>然后我们再尝试打包，分析一下babel-loader的时间</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 846px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/9d1709d15c5d6c27b8da868781ebfb3f/5b481/speed_measure.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 77.8%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAYAAAAWGF8bAAAACXBIWXMAABJ0AAASdAHeZh94AAAB4ElEQVQ4y5WUWW/aQBSF+S9VE4Lx7rE93vCGgUCBAKEli9pEVbe3/v+HrwNUTdpKiXm4Gmt0/emec66mYzoxtsjoWyGWl2CockRKYAZktkTXBWeaS7fvcf77fKk6ZhASlSVZcYkb5hiGj9EXGJqHtm9SkLc99w/sNWgnq2fcPX7n9uM33q1vGVcz5oOaRZbjOCF9Q2BZAk1vOWE1uuLx609291+4f/jB9e1nxsst0+2catkQSEno+ZjWk/QXgVE2Zr19YLrYsX7/icl8i5vkpMuMdJ6iC583Xae1jx07lqSjgqJRHsoS25RYmqCvHX++eNbcSnJQDJjfbZhcLxR4RFlVDGSKa8njVFp72AEoiojhjZpwo2SOS7w8QQ8lPTNUDSrdE2BHYB7TfGioNjVJ1ZDKAZnvoxteqxD+A+puSL24JBkOiZIRaRQRB8Ffa7I/z9sC3SxidDOkXFdERY2uvNtLPcjVnha6+/y7teS6ochzCpX8fu/2CV/oJ3poSRXKakpcqwlVwuEwZX9nugmRHyBVdU+R7CRK8q6hXNUHoB3Jg2zLFAhb0PvHy1eBXhYz2c2oVyOqKxVMMzg8EmEekZYxuoKe9U6QrNkBwUDtX5whkkw9XyE99eJo7rG6J3r4C5XEAqIGpU5aAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"图片\"\n        title=\"图片\"\n        src=\"/static/9d1709d15c5d6c27b8da868781ebfb3f/5b481/speed_measure.png\"\n        srcset=\"/static/9d1709d15c5d6c27b8da868781ebfb3f/0b533/speed_measure.png 500w,\n/static/9d1709d15c5d6c27b8da868781ebfb3f/5b481/speed_measure.png 846w\"\n        sizes=\"(max-width: 846px) 100vw, 846px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<ul>\n<li>我们可以看到优化了将近 9 s</li>\n</ul>\n<h2>优化二 添加公用包的缓存</h2>\n<ul>\n<li>之前我们通过将不会发生变化的三方库进行抽离为dll文件，然后二次打包的时候不再对这些文件进行打包，以此来进行打包优化</li>\n<li>不过由于webpack的升级，已经有了不差于dll的打包性能，所以我们不再考虑dll形式的打包</li>\n<li>DLL不明显了，但是有了更好的替代品 hard-source-webpack-plugin ，只需要简单引入，之后第一次打包的时候可能会慢一点，但是从第二次开始就可以看到明显的差别</li>\n<li>使用方法如下</li>\n</ul>\n<pre><code class=\"language-js\">const HardSourceWebpackPlugin = require('hard-source-webpack-plugin');\n\nmodule.exports = {\n  ...\n  plugins: [\n    new HardSourceWebpackPlugin(),\n  ],\n}\n</code></pre>\n<ul>\n<li>之后我们再来对比一下，第一次打包</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 905px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/0a5a839f48d274f53f61f79181e56bb4/65d79/optimize_hard_source.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 59.599999999999994%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAABJ0AAASdAHeZh94AAABZ0lEQVQoz5WTwXKbMBRF+ZkmDRhsgwQSAhuBcUPjxMRtmCRtPVl0Ml32/zcnctpOvYTFmyeNNGfuvXrygmVKogvChebjTOBHKX4o8d06OO1dXQbJ+9mY8iKpyKsGqSxRbAhcLRcK6cDK9WyecTmbAExLy83hgZv9I5vunlXZIkSBnitMlDGbST74f4BjlHqresfw7SeH4cht/8Swf+JwfU9VbcmUoUgzkjjlYqRtr97ueXn9zfPxle8vv6i7A+XtBvvFslDqPUM/HJ+jlxUb+ocju/0zu/4RYztEVWI+Fw6YceHs/oONsiysZvO1pum3yNw9TJAyDwRXp9zC/xdHK0xKQ91/onI2TdNS25pCGMLoPLdkPFCsc5rBsr6r0HVFvMrxY8VVmE6avzOFOe3QUt01aDcyRWaQ8ZnFiVBPVobux7XLcYtetySJJpo74F+rkxUutcb2LWXXuB/jelkgYukUismwU70BXw2BEYpWaiQAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"图片\"\n        title=\"图片\"\n        src=\"/static/0a5a839f48d274f53f61f79181e56bb4/65d79/optimize_hard_source.png\"\n        srcset=\"/static/0a5a839f48d274f53f61f79181e56bb4/0b533/optimize_hard_source.png 500w,\n/static/0a5a839f48d274f53f61f79181e56bb4/65d79/optimize_hard_source.png 905w\"\n        sizes=\"(max-width: 905px) 100vw, 905px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<ul>\n<li>可以看到第一次的打包长中HardSourceWebpackPlugin 占了 30多s，几乎跟打包时常一样了</li>\n<li>但是当我们第二次打包的时候</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 902px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/9a5670f6b11f7999300161919faddbd7/58213/optimize_hard_source_after.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 52.2%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAABJ0AAASdAHeZh94AAABW0lEQVQoz5WSWU+DQBSF+TEtZSswwLDKFFroYukiiVVbbYzG5cH4/9+Ow9i4Jg19+HInmZsz59w7kmK6MEgARffQ012BzOkcqmJ4gt6P8zEkJ07AigkIZeiTGIaTgNohGMc1fXQPj7QVlWiaYVKtkZdLeGGGwI8Q+TFMw4dhUOimB/UUh/P1DR6e37Hdv+D67gmbzQ6L1QXS8xLRIEFEfZgW/RX/qOCk2mD/+Ibd/Suubp8wmtXIVgWyOoNzFn7NtXXkQVFhfblHxZ0u6i1iNkY8ZUiXDFYQQNbc05Yiaw66qo2OYvNKBLLqiq0r/UNj47KFmBBsNuuFOZLBVMCGc9hewp2RVgL/BMN0jJLPbVHvhNhwvAJNCmhWKBbR1dzv/6n+Qfu8b1I2ND2Swf9bn0QCzQpgkhB5XmI6W0LnkVnK3bNSzNbwKEzKe/xAzNd0KAihYKM5cm6E0BQfMxBBrC7aUMYAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"图片\"\n        title=\"图片\"\n        src=\"/static/9a5670f6b11f7999300161919faddbd7/58213/optimize_hard_source_after.png\"\n        srcset=\"/static/9a5670f6b11f7999300161919faddbd7/0b533/optimize_hard_source_after.png 500w,\n/static/9a5670f6b11f7999300161919faddbd7/58213/optimize_hard_source_after.png 902w\"\n        sizes=\"(max-width: 902px) 100vw, 902px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<ul>\n<li>这时神奇的事发生了，我们的打包时间变得只有13s了，缩短了60%</li>\n</ul>\n<h2>优化三 vendor代码分离</h2>\n<ul>\n<li>我们发现打出来的三方库的包vendor只有一个，体积达到了 2.6 M，这样对我们的首次加载是极其不友好的</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 905px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/f53ab1dd0530c86e20fa622a15fc0605/65d79/vendor_size.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 33.4%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAABJ0AAASdAHeZh94AAAA7klEQVQoz51Rf3ODIAz1+3/FnT13tlVBQBwqSOEtYW3Xs39tucvlF3l5IVWMETlnHGXfd/RCwYedogxtLAL5/DbGGzYfkFK69+YnRnU61WjbFsuyFBBWFh4kxQCtNbz3EEOPpmkgpSx1v22w1hafwZ6AXXeFEBITFe08F5syCgulFGbKhRDg3IJpmqBoQEo/LJd1fQf8qGt8the0lw6DVHBbwOr3oudrDzFquNVD0crdIEscYoKlAdp+4Y74C8i0efI4jjDGwJDPbPh/nHPYaDVen+1KjB6NN8ox8zeG+I+8HPF40OqB/ic9sHr1vwHj0CMVGwf3sgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"图片\"\n        title=\"图片\"\n        src=\"/static/f53ab1dd0530c86e20fa622a15fc0605/65d79/vendor_size.png\"\n        srcset=\"/static/f53ab1dd0530c86e20fa622a15fc0605/0b533/vendor_size.png 500w,\n/static/f53ab1dd0530c86e20fa622a15fc0605/65d79/vendor_size.png 905w\"\n        sizes=\"(max-width: 905px) 100vw, 905px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<ul>\n<li>导致vendor包过大的原因主要是我们的react组件都是同步引入的，导致webpack打包时认为是首页就需要的全部组件，从而将所有的依赖与文件都打到了一起</li>\n<li>解决这个问题我们就需要react的按需引入功能，配合webpack本身的异步分离打包实现vendor包的优化</li>\n<li>react本身支持异步导入，但是因为我们的项目使用了babel，所以我们需要确保babel可以解析异步导入语句，并能正确解析，所以引入 'babel-plugin-syntax-dynamic-import' ,使用方法如下</li>\n</ul>\n<pre><code class=\"language-js\">// 首先引入\nyarn add babel-plugin-syntax-dynamic-import -D -S\n// 然后修改 .babelrc 文件\n\"plugins\": [\n  \"syntax-dynamic-import\",\n  ...\n]\n</code></pre>\n<ul>\n<li>这样就保证我们可以正常使用react的异步导入方法了</li>\n<li>然后因为我们使用了typescript，并且配置项中的module是 es6 ，但是该模式下不支持异步导入，所以将其修改为 commonjs，如下</li>\n</ul>\n<pre><code class=\"language-js\">// tsconfig.json\n{\n  \"compilerOptions\": {\n    ...\n    \"module\": \"commonjs\", // 模块引入方式\n  }\n}\n</code></pre>\n<ul>\n<li>然后就完成了webpack基本项的配置，接下来就要修改我们的react代码</li>\n<li>我们使用react提供的 lazy 方法对组件页面进行异步引入</li>\n</ul>\n<pre><code class=\"language-js\">// 原代码\nimport * as React from 'react'\nimport Home from 'pages/home'\n\n// 异步导入\nimport * as React from 'react'\nconst { lazy } = React\nconst Home = lazy(() => import('pages/home'))\n</code></pre>\n<ul>\n<li>按这种形式将我们的所有页面引入都修改了，然后再进行打包尝试，打包后的结果如下</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 877px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/8c16623f3cc19666704e5d027dcf4353/4b446/vendor_list.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 73.4%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAABJ0AAASdAHeZh94AAAB80lEQVQ4y22TC2+bQBCE/f9/VSu1TZO0lZo2TnFjqDE2YDhe5mXzmO5cjEUMJ50SuNvhm93xwvd95HkOrr7v9eY6n89I0xR5keN0OqEsS/2cZZm+0zSNfndbt3h5WSIIgslBJZdd10UYhiiKAvZmA9O0EEXR23lVIUmSa92wFiyaJRSqOI5xPB41IYtDpTQhFz+Sy54QGoahSSaEQuB5HpSIFEWpXTiOo4kHwVlCFvHLwxoOSUV7JKrrWtNSlH0czsfOroIbe4P9hXB8WNeVFqAQaZUKtZNxDwf77wRp43A4TCyTioK0xWIKMxHq4oaEs4LbrQPP9yaCJxFkMS1SkPbYvyhS6LoeXdvOWzYtC7v9fnYoJKJF5o00vnyY77quQ9s284S8MEzuNja0y9jU8j+nStt818kdio6DfRV8Xa91HKaEl2Crt2DTOp89z0WrCdvrxCeEQRjgdukwX4LNAZEmGQilhxQs54L9Vwi3ux1q+e0WjII0upVDPnsyfSUihQimIuzL1EPpaSeFvJPODcX7eof950+wP36Af/cF8Y/vqJbPqGUHD/dI5Ln4/QvHp58IH+9lP6BZGXJniezbI3uDfiS6MFcW1n9MrJ4N/HvdwF7b8B3JmxfBsRy4tvTRVfovdxykSFUG5cdQjsSta98J/gdmnITTfyFT7QAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"图片\"\n        title=\"图片\"\n        src=\"/static/8c16623f3cc19666704e5d027dcf4353/4b446/vendor_list.png\"\n        srcset=\"/static/8c16623f3cc19666704e5d027dcf4353/0b533/vendor_list.png 500w,\n/static/8c16623f3cc19666704e5d027dcf4353/4b446/vendor_list.png 877w\"\n        sizes=\"(max-width: 877px) 100vw, 877px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<ul>\n<li>可以看到我们的vendor变成了 160 多k，并且将原来的大文件拆分为很多小的bundle文件，这对我们的首屏加载有很大的帮助</li>\n</ul>","fields":{"slug":"/react_md_5/"},"frontmatter":{"title":"从零搭建一个react-hooks项目（五）","tags":["react","react hooks","redux","webpack"],"categories":"Webpack"}}},{"node":{"html":"<ul>\n<li>javascript中的垃圾回收历史有两种，一种是最常用的标记清除，一种是不常用的引用计数清除法。</li>\n</ul>\n<h2>标记清除</h2>\n<ul>\n<li>标记清除是现代浏览器最常用的垃圾回收方式，原理是：</li>\n<li>当上下文有变量进入的时候就为它添加一个标记，这样整个程序执行时每一个创建的变量都会被添加标记。当变量离开上下文时也会被加上离开上下文的标记。然后当垃圾回收进程执行时，会把当前上下文的所有变量跟被引用的变量去除标记，这样剩下的有标记就都是不被引用也不被使用的变量了，这样就可以做内存清理了，销毁带标记的值并回收内存。</li>\n</ul>\n<h2>引用计数清除</h2>\n<ul>\n<li>这种计数方式在早期浏览器有使用过，后面就基本不怎么使用了，原理如下：</li>\n<li>当一个值被赋值给一个变量时就会把该值的引用数加一。比如，当声明一个变量并引用该值，则该值的引用数加一，当这个值被赋给另一个变量时，引用数继续加一。当一个引用该值的变量被其他值覆盖了，则该值的引用数减一，当引用数为0则表示该值不可被访问了，就会被垃圾回收。</li>\n<li>\n<p>该方式不常用是因为在循环引用时会无法释放内存，比如当a是一个对象，b也是一个对象，a的某个属性指向了b，b的某个属性指向了a，这样他们的引用值一直都不会为0，也就导致了该值一直存在无法回收。只有当我们显示的将a对应的属性跟b对应的属性都赋值null才会让他们进入垃圾回收。</p>\n<!--more-->\n<h2>性能优化</h2>\n</li>\n<li>现代浏览器的垃圾回收都是按照已分配对象的大小跟数量来判断的，这是因为早期IE是根据分配数来进行垃圾回收，比如设定了256个变量或者64k的字符串等，当满足其中的条件就会进行回收，这有可能整个脚本始终存在这么多的变量就导致了一直在运行，严重影响性能。</li>\n<li>所以改为了现有的根据分配对象来进行，首先它的起始阈值跟之前是一致的，只不过当某次垃圾回收的内存不到已分配的15%，那么就说明程序过大，这个阈值不够了，就会对阈值进行翻倍，然后下一次如果还是不到15%就继续翻倍，直到它满足15%以上为止</li>\n<li>如果某次的内存已经达到了85%，说明这个阈值已经过大了，应该再频繁一点，然后就会重置为默认值，重复进行这两个步骤，这样我们的性能就有很好的提升</li>\n<li>对声明的全局变量要是不再使用应该置为null</li>\n<li>多使用let、const提升性能，因为都是块级作用域，肯定会比全局变量更早终止，也就有可能更早的被回收</li>\n</ul>\n<h2>隐藏类优化性能</h2>\n<ul>\n<li>当我们的两个对象共享一个构造函数与原型时，在v8引擎会默认两个实例引用同一个隐藏类，如下：</li>\n</ul>\n<pre><code class=\"language-js\">function Article(){\n  this.title = \"my name\"\n}\nlet a1 = new Article()\nlet a2 = new Article()\n</code></pre>\n<ul>\n<li>这种情况下会默认使用一个隐藏类，但是当我们对对象进行了删除或者新增属性就会打破这个规则，如下</li>\n</ul>\n<pre><code class=\"language-js\">// 新增属性\nfunction Article(){\n  this.title = \"my name\"\n}\nlet a1 = new Article()\nlet a2 = new Article()\na2.name = 'danny'\n\n// 删除属性\nfunction Article(){\n  this.title = \"my name\"\n}\nlet a1 = new Article()\nlet a2 = new Article()\ndelete a2.title\n</code></pre>\n<ul>\n<li>这两种情况都会导致不再共享一个隐藏类，对应两个隐藏类，如果隐藏类过大就会影响性能，我们可以进行下面的优化</li>\n<li>对需要新增的属性操作添加在原型内，如下</li>\n</ul>\n<pre><code class=\"language-js\">function Article(name){\n  this.title = \"my name\"\n  this.name = name\n}\nlet a1 = new Article()\nlet a2 = new Article('danny')\n</code></pre>\n<ul>\n<li>这样还是共用一个隐藏类，针对删除操作，我们不要显示的删除，只需要将值设为null即可，如下</li>\n</ul>\n<pre><code class=\"language-js\">function Article(){\n  this.title = \"my name\"\n}\nlet a1 = new Article()\nlet a2 = new Article()\na2.title = null\n</code></pre>","fields":{"slug":"/collect-garbage/"},"frontmatter":{"title":"javascript中的垃圾回收","tags":["JavaScript回顾"],"categories":"JavaScript"}}},{"node":{"html":"<h1>script不为人知的标签属性</h1>\n<h2>普通引用</h2>\n<ul>\n<li>js加载与执行都会阻塞页面渲染与执行，等到js加载并执行完成后才会继续页面的渲染</li>\n</ul>\n<h2>async</h2>\n<ul>\n<li>js加载不会阻塞页面渲染，js加载后就会立即执行，执行时会阻塞页面渲染，有多个async的文件时，跟引入的顺序无关，谁先加载完就执行谁</li>\n</ul>\n<h2>defer</h2>\n<ul>\n<li>\n<p>js加载不会阻塞页面渲染，js加载后不会立即执行，等页面渲染完成后才执行，在 DOMContentLoaded 事件之前执行，有多个 defer 文件时，规范应该是按引入的顺序执行，但实际情况下并不一定按原有顺序执行，所以多个 defer 引入需注意</p>\n<!--more-->\n<h2>charset</h2>\n</li>\n<li>定义js脚本使用的编码值，大多数浏览器都没有遵守它，无意义</li>\n</ul>\n<h2>crossorigin</h2>\n<ul>\n<li>当正常引入跨域资源脚本时，因为浏览器限制，如果该脚本报错我们是拿不到报错信息的，监听onerror只能拿到script error，但是最新的html5规范又规定允许本地获取到跨域脚本错误的，这个时候，满足两个条件就可以实现</li>\n<li>跨域资源服务器通过 Access-Control-Allow-Origin 头信息允许当前域名可以获取错误信息。</li>\n<li>script标签指定脚本地址是跨域资源，也就是我们的 crossorigin，当值为 anonymous 时不携带cookie等认证信息，当值为 use-credentials 会携带cookie等认证信息</li>\n</ul>\n<h2>integrity</h2>\n<ul>\n<li>又称SRI，子资源完整性完整性。该值由两部分组成签名算法跟摘要签名内容组成，用 - 连接。</li>\n<li>指定了该值之后，浏览器在拿到资源后会用 integrity 指定的签名算法对资源进行计算并与 摘要签名内容 进行比较，如果值不统一，说明是经过篡改的，就不会执行该资源</li>\n</ul>\n<h2>type</h2>\n<ul>\n<li>传统意义上该值为\"text/javscript\"或者\"text/ecmascript\"，但是这两个值已经不赞成使用了</li>\n<li>通常我们应该设置该值为\"application/x-javascript\"，虽然设置该值可能会导致脚本被忽略</li>\n<li>其他在非IE浏览器下，我们可以设置为\"application/javascript\"或者\"application/ecmascript\"</li>\n<li>如果设置该值为\"module\"，则该文件下的code会被视为ES6模块，只有这样才能使用import跟export关键字</li>\n</ul>","fields":{"slug":"/script-element/"},"frontmatter":{"title":"script不为人知的标签属性","tags":["JavaScript回顾"],"categories":"JavaScript"}}},{"node":{"html":"<h1>循环语句</h1>\n<h2>for-in 循环语句</h2>\n<ul>\n<li>for-in是严格迭代语句，会迭代一个对象中非Symbol的其他属性值，语法如下</li>\n</ul>\n<pre><code class=\"language-js\">for(const prop in obj) {\n  console.log(prop)  \n}\n</code></pre>\n<ul>\n<li>for-in迭代对象是无序的，各浏览器下返回的顺序可能不一致</li>\n<li>const并不是必须的，但建议使用，避免影响外界变量</li>\n<li>迭代null或undefined则迭代内的表达式不会被执行</li>\n</ul>\n<h2>for-of 循环语句</h2>\n<ul>\n<li>for-of也是迭代语句，只能迭代一个可迭代对象，语法如下</li>\n</ul>\n<pre><code class=\"language-js\">for(const value in obj) {\n  console.log(value)  \n}\n</code></pre>\n<ul>\n<li>迭代是有序的，由对象内部的next()方法决定</li>\n<li>\n<p>迭代一个非迭代器对象会抛出错误</p>\n<!--more-->\n<h2>标记语法</h2>\n</li>\n<li>用来标记一个表达式，用于在后续使用，一般用于配合break、continue打破循环使用</li>\n<li>标记语法如下</li>\n</ul>\n<pre><code class=\"language-js\">label: statement\n</code></pre>\n<ul>\n<li>break用于结束这个循环体，执行循环体后的语句</li>\n<li>continue用于结束单次循环，进行该循环体的下一次循环</li>\n<li>配合标记语法如下</li>\n</ul>\n<pre><code class=\"language-js\">let num = 0\noutermost: for(let i = 0; i &#x3C; 10; i++) {\n  for(let j = 0; j &#x3C; 10; j++) {\n    if(i === 5 &#x26;&#x26; j === 5) {\n      break outermost\n    }\n    num++\n  }\n}\n\nconsole.log(num) // 55\n</code></pre>\n<ul>\n<li>这里当执行到i跟j都是5的时候，我们的break将外层循环结束了，导致后续的4次大循环与当次剩余的5次小循环无法继续，所以导致最终的输出为55</li>\n</ul>\n<pre><code class=\"language-js\">let num = 0\noutermost: for(let i = 0; i &#x3C; 10; i++) {\n  for(let j = 0; j &#x3C; 10; j++) {\n    if(i === 5 &#x26;&#x26; j === 5) {\n      continue outermost\n    }\n    num++\n  }\n}\n\nconsole.log(num) // 95\n</code></pre>\n<ul>\n<li>这里的continue跳过了外层循环，导致子循环后续的5次没法执行直接到了下一个循环，所以最终次数会少5，变成了95</li>\n</ul>\n<h2>with语法</h2>\n<ul>\n<li>with语法用于将一个代码执行块与一个变量绑定，语法如下</li>\n</ul>\n<pre><code class=\"language-js\">with (expression) statement;\n</code></pre>\n<ul>\n<li>当一个对象被一次又一次的引用执行的时候就可以使用with语法来简化，比如下场景</li>\n</ul>\n<pre><code class=\"language-js\">let qs = location.search.substring(1)\nlet hostname = location.hostname\nlet url = location.href\n</code></pre>\n<ul>\n<li>这里我们的location对象被多次重复引用，我们可以使用with进行简化</li>\n</ul>\n<pre><code class=\"language-js\">with(location){\n  let qs = search.substring(1)\n  let hostname = hostname\n  let url = href\n}\n</code></pre>\n<ul>\n<li>with工作原理会在当前的作用域内查找是否有对应的变量，如果没有就会从对应location对象上面查找对应的同名属性</li>\n<li>在严格模式下with语法会报错</li>\n<li>with语法会降低代码性能与导致一些奇怪的bug，所以不推荐使用</li>\n</ul>","fields":{"slug":"/loop-statement/"},"frontmatter":{"title":"常用循环语句的基本属性","tags":["JavaScript回顾"],"categories":"JavaScript"}}},{"node":{"html":"<h1>乘、除、取余、指数、加法、减法、比较、相等操作符</h1>\n<h2>乘</h2>\n<ul>\n<li>乘法的计算遵循下面的原则</li>\n<li>如果结果超出ECMAScript所表示的范围，那么最终会得到 Infinity 或者 -Infinity</li>\n<li>NaN参与运算，得到NaN</li>\n<li>Infinity 与 0 相乘得 NaN </li>\n<li>Infinity 与 非 0 数相乘得 Infinity 或者 -Infinity ，由非 0 数决定符号</li>\n<li>如果其中一个是非数值，将会被Number()强制转为数值参与计算</li>\n</ul>\n<h2>除</h2>\n<ul>\n<li>除法的计算遵循下原则</li>\n<li>如果结果超出ECMAScript所表示的范围，那么最终会得到 Infinity 或者 -Infinity</li>\n<li>NaN参与运算，得到NaN</li>\n<li>Infinity 除以 Infinity 得到 NaN</li>\n<li>0 除以 0 得 NaN</li>\n<li>Infinity 除以 任何数都得 Infinity 或者 -Infinity ，符号由除数决定</li>\n<li>\n<p>如果其中一个操作符为非数值，则被Number()转为数值参与计算</p>\n<!--more-->\n<h2>取余</h2>\n</li>\n<li>取余的计算规则如下</li>\n<li>如果被除数是 Infinity ，除数是有限值，那么结果为 NaN</li>\n<li>如果被除数是 有限值，除数为 0，那么结果为 NaN</li>\n<li>除数跟被除数都是Infinity,则结果为NaN</li>\n<li>被除数是有限值，除数是Infinity,结果是被除数</li>\n<li>被除数是0，除数是非0，结果是0</li>\n<li>如果其中一个操作符为非数值，则被Number()转为数值参与计算</li>\n</ul>\n<h2>指数操作符</h2>\n<ul>\n<li>指数被用来表示某个数的多少次方，用<code>Math.pow()</code>来计算，在ECMAScript 7中可以使用 <code>**</code> 来表示</li>\n</ul>\n<pre><code class=\"language-js\">console.log(Math.pow(3, 2)) // 9\nconsole.log(3 ** 2) // 9\n</code></pre>\n<ul>\n<li>有了 <code>**</code>操作符自然也就有了对应的速写计算符<code>**=</code>，如下</li>\n</ul>\n<pre><code class=\"language-js\">let square = 3\nsquare **= 2\nconsole.log(square) // 9\n</code></pre>\n<h2>加法操作符</h2>\n<ul>\n<li>加法操作符比较特殊，对应不同的数据状态会发生不同的数据类型转换，规则如下</li>\n</ul>\n<h3>两个数都是数值的计算规则</h3>\n<ul>\n<li>如果两个数都是数值类型，那么对应规则如下</li>\n<li>有NaN参与计算，则值为NaN</li>\n<li>Infinity 加 -Infinity，结果为NaN</li>\n<li>-0 加 +0，结果为+0</li>\n<li>-0 加 -0，为-0， +0 加 +0，为+0</li>\n<li>Infinity 加 Infinity为Infinity，-Infinity 加 -Infinity 为 -Infinity</li>\n</ul>\n<h3>字符串参与计算的规则如下</h3>\n<ul>\n<li>其中一个值为字符串，则另一个值会被转为字符串然后进行拼接</li>\n</ul>\n<h2>减法操作符</h2>\n<ul>\n<li>减法操作符的计算规则</li>\n<li>NaN参与运算结果为NaN</li>\n<li>Infinity 减 Infinity ,结果为NaN</li>\n<li>-Infinity 减 -Infinity，结果为NaN</li>\n<li>Infinity 减 -Infinity，结果为Infinity</li>\n<li>-Infiniy 减 Infinity，结果为 -Infinity</li>\n<li>+0 减 +0 结果为 +0</li>\n<li>-0 减 +0 结果为 -0</li>\n<li>-0 减 -0 结果为 +0</li>\n<li>如果其中一个是 字符串、布尔值、null或者undefined，会使用Number()转为数值参与计算</li>\n<li>如果其中一个是对象，则会调用该对象的 valueOf() 方法来获取数值进行计算，如果对象没有valueOf方法，那么会调用toString()方法来获取值并转为对象参与计算</li>\n</ul>\n<h2>比较运算符</h2>\n<ul>\n<li>比较运算法有 >, &#x3C;, &#x3C;=, >=</li>\n<li>用来比较两个变量的大小关系，会返回一个布尔值</li>\n<li>针对不同数据类型，比较规则如下</li>\n<li>数值则直接比较大小</li>\n<li>都是字符串则依次比较每个字符对应的字符编码</li>\n<li>其中一个是数值则把另一个转为数值进行比较</li>\n<li>如果是对象，则调用 valueOf() 获取值参与比较，没有该属性就获取 toString()方法获取值参与比较</li>\n<li>如果其中一个是布尔值，则把它转为数值参与计算</li>\n<li>字符串比较时，所有的小写字母都要大于大写字母，所以要是想按字母顺序比较的话需要同时转为大写或者小写，如下</li>\n</ul>\n<pre><code class=\"language-js\">let result = \"Brick\" &#x3C; \"alphabet\"\nconsole.log(result) // true，并不是我们的预期\n\nlet result = \"Brick\".toLowerCase() &#x3C; \"alphabet\".toLowerCase()\nconsole.log(result) // false\n</code></pre>\n<ul>\n<li>NaN参与比较运算符永远都得false，哪怕是比较两个 NaN</li>\n</ul>\n<pre><code class=\"language-js\">let result = NaN > 3 // false\nlet result = NaN &#x3C;= 3 // false\n\nlet result = NaN > NaN // false\nlet result = NaN &#x3C;= NaN // false\n</code></pre>\n<h2>相等运算符</h2>\n<ul>\n<li>相等运算符分为全等与不全等运算符，不全等运算符不会比较类型，而是在比较时进行类型转换</li>\n</ul>\n<h3>不全等运算符规则</h3>\n<ul>\n<li>null 跟 undefined 相等</li>\n<li>null 跟 undefined 不会被转为其他类型进行比较</li>\n<li>NaN 参与比较永远返回false</li>\n<li>两个对象比较则对比是否两个是同一个对象，是就返回true，不是就返回false</li>\n<li></li>\n</ul>","fields":{"slug":"/multiplicative-operators/"},"frontmatter":{"title":"常用计算符独特的计算属性","tags":["JavaScript回顾"],"categories":"JavaScript"}}},{"node":{"html":"<h1>字符串模板标记函数</h1>\n<h2>字符串模板</h2>\n<ul>\n<li>ES6新增的字符串定义方式，可以通过 <code></code> 配合${} 来进行变量的嵌入，如下示例</li>\n</ul>\n<pre><code class=\"language-js\">let name = '张三'\nlet age = 24\n// 常规定义字符串的方式\nlet str = '我的名字叫' + name + ', 我今年' + age + '岁了'\n\n// 字符串模板定义\nlet str1 = `我的名字叫${ name },我今年${ age }岁了`\n\nconsole.log(str === str1) // true\n</code></pre>\n<!--more-->\n<h2>模板标记函数</h2>\n<ul>\n<li>模板标记函数的定义跟普通函数一致，但是在使用它之前要准备一个字符串模板，调用方式也跟常规的函数调用方法不同，不需要使用 functionName() 的形式调用，直接在函数名后面跟模板字符串即可，如下:</li>\n</ul>\n<pre><code class=\"language-js\">let a = 6\nlet b = 9\nlet sum = 15\nfunction tagTemplate(strings, aVariable, bVariable, sumVariable) {\n  console.log(strings)        // ['', ' + ', ' = ', '']\n  console.log(aVariable)      // 6\n  console.log(bVariable)      // 9\n  console.log(sumVariable)    // 15\n}\n\ntagTemplate`${a} + ${b} = ${sum}`\n\nlet c = '张三'\nlet d = 24\nfunction tagTemplate(strings, cVariable, dVariable, notVariable) {\n  console.log(strings)        // ['我叫', '，今年', '岁了']\n  console.log(cVariable)      // '张三'\n  console.log(dVariable)      // 24\n  console.log(notVariable)    // undefined\n}\n\ntagTemplate`我叫${c}，今年${d}岁了`\n</code></pre>\n<ul>\n<li>使用标记函数可以看到，参数里面的第一个参数是数组，是由字符串模板被插入变量分割之后剩余字符串组成的数组，之后的参数依次就是按顺序插入变量的值了</li>\n<li>知道参数的形式后我们就可以用ES6的结构对插入变量进行一个遍历了</li>\n</ul>\n<pre><code class=\"language-js\">let c = '张三'\nlet d = 24\nfunction tagTemplate(strings, ...variable) {\n  console.log(strings)        // ['我叫', '，今年', '岁了']\n  for(let i = 0; i &#x3C; variable.length; i++) {\n    console.log(variable[i])\n  }\n  // '张三'  24\n}\n\ntagTemplate`我叫${c}，今年${d}岁了`\n</code></pre>\n<h3>模板标记函数下的raw数组</h3>\n<ul>\n<li>采用模板标记函数后，第一个数组返回的是我们的非变量插入的字符串片段，这里的字符串片段是会转换成我们的实际展示形式的，比如 \\u00A9 会转为 ©，\\n 会转为一个空格</li>\n<li>如果我们想要拿到没有经过转换的原版字符串，这里我们就可以使用这个数组上的raw属性来获取原版字符串的数组，我们可以看下代码</li>\n</ul>\n<pre><code class=\"language-js\">function tagTest(strings, ...rest){\n  for(let value of strings) {\n    console.log(value)\n  }\n  for(let value of strings.raw) {\n    console.log(value)\n  }\n}\nlet a = '张三'\nlet b = 24\ntagTest`你${ a }\\u00A9,哈哈\\n${ b }我`\n// strings遍历\n// 你\n// ©,哈哈 \n// 我\n\n// strings.raw遍历\n// 你\n// \\u00A9,哈哈\\n\n// 我\n</code></pre>\n<ul>\n<li>这就是模板标记函数给我们提供的一些特性，其实归结起来就是插入变量的提取跟原始字符串的收集，方便我们的使用</li>\n</ul>\n<h2>String.raw</h2>\n<ul>\n<li>String.raw是ES6标准的一个字符串方法，使用方式类似于模板标记函数，后面直接跟一个模板字符串即可，会原样返回该模板字符串的值，不受可编译字符的影响，普通的字符串会返回经过转义的字符串结果，如下</li>\n</ul>\n<pre><code class=\"language-js\">console.log(`\\u00A9`)\n// ©\nconsole.log(String.raw`\\u00A9`)\n// \\u00A9\n\nconsole.log(`Hi\\n`)\n// Hi\nconsole.log(String.raw`Hi\\n`)\n// Hi\\n\n\nconsole.log(`Hi\n张三`)\n// Hi\n// 张三\nconsole.log(String.raw`Hi\n张三`)\n// Hi\n// 张三\n</code></pre>\n<ul>\n<li>它只对会被重新编译的字符串生效，实际的回车或者空格是不会被转义回去的</li>\n<li>其实我也没想好这玩意哪里能用到，既然看到了就记录一下</li>\n</ul>","fields":{"slug":"/template-tag-function/"},"frontmatter":{"title":"字符串模板标记函数","tags":["JavaScript回顾"],"categories":"JavaScript"}}},{"node":{"html":"<h1>符号类型(symbol)</h1>\n<ul>\n<li>Symbol是ES6新增的一种数据类型，用以标识独一无二的类型，所有的Symbol实例都是独一无二的</li>\n</ul>\n<h2>Symbol的使用方式</h2>\n<ul>\n<li>Symbol跟其他类不同，生成实例不需要使用 new 关键字，使用 new 关键字会报错，可以接受一个字符串作为Symbol的入参，也可以不传参直接生成，如下</li>\n</ul>\n<pre><code class=\"language-js\">let sm = new Symbol() // TypeError: Symbol is not a constructor\n\nlet sm1 = Symbol()\nconsole.log(sm1) // Symbol()\nconsole.log(typeof sm1) // symbol\nlet sm2 = Symbol('test')\nconsole.log(sm2) // Symbol('test')\n</code></pre>\n<!--more-->\n<ul>\n<li>每一个Symbol实例都不相同，如下实验</li>\n</ul>\n<pre><code class=\"language-js\">let sm = Symbol()\nlet sm1 = Symbol()\nconsole.log(sm === sm1) // false\n\nlet sm2 = Symbol('test')\nlet sm3 = Symbol('test')\nconsole.log(sm2 === sm3) // false\n</code></pre>\n<ul>\n<li>这也是Symbol最显著的特殊，可以让我们无后顾之忧的拓展对象属性，而不用担心会跟其现有的属性或方法冲突</li>\n</ul>\n<h2>Symbol.for()</h2>\n<ul>\n<li>如果都是使用上面的Symbol()来给对象赋值的的话我们就没法读取到该属性值了，如下</li>\n</ul>\n<pre><code class=\"language-js\">let a = {}\na[Symbol('test')] = 123\nconsole.log(a[Symbol('test')]) // undefined\n</code></pre>\n<ul>\n<li>因为在这里我们赋值跟取值的Symbol是完全不同的，为了避免这种情况，且能获取到对应的值我们需要使用Symbol.for()</li>\n<li>Symbol.for()方法的使用跟Symbol()的使用是一致的，可以接收一个字符串来做Symbol的唯一表示，调用该方式时，会从全局运行注册对象中查找有没有该Symbol，如果没有找到，就会生成一个Symbol对象并注册到全局运行注册对象中，然后返回该对象，如果查到了该Symbol，则直接返回该对象，所以看下示例：</li>\n</ul>\n<pre><code class=\"language-js\">let a = Symbol.for('test') // 没找到，创建实例\nlet b = Symbol.for('test') // 找到，直接返回实例\nconsole.log(a === b) // true\n\nlet c = {}\nc[Symbol.for('foo')] = 123\nconsole.log(c[Symbol.for('foo')]) // 123\n</code></pre>\n<ul>\n<li>使用Symbol()给对象赋值的方式，如下</li>\n</ul>\n<pre><code class=\"language-js\">let s1 = Symbol('foo'),\n  s2 = Symbol('bar'),\n  s3 = Symbol('baz'),\n  s4 = Symbol('qux')\nlet o = {\n  [s1]: 'foo val'\n}\nconsole.log(o) // {Symbol(foo): \"foo val\"}\nObject.defineProperty(o, s2, { value: 'bar val' })\nconsole.log(o) // {Symbol(foo): \"foo val\", Symbol(bar): \"bar val\"}\nObject.defineProperties(o, {\n  [s3]: { value: 'baz val' },\n  [s4]: { value: 'qux val' }\n})\nconsole.log(o) // {Symbol(foo): \"foo val\", Symbol(bar): \"bar val\", Symbol(baz): \"baz val\", Symbol(qux): \"qux val\"}\n</code></pre>\n<h2>Symbol.keyFor()</h2>\n<ul>\n<li>我们可以使用 Symbol.keyFor() 来检查一个Symbol实例是否存在与全局运行注册表中，该方法接收一个Symbol实例，如果全局注册表中存在该实例，则返回对应的key值，如果不存在，就会返回一个undefined，如下</li>\n</ul>\n<pre><code class=\"language-js\">Symbol.keyFor(Symbol.for('test')) // 'test'，通过Symbol.for()创建的Symbol实例会自动在注册表中注册\nSymbol.keyFor(Symbol('test')) // undefined 通过Symbol()方式创建的不会在注册表中注册，所以会返回undefined\n</code></pre>\n<h2>Object.getOwnPropertyNames() 跟 Object.getOwnPropertySymbols()</h2>\n<ul>\n<li>然后我们尝试使用 Object.getOwnPropertyNames 跟 Object.getOwnPropertySymbols 来获取一下对象o的值来看一下</li>\n</ul>\n<pre><code class=\"language-js\">Object.getOwnPropertyNames(o) // []\nObject.getOwnPropertySymbols(o) // [Symbol(foo), Symbol(bar), Symbol(baz), Symbol(qux)]\n</code></pre>\n<ul>\n<li>这里我们能看到使用 Object.getOwnPropertyNames 好像并不能获取到我们Symbol实例键，我们再给o拓展几个普通属性试试</li>\n</ul>\n<pre><code class=\"language-js\">o['baz'] = '123'\no['foo'] = '234'\n\nObject.getOwnPropertyNames(o) // [\"baz\", \"foo\"]\nObject.getOwnPropertySymbols(o) // [Symbol(foo), Symbol(bar), Symbol(baz), Symbol(qux)]\n</code></pre>\n<ul>\n<li>看到上结果我们也能知道，Object.getOwnPropertyNames 用于获取我们的常规除Symbol外的常规键值，Object.getOwnPropertySymbols 用于获取我们的Symbol键值</li>\n</ul>\n<h2>Object.getOwnPropertyDescriptors() 跟 Reflect.ownKeys()</h2>\n<ul>\n<li>然后我们再使用 Object.getOwnPropertyDescriptors() 跟 Reflect.ownKeys()来获取一下o的属性</li>\n</ul>\n<pre><code class=\"language-js\">Object.getOwnPropertyDescriptors(o) // {baz: {…}, foo: {…}, Symbol(foo): {…}, Symbol(bar): {…}, Symbol(baz): {…},Symbol(qux): {...}}\nReflect.keys(o) // [\"baz\", \"foo\", Symbol(foo), Symbol(bar), Symbol(baz), Symbol(qux)]\n</code></pre>\n<ul>\n<li>从中我们能看到 Object.getOwnPropertyDescriptors() 可以获取对象的常规值跟Symbol对应的值，Reflec.ownKeys() 可以获取对象的常规键跟Symbol键</li>\n</ul>","fields":{"slug":"/symbol/"},"frontmatter":{"title":"符号类型(symbol)","tags":["JavaScript回顾"],"categories":"JavaScript"}}},{"node":{"html":"<h1>Well-Known Symbols</h1>\n<ul>\n<li>well-known symbols 是es6引入的在整个javascript中使用的一系列方法，用于直接访问、重写、模拟语言内部的一系列行为。这些方法或者说符号以字符串属性存在于Symbol的工厂函数上。</li>\n<li>这些符号存在的主要意义就是重新定义它们用于修改原生语言中的构造函数表现形式。例如，for of 循环其实是依靠于对象原型提供的 Symbol.iterator 属性，所以我们可以通过重新定义对象的 Symbol.iterator 属性来控制它的for of 表现。</li>\n<li>well-known symbols 这些符号就是Symbol对象上的一些字符串属性，定义良好的符号都具有不可写入、不可重复、不可配置的特性。</li>\n</ul>\n<h2>Symbol.asyncIterator</h2>\n<ul>\n<li>ECMAScript规范中，此符号用于描述一个对象返回默认异步迭代对象的方法属性。当对象具有该属性则该对象是异步可迭代的，可以被 for await of 表达式调用。</li>\n<li>语言构造器例如 for await of 利用该符号对应的方法来实现异步迭代。</li>\n<li>所以我们可以对一个自定义对象添加该符号方法实现其可被for await of 调用</li>\n<li>\n<p>for await of 的调用必须在async 函数下才可以</p>\n<!--more-->\n<pre><code class=\"language-js\">var a = { a :1, b: 2 }\nasync function b(){\nfor await(var value of a) {\nconsole.log(a)\n}\n}\nb() // TypeError: a is not async iterable\n</code></pre>\n</li>\n</ul>\n<p>var a = {\na :1,\nb: 2,\n*<a href=\"\">Symbol.asyncIterator</a>{\n}\n}\nasync function b(){\nfor await(var value of a) {\nconsole.log(a)\n}\n}\nb() // Promise {<resolved>: undefined}</p>\n<pre><code>- 可以看出只要我们实现了符号对应的异步方法，就可以正常调用，下面我们可以自定义我们想要的表现形式\n\n```js\nclass Emitter {\n  constructor(max) {\n    this.max = max\n    this.asyncIdx = 0\n  }\n  async*[Symbol.asyncIterator] () {\n    while(this.asyncIdx &#x3C; this.max) {\n      if(this.asyncIdx % 2 === 0) {\n        yield new Promise(resolve => resolve(this.asyncIdx++))\n      } else {\n        yield new Promise(resolve => {\n          setTimeout(() => {\n            resolve(this.asyncIdx++)\n          }, 1000)\n        })\n      }\n    }\n  }\n}\nvar a = new Emitter(6)\nasync function b(){\n  for await(let value of a) {\n    console.log(value)\n  }\n}\nb() // 0 1 2 3 4 5 \n</code></pre>\n<h2>Symbol.hasInstance</h2>\n<ul>\n<li>在ECMAScript标准中，该符号用做决定对象是否为构造器的实例。也就是“一个方法用来决定构造函数是否识别一个对象为它的实例。在语法上由instanceof方法调用”。instanceof操作符提供了一个方法判断一个对象实例在其原型链中是否有该原型。</li>\n<li>instanceof使用如下</li>\n</ul>\n<pre><code class=\"language-js\">function Foo(){}\nlet f = new Foo()\n\nconsole.log(f instanceof Foo) // true\n</code></pre>\n<ul>\n<li>在ES6中，instanceof 操作使用 SYmbol.hasInstance 来衡量这个关系。该键对应一个函数具有跟instanceof相同的表现，但是操作方式相反，如下</li>\n</ul>\n<pre><code class=\"language-js\">function Foo(){}\nlet f = new Foo()\nconsole.log(Foo[Symbol.hasInstance](f)) // true\n</code></pre>\n<ul>\n<li>该属性被定义到了函数原型上面，所以所有的函数跟类都自动具有了该方法，因为instanceof操作符会在原型链上查找这个属性值，所以我们可以在一个继承类上来重新定义该属性。</li>\n</ul>\n<pre><code class=\"language-js\">class Bar{}\nclass Baz extends Bar{\n  static [Symbol.hasInstance] (){\n    return false\n  }\n}\n\nlet b = new Baz()\nconsole.log(Bar[Symbol.hasInstance](b)) // true\nconsole.log(b instanceof Bar) // true\nconsole.log(Baz[Symbol.hasInstance](b)) // false\nconsole.log(b instanceof Baz) // false\n</code></pre>\n<ul>\n<li>我们能看到，当我们查找是否是Bar的实例时，因为我们的构造函数就是继承自Bar，并且没有修改Bar的相关属性，所以能正常返回true。但是当我们修改了Baz的构造函数之后，再次调用Baz返回的就是我们修改后的函数值了</li>\n</ul>\n<h2>Symbol.isConcatSpreadable</h2>\n<ul>\n<li>在ECMAScript标准中，此符号用来决定一个对象在被Array.prototype.concat()方法调用的时候是否要被扁平化。Array.prototype.concat()方法在ES6中将会基于传入的类数组对象来决定如何将其与数组实例拼接。符号Symbol.isConcatSpreadable将允许你重写这个方法。</li>\n<li>数组对象在默认情况下将会被扁平化处理到当前数组中，当对应实例的Symbol.isConcatSpreadable属性为false或者falsy数据时，则数组对象会被整个塞到当前数组中。如下</li>\n</ul>\n<pre><code class=\"language-js\">let initial = ['foo']\nlet array = ['baz']\nconsole.log(initial.concat(array)) // [\"foo\", \"baz\"]\n\nlet initial = ['foo']\nlet array = ['baz']\narray[Symbol.isConcatSpreadable] = false\nconsole.log(initial.concat(array)) // [\"foo\", Array(1)]\n</code></pre>\n<ul>\n<li>类数组对象在默认情况下会被整个塞到当前数组中，类似于append表现，当我们修改其Symbol.isConcatSpreadable属性为true或者truthy时，这个对象将会被扁平化处理，然后拼接到数组中。</li>\n<li>类数组对象有两个特征，一个是length属性值为数值，一个是有数字键值，看以下表现</li>\n</ul>\n<pre><code class=\"language-js\">// 默认值\nlet arrayLikeObject = { length: 1, 0: 'baz'}\nlet initial = ['foo']\nconsole.log(initial.concat(arrayLikeObject)) // [\"foo\", {…}]\n\n// 修改后\nlet arrayLikeObject = { length: 1, 0: 'baz'}\nlet initial = ['foo']\narrayLikeObject[Symbol.isConcatSpreadable] = true\nconsole.log(initial.concat(arrayLikeObject)) // [\"foo\", \"baz\"]\n</code></pre>\n<ul>\n<li>其他的非数组或者类数组对象在设置了Symbol.isConcatSpreadable为true时都会被忽略，并不会被添加进去</li>\n</ul>\n<pre><code class=\"language-js\">let otherObject = new Set().add('qux')\nlet initial = ['foo']\nconsole.log(initial.concat(otherObject)) // [\"foo\", Set(1)]\n\nlet otherObject = new Set().add('qux')\nlet initial = ['foo']\notherObject[Symbol.isConcatSpreadable] = true\nconsole.log(initial.concat(otherObject)) // [\"foo\"]\n</code></pre>\n<h2>Symbol.iterator</h2>\n<ul>\n<li>在ECMAScript标准中，该符号用于描述一个对象返回默认迭代器对象的方法属性。当对象具有该属性则该对象是可迭代的，可以被for of 循环调用。</li>\n<li>for of 语句就是利用此符号来执行迭代，该语句将会调用Symbol.iterator对应的函数，并期望它返回一个实现了迭代器的对象，在很多场景下会返回一个生成器(一个实现了Iterator api的对象。)</li>\n</ul>\n<pre><code class=\"language-js\">class Foo{\n  *[Symbol.iterator](){}\n}\nlet f = new Foo()\nconsole.log(f[Symbol.iterator]()) // Generator {&#x3C;suspended>}\n</code></pre>\n<ul>\n<li>需要注意的是，通过Symbol.iterator生产的对象需要能够连续生产对象凭借 next() 方法。这可以通过显示声明next方法或者通过生成器函数生成。</li>\n</ul>\n<pre><code class=\"language-js\">// 显式定义next\nclass Emitter{\n  constructor(max){\n    this.max = max\n    this.idx = 0\n  }\n  [Symbol.iterator](){\n    return {\n      next:() => {\n        if(this.idx &#x3C; this.max) {\n          return { value: this.idx++, done: false}\n        } else {\n          return { done: true }\n        }\n      }\n    }\n  }\n}\nfunction count(){\n  let emitter = new Emitter(6)\n  for(let x of emitter) {\n    console.log(x)\n  }\n}\ncount() // 0 1 2 3 4 5\n\n// 生成器函数生成\nclass Emitter{\n  constructor(max){\n    this.max = max\n    this.idx = 0\n  }\n  *[Symbol.iterator](){\n    while(this.idx &#x3C; this.max) {\n      yield this.idx++\n    }\n  }\n}\n\nfunction count(){\n  let emitter = new Emitter(5)\n  for(const x of emitter) {\n    console.log(x)\n  }\n}\n\ncount()  // 0 1 2 3 4\n</code></pre>\n<h2>Symbol.match</h2>\n<ul>\n<li>ECMAScript标准中，此符号是用于描述一个字符串与正则表达式的匹配关系的方法属性。被String.prototype.match()方法调用，String.prototype.match()方法会调用Symbol.match对应的函数去计算表达式，因为正则表达式的原型上有该方法属性，所以所有的正则表达式都可以被String.prototype.mactch()方法调用。</li>\n<li>如果提供其他的非正则表达式参数给String.prototype.match()将会把参数转为正则表达式。</li>\n<li>如果要避免此行为并且想要将参数直接使用，我们可以通过为参数指定 Symbol.match 属性为函数来绕过这个限制，该函数只接受一个参数，参数为调用match方法的字符串实例，返回值为任意类型。</li>\n</ul>\n<pre><code class=\"language-js\">// 正常情况\nvar a = {}\n'123123'.match(a) // null\n\n// 添加值\nvar a = {}\nObject.prototype[Symbol.match] = string => string.includes('123')\n'123123'.match(a) // true\n</code></pre>\n<ul>\n<li>上面我们就是为对象指定了Symbol.match属性，所以但我们传递进去对象值时都会返回true</li>\n</ul>\n<h2>Symbol.replace</h2>\n<ul>\n<li>ECMAScript标准中，此符号是用于描述“替换字符串中匹配到的子字符串的一个正则表达式方法，被String.prototype.replace()方法调用”</li>\n<li>String.prototype.replace将会调用参数上的Symbol.replace对应的方法来进行表达式计算</li>\n<li>正则表达式原型有Symbol.replace方法，所以所有的正则表达式都可以被replace方法调用。</li>\n<li>同样的，如果传入的是非正则类型，则会被强制转为正则类型。我们可以通过为入参定义Symbol.replace方法来绕过并重新定义行为</li>\n<li>定义的方法有两个参数，一个是原始字符串，一个是要替换的字符串</li>\n</ul>\n<pre><code class=\"language-js\">// 原表现形式\nclass Test{\n  constructor(str){\n    this.str = str\n  }\n}\n\"aaasdasddd\".replace(new Test('asd'), '123') // 'aaasdasddd'\n\n// 重新定义属性\nclass Test{\n  constructor(str){\n    this.str = str\n  }\n  [Symbol.replace] = (str, replaceStr) => str.split(this.str).join(replaceStr)\n}\n\"aaasdasddd\".replace(new Test('asd'), '123') // 'aa123123dd'\n</code></pre>\n<ul>\n<li>上面我们就实现了传递一个非正则对象给replace方法并成功完成我们想要的展示形式</li>\n</ul>\n<h2>Symbol.search</h2>\n<ul>\n<li>在ECMAScript规范中，该符号用来描述“一个用来返回字符串中符合对应正则表达式的字符串的位置，被String.prototype.search()方法调用”</li>\n<li>String.prototype.search将会调用参数上的Symbol.search对应的方法来进行表达式计算</li>\n<li>正则表达式原型有Symbol.search方法属性，所以所有的正则表达式都可以被search方法调用。</li>\n<li>同样的，如果传入的是非正则类型，则会被强制转为正则类型。我们可以通过为入参定义Symbol.search方法来绕过并重新定义行为</li>\n<li>定义的方法只有一个参数，就是对应的字符串实例，返回值为任意类型</li>\n</ul>\n<pre><code class=\"language-js\">// 原表现形式\nclass Search{\n  constructor(str){\n    this.str = str\n  }\n}\n\"hahaha\".search(new Search('ha')) // -1\n\n// 重新定义属性\nclass Search{\n  constructor(str){\n    this.str = str\n  }\n  [Symbol.replace] = (str) => str.indexOf(this.str)\n}\n\"hahaha\".replace(new Search('ha')) // 0\n</code></pre>\n<h2>Symbol.species</h2>\n<ul>\n<li>该符号被构建函数调用创造派生实例</li>\n<li>在构造类中声明静态getter方法Symbol.species将会覆盖新创建实例原型的构建函数</li>\n<li>当我们调用map方法或者concat方法时会默认返回对应实例的默认构造函数，如果我们这里通过声明getter方法Symbol.species来将其修改为其他构建对象，那在map或concat方法后返回的对象类型就会发生变化</li>\n</ul>\n<pre><code class=\"language-js\">class Bar extends Array {}\nvar b = new Bar(1, 2, 3)\nconsole.log(b instanceof Array) // true\nconsole.log(b instanceof Bar) // true\n\n// 添加getter方法\nclass Baz extends Array {\n  static get [Symbol.species] () {\n    return Number\n  }\n}\nvar c = new Baz(1, 2, 3)\nconsole.log(c instanceof Array)   // true\nconsole.log(c instanceof Baz)     // true\nconsole.log(c instanceof Number)  // false\n\nconsole.log(c.concat(c) instanceof Array)   // false\nconsole.log(c.concat(c) instanceof Baz)     // false\nconsole.log(c.concat(c) instanceof Number)  // true\n</code></pre>\n<ul>\n<li>从上面我们可以看出，声明getter方法Symbol.species后，对单独的实例不会有影响，但是当返回默认的构造函数时，就会使用我们Symbol.species中返回的构造函数了</li>\n</ul>\n<h2>Symbol.split</h2>\n<ul>\n<li>该符号用于描述“一个用于在匹配正则表达式的位置进行字符串分割的正则表达式方法，被String.prototype.split()方法调用”</li>\n<li>String.prototype.split将会调用入参对象的Symbol.split属性方法来进行表达式计算。</li>\n<li>正则表达式原型有Symbol.split方法属性，所以所有的正则表达式都可以被split方法调用。</li>\n<li>同样的，如果传入的是非正则类型，则会被强制转为正则类型。我们可以通过为入参定义Symbol.split方法来绕过并重新定义行为</li>\n<li>定义的方法只有一个参数，就是对应的字符串实例，返回值为任意类型</li>\n</ul>\n<pre><code class=\"language-js\">// 原表现形式\nclass Split{\n  constructor(str){\n    this.str = str\n  }\n}\n\"123hahaha123\".split(new Split('ha')) // [\"123hahaha123\"]\n\n// 重新定义属性\nclass Split{\n  constructor(str){\n    this.str = str\n  }\n  [Symbol.split](target){\n    console.log(123, target, this.str)\n    return target.split(this.str)\n  }\n}\n\"123hahaha123\".split(new Split('ha')) // [\"123\", \"\", \"\", \"123\"]\n</code></pre>\n<h2>Symbol.toPrimitive</h2>\n<ul>\n<li>该符号用于描述“一个将对象转换为常规数据类型的方法，被强制类型操作符所调用”。很多内置操作符都会尝试将对象转为基本数据类型，例如：string类型、number类型、number类型，或者其他的基本类型。</li>\n<li>对一个自定义的对象，我们可以通过定义它的Symbol.toPrimitive属性来决定它的强制类型转换方式。该方法接收一个它原本会被转换为的数据类型的类型字符串名称，所以我们根据这个情况构造我们想要的形式</li>\n</ul>\n<pre><code class=\"language-js\">// 原始类型\nclass Foo{}\nlet foo = new Foo()\nconsole.log(3 + foo) // \"3[object Object]\"\nconsole.log(3 - foo)  // NaN\nconsole.log(String(foo))  // \"[object Object]\"\n\n// 自定义表现形式\nclass Bar {\n  constructor(){\n    this[Symbol.toPrimitive] = function (hint){\n      switch(hint) {\n        case 'string':\n          return 'string bar'\n        case 'number':\n          return 3\n        case 'default':\n        default:\n          return 'default bar'\n      }\n    }\n  }\n}\nlet bar = new Bar()\nconsole.log(3 + bar) // 3default bar\nconsole.log(3 - bar)  // 0\nconsole.log(String(bar))  // string bar\n</code></pre>\n<ul>\n<li>上面我们可以看到，当对象遇到 + 操作符时它无法确定要执行字符串拼接的 + 操作还是数值的相加 + 操作，所以就返回了默认的 default bar;当对象遇到 - 操作时明确的知道自己要被转为数值类型，所以走了 case 'number' ，返回了3，然后被执行操作；当预定String()方法时也明确的知道自己要返回字符串类型，所以返回了 string bar</li>\n</ul>\n<h2>Symbol.toStringTag</h2>\n<ul>\n<li>该符号用于描述“一个对象的创建对象类型的默认字符串描述，被Object.prototype.toString所调用”，该创建对象的字符串描述会依靠Symbol.toStringTag方法来获取，默认为\"Object\"</li>\n<li>内置类型都有声明这个属性方法，但是自定义对象就需要我们显式声明了</li>\n</ul>\n<pre><code class=\"language-js\">// 内置对象\nvar s = new Set()\nconsole.log(s)                      // Set(0) {}\nconsole.log(s.toString())           // [object Set]\nconsole.log(s[Symbol.toStringTag])  // Set\n// 自定义对象\nclass Foo{}\nvar f = new Foo()\nconsole.log(f)                      // Foo {}\nconsole.log(f.toString())           // [object Object]\nconsole.log(f[Symbol.toStringTag])  // undefined\n\n// 修改后的自定义对象\nclass Bar{\n  constructor(){\n    this[Symbol.toStringTag] = 'Bar'\n  }\n}\nvar b = new Bar()\nconsole.log(b)                      // Bar {Symbol(Symbol.toStringTag): \"Bar\"}\nconsole.log(b.toString())           // [object Bar]\nconsole.log(b[Symbol.toStringTag])  // Bar\n</code></pre>\n<h2>Symbol.unscopables</h2>\n<ul>\n<li>该符号用于描述“防止被width操作绑定到该对象的自有属性或者继承属性”，设置这个属性将指定键值改为true则with方法将无法在该对象上查找指定属性</li>\n</ul>\n<pre><code class=\"language-js\">// 正常形式\nvar o = { foo: 'asd' }\nwith(o) {\n  console.log(foo) // 'asd'\n}\n\n// 自定义后\nvar o = { foo: 'asd' }\no[Symbol.unscopables] = {\n  foo: true\n}\nwith(o) {\n  console.log(foo)  // Uncaught ReferenceError: foo is not defined\n}\n</code></pre>\n<ul>\n<li>新的ECMAScript规范中已经不推荐使用with方法了，所以，我们的Symbol.unscopables也不再推荐使用</li>\n</ul>","fields":{"slug":"/well-known-symbol/"},"frontmatter":{"title":"Well-Known Symbols","tags":["JavaScript回顾"],"categories":"JavaScript"}}},{"node":{"html":"<h1>Date 类型</h1>\n<ul>\n<li>Date构造函数可以接收毫秒数来创建时间对象，对此提供了辅助函数来进行毫秒数的获取</li>\n</ul>\n<h2>Date.parse()</h2>\n<ul>\n<li>\n<p>该方法接收一个表示日期的字符串，并转为对应的毫秒数，接受的格式如下</p>\n<ul>\n<li>\"月/日/年\"，如\"5/23/2019\"</li>\n<li>\"月名日,年\"，如\"May 23, 2019\"</li>\n<li>\"周几月名日年时:分:秒:时区\"，如\"Tue May 23 2020 00:00:00 GMT-0700\"</li>\n<li>拓展格式\"YYYY-MM-DDTHH:mm:ss.sssZ\"，如：\"2020-05-23T00:00:00\"</li>\n</ul>\n</li>\n<li>使用方式如下</li>\n</ul>\n<pre><code class=\"language-js\">let time1 = new Date(Date.parse(\"May 23, 2020\"))\n// Sat May 23 2020 00:00:00 GMT+0800 (中国标准时间)\n</code></pre>\n<ul>\n<li>如果传给Date.parse()的字符串不能表示时间该方法返回NaN</li>\n<li>如果在给new Date()传参时直接传了表示时间的字符串，那Date会在后台隐式调用Date.parse()，下代码与上面同样</li>\n</ul>\n<pre><code class=\"language-js\">let time1 = new Date(\"May 23, 2020\")\n// Sat May 23 2020 00:00:00 GMT+0800 (中国标准时间)\n</code></pre>\n<ul>\n<li>\n<p>关于越界时间，当我们传了一个不存在的时间比如3月32号时部分浏览器会返回4月1号的时间，有些浏览器则会直接返回当前时间，比如你在5月1日运行代码就会返回5月1号的时间</p>\n<!--more-->\n<h2>Date.UTC()</h2>\n</li>\n<li>这个方法也是用于返回日期的毫秒数，但是参数不一样，参数是年，零起点的月数（也就是1月用0表示，2月用1表示，依次类推），日，时（0-24），分，秒，毫秒</li>\n<li>只有年跟月是必须，其他的不填都默认为0，使用方式如下</li>\n</ul>\n<pre><code class=\"language-js\">let time2 = new Date(Date.UTC(2020, 09, 12, 15, 44, 03))\n// Mon Oct 12 2020 23:44:03 GMT+0800 (中国标准时间)\n</code></pre>\n<ul>\n<li>可以看到其实会被我们的参数当做UTC时间来做解析，最后得到的是本地的 23：44</li>\n<li>当我们在new Date()的时候使用Date.UTC形式的参数，那Date也会隐式调用Date.UTC()，但是不同的是不会被当做UTC时间处理而是当做本地时间处理，如下</li>\n</ul>\n<pre><code class=\"language-js\">let time2 = new Date(2020, 09, 12, 15, 44, 03)\n// Mon Oct 12 2020 15:44:03 GMT+0800 (中国标准时间)\n</code></pre>\n<h2>Date原型方法</h2>\n<ul>\n<li>Date对象重写了toString、valueOf、toLocalString方法</li>\n<li>toLocalString与toString，两个方法分别返回对应的GMT时间与本地时间，如下</li>\n</ul>\n<pre><code class=\"language-js\">new Date().toLocaleString()\n// \"2020/10/12 下午3:53:58\"\nnew Date().toString()\n// \"Mon Oct 12 2020 15:54:04 GMT+0800 (中国标准时间)\"\n</code></pre>\n<ul>\n<li>valueOf方法会返回对应时间的毫秒数，数字类型</li>\n</ul>\n<pre><code class=\"language-js\">new Date().valueOf()\n// 1602489459169\n</code></pre>\n<ul>\n<li>\n<p>Date格式时间的方法</p>\n<ul>\n<li>toDateString()，显示时间中的周几、月、日、年</li>\n<li>toTimeString()，显示时间中的时、分、秒、时区</li>\n<li>toLocalDateString()，获取本地时间的周几、月、日、年</li>\n<li>toLocalTimeString()，获取本地时间的时、分、秒、时区</li>\n<li>toUTCString()，显示完整的UTC时间</li>\n</ul>\n</li>\n</ul>","fields":{"slug":"/Date/"},"frontmatter":{"title":"Date类型","tags":["JavaScript回顾"],"categories":"JavaScript"}}},{"node":{"html":"<h1>Number 类型</h1>\n<ul>\n<li>Number对象也重写了toString、toLocalString、valueOf方法</li>\n<li>valueOf返回原数值</li>\n<li>toString()接收一个参数用于表示该数字的几进制数，如下</li>\n</ul>\n<pre><code class=\"language-js\">let num = 10\nconsole.log(num.toString()) // '10'\nconsole.log(num.toString(2)) // '1010'\nconsole.log(num.toString(8)) // '12'\nconsole.log(num.toString(10)) // '10'\nconsole.log(num.toString(16)) // 'a'\n</code></pre>\n<ul>\n<li>toExponential()用于表示数值的科学技术法的表示字符串</li>\n</ul>\n<pre><code class=\"language-js\">console.log(num.toExponential()) // 1e+1\n</code></pre>\n<ul>\n<li>\n<p>toPrecision()会根据你传入的参数决定输出结果，该参数表示结果中的数字的位数，如下</p>\n<!--more-->\n<pre><code class=\"language-js\">let num1 = 99\nconsole.log(num1.toPrecision(1)) // 1e+2\nconsole.log(num1.toPrecision(2)) // 99\nconsole.log(num1.toPrecision(3)) // 99.0\n</code></pre>\n</li>\n<li>ES6新增isInteger()用于判断是否是整数</li>\n</ul>\n<pre><code class=\"language-js\">console.log(Number.isInteger(1)) // true\nconsole.log(Number.isInteger(1.00)) // true\nconsole.log(Number.isInteger(1.01)) // false\n</code></pre>\n<ul>\n<li>该方法不会受到小数点后都是0的影响</li>\n<li>IEEE 754数值格式有一个特殊的数值范围，此范围内的二进制值可表示一个整数，该范围为Number.MIN<em>SAFE</em>INTEGER((-2) ** 53 + 1) 到 Number.MAX<em>SAFE</em>INTEGER(2 ** 53 - 1)</li>\n<li>超出这个范围的值在保存为整数时数值可能会变化，所以我们可以通过 Number.isSafeInteger()来判断一个整数是否在该范围内</li>\n</ul>\n<pre><code class=\"language-js\">console.log(Number.isSafeInteger(-1 * (2 ** 53))) // false\nconsole.log(Number.isSafeInteger(-1 * (2 ** 53) + 1)) // true\n</code></pre>","fields":{"slug":"/Number/"},"frontmatter":{"title":"Number类型","tags":["JavaScript回顾"],"categories":"JavaScript"}}},{"node":{"html":"<h1>String类型</h1>\n<ul>\n<li>字符串由16位码元组成，多数字符都是16位码元对应一个字符，length属性就是表示有多少个16位码元</li>\n<li>charAt()方法返回给定索引位置的字符，参数为索引位置</li>\n<li>javascript采用UCS-2和UTF-16两种Unicode编码混合策略，对于(U+0000~U+FFFF)，这两种编码是一样的</li>\n<li>charCodeAt()可以查看对应索引位置的字符编码，参数为索引位置</li>\n<li>fromCharCode()可以根据给定的UTF-16码元创建字符串，然后将其拼接返回</li>\n</ul>\n<pre><code class=\"language-js\">let message = 'abcde'\nconsole.log(message.charAt(2)) // 'c'\nconsole.log(message.charCodeAt(2)) // 99\n// 可以16进制入参\nconsole.log(String.fromCharCode(0x61, 0x62, 0x63, 0x64, 0x65)) // \"abcde\"\nconsole.log(String.fromCharCode(97, 98, 99, 100, 101)) // \"abcde\"\n</code></pre>\n<ul>\n<li>对于在U+0000~U+FFFF范围内的字符，length、charAt()、charCodeAt()、fromCharCode()都可以正常运行</li>\n<li>当拓展到Unicode增补字符平面就不行了，上面的16位只能标识65536个字符，这些表示基本多语言平面，为了表示更多的字符，采用了每个字符使用另外16位去选择一个增补平面。这种每个字符使用两个16位码元的策略称为代理对</li>\n<li>\n<p>当我们对含有代理对编码的字符串就会有问题，如下</p>\n<!--more-->\n<pre><code class=\"language-js\">let message = 'ab😊de'\nconsole.log(message.length)     // 6\nconsole.log(message.charAt(1))  // b\nconsole.log(message.charAt(2))  // �\nconsole.log(message.charAt(3))  // �\nconsole.log(message.charAt(4))  // d \nconsole.log(message.charCodeAt(1))  // 98\nconsole.log(message.charCodeAt(2))  // 55357\nconsole.log(message.charCodeAt(3))  // 56842\nconsole.log(message.charCodeAt(4))  // 100\n</code></pre>\n</li>\n</ul>\n<p>console.log(String.fromCharCode(97, 98, 55357, 56842, 100, 101)) // ab😊de</p>\n<pre><code>- 这里我们能看到笑脸符明显占了两个字符，然后我们尝试使用fromCharCode()来将代理对进行解析为字符串是没有问题的，这是因为浏览器可以正常解析代理对\n- 针对这种情况，我们可以使用codePointAt()来替代charCodeAt()\n- codePointAt()使用方法跟charCodeAt()基本一致，也是接受一个表示索引的参数并返回该索引的码点。码点是Unicode中一个字符的完整标识，可能是16位，也有可能32位，codePointAt()可以查看完整的码点\n\n```js\nlet message = 'ab😊de'\nconsole.log(message.codePointAt(1))  // 98\nconsole.log(message.codePointAt(2))  // 128522\nconsole.log(message.codePointAt(3))  // 56842\nconsole.log(message.codePointAt(4))  // 100\n</code></pre>\n<ul>\n<li>我们可以通过字符串解析来识别代理对，如下</li>\n</ul>\n<pre><code class=\"language-js\">let message = 'ab😊de'\nconsole.log([...message]) // [\"a\", \"b\", \"😊\", \"d\", \"e\"]\n</code></pre>\n<ul>\n<li>这样就将我们的代理对给完整解析了</li>\n<li>对应的，我们也有fromCodePoint()来讲对应的码点转为字符串，并拼接返回</li>\n</ul>\n<pre><code class=\"language-js\">// 使用 fromCharCode要有6位数字才可以\nconsole.log(String.fromCharCode(97, 98, 55357, 56842, 100, 101)) // ab😊de\n// 使用 fromCodePoint\nconsole.log(String.fromCodePoint(97, 98, 128522, 100, 101)) // ab😊de\n</code></pre>\n<h2>normalize 方法</h2>\n<ul>\n<li>该方法针对一些可以使用多种编码方式表达的unicode字符，比如下面字符</li>\n</ul>\n<pre><code class=\"language-js\">// 上面带圆圈的 A\nconsole.log(String.fromCharCode(0x00C5))          // Å\n// 长度单位 “埃”\nconsole.log(String.fromCharCode(0x212B))          // Å\n// U+004大写字符 A, U+030A 上面的圆圈\nconsole.log(String.fromCharCode(0x0041, 0x030A))  // Å\n</code></pre>\n<ul>\n<li>上面三种编码返回的字符串看上去是一样的，其实编码不一样，所以比较起来也不会一样</li>\n</ul>\n<pre><code class=\"language-js\">let a1 = String.fromCharCode(0x00C5),\na2 = String.fromCharCode(0x212B),\na3 = String.fromCharCode(0x0041, 0x030A)\nconsole.log(a1 === a2)  // false\nconsole.log(a1 === a3)  // false\nconsole.log(a2 === a3)  // false\n</code></pre>\n<ul>\n<li>针对上情况，Unicode提供了4种格式化方法，将类似上面的字符串转为一致格式，分别是NFD、NFC、NFKD、NFKC</li>\n<li>然后我们就可以使用normalize方法跟对应的优化方法名称来进行格式化</li>\n</ul>\n<pre><code class=\"language-js\">let a1 = String.fromCharCode(0x00C5),\na2 = String.fromCharCode(0x212B),\na3 = String.fromCharCode(0x0041, 0x030A)\n\n// U+005C是对U+212B进行NFC/NFKC规范之后的结果\nconsole.log(a1 === a1.normalize('NFD')) // false\nconsole.log(a1 === a1.normalize('NFC')) // true\nconsole.log(a1 === a1.normalize('NFKD')) // false\nconsole.log(a1 === a1.normalize('NFKC')) // true\n\n// U+212B是未规范化的\nconsole.log(a2 === a2.normalize('NFD')) // false\nconsole.log(a2 === a2.normalize('NFC')) // false\nconsole.log(a2 === a2.normalize('NFKD')) // false\nconsole.log(a2 === a2.normalize('NFKC')) // false\n\n// U+0041/U+030A是对U+212B进行NFD/NFKD规范之后的结果\nconsole.log(a3 === a3.normalize('NFD')) // true\nconsole.log(a3 === a3.normalize('NFC')) // false\nconsole.log(a3 === a3.normalize('NFKD')) // true\nconsole.log(a3 === a3.normalize('NFKC')) // false\n</code></pre>\n<ul>\n<li>当对上述编码采用同样的规范方式可以让比较操作符返回正确结果</li>\n</ul>\n<pre><code class=\"language-js\">let a1 = String.fromCharCode(0x00C5),\na2 = String.fromCharCode(0x212B),\na3 = String.fromCharCode(0x0041, 0x030A)\n\nconsole.log(a1.normalize(\"NFD\") === a2.normalize(\"NFD\")) // true\nconsole.log(a1.normalize(\"NFKC\") === a3.normalize(\"NFKC\")) // true\nconsole.log(a2.normalize(\"NFC\") === a3.normalize(\"NFC\")) // true\n</code></pre>\n<h2>slice、substr、substring对比</h2>\n<ul>\n<li>这三种方法都是从字符串中提取子字符串</li>\n<li>都接收一个或两个参数，第一个参数为开始位置</li>\n<li>slice跟substring第二个参数为提取结束的位置，该位置之前的字符串都会被提取</li>\n<li>substr第二个参数表示要提取的字符串的长度</li>\n<li>忽略第二个参数这三个方法的返回值一致，都会提取到字符串尾</li>\n</ul>\n<pre><code class=\"language-js\">let stringValue = 'hello world'\nconsole.log(stringValue.slice(3))      //  'lo world'\nconsole.log(stringValue.substring(3))  //  'lo world'\nconsole.log(stringValue.substr(3))     //  'lo world'\nconsole.log(stringValue.slice(3, 7))      //  'lo w'\nconsole.log(stringValue.substring(3, 7))  //  'lo w'\nconsole.log(stringValue.substr(3, 7))     //  'lo worl'\n</code></pre>\n<ul>\n<li>当参数为负数时，slice会将所有负数跟字符串长度相加作为新的参数</li>\n<li>substr会将第一个负数参数与字符串长度相加，第二个负数参数转为0</li>\n<li>substring会将所有的负数参数转为0，会将小的参数作为起点，大的参数作为终点</li>\n</ul>\n<pre><code class=\"language-js\">let stringValue = 'hello world'\nconsole.log(stringValue.slice(-3))      //  'rld'\nconsole.log(stringValue.substring(-3))  //  'hello world'\nconsole.log(stringValue.substr(-3))     //  'rld'\nconsole.log(stringValue.slice(3, -4))      //  'lo w'\nconsole.log(stringValue.substring(3, -4))  //  'hel'\nconsole.log(stringValue.substr(3, -4))     //  ''\n</code></pre>\n<h2>indexOf与lastIndexOf</h2>\n<ul>\n<li>都是查找指定字符串，接受两个参数，第一个是查找字符串，第二个是起始位置</li>\n<li>indexOf默认从0开始向后找，指定第二个参数后会从第二个参数指定的下标开始找，忽略该下标之前的字符</li>\n<li>lastIndexOf默认从字符串最后一位开始向前找，指定第二个参数则会从参数指定的下标向前找，忽略该下标之前的字符</li>\n</ul>\n<h2>startsWith、endsWith、includes</h2>\n<ul>\n<li>ES6新增用于判断字符串中是否包含另外字符串的方法，都返回布尔值</li>\n<li>startsWith检查开始于索引0的匹配项</li>\n<li>endsWith检查开始于索引(string.length - subString.length)的匹配项</li>\n<li>includes检查整个字符串</li>\n</ul>\n<pre><code class=\"language-js\">let message = 'foobarbaz'\n\nconsole.log(message.startsWith('foo')) // true\nconsole.log(message.startsWith('bar')) // false\n\nconsole.log(message.endsWith('baz')) // true\nconsole.log(message.endsWith('bar')) // false\n\nconsole.log(message.includes('bar')) // true\nconsole.log(message.includes('foo')) // true\n</code></pre>\n<ul>\n<li>startsWith与includes可接收第二个参数，用于表示开始查找的位置，传入该参数会忽略该参数之前的字符</li>\n<li>endsWith也可以接收第二个参数，用于表示字符串末尾的位置，传入该参数就好像将被查找字符串截断了一样</li>\n</ul>\n<pre><code class=\"language-js\">let message = 'foobarbaz'\n\nconsole.log(message.startsWith('foo')) // true\nconsole.log(message.startsWith('foo', 1)) // false\n\nconsole.log(message.includes('bar')) // true\nconsole.log(message.includes('bar', 4)) // false\n\nconsole.log(message.endsWith('bar')) // false\nconsole.log(message.endsWith('bar', 6)) // true\n</code></pre>\n<h2>trim、trimRight、trimLeft</h2>\n<ul>\n<li>分别用于去除两端的空格、右面的空格、左面的空格</li>\n</ul>\n<h2>repeat方法</h2>\n<ul>\n<li>接收一个整数参数，表示将该字符串复制多少次然后拼接返回</li>\n</ul>\n<pre><code class=\"language-js\">let stringValue = 'na '\nconsole.log(stringValue.repeat(8)) // 'na na na na na na na na '\n</code></pre>\n<h2>padStart、padEnd方法</h2>\n<ul>\n<li>这两个方法会复制字符串，如果小于指定字符串，则在相应的一边填充字符，直到满足条件，第一个参数是长度，第二个参数是可选的填充字符串，默认为空格</li>\n</ul>\n<pre><code class=\"language-js\">let stringValue = 'foo'\nconsole.log(stringValue.padStart(6))      // '   foo'\nconsole.log(stringValue.padStart(6, '.')) // '...foo'\nconsole.log(stringValue.padEnd(6))        // 'foo   '\nconsole.log(stringValue.padEnd(6, '.'))   // 'foo...'\n</code></pre>\n<ul>\n<li>要是第二个参数指定的是多个字符的字符串，那么在复制后如果长度超出会把参数指定的字符串裁剪</li>\n<li>如果第一个参数指定的长度小于等于原始字符串长度，则返回原始字符串</li>\n</ul>\n<pre><code class=\"language-js\">let stringValue = 'foo'\nconsole.log(stringValue.padStart(8, 'bar')) // 'barbafoo'\nconsole.log(stringValue.padStart(2))        // 'foo'\nconsole.log(stringValue.padEnd(8, 'bar'))   // 'foobarba'\nconsole.log(stringValue.padEnd(2))          // 'foo'\n</code></pre>\n<h2>字符串解析与迭代</h2>\n<ul>\n<li>字符串原型暴露了 @@iterator方法，所以字符串可以被解析与迭代，如下</li>\n</ul>\n<pre><code class=\"language-js\">let a = 'abcde'\nfor(const c of a) {\n  console.log(c)\n}\n// a\n// b\n// c\n// d\n// e\nconsole.log([...a])\n// [\"a\", \"b\", \"c\", \"d\", \"e\"]\n</code></pre>\n<h2>toLowerCase、toUpperCase、toLocalLowerCase、toLocalUpperCase</h2>\n<ul>\n<li>都是用于进行大小写转换的，toLowerCase与toLocalLowerCase都是将字符串转为小写字母表示，toLocalLowerCase是为了防止出现地方字符无法转换的情况</li>\n<li>toUpperCase与toLocalUpperCase都是将字符串转为大写字母表示，toLocalUpperCase是为了防止出现地方字符无法转换的情况</li>\n</ul>\n<h2>match、search、replace方法</h2>\n<ul>\n<li>match方法接收一个正则表达式或正则表达式字符串，返回一个数组，第一个元素是与正则匹配的字符串，其余的元素是表达式中的捕获组匹配到的字符串('()'中的内容)</li>\n<li>search方法是查找方法，也是接收一个正则表达式或者正则表达式字符串，返回匹配到的第一个的索引，没有找到返回-1</li>\n<li>replace是替换方法，接受两个参数，第一个参数是正则表达式或者字符串（该字符串时不会转为正则表达式），第二个参数是字符串或者函数。当地一个参数为字符串时只会替换查找到的第一个字符串，要想全部替换必须用正则表达式</li>\n</ul>\n<pre><code class=\"language-js\">let text = 'cat, bat, sat, fat'\nconsole.log(text.replace('at', 'ond'))    // cond, bat, sat, fat\nconsole.log(text.replace(/at/g, 'ond'))   // cond, bond, sond, fond\nconsole.log(text.replace(/(.at)/g, 'word ($1)')) // word (cat), word (bat), word (sat), word (fat)\n</code></pre>\n<ul>\n<li>第二个参数为函数时，当匹配项只有一个时，有三个参数，整个模式匹配的字符串、匹配字符串的开始位置、整个字符串。</li>\n<li>当有多个捕获组的情况下，每个匹配的捕获组的字符串也会被当做参数，最后两个参数仍然是匹配字符串的开始位置、整个字符串</li>\n<li>这个函数应该返回一个字符串，表示把匹配项换成什么</li>\n</ul>\n<h2>split方法</h2>\n<ul>\n<li>split会根据传入的参数将字符串转为数组，参数可以是字符串，也可以是RegExp对象。还可以接收第二个参数来表示数组大小，确保数组不会超过指定大小</li>\n</ul>\n<pre><code class=\"language-js\">let color = 'red,blue,green,yellow'\nconsole.log(color.split(','))     // [\"red\", \"blue\", \"green\", \"yellow\"]\nconsole.log(color.split(',', 2))  // [\"red\", \"blue\"]\nconsole.log(color.split(/[^,]+/)) // [\"\", \",\", \",\", \",\", \"\"]\n</code></pre>\n<h2>localeCompare方法</h2>\n<ul>\n<li>用于比较字符串</li>\n<li>按照字母排序，如果字符串应该排在字符串参数之前，返回负数</li>\n<li>字符串与参数字符串相同，返回0</li>\n<li>字符串应该在字符串参数之后，返回正数</li>\n</ul>\n<pre><code class=\"language-js\">let stringValue = 'yellow'\nconsole.log(stringValue.localeCompare('brick'))   // 1\nconsole.log(stringValue.localeCompare('yellow'))  // 0\nconsole.log(stringValue.localeCompare('zoo'))     // -1\n</code></pre>","fields":{"slug":"/String/"},"frontmatter":{"title":"String类型","tags":["JavaScript回顾"],"categories":"JavaScript"}}},{"node":{"html":"<h1>Global对象及方法</h1>\n<h2>encodeURI、encodeURIComponent</h2>\n<ul>\n<li>这两个方法都是用于编码统一资源标识符（URI），以传给浏览器</li>\n<li>区别是encodeURI不会编码属于URL组件的特殊字符，如冒号、斜杠、问号、井号，而encodeURIComponent会编码所有的非标准字符</li>\n<li>所以一般我们会使用encodeURIComponent</li>\n<li>它们分别对应的解码方法时decodeURI与decodeURIComponent</li>\n</ul>\n<h2>eval</h2>\n<ul>\n<li>eval接收一个完整的要执行的ECMAScript字符串，当解释器发现eval()方法时会将其解释为真实的ECMAScript语句</li>\n<li>然后将其插入当前位置，插入的语句属于该调用的执行上下文，被执行语句与该上下文有同样的作用域链</li>\n</ul>\n<pre><code class=\"language-js\">let msg = 'hello'\neval(\"console.log(msg)\") // 'hello'\n</code></pre>\n<!--more-->\n<ul>\n<li>可以在eval中定义函数或变量，然后在外面引用</li>\n</ul>\n<pre><code class=\"language-js\">eval(\"function sayHi(){ console.log('hi')}\")\nsayHi() // hi\n\neval(\"let msg = 'world'\")\nconsole.log(msg) // msg is not defined\n</code></pre>\n<ul>\n<li>这是因为eval中的变量跟函数都无法被提升，只有到执行之后才会被创建，所以函数可以正常执行，但是变量在编译阶段就会报错</li>\n<li>在严格模式下使用eval会报错</li>\n</ul>\n<h2>Math对象</h2>\n<ul>\n<li>Math.E,自然对数的基数e的值</li>\n<li>Math.LN10，10为底的自然对数</li>\n<li>Math.LN2，2为底的自然对数</li>\n<li>Math.LOG2E，以2为底e的对数</li>\n<li>Math.LOG10E，以10为底e的对数</li>\n<li>Math.PI，数字π</li>\n<li>Math.SQRT1_2，1/2的平方根</li>\n<li>Math.SQRT2，2的平方根</li>\n</ul>\n<h3>min和max方法</h3>\n<ul>\n<li>min，确定一组数值的最小值</li>\n<li>max，确定一组数值的最大值</li>\n</ul>\n<pre><code class=\"language-js\">console.log(Math.min(3, 8, 4, 12, 66,44, 66, 77)) // 3\nconsole.log(Math.max(3, 8, 4, 12, 66,44, 66, 77)) // 77\n</code></pre>\n<ul>\n<li>由接受参数形式可以对数组解构来获取最大最小值</li>\n</ul>\n<pre><code class=\"language-js\">let arr = [3, 8, 4, 12, 66,44, 66, 77]\nconsole.log(Math.min(...arr)) // 3\nconsole.log(Math.max(...arr)) // 77\n</code></pre>\n<ul>\n<li>其他方法</li>\n<li>Math.abs()，返回绝对值</li>\n<li>Math.exp(x)，返回MATH.E的x次幂</li>\n<li>Math.expm1(x)，Math.exp(x) - 1</li>\n<li>Math.log(x)，返回x的自然对数</li>\n<li>Math.log1p(x)，等于1 + Math.log(x)</li>\n<li>Math.pow(x, power)，返回x的power次幂</li>\n<li>Math.hypot(...nums)，返回nums中每个数平方和的平方根</li>\n<li>Math.clz32(x)，返回32位整数x的前置0的数量</li>\n<li>Math.sign(x)，返回表示x符号的1，0，-0，-1</li>\n<li>Math.trunc(x)，返回x的整数部分，删除所有小数部分</li>\n<li>Math.sqrt(x)，返回x的平方根</li>\n<li>Math.cbrt(x)，返回x的立方根</li>\n<li>Math.acos(x)，返回x的反余弦</li>\n<li>Math.acosh(x)，返回x的反双曲余弦</li>\n<li>Math.asin(x)，返回x的反正弦</li>\n<li>Math.asinh(x)，返回x的双反曲正弦</li>\n<li>Math.atan(x)，返回x的反正切</li>\n<li>Math.atanh(x)，返回x的双反曲正切</li>\n<li>Math.atan2(y, x)，返回y/x的反正切</li>\n<li>Math.cos(x)，返回x的余弦</li>\n<li>Math.sin(x)，返回x的正弦</li>\n<li>Math.tan(x)，返回x的正切</li>\n</ul>","fields":{"slug":"/Global/"},"frontmatter":{"title":"Global对象","tags":["JavaScript回顾"],"categories":"JavaScript"}}}]}},"pageContext":{}},"staticQueryHashes":["2566592090"]}