{"data":{"allMarkdownRemark":{"totalCount":5,"edges":[{"node":{"html":"<h1>字符串排列 (No repeats please)</h1>\n<h2>题目链接</h2>\n<ul>\n<li><a href=\"https://freecodecamp.cn/challenges/no-repeats-please\">中文链接</a></li>\n<li><a href=\"https://freecodecamp.com/challenges/no-repeats-please\">英文链接</a></li>\n</ul>\n<h2>问题解释</h2>\n<ul>\n<li>这个 <code>function</code> 接收一个字符串参数 <code>str</code>。返回值为参数 <code>str</code> 没有连续重复字符串的排列个数</li>\n<li>如果 <code>str</code> 为 <code>\"aab\"</code>，则返回值应为 <code>2</code>，因为全排列后，会出现两个 <code>\"aba\"</code>，不含连续重复字符串 (排除 <code>\"aab\"</code> 和 <code>\"baa\"</code>)</li>\n</ul>\n<!--more-->\n<h1>解题思路</h1>\n<ul>\n<li>这道题应该是高级算法题目中难度稍大的一道题。题目的难点在于获取字符串的全排列。我觉得这里有必要先说一下，如何获取全排列</li>\n<li>只要我们可以获取字符串的全排列，那就至少有两种方式判断字符串是否含有连续重复的字符。可以遍历，也可以用正则</li>\n<li><a href=\"https://zh.wikipedia.org/wiki/%E7%BD%AE%E6%8F%9B\">排列 (也叫置换)，Permutation</a> 与 <a href=\"https://zh.wikipedia.org/wiki/%E7%B5%84%E5%90%88\">组合，Combination</a>，高中数学就已经涉及到。比如，对于 <code>123</code>，从中取出两个数有三种组合，分别是 <code>12</code>、<code>13</code> 和 <code>23</code>。同样是取出两个数，有六种排列，分别是 <code>12</code>、<code>21</code>、<code>13</code>、<code>31</code>、<code>23</code> 和 <code>32</code></li>\n<li>再说一下什么是全排列 (Full Permutation)，全排列的意思是，从 <code>n</code> 个中取出 <code>n</code> 个的排列。对于 <code>123</code>，取出三个数的排列，就是 <code>123</code> 的全排列。<code>123</code> 的全排列总共有六种，分别是 <code>123</code>、<code>132</code>、<code>213</code>、<code>231</code>、<code>312</code> 和 <code>321</code>。计算数量方式很简单，就是 <code>n!</code>，<code>n</code> 的阶乘。对于 <code>123</code> 来说，也就是 <code>3!</code>，得 <code>6</code></li>\n</ul>\n<h2>全排列的实现 - 封装，循环</h2>\n<ul>\n<li>\n<p>我们可以先根据这个实际的例子想想，怎样才能无遗漏的输出全排列</p>\n<ul>\n<li>两个数就不用说了，对于 <code>12</code>，只有 <code>12</code> 和 <code>21</code> 两种</li>\n<li>\n<p>三个数，比如 <code>123</code>，我们先分为三种情况，就是 <code>1</code> 开头，<code>2</code> 开头和 <code>3</code> 开头</p>\n<ul>\n<li>对于 <code>1</code> 开头的情况，剩下 <code>2</code> 和 <code>3</code>，这就回到了两个数的排列</li>\n<li>对于 <code>2</code> 开头的情况，剩下 <code>1</code> 和 <code>3</code>，这也回到了两个数的排列</li>\n<li><code>3</code> 开头的情况同理</li>\n</ul>\n</li>\n<li>四个数，先按照开头分为四种情况，然后按照三个数的排列去处理</li>\n<li>......</li>\n<li>以此类推</li>\n</ul>\n</li>\n<li>你可能已经看出来了，这就是一个递归。就好像求斐波那契数列的某一个元素，我们要先求出前面的；要想求出前面的，我们就要求出更前面的。记 \"斐波那契数列的第 <code>n</code> 位\" 这件事为 <code>F(n)</code>，则有 <code>F(n) = F(n - 1) + F(n - 2)</code></li>\n<li>类似地，记 \"求出 <code>n</code> 个字符串的全排列\" 这件事为 <code>P(n)</code>，则有 <code>P(n) = 分别以这n个字符之一开头 + P(n - 1)</code>。其中，<code>P(n - 1)</code> 表示去掉那个开头字符的剩余字符串的全排列。哪怕只有两个字符，比如对于上面例子中的 <code>12</code>，同样符合这一条结论</li>\n<li>以 <code>'abc'</code> 为例，执行步骤如下：</li>\n</ul>\n<pre><code>给出 abc\n\n1. a 作为开头 -> 求 bc 全排列 -> 得到 bc 和 cb -> 与 a 合并 -> 得到 abc 和 acb\n2. b 作为开头 -> 求 ac 全排列 -> 得到 ac 和 ca -> 与 b 合并 -> 得到 bac 和 bca\n3. c 作为开头 -> 求 ab 全排列 -> 得到 ab 和 ba -> 与 c 合并 -> 得到 cab 和 cba\n</code></pre>\n<ul>\n<li>注意，这只是其中一种实现方式。后面我们还会看到另一种实现</li>\n<li>首先我们来想一下公共逻辑是什么。对于一个字符串，我们取出一个字符作为开头，然后对去掉这个开头字符的剩余字符串继续求全排列。求出来之后，与取到的字符合并起来就行</li>\n<li>对于 <code>P(n)</code> 来说，我们要取出一个字符作为开头，而且原始的字符串可能本身就含有重复的字符。在代码中，我们可以通过开头字符在原字符串中的索引来区分</li>\n<li>对于我们封装的函数，可以直接使用字符串作为参数。这是因为，在获取剩余字符串全排列，即 <code>P(n - 1)</code> 时，我们并不关心去掉的那个，用作开头的字符是什么，只需要关心现在我们要生成谁的全排列就好</li>\n<li>因此，我们需要在递归调用时，传入去掉那个用作开头的字符之后的，剩余字符串。这个很容易实现，如果我们知道了去掉的那个字符的索引，那我们就可以用 <code>str.slice(0, i)</code> 来获取这个字符之前的字符串，用 <code>str.slice(i + 1, str.length)</code> 来获取这个字符之后的字符串 (注意，<code>slice</code> 方法的第一个参数是包含的，第二个不包含。如果 <code>i</code> 本身就是 <code>0</code>，那么取到的是 <strong>空字符串</strong>)，拼接在一起就可以作为递归调用的参数</li>\n<li>跳出条件也不难想，只要传入的参数长度为 <code>1</code> 或 <code>0</code>，直接返回即可</li>\n<li>另外，每次调用，我们都需要一个数组来保存根据当前参数生成的全排列。代码如下</li>\n</ul>\n<pre><code class=\"language-js\">function permAlone(string) {\n    function _perm(str) {\n        // 跳出条件\n        if (str.length &#x3C; 2) return str;\n        var permutations = [];\n\n        for (var i = 0; i &#x3C; str.length; i++) {\n            // 获取开头的字符串和剩余字符串\n            var start = str[i];\n            var remaining = str.slice(0, i) + str.slice(i + 1, str.length);\n\n            // 根据通过剩余字符串的全排列，生成前一次的全排列。注意 _perm(remaining) 是一个数组\n            for (var permutation of _perm(remaining)) {\n                permutations.push(start + permutation);\n            }\n        }\n        return permutations;\n    }\n}\n</code></pre>\n<h2>判断连续重复字符</h2>\n<h3>遍历</h3>\n<ul>\n<li>判断是否有连续重复的字符，最简单的方式是遍历。只需要在外面用一个变量记录上一个字符就可以</li>\n<li>只要当前的和上一个相同，直接跳出就可以，不需要继续判断。代码如下：</li>\n</ul>\n<pre><code class=\"language-js\">function hasRepeatChar(str) {\n    var previous = '';\n    for (var i = 0; i &#x3C; str.length; i++) {\n        if (previous === str[i]) {\n            return true;\n        } else {\n            // 赋值，用于下次判断\n            previous = str[i];\n        }\n    }\n    // 不存在连续重复字符\n    return false;\n}\n</code></pre>\n<h3>递归</h3>\n<ul>\n<li>递归也是很容易写的。跟上面的思路一样，调用的时候传入两个参数，分别是上一个字符，和剩余字符串。其中，剩余字符串可以通过 <code>str.slice(1)</code> 获取</li>\n<li>为避免 <code>str</code> 本身就是空字符串，需要多一次判断，即如果 <code>prevChar</code> 不是空的 (这说明 <code>prevChar</code> 被赋过值，而并非初始的空值)，我们才可以认为 <code>str</code> 不含连续重复字符，则返回 <code>false</code>。因此，跳出条件是 <code>str</code> 为空且 <code>prevChar</code> 有值。如果这时候 <code>prevChar</code> 也是空的，那就证明传入的 <code>str</code> 本身就是空的。为了防止混淆，我们直接给它返回 <code>\"Empty string\"</code>。事实上，这种 corner case 在这道题目中不会遇到。代码如下：</li>\n</ul>\n<pre><code class=\"language-js\">function hasRepeatChar(str, prevChar) {\n    if (str.length === 0) return prevChar ? false : 'Empty string';\n    if (prevChar === str[0]) return true;\n\n    return hasRepeatChar(str.slice(1), str[0]);\n}\n</code></pre>\n<h3>正则表达式</h3>\n<ul>\n<li>正则是个好东西。在正则里，有一中写法叫做 <code>back reference</code>，就是 <code>\\\\</code> 后面加一个正整数。请参考 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions\">文档</a> 中 <code>\\\\n</code> 的那一行</li>\n<li>简单来说，<code>\\\\x</code> 就是匹配之前，正数第 <code>x</code> 个 matched group (匹配组，也叫捕获组，其实就是小括号包含的内容)</li>\n<li>对于判断一个字符串是否含有连续重复字符，我们并不关注它重复了几次，也不需要关注它有几组重复的。因此，这里不需要 <code>global</code> flag <code>/g</code></li>\n<li>那么，对于字符串中的任意字符，只要这个字符右边的字符和它相同，那就匹配到，并且返回 <code>false</code>。听起来像是句废话，只是，如果你看不懂后面的正则，记得回来再读读这句话。代码如下：</li>\n</ul>\n<pre><code class=\"language-js\">function hasRepeatChar(str) {\n    return !/(\\w)\\1/.test(str);\n}\n</code></pre>\n<h1>基本解法</h1>\n<h2>思路提示</h2>\n<ul>\n<li>思路上面已经说得很清楚。通过上面的递归调用，我们可以得到了一个包含字符串全排列的数组，只需要通过上面的正则过滤一下，保留不含连续重复字符的字符串，并返回它的 <code>length</code></li>\n</ul>\n<h2>代码</h2>\n<pre><code class=\"language-js\">function permAlone(string) {\n    function _perm(str) {\n        if (str.length &#x3C; 2) return str;\n        var permutations = [];\n\n        for (var i = 0; i &#x3C; str.length; i++) {\n            var start = str[i];\n            var remaining = str.slice(0, i) + str.slice(i + 1, str.length);\n\n            for (var permutation of _perm(remaining)) {\n                permutations.push(start + permutation);\n            }\n        }\n        return permutations;\n    }\n    return _perm(string).filter(function(str) {\n        return !/(\\w)\\1/.test(str);\n    }).length;\n}\n</code></pre>\n<h1>数组方法 - 思路的优化</h1>\n<h2>思路提示</h2>\n<ul>\n<li>上面的方式是把子问题 (剩余字符串的全排列) 添加到之前取出的开头字符后面，这也就意味着，对于长度为 <code>n</code> 的字符串 <code>string</code>，开头的字符我们要获取 <code>n</code> 次。每一次取了开头，我们又要再对子问题进行 <code>n - 1</code> 次取开头的操作，因此这时候的时间复杂度会是 <code>n!</code>。效率很低</li>\n<li>如果我们换一个思路，采用 \"插值\" 的方法，会让整体操作变少一些。注意，这个思路并不一定需要用数组去实现。确切的说，如果不用数组去实现，效率会更高。只是个人觉得，用数组会比较容易写，也比较容易理解</li>\n<li>之前的方式，如果我们说它是 \"从前往后\" 实现的，那现在我们来试试从后往前实现</li>\n<li>对于字符串 <code>'abc'</code>，给出子串 <code>'bc'</code>，剩余 <code>'a'</code>。我们可以通过把 <code>'a'</code> 放到 <code>'bc'</code> 里面，不同的位置来实现排列。注意到 <code>'bc'</code> 有三个位置可以插入 <code>'a'</code>，分别是：</li>\n</ul>\n<pre><code> b c\n↑ ↑ ↑\n1 2 3\n</code></pre>\n<ul>\n<li>如果把 <code>'a'</code> 分别插入上面说的位置 <code>1</code>、<code>2</code> 和 <code>3</code>，我们就可以得到 <code>'abc'</code>、<code>'bac'</code> 和 <code>'bca</code></li>\n<li><code>'bc'</code> 排列还有一种情况 <code>'cb'</code>。再把 <code>'a'</code> 插入到 <code>'cb'</code> 的三个位置，我们就可以得到另外三种排列</li>\n<li>注意到，<code>'bc'</code> 和 <code>'cb'</code>，其实就是在子串 <code>'c'</code> 中插入 <code>'b'</code> 产生的。因为 <code>'c'</code> 只有两个位置可以插入 <code>'b'</code>：</li>\n</ul>\n<pre><code> c\n↑ ↑\n1 2\n</code></pre>\n<ul>\n<li>这样，我们就得到了一个新的递归思路，如下 (左边的竖线只是为了方便看清递归弹出的时候对应上面的哪一步，弹出步骤中的插入值与上面取出的第一个字符相对应)：</li>\n</ul>\n<pre><code>给出 'abc'\n\n|- 取出第一个字符 a，剩余 bc\n|  |- 取出第一个字符 b，剩余 c\n|  |  |- 取出第一个字符 c，剩余空字符串 (划重点，这个就是弹出的条件)\n|  |  |- 在上次剩余值中插入 c，只能得到一种情况 c\n|  |- 在上次剩余值 (c) 中插入 b，得到 bc 和 cb\n|- 在上次剩余值 (bc 和 cb) 中插入 a，得到 abc, bac, bca 和 acb, cab, cba\n</code></pre>\n<ul>\n<li>这个思路很像是，先一直走到底 (即长度为 0 的时候)，弹出的过程中，我们再来生成需要的结果</li>\n<li>这段代码加注释不太方便，详细解释还是写到代码之后吧</li>\n<li>如果你还是不知道如何写代码，不要怕麻烦，试着写出来 <code>'abcd'</code> 的详细过程，写完你就能理解了</li>\n</ul>\n<h2>代码</h2>\n<pre><code class=\"language-js\">function permAlone(string) {\n    return _perm(string.split('')).filter(function(str) {\n        return !/(\\w)\\1/.test(str);\n    }).length;\n\n    function _perm(arr) {\n        return arr.length === 0 ? [[]] : _perm(arr.slice(1)).reduce(function(accum, curr) {\n            // 插值的实现\n            for (var i = 0; i &#x3C; arr.length; i++) {\n                accum.push([curr.slice(0, i), arr[0], curr.slice(i)].join(''));\n            }\n            return accum;\n        }, []);\n    }\n}\n</code></pre>\n<h2>解释</h2>\n<ul>\n<li>先说一句，上面的代码，尽管思路优化了，但速度理论上会比之前的慢，因为咱们用了数组</li>\n<li>外面那层应该没啥疑问，既然决定了用数组去处理，那就干脆直接传入数组，一个 <code>split</code> 的事儿而已</li>\n<li>封装的 <code>_perm</code>，其实还是要进行递归调用的。当外面的 <code>string</code> 是空字符串时，返回值是 <code>[[]]</code>，而不可以是 <code>[]</code>。原因很简单，如果是 <code>[]</code>，那么 <code>reduce</code> 就不会执行了，因为没有元素。你可以试试以下的代码片段，就理解了：</li>\n</ul>\n<pre><code class=\"language-js\">// 不会输出 '执行了'，返回值是 []\n[].reduce((accum, curr) => {\n    console.log('执行了');\n    return accum;\n}, []);\n\n// 会输出 '执行了'，返回值也是 []\n[[]].reduce((accum, curr) => {\n    console.log('执行了');\n    return accum;\n}, []);\n</code></pre>\n<ul>\n<li>只要 <code>arr</code> 长度不为 <code>0</code>，那我们就递归调用 <code>_perm(arr.slice(1))</code>，直到遇到传入的 <code>arr</code> 长度为 <code>0</code>，才开始执行 <code>reduce</code> 弹出的过程。详情请看上面的思路分析</li>\n<li>里面的 <code>for</code> 循环很重要，\"插值\" 这个核心步骤就是在这里实现的。如果看不懂这个过程，请去了解一下 <code>slice</code> 方法是怎么回事，然后举几个例子带进去试一试就明白了</li>\n</ul>\n<h1>算法优化 - Heap's algorithm</h1>\n<h2>思路提示</h2>\n<ul>\n<li>注意，这里的 Heap 不是指数据结构的 \"堆\"，而是发明者的名字。如果你从来没听说过这个算法，那只靠自己想可能有些困难</li>\n<li>\n<p>给出字符串 <code>'abc'</code>，我们可以按照先确定结尾字符的思路来这样推一下：</p>\n<ul>\n<li>\n<p><code>'c'</code> 作为结尾：</p>\n<ul>\n<li>我们得到第一个排列 <code>'abc'</code></li>\n<li>通过交换 <code>'a'</code> 和 <code>'b'</code>，我们可以得到另一种排列 <code>'bac'</code></li>\n</ul>\n</li>\n<li>\n<p>交换开头结尾，这时候 <code>'b'</code> 作为结尾：</p>\n<ul>\n<li>得到 <code>'cab'</code></li>\n<li>通过交换 <code>'c'</code> 和 <code>'a'</code>，得到 <code>'acb'</code></li>\n</ul>\n</li>\n<li>\n<p>交换开头结尾，这时候 <code>'a'</code> 作为结尾：</p>\n<ul>\n<li>得到 <code>'bca'</code></li>\n<li>通过交换 <code>'b'</code> 和 <code>'c'</code>，得到 <code>'cba'</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>思路大致上是这样，通过交换去实现。交换的好处在于，我们不需要额外的空间去存储。值得注意的是，在 JavaScript 中，字符串可以通过 index 访问某一个位置的字符，但不可以修改它的值。因此，想要换位，我们还是要通过数组来实现的</li>\n<li>事实上，真正实现起来还与上面的例子有区别。在 <code>Heap's Algorithm</code> 的 <a href=\"https://en.wikipedia.org/wiki/Heap%27s_algorithm\">维基百科页面</a> 有详细的解释，也有四个元素的详细步骤示例。其实，并不是 \"交换开头结尾\" 这么简单的</li>\n<li>实现数组中元素交换的方式也非常多。有朋友可能首先想到的是用 <code>splice</code>，但这样做效率会很低，我会比较推荐用变量缓存一个值的做法，很容易写。比如，我们需要交换 index 为 <code>2</code> 和 <code>4</code> 的元素：</li>\n</ul>\n<pre><code class=\"language-js\">var arr = [1, 2, 3, 4, 5, 6];\n\nvar temp = arr[2];\narr[2] = arr[4];\narr[4] = temp;\n\nconsole.log(arr);  // [1, 2, 5, 4, 3, 6]\n</code></pre>\n<ul>\n<li>当然，还有一种比较好玩儿的黑科技：</li>\n</ul>\n<pre><code class=\"language-js\">var arr = [1, 2, 3, 4, 5, 6];\narr[2] = [arr[4], arr[4] = arr[2]][0]\n\nconsole.log(arr);  // [1, 2, 5, 4, 3, 6]\n</code></pre>\n<ul>\n<li>如果你听说过 ES6 的解构赋值，也可以这么写。注意这个在不支持 ES6 的浏览器里是不行的：</li>\n</ul>\n<pre><code class=\"language-js\">var arr = [1, 2, 3, 4, 5, 6];\n[arr[2], arr[4]] = [arr[4], arr[2]]\n\nconsole.log(arr);  // [1, 2, 5, 4, 3, 6]\n</code></pre>\n<ul>\n<li>维基百科页面也提供了伪代码，而且提供了递归和非递归的两个版本。两个版本都用到了两个参数，但我们只需要一个 <code>n</code> 就够了，不需要第二个 <code>A</code>，因为我们的数组可以通过 <code>var arr = str.split('');</code> 将它定义到函数 <code>generate</code> 外面。这样，伪代码如下：</li>\n</ul>\n<pre><code class=\"language-js\">函数 generate\n参数 num\n\n如果 num 等于 1:\n    arr.join('')，并添加到结果数组\n否则:\n    循环，0 至 num:\n        递归调用 generate(num - 1)\n        如果 num 为偶数:\n            交换 strArr[i] 与 strArr[num - 1]\n        如果 num 为奇数:\n            交换 strArr[0] 与 strArr[num - 1]\n</code></pre>\n<h2>代码</h2>\n<pre><code class=\"language-js\">function permAlone(str) {\n    var arr = str.split('');\n    var result = [];\n    // 声明需要放在这里，因为赋值是在弹出的时候执行的\n    var tempIndex;\n\n    function generate(num) {\n        if (num === 1) {\n            result.push(arr.join(''));\n        } else {\n            for (var i = 0; i &#x3C; num; i++) {\n                generate(num - 1);\n                tempIndex = num % 2 ? 0 : i;\n                arr[tempIndex] = [arr[num - 1], arr[num - 1] = arr[tempIndex]][0];\n            }\n        }\n    }\n    \n    generate(arr.length);\n    \n    return result.filter(function(str) {\n        return !/(\\w)\\1/.test(str);\n    }).length;\n}\n</code></pre>","fields":{"slug":"/advanced-no-repeats-please/"},"frontmatter":{"title":"FreeCodeCamp 高级算法题 - 字符串排列","tags":["FreeCodeCamp","高级","算法"],"categories":"FCC"}}},{"node":{"html":"<h1>类型</h1>\n<h2>内置类型</h2>\n<ul>\n<li>内置类型有哪些？如何校验？</li>\n<li>特殊类型有哪些？注意事项是？</li>\n</ul>\n<h2>问题解释</h2>\n<ul>\n<li>内置类型为空值<code>(null)</code>，未定义<code>(undefined)</code>，布尔值<code>(boolean)</code>，数字<code>(number)</code>，字符串<code>(string)</code>，对象<code>(object)</code>，符号<code>(symbol,ES6新增)</code></li>\n<li>\n<p>特殊类型为空值(特殊对象)，数组(特殊对象)，函数(特殊对象)</p>\n<!--more-->\n</li>\n<li>\n<p>类型校验</p>\n<pre><code class=\"language-js\">typeof undefined === 'undefined' //true\ntypeof true === 'boolean' //true\ntypeof 42 === 'number' //true\ntypeof '42' === 'string' //true\ntypeof {a:2} === 'object' //true\ntypeof Symbol() === 'symbol' //true\n// 特殊情况\ntypeof null === 'object' //true\ntypeof [1,2,3] === 'object' //true\ntypeof function(){} === 'function' // true\n</code></pre>\n<h3>校验方式</h3>\n</li>\n<li>校验null (!a &#x26;&#x26; typeof a ==='object') //true</li>\n<li>校验数组 arr.constructor === Array 或 arr instanceof Array</li>\n</ul>\n<h3>数组</h3>\n<ul>\n<li>\n<p>数组可以容纳任何类型的值，无需设定大小</p>\n</li>\n<li>\n<p>delete运算符可以将单元从数组中删除，但，删除后，数组length属性不会发生变化</p>\n</li>\n<li>\n<p>数组通过数组进行索引，但因为它是对象的本质，所以也可以包含字符串键值与属性<code>(但并不计算在数组长度内)</code></p>\n<pre><code class=\"language-js\">var a = []\na[0] = 1\na['foo'] = 2\na.length; // 1\na['foo']; // 2\na.foo;    // 2\n</code></pre>\n</li>\n<li>\n<p>注意点：若字符串键值能强制转换为数字的话，会被当作数字索引来处理</p>\n<pre><code class=\"language-js\">  var a = []\n  a['13'] = 42\n  a.length; // 14\n</code></pre>\n</li>\n<li>\n<p>Array.from()可将类数组对象转为数组对象，例（arguments,dom列表）</p>\n<h2>字符串与字符串数组</h2>\n</li>\n<li>\n<p>都具有<code>length</code>属性与<code>indexOf</code>方法和<code>concat</code>方法</p>\n<pre><code class=\"language-js\">var a = 'foo'\nvar b = ['f','o','o']\n\na.length; // 3\nb.length; //3\n\na.indexOf('o') // 1\nb.indexOf('o') // 1\nvar c = a.concat('bar') //foobar\nvar d = b.concat(['b', 'a', 'r']) // ['f', 'o', 'o', 'b', 'a', 'r']\n</code></pre>\n</li>\n<li>\n<p>字符串没有数组函数，但可以借用数组的非变更方法来处理</p>\n<pre><code class=\"language-js\">var c = Array.prototype.join.call(a, '-')\nvar d = Array.prototype.map.call(a, function(v) {\n  return v.toUpperCase() + '.'\n}).join(\"\")\nc; //\"f-o-o\"\nd: //\"f.o.o\"\n</code></pre>\n</li>\n<li>\n<p>不可借用数组的可变成员函数reverse,因为字符串是不可变的<code>Array.prototype.reserve.call(a)</code>无效</p>\n</li>\n<li>\n<p>处理方法：</p>\n<pre><code class=\"language-js\">var c = a.split(\"\").reverse().join(\"\")\n</code></pre>\n</li>\n</ul>\n<h2>数字</h2>\n<ul>\n<li>检测是否是整数 <code>Number.isInteger()</code></li>\n<li>检测是狗是安全整数 <code>Number.isSafeInteger()</code></li>\n<li>检测是否是NaN <code>Number.isNaN()</code></li>\n<li>检测两个值是否绝对相等 <code>Object.is(a, b)</code></li>\n</ul>\n<h2>奇特的小技巧</h2>\n<ul>\n<li>\n<p>~运算符可将结果强制类型转换为真值/假值</p>\n<pre><code class=\"language-js\">var a = \"Hello world\"\nif(~a.indexOf('lo')) { // true\n  // 找到匹配\n}\n// 相应的 !~a.indexOf('lo')为未找到匹配\n</code></pre>\n</li>\n</ul>","fields":{"slug":"/type/"},"frontmatter":{"title":"你不知道的javascript-类型","tags":["javascript","入门"],"categories":"JavasSript"}}},{"node":{"html":"<h1>TCP协议的3次握手与4次分手</h1>\n<h2>TCP协议的连接与断开</h2>\n<ul>\n<li>什么是TCP协议的三次握手？为什么会有三次握手？</li>\n<li>什么是TCO协议的四次分手？为什么会有四次分手？</li>\n</ul>\n<h2>问题解释</h2>\n<ul>\n<li>TCP的三次握手其实是在客户端与服务端建立一个TCP连接，在TCP/IP协议中，采用三次握手可建立可靠的连接服务</li>\n<li>\n<p>TCP的四次分手用来断开客户端与服务端的连接</p>\n<!--more-->\n</li>\n</ul>\n<h2>详解</h2>\n<h3>TCP报文重要字段解释</h3>\n<ul>\n<li>序号：<code>seq</code>序号，标识从TCP源向目的端发送字节流，并由发送端对其标记</li>\n<li>确认序号：<code>ack</code>序号，只有<code>ACK</code>标志位为1时确认序号字段才有效，<code>ack=seq+1</code>（注意：<code>ack</code>序号与<code>ACK</code>标志位不是同一个东西）</li>\n<li>注意：确认放<code>ack</code>=发起方<code>req+1</code>时两者配对成功</li>\n<li>\n<p>标志位：共六个，即<code>URG</code>,<code>ACK</code>,<code>PSH</code>,<code>RST</code>,<code>SYN</code>,<code>FIN</code></p>\n<ul>\n<li><code>ACK</code>:确认序号有效</li>\n<li><code>PSH</code>:接收方尽快将报文提交应用层</li>\n<li><code>RST</code>:连接重置</li>\n<li><code>URG</code>:紧急指针有效</li>\n<li><code>SYN</code>:发起一个新连接</li>\n<li><code>FIN</code>:释放一个链接</li>\n</ul>\n</li>\n</ul>\n<h3>三次握手</h3>\n<ul>\n<li>\n<p>三次握手是为了在客户端与服务端建立可靠安全的连接服务，所以需要三次握手确认</p>\n<ul>\n<li>第一次：客户端将标志位<code>SYN</code>设置为<code>1</code>，产生一个随机值<code>seq=J</code>并将其发送给server,等待server确认，自己进入<code>SYN_SENT</code>状态（我要跟你连接了，你看看你听得到吗）</li>\n<li>第二次：server收到数据包由<code>SYN=1</code>知道客户端建立请求，server将标志位<code>SYN</code>与<code>ACK</code>都设置为1，随机产生一个值<code>seq=K</code>，并将该数据发回客户端确认连接请求，server进入<code>SYN_RCVD</code>状态（我听到了，你看看你听得到我吗）</li>\n<li>第三次：客户端收到确认后检查<code>ack</code>是否为<code>J+1</code>,<code>ACK</code>是否为<code>1</code>，如果正确则将标志位<code>ACK</code>设置为<code>1</code>，<code>ack=K+1</code>,并将数据包发给server，server检查<code>ack</code>是否为<code>K+1</code>,<code>ACK</code>是否为<code>1</code>，如果正确则连接建立成功，客户端与服务端进入<code>ESTABLISHED</code>状态，完成三次握手，此后客户端与服务端即可开始传输数据了（我也能听到了，咱们来交流吧）</li>\n</ul>\n</li>\n</ul>\n<h3>四次分手</h3>\n<ul>\n<li>\n<p>当我们用三次握手建立连接后数据传输完成要断开TCP链接啊，所以就有了四次分手</p>\n<ul>\n<li>由于TCP连接是双全工的，每个方向都需要单独关闭，当一方发送数据完成后需要发送一个<code>FIN</code>来终止这一方向连接，收到FIN只是表示对方不会有数据流动了，但是接收方依然可以发送数据，直到接收方也发送了<code>FIN</code></li>\n<li>第一次：客户端发送一个FIN，用来关闭客户端到服务端的数据传输，客户端进入<code>FIN_WAIT_1</code>状态（我没有要说的了，我想关闭连接了）</li>\n<li>第二次：服务端收到<code>FIN</code>后，发送一个<code>ACK</code>给客户端，确认序号为收到序号+1，服务端进入<code>CLOSE_WAIT</code>状态（我知道你不想说了，我不确定我还有没有要说的）</li>\n<li>第三次：服务端向客户端发送一个<code>FIN</code>，用来关闭服务端到客户端的数据传输，服务端进入<code>LAST_ACK</code>状态（我也没有要说的了，咱关闭连接吧）</li>\n<li>第四次：客户端收到<code>FIN</code>后，客户端进入<code>TIME_WAIT</code>状态，接着发送一个<code>ACK</code>给服务端，确认序号为收到序号+1，服务端进入<code>CLOSED</code>状态，完成四次分手（好的，我知道了，咱关闭吧，你听不到我的声音就说明关闭了）</li>\n</ul>\n</li>\n<li>\n<p>为什么建立连接是三次而分手要四次呐？</p>\n<ul>\n<li>因为服务端在<code>LISTEN</code>状态下，收到建立请求的<code>SYN</code>报文后，把<code>ACK</code>与<code>SYN</code>都放在一个报文里发给了客户端。关闭连接时当收到对方的<code>FIn</code>报文仅仅表示对方不再发数据了，但还能接数据，自己也未必把所有数据发送给对方了，所以己方可以立即关闭也可以发送数据后再发送<code>FIn</code>报文给对方同意现在关闭，因此<code>ACK</code>与<code>FIN</code>都会分开发送</li>\n</ul>\n</li>\n</ul>","fields":{"slug":"/TCP-IP-ThreeHandShake/"},"frontmatter":{"title":"HTTP与TCP/IP了解","tags":["HTTP","TCP/IP"],"categories":"HTTP"}}},{"node":{"html":"<h1>生成器详解</h1>\n<h2>生成器</h2>\n<ul>\n<li>生成器是什么？为什么会需要生成器？</li>\n</ul>\n<h2>生成器的由来</h2>\n<ul>\n<li>传统异步流程对程序员并不友好，设定回调函数的方式不符合大脑对任务步骤的规划</li>\n<li>生成器就是实现看似同步的异步流程控制</li>\n</ul>\n<!--more-->\n<h1>生成器的奇特之处</h1>\n<h2>打破完整运行</h2>\n<ul>\n<li>传统意义上，<code>javascript</code>函数一旦开始运行，那么在结束之前将没有别的代码可以打断并插入运行</li>\n<li>\n<p>ES2015引入了新的函数类型，并不符合从始到终不可打断的原则，这类新的函数就是生成器</p>\n<pre><code class=\"language-js\">var x = 1;\nfunction foo() {\nx++\nbar();\nconsole.log( \"x:\", x )\n}\nfunction bar() {\nx++\n}\nfoo(); // x: 3 \n</code></pre>\n</li>\n<li>这里因为bar存在于foo内部，所以可以实现x的改变，那如过在外面调用bar有没有可能改变x的输出呐？</li>\n<li>如果在多线程语言中，这个自然可以通过抢占线程来实现，但javascript是一个单线程的语言。但是，要是我们通过让<code>foo</code>暂停然后先执行<code>bar</code>会怎么样呐？</li>\n<li>\n<p>下面就是我们用ES2015来实现的效果</p>\n<pre><code class=\"language-js\">var x = 1;\nfunction *foo() {\nx++;\nyield; // 暂停！\nconsole.log( \"x:\", x );\n}\nfunction bar() {\nx++;\n} \n// 构造一个迭代器it来控制这个生成器\nvar it = foo();\n// 这里启动foo()！\nit.next();\nx; // 2\nbar();\nx; // 3\nit.next(); // x: 3\n</code></pre>\n</li>\n<li><code>it=foo()</code> 运算其实只是生成了一个迭代器，并没有执行生成器（迭代器在下面会介绍）</li>\n<li>第一个<code>it.next()</code>执行了生成器，也就运行了<code>*foo</code>代码里的<code>x++</code>这一句，停在了<code>yield</code></li>\n<li><code>*foo</code>停在了<code>yield</code>这里，第一个<code>it.next</code>调用结束，暂停了<code>foo</code>,此时<code>x</code>值变为<code>2</code></li>\n<li>暂停<code>foo</code>后我们执行了<code>bar</code>函数使<code>x</code>变为<code>3</code></li>\n<li>最后一个<code>it.next</code>将生成器恢复了，使其完成代码块的执行，打印了<code>3</code></li>\n<li>这里我们也能发现，生成器函数与普通函数相比函数名之前会多一个<code>*</code>,并且函数执行过程碰到<code>yield</code>会被暂停</li>\n</ul>\n<h2>输入与输出</h2>\n<ul>\n<li>\n<p>生成器作为一个函数，除了有新的执行模式，还具备一般函数的基本特性，可接受参数与返回值</p>\n<pre><code class=\"language-js\">function *foo(x,y) {\nreturn x * y;\n}\nvar it = foo( 6, 7 ); \nvar res = it.next();\nres.value; // 42 \n</code></pre>\n</li>\n<li>\n<p>生成器的传参，返回值与传统函数一致</p>\n</li>\n<li>\n<p>注意：这里我们能看到foo(6,7)并没有像普通函数一样执行，是因为这一步只是执行了迭代器的生成并赋值给了it,然后我们才可以对其进行暂停与恢复</p>\n</li>\n<li>\n<p>it.next是让生成器从当前位置继续运行，直到碰到下一个yield或者生成器代码执行结束</p>\n</li>\n<li>\n<p>it.next调用的结果是一个对象，有value属性，值为生成器返回的值(如果有的话)</p>\n</li>\n</ul>\n<h2>迭代器消息传递</h2>\n<ul>\n<li>\n<p>迭代器除了控制生成器之外，还提供了消息的输入与输出，通过yield与next(..)实现</p>\n<pre><code class=\"language-js\">function *foo(x) {\nvar y = x * (yield);\nreturn y;\n}\nvar it = foo( 6 );\n// 启动foo(..)\nit.next();\nvar res = it.next( 7 );\nres.value; // 42 \n</code></pre>\n</li>\n<li>这里是外部消息的输入，foo函数接受原始参数6，之后执行到了yield这一步暂停，并要求调用代码即it.next为yield提供一个结果值</li>\n<li>第二个it.next作为yield的恢复调用理所当然的需要提供一个值，也就是我们的7</li>\n<li>所以函数内部y = x * (yield) 其实就是y = 6 * 7即42</li>\n<li>这里我们要注意，迭代器的next总要比生成器的yield多一个，因为它需要第一个next来启动生成器，其后才是每次遇到yield暂停，next恢复</li>\n</ul>\n<pre><code class=\"language-js\">function *foo(x) {\n  var y = x * (yield \"Hello\"); // &#x3C;-- yield一个值！\n  return y;\n}\nvar it = foo( 6 );\nvar res = it.next(); // 第一个next()，并不传入任何东西\nres.value // \"Hello\"\nres = it.next( 7 ); // 向等待的yield传入7\nres.value; // 42 \n</code></pre>\n<ul>\n<li>这里与上面的改动在于yield之后跟了一个数据'Hello'，它其实是yield传给外面的数据，用来响应next的调用，可以理解为我启动了你要是暂停得给我个解释啊，抛出的一个返回值</li>\n<li>上面也就是我们生成器的消息互通，通过yield与next构成消息的双向传递</li>\n</ul>\n<h1>迭代器</h1>\n<h2>为什么需要迭代器</h2>\n<ul>\n<li>生成器是对函数的暂停与恢复执行，那么在多次暂停时就需要有东西来保存其暂停时的值，而迭代器的作用也就凸现出来了</li>\n<li>\n<p>迭代器是一个定义良好的接口，可以从一个生产者一步步得到一系列的值</p>\n<pre><code class=\"language-js\">var something = (function(){\nvar nextVal;\nreturn {\n  // for..of循环需要\n  [Symbol.iterator]: function(){ return this; },\n  // 标准迭代器接口方法\n  next: function(){\n    if (nextVal === undefined) {\n      nextVal = 1;\n    }\n    else {\n      nextVal = (3 * nextVal) + 6;\n    }\n    return { done:false, value:nextVal };\n  }\n};\n})();\nsomething.next().value; // 1\nsomething.next().value; // 9\nsomething.next().value; // 33\nsomething.next().value; // 105 \n</code></pre>\n</li>\n<li>上面就是一个标准的数字生产迭代器，Symbol.iterator存在的原因是ES2015开始要想从一个可迭代对象中提取迭代器，则该对象必须是ES6符号值Symbol.iterator,调用这个函数会返回一个迭代器</li>\n<li>这里我们可以通过next方法返回一个对象，该对象有两个属性值：done为boolean值，标识迭代器的完成状态，value返回迭代值</li>\n</ul>\n<h2>生成器与迭代器</h2>\n<ul>\n<li>上面就是迭代器的作用与简单实现，这里我们就可以知道当我们执行it=foo()这一步时为什么会返回一个迭代器了</li>\n<li>\n<p>严格来说生成器本身并不是一个iterable(可迭代对象),但当你执行一个生成器时，就得到了一个迭代器</p>\n<pre><code class=\"language-js\">function *foo(){ .. }\nvar it = foo(); \n</code></pre>\n</li>\n<li>生成器通过执行返回一个迭代器也就可以实现生成器的无限次暂停与恢复</li>\n</ul>\n<h1>生成器与异步编程模式</h1>\n<h2>生成器与异步回调</h2>\n<ul>\n<li>\n<p>在传统的异步函数ajax中，我们为了实现异步数据获取通常会使用异步回调的方法，如下</p>\n<pre><code class=\"language-js\">function foo(x,y,cb) {\najax(\n\"http://some.url.1/?x=\" + x + \"&#x26;y=\" + y,\ncb\n);\n}\nfoo( 11, 31, function(err,text) {\nif (err) {\nconsole.error( err );\n}\nelse {\nconsole.log( text );\n}\n} ); \n</code></pre>\n</li>\n<li>\n<p>但是有了生成器之后我们就可以这么实现了</p>\n<pre><code class=\"language-js\">function foo(x,y) {\najax(\n\"http://some.url.1/?x=\" + x + \"&#x26;y=\" + y,\nfunction(err,data){\n  if (err) {\n    // 向*main()抛出一个错误\n    it.throw( err );\n  }\n  else {\n    // 用收到的data恢复*main()\n    it.next( data );\n  }\n}\n);\n}\nfunction *main() {\ntry {\nvar text = yield foo( 11, 31 ); \nconsole.log( text );\n}\ncatch (err) {\nconsole.error( err );\n}\n}\nvar it = main();\n// 这里启动！\nit.next(); \n</code></pre>\n</li>\n<li>这里的代码看上去比上面的好像要长一点，但是这段代码比上面的代码要好得多</li>\n<li>这段代码好像变成了之前的同步代码，在有异步请求的时候还能运行吗？当然是可以的，主要原因就在yield身上，当我们执行生成器main的时候，遇到yield后暂停了foo(11,31)后面的其他代码，等待迭代器的下一个next来恢复它的执行</li>\n<li>当我们的ajax执行完成后，调用了next方法来恢复它，并把ajax的返回值传递给了生成器，使其赋值给了text，接着让main继续执行</li>\n</ul>","fields":{"slug":"/yield/"},"frontmatter":{"title":"ES2015生成器","tags":["JavaScript","ES2015","进修"],"categories":null}}},{"node":{"html":"<h1>call,apply,bind详解</h1>\n<h2>call,apply,bind的使用</h2>\n<ul>\n<li>call,apply,bind的作用是什么？用法是什么？</li>\n<li>call,apply,bind之间有什么联系？区别是什么？</li>\n</ul>\n<h2>问题详解</h2>\n<ul>\n<li>功能上，call，apply，bind都可以用来改变函数内部this的指向</li>\n<li>用法上，三者都是函数调用对应的call,apply,bind方法，传入不同的参数实现函数内部this指向改变</li>\n</ul>\n<!--more-->\n<h2>apply与call</h2>\n<ul>\n<li><code>call</code>与<code>apply</code>在功能上是完全一致的，都是为了改变函数运行的上下文，即this的指向</li>\n<li>用法上，<code>apply</code>接受两个参数，第一个是重新定义的this对象，第二个则是想要传递给函数的参数列表的集合，是一个数组</li>\n<li><code>call</code>接受多个参数，第一个参数为重新定义的this对象，第二个及以后的各个参数即为传递给函数的参数列表</li>\n<li>综上，当函数的参数数量确定的情况下，可以使用<code>call</code>，当函数参数数量不确定的情况下应该使用<code>apply</code>,可以将参数push进数组，然后将数组作为第二个参数，或者可以在函数内部通过<code>arguments</code>来获取所有参数列表</li>\n</ul>\n<h3>apply与call妙用</h3>\n<ul>\n<li>当我们一个对象没有某个方法，但是别的对象有的情况下我们就可以使用call或者apply来“借用”别的对象的方法，例：</li>\n</ul>\n<pre><code class=\"language-js\">  \nvar apple = {\n  color: 'red',\n  say: function(){\n    console.log(this.color)\n  }\n}\nvar banana = {\n  color: 'yellow'\n}\napple.say.call(banana) // yellow\n</code></pre>\n<ul>\n<li>\n<p>这里banana本来是没有say这个方法的，但是apple有这个方法，所以我们暂时借用他的方法来说出自己的颜色</p>\n</li>\n<li>\n<p>call与apply的常用妙法</p>\n<ul>\n<li>\n<p>数组之间追加</p>\n<pre><code class=\"language-js\">var arr1 = [12,'foo',{a:1}]\nvar arr2 = ['a', 23, {b:2}]\nArray.prototype.push.apply(arr1, arr2)\nconsole.log(arr1) // [ 12, 'foo', { a: 1 }, 'a', 23, { b: 2 } ]\n</code></pre>\n<p>这里利用了<code>apply</code>会将数组分解为各个参数的效果配合数组的push方法，将第二个数组分别添加到第一个数组实现数组的追加</p>\n</li>\n<li>\n<p>获取数组的最大值</p>\n<pre><code class=\"language-js\">var numbers = [13, 14,5,34,-38,56]\nvar maxNumbers = Math.max.apply(Math, numbers)\nconsole.log(maxNumbers)\n</code></pre>\n<p>这里数组本身没有max方法，但是Math对象有，所以我们就通过apply将其借用</p>\n</li>\n<li>\n<p>伪类数组调用数组方法实现自定义log方法，代理consolelog方法，并在每个打印之前添加一个（app）前缀</p>\n<pre><code class=\"language-js\">function log(){\nvar args = Array.prototype.slice.apply(arguments)\nargs.unshift('(app)')\nconsole.log.apply(console, args) \n}\nlog(1) // (app) 1\nlog(1,2,3) // (app) 1 2 3\n</code></pre>\n<p>这里的话可能有点难懂，其实实现这个功能我们先是获取到我们需要打印的数据，因为<code>console.log()</code>可以接受多个参数，所以我们采用<code>arguments</code>来获取所有参数，因为要在打印之前添加前缀,其实就是添加一个打印内容，所以我们要在传递给<code>console.log</code>的参数列表里面新增一个，但因为参数列表是一个类数组对象，并没有数组方法，所以我们通过借用数组的slice方法将类数组对象转为数组对象，然后再传递给<code>console.log</code></p>\n</li>\n</ul>\n</li>\n</ul>\n<h3>bind方法</h3>\n<ul>\n<li>\n<p>bind方法其实会创建一个新的函数，称为绑定函数，当调用这个函数的时候，绑定函数会以创建它时传入的第一个参数作为this，第二个及以后的参数按顺序作为原函数的参数来调用原函数</p>\n</li>\n<li>\n<p>bind常用用法</p>\n<ul>\n<li>\n<p>改变系统函数this指向</p>\n<pre><code class=\"language-js\">var foo = {\nbar: '哈哈',\neventBind: function(){\n  setTimeout(function(){\n    console.log(this)\n    console.log(this.bar)\n  }, 20)\n}\n}\nfoo.eventBind() // window对象   undefined\nvar foo1 = {\nbar: '哈哈',\neventBind: function(){\n  setTimeout(function(){\n    console.log(this)\n    console.log(this.bar)\n  }.bind(this), 20)\n}\n}\nfoo1.eventBind() // 对象foo1   '哈哈'\n</code></pre>\n<p>这里我们想要的是打印出对象<code>foo</code>与它下面<code>bar</code>的值，但是在<code>setTimeout</code>里面，定时器函数内部的this是指向window对象的，所以<code>this.bar</code>会是一个<code>undefined</code>，所以在这里我们可以使用<code>bind</code>来改变<code>this</code>的指向，当我们在函数后面挂载<code>bind</code>并传递当前<code>this</code>进入时，函数内部的<code>this</code>就被我们偏转回了我们想要的对象<code>foo1</code>,所以正确的输出了我们想要的结果</p>\n</li>\n<li>\n<p>那如果我们联系bind会发生什么呐？</p>\n<pre><code class=\"language-js\">var bar = function(){\nconsole.log(this.x)\n}\nvar foo = {\nx:3\n}\nvar sed = {\nx: 4\n}\nvar func = bar.bind(foo).bind(sed)\nfunc() // ?\nvar fiv = {\nx: 5\n}\nvar func1 = bar.bind(foo).bind(sed).bind(fiv)\nfunc() // ?\n</code></pre>\n<p>答案其实是两个3，并不是我们想象的4，5原因是在javascript中，多次bind是无效的。</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3>apply,call,bind比较</h3>\n<ul>\n<li>\n<p>看下面代码</p>\n<pre><code class=\"language-js\">var obj = {\n  x: 81\n}\nvar foo = {\n  getX: function(){\n    return this.x\n  }\n}\nconsole.log(foo.getX.bind(obj)()) // 81\nconsole.log(foo.getX.call(obj)) // 81\nconsole.log(foo.getX.apply(obj)) // 81\n</code></pre>\n<p>虽然三个都输出81，但是注意，bind方法之后我们又加了一个括号对其调用，所以这里bind在改变this之后并没有马上执行，而是在执行的时候才使用bind方法，而call与apply则是会立即执行</p>\n</li>\n</ul>","fields":{"slug":"/call-apply/"},"frontmatter":{"title":"javascript回顾","tags":["JavaScript","回顾","入门"],"categories":"JavasSript"}}}]}},"pageContext":{"limit":10,"skip":0,"currentIndex":0}}