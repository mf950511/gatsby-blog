{"data":{"markdownRemark":{"html":"<h1>call,apply,bind详解</h1>\n<h2>call,apply,bind的使用</h2>\n<ul>\n<li>call,apply,bind的作用是什么？用法是什么？</li>\n<li>call,apply,bind之间有什么联系？区别是什么？</li>\n</ul>\n<h2>问题详解</h2>\n<ul>\n<li>功能上，call，apply，bind都可以用来改变函数内部this的指向</li>\n<li>用法上，三者都是函数调用对应的call,apply,bind方法，传入不同的参数实现函数内部this指向改变</li>\n</ul>\n<!--more-->\n<h2>apply与call</h2>\n<ul>\n<li><code>call</code>与<code>apply</code>在功能上是完全一致的，都是为了改变函数运行的上下文，即this的指向</li>\n<li>用法上，<code>apply</code>接受两个参数，第一个是重新定义的this对象，第二个则是想要传递给函数的参数列表的集合，是一个数组</li>\n<li><code>call</code>接受多个参数，第一个参数为重新定义的this对象，第二个及以后的各个参数即为传递给函数的参数列表</li>\n<li>综上，当函数的参数数量确定的情况下，可以使用<code>call</code>，当函数参数数量不确定的情况下应该使用<code>apply</code>,可以将参数push进数组，然后将数组作为第二个参数，或者可以在函数内部通过<code>arguments</code>来获取所有参数列表</li>\n</ul>\n<h2>apply与call妙用</h2>\n<ul>\n<li>当我们一个对象没有某个方法，但是别的对象有的情况下我们就可以使用call或者apply来“借用”别的对象的方法，例：</li>\n</ul>\n<pre><code class=\"language-js\">  \nvar apple = {\n  color: 'red',\n  say: function(){\n    console.log(this.color)\n  }\n}\nvar banana = {\n  color: 'yellow'\n}\napple.say.call(banana) // yellow\n</code></pre>\n<ul>\n<li>\n<p>这里banana本来是没有say这个方法的，但是apple有这个方法，所以我们暂时借用他的方法来说出自己的颜色</p>\n</li>\n<li>\n<p>call与apply的常用妙法</p>\n<ul>\n<li>数组之间追加</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"language-js\">  var arr1 = [12,'foo',{a:1}]\n  var arr2 = ['a', 23, {b:2}]\n  Array.prototype.push.apply(arr1, arr2)\n  console.log(arr1) // [ 12, 'foo', { a: 1 }, 'a', 23, { b: 2 } ]\n</code></pre>\n<ul>\n<li>\n<p>这里利用了<code>apply</code>会将数组分解为各个参数的效果配合数组的push方法，将第二个数组分别添加到第一个数组实现数组的追加</p>\n</li>\n<li>\n<p>获取数组的最大值</p>\n</li>\n</ul>\n<pre><code class=\"language-js\">  var numbers = [13, 14,5,34,-38,56]\n  var maxNumbers = Math.max.apply(Math, numbers)\n  console.log(maxNumbers)\n</code></pre>\n<ul>\n<li>\n<p>这里数组本身没有max方法，但是Math对象有，所以我们就通过apply将其借用</p>\n</li>\n<li>\n<p>伪类数组调用数组方法实现自定义log方法，代理consolelog方法，并在每个打印之前添加一个（app）前缀</p>\n</li>\n</ul>\n<pre><code class=\"language-js\">  function log(){\n    var args = Array.prototype.slice.apply(arguments)\n    args.unshift('(app)')\n    console.log.apply(console, args) \n  }\n  log(1) // (app) 1\n  log(1,2,3) // (app) 1 2 3\n</code></pre>\n<ul>\n<li>这里的话可能有点难懂，其实实现这个功能我们先是获取到我们需要打印的数据，因为<code>console.log()</code>可以接受多个参数，所以我们采用<code>arguments</code>来获取所有参数，因为要在打印之前添加前缀,其实就是添加一个打印内容，所以我们要在传递给<code>console.log</code>的参数列表里面新增一个，但因为参数列表是一个类数组对象，并没有数组方法，所以我们通过借用数组的slice方法将类数组对象转为数组对象，然后再传递给<code>console.log</code></li>\n</ul>\n<h2>bind方法</h2>\n<ul>\n<li>bind方法其实会创建一个新的函数，称为绑定函数，当调用这个函数的时候，绑定函数会以创建它时传入的第一个参数作为this，第二个及以后的参数按顺序作为原函数的参数来调用原函数</li>\n<li>bind常用用法</li>\n<li>改变系统函数this指向</li>\n</ul>\n<pre><code class=\"language-js\">var foo = {\n  bar: '哈哈',\n  eventBind: function(){\n    setTimeout(function(){\n      console.log(this)\n      console.log(this.bar)\n    }, 20)\n  }\n}\nfoo.eventBind() // window对象   undefined\nvar foo1 = {\n  bar: '哈哈',\n  eventBind: function(){\n    setTimeout(function(){\n      console.log(this)\n      console.log(this.bar)\n    }.bind(this), 20)\n  }\n}\nfoo1.eventBind() // 对象foo1   '哈哈'\n</code></pre>\n<ul>\n<li>\n<p>这里我们想要的是打印出对象<code>foo</code>与它下面<code>bar</code>的值，但是在<code>setTimeout</code>里面，定时器函数内部的this是指向window对象的，所以<code>this.bar</code>会是一个<code>undefined</code>，所以在这里我们可以使用<code>bind</code>来改变<code>this</code>的指向，当我们在函数后面挂载<code>bind</code>并传递当前<code>this</code>进入时，函数内部的<code>this</code>就被我们偏转回了我们想要的对象<code>foo1</code>,所以正确的输出了我们想要的结果</p>\n</li>\n<li>\n<p>那如果我们联系bind会发生什么呐？</p>\n</li>\n</ul>\n<pre><code class=\"language-js\">  var bar = function(){\n    console.log(this.x)\n  }\n  var foo = {\n    x:3\n  }\n  var sed = {\n    x: 4\n  }\n  var func = bar.bind(foo).bind(sed)\n  func() // ?\n  var fiv = {\n    x: 5\n  }\n  var func1 = bar.bind(foo).bind(sed).bind(fiv)\n  func() // ?\n</code></pre>\n<ul>\n<li>答案其实是两个3，并不是我们想象的4，5原因是在javascript中，多次bind是无效的。</li>\n</ul>\n<h2>apply,call,bind比较</h2>\n<ul>\n<li>看下面代码</li>\n</ul>\n<pre><code class=\"language-js\">  var obj = {\n    x: 81\n  }\n  var foo = {\n    getX: function(){\n      return this.x\n    }\n  }\n  console.log(foo.getX.bind(obj)()) // 81\n  console.log(foo.getX.call(obj)) // 81\n  console.log(foo.getX.apply(obj)) // 81\n</code></pre>\n<ul>\n<li>虽然三个都输出81，但是注意，bind方法之后我们又加了一个括号对其调用，所以这里bind在改变this之后并没有马上执行，而是在执行的时候才使用bind方法，而call与apply则是会立即执行</li>\n</ul>","frontmatter":{"title":"javascript回顾","date":"2019-02-27T00:00:00.000Z","tags":["JavaScript回顾","回顾","入门"],"categories":"JavaScript"},"fields":{"slug":"/call-apply/"}}},"pageContext":{"slug":"/call-apply/"}}