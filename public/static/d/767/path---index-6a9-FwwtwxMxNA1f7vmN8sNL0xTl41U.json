{"data":{"allMarkdownRemark":{"totalCount":5,"edges":[{"node":{"html":"<h1>字符串排列 (No repeats please)</h1>\n<h2>题目链接</h2>\n<ul>\n<li><a href=\"https://freecodecamp.cn/challenges/no-repeats-please\">中文链接</a></li>\n<li><a href=\"https://freecodecamp.com/challenges/no-repeats-please\">英文链接</a></li>\n</ul>\n<h2>问题解释</h2>\n<ul>\n<li>这个 <code>function</code> 接收一个字符串参数 <code>str</code>。返回值为参数 <code>str</code> 没有连续重复字符串的排列个数</li>\n<li>如果 <code>str</code> 为 <code>\"aab\"</code>，则返回值应为 <code>2</code>，因为全排列后，会出现两个 <code>\"aba\"</code>，不含连续重复字符串 (排除 <code>\"aab\"</code> 和 <code>\"baa\"</code>)</li>\n</ul>\n<!--more-->\n<h1>解题思路</h1>\n<ul>\n<li>这道题应该是高级算法题目中难度稍大的一道题。题目的难点在于获取字符串的全排列。我觉得这里有必要先说一下，如何获取全排列</li>\n<li>只要我们可以获取字符串的全排列，那就至少有两种方式判断字符串是否含有连续重复的字符。可以遍历，也可以用正则</li>\n<li><a href=\"https://zh.wikipedia.org/wiki/%E7%BD%AE%E6%8F%9B\">排列 (也叫置换)，Permutation</a> 与 <a href=\"https://zh.wikipedia.org/wiki/%E7%B5%84%E5%90%88\">组合，Combination</a>，高中数学就已经涉及到。比如，对于 <code>123</code>，从中取出两个数有三种组合，分别是 <code>12</code>、<code>13</code> 和 <code>23</code>。同样是取出两个数，有六种排列，分别是 <code>12</code>、<code>21</code>、<code>13</code>、<code>31</code>、<code>23</code> 和 <code>32</code></li>\n<li>再说一下什么是全排列 (Full Permutation)，全排列的意思是，从 <code>n</code> 个中取出 <code>n</code> 个的排列。对于 <code>123</code>，取出三个数的排列，就是 <code>123</code> 的全排列。<code>123</code> 的全排列总共有六种，分别是 <code>123</code>、<code>132</code>、<code>213</code>、<code>231</code>、<code>312</code> 和 <code>321</code>。计算数量方式很简单，就是 <code>n!</code>，<code>n</code> 的阶乘。对于 <code>123</code> 来说，也就是 <code>3!</code>，得 <code>6</code></li>\n</ul>\n<h2>全排列的实现 - 封装，循环</h2>\n<ul>\n<li>\n<p>我们可以先根据这个实际的例子想想，怎样才能无遗漏的输出全排列</p>\n<ul>\n<li>两个数就不用说了，对于 <code>12</code>，只有 <code>12</code> 和 <code>21</code> 两种</li>\n<li>\n<p>三个数，比如 <code>123</code>，我们先分为三种情况，就是 <code>1</code> 开头，<code>2</code> 开头和 <code>3</code> 开头</p>\n<ul>\n<li>对于 <code>1</code> 开头的情况，剩下 <code>2</code> 和 <code>3</code>，这就回到了两个数的排列</li>\n<li>对于 <code>2</code> 开头的情况，剩下 <code>1</code> 和 <code>3</code>，这也回到了两个数的排列</li>\n<li><code>3</code> 开头的情况同理</li>\n</ul>\n</li>\n<li>四个数，先按照开头分为四种情况，然后按照三个数的排列去处理</li>\n<li>......</li>\n<li>以此类推</li>\n</ul>\n</li>\n<li>你可能已经看出来了，这就是一个递归。就好像求斐波那契数列的某一个元素，我们要先求出前面的；要想求出前面的，我们就要求出更前面的。记 \"斐波那契数列的第 <code>n</code> 位\" 这件事为 <code>F(n)</code>，则有 <code>F(n) = F(n - 1) + F(n - 2)</code></li>\n<li>类似地，记 \"求出 <code>n</code> 个字符串的全排列\" 这件事为 <code>P(n)</code>，则有 <code>P(n) = 分别以这n个字符之一开头 + P(n - 1)</code>。其中，<code>P(n - 1)</code> 表示去掉那个开头字符的剩余字符串的全排列。哪怕只有两个字符，比如对于上面例子中的 <code>12</code>，同样符合这一条结论</li>\n<li>以 <code>'abc'</code> 为例，执行步骤如下：</li>\n</ul>\n<pre><code>给出 abc\n\n1. a 作为开头 -> 求 bc 全排列 -> 得到 bc 和 cb -> 与 a 合并 -> 得到 abc 和 acb\n2. b 作为开头 -> 求 ac 全排列 -> 得到 ac 和 ca -> 与 b 合并 -> 得到 bac 和 bca\n3. c 作为开头 -> 求 ab 全排列 -> 得到 ab 和 ba -> 与 c 合并 -> 得到 cab 和 cba\n</code></pre>\n<ul>\n<li>注意，这只是其中一种实现方式。后面我们还会看到另一种实现</li>\n<li>首先我们来想一下公共逻辑是什么。对于一个字符串，我们取出一个字符作为开头，然后对去掉这个开头字符的剩余字符串继续求全排列。求出来之后，与取到的字符合并起来就行</li>\n<li>对于 <code>P(n)</code> 来说，我们要取出一个字符作为开头，而且原始的字符串可能本身就含有重复的字符。在代码中，我们可以通过开头字符在原字符串中的索引来区分</li>\n<li>对于我们封装的函数，可以直接使用字符串作为参数。这是因为，在获取剩余字符串全排列，即 <code>P(n - 1)</code> 时，我们并不关心去掉的那个，用作开头的字符是什么，只需要关心现在我们要生成谁的全排列就好</li>\n<li>因此，我们需要在递归调用时，传入去掉那个用作开头的字符之后的，剩余字符串。这个很容易实现，如果我们知道了去掉的那个字符的索引，那我们就可以用 <code>str.slice(0, i)</code> 来获取这个字符之前的字符串，用 <code>str.slice(i + 1, str.length)</code> 来获取这个字符之后的字符串 (注意，<code>slice</code> 方法的第一个参数是包含的，第二个不包含。如果 <code>i</code> 本身就是 <code>0</code>，那么取到的是 <strong>空字符串</strong>)，拼接在一起就可以作为递归调用的参数</li>\n<li>跳出条件也不难想，只要传入的参数长度为 <code>1</code> 或 <code>0</code>，直接返回即可</li>\n<li>另外，每次调用，我们都需要一个数组来保存根据当前参数生成的全排列。代码如下</li>\n</ul>\n<pre><code class=\"language-js\">function permAlone(string) {\n    function _perm(str) {\n        // 跳出条件\n        if (str.length &#x3C; 2) return str;\n        var permutations = [];\n\n        for (var i = 0; i &#x3C; str.length; i++) {\n            // 获取开头的字符串和剩余字符串\n            var start = str[i];\n            var remaining = str.slice(0, i) + str.slice(i + 1, str.length);\n\n            // 根据通过剩余字符串的全排列，生成前一次的全排列。注意 _perm(remaining) 是一个数组\n            for (var permutation of _perm(remaining)) {\n                permutations.push(start + permutation);\n            }\n        }\n        return permutations;\n    }\n}\n</code></pre>\n<h2>判断连续重复字符</h2>\n<h3>遍历</h3>\n<ul>\n<li>判断是否有连续重复的字符，最简单的方式是遍历。只需要在外面用一个变量记录上一个字符就可以</li>\n<li>只要当前的和上一个相同，直接跳出就可以，不需要继续判断。代码如下：</li>\n</ul>\n<pre><code class=\"language-js\">function hasRepeatChar(str) {\n    var previous = '';\n    for (var i = 0; i &#x3C; str.length; i++) {\n        if (previous === str[i]) {\n            return true;\n        } else {\n            // 赋值，用于下次判断\n            previous = str[i];\n        }\n    }\n    // 不存在连续重复字符\n    return false;\n}\n</code></pre>\n<h3>递归</h3>\n<ul>\n<li>递归也是很容易写的。跟上面的思路一样，调用的时候传入两个参数，分别是上一个字符，和剩余字符串。其中，剩余字符串可以通过 <code>str.slice(1)</code> 获取</li>\n<li>为避免 <code>str</code> 本身就是空字符串，需要多一次判断，即如果 <code>prevChar</code> 不是空的 (这说明 <code>prevChar</code> 被赋过值，而并非初始的空值)，我们才可以认为 <code>str</code> 不含连续重复字符，则返回 <code>false</code>。因此，跳出条件是 <code>str</code> 为空且 <code>prevChar</code> 有值。如果这时候 <code>prevChar</code> 也是空的，那就证明传入的 <code>str</code> 本身就是空的。为了防止混淆，我们直接给它返回 <code>\"Empty string\"</code>。事实上，这种 corner case 在这道题目中不会遇到。代码如下：</li>\n</ul>\n<pre><code class=\"language-js\">function hasRepeatChar(str, prevChar) {\n    if (str.length === 0) return prevChar ? false : 'Empty string';\n    if (prevChar === str[0]) return true;\n\n    return hasRepeatChar(str.slice(1), str[0]);\n}\n</code></pre>\n<h3>正则表达式</h3>\n<ul>\n<li>正则是个好东西。在正则里，有一中写法叫做 <code>back reference</code>，就是 <code>\\\\</code> 后面加一个正整数。请参考 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions\">文档</a> 中 <code>\\\\n</code> 的那一行</li>\n<li>简单来说，<code>\\\\x</code> 就是匹配之前，正数第 <code>x</code> 个 matched group (匹配组，也叫捕获组，其实就是小括号包含的内容)</li>\n<li>对于判断一个字符串是否含有连续重复字符，我们并不关注它重复了几次，也不需要关注它有几组重复的。因此，这里不需要 <code>global</code> flag <code>/g</code></li>\n<li>那么，对于字符串中的任意字符，只要这个字符右边的字符和它相同，那就匹配到，并且返回 <code>false</code>。听起来像是句废话，只是，如果你看不懂后面的正则，记得回来再读读这句话。代码如下：</li>\n</ul>\n<pre><code class=\"language-js\">function hasRepeatChar(str) {\n    return !/(\\w)\\1/.test(str);\n}\n</code></pre>\n<h1>基本解法</h1>\n<h2>思路提示</h2>\n<ul>\n<li>思路上面已经说得很清楚。通过上面的递归调用，我们可以得到了一个包含字符串全排列的数组，只需要通过上面的正则过滤一下，保留不含连续重复字符的字符串，并返回它的 <code>length</code></li>\n</ul>\n<h2>代码</h2>\n<pre><code class=\"language-js\">function permAlone(string) {\n    function _perm(str) {\n        if (str.length &#x3C; 2) return str;\n        var permutations = [];\n\n        for (var i = 0; i &#x3C; str.length; i++) {\n            var start = str[i];\n            var remaining = str.slice(0, i) + str.slice(i + 1, str.length);\n\n            for (var permutation of _perm(remaining)) {\n                permutations.push(start + permutation);\n            }\n        }\n        return permutations;\n    }\n    return _perm(string).filter(function(str) {\n        return !/(\\w)\\1/.test(str);\n    }).length;\n}\n</code></pre>\n<h1>数组方法 - 思路的优化</h1>\n<h2>思路提示</h2>\n<ul>\n<li>上面的方式是把子问题 (剩余字符串的全排列) 添加到之前取出的开头字符后面，这也就意味着，对于长度为 <code>n</code> 的字符串 <code>string</code>，开头的字符我们要获取 <code>n</code> 次。每一次取了开头，我们又要再对子问题进行 <code>n - 1</code> 次取开头的操作，因此这时候的时间复杂度会是 <code>n!</code>。效率很低</li>\n<li>如果我们换一个思路，采用 \"插值\" 的方法，会让整体操作变少一些。注意，这个思路并不一定需要用数组去实现。确切的说，如果不用数组去实现，效率会更高。只是个人觉得，用数组会比较容易写，也比较容易理解</li>\n<li>之前的方式，如果我们说它是 \"从前往后\" 实现的，那现在我们来试试从后往前实现</li>\n<li>对于字符串 <code>'abc'</code>，给出子串 <code>'bc'</code>，剩余 <code>'a'</code>。我们可以通过把 <code>'a'</code> 放到 <code>'bc'</code> 里面，不同的位置来实现排列。注意到 <code>'bc'</code> 有三个位置可以插入 <code>'a'</code>，分别是：</li>\n</ul>\n<pre><code> b c\n↑ ↑ ↑\n1 2 3\n</code></pre>\n<ul>\n<li>如果把 <code>'a'</code> 分别插入上面说的位置 <code>1</code>、<code>2</code> 和 <code>3</code>，我们就可以得到 <code>'abc'</code>、<code>'bac'</code> 和 <code>'bca</code></li>\n<li><code>'bc'</code> 排列还有一种情况 <code>'cb'</code>。再把 <code>'a'</code> 插入到 <code>'cb'</code> 的三个位置，我们就可以得到另外三种排列</li>\n<li>注意到，<code>'bc'</code> 和 <code>'cb'</code>，其实就是在子串 <code>'c'</code> 中插入 <code>'b'</code> 产生的。因为 <code>'c'</code> 只有两个位置可以插入 <code>'b'</code>：</li>\n</ul>\n<pre><code> c\n↑ ↑\n1 2\n</code></pre>\n<ul>\n<li>这样，我们就得到了一个新的递归思路，如下 (左边的竖线只是为了方便看清递归弹出的时候对应上面的哪一步，弹出步骤中的插入值与上面取出的第一个字符相对应)：</li>\n</ul>\n<pre><code>给出 'abc'\n\n|- 取出第一个字符 a，剩余 bc\n|  |- 取出第一个字符 b，剩余 c\n|  |  |- 取出第一个字符 c，剩余空字符串 (划重点，这个就是弹出的条件)\n|  |  |- 在上次剩余值中插入 c，只能得到一种情况 c\n|  |- 在上次剩余值 (c) 中插入 b，得到 bc 和 cb\n|- 在上次剩余值 (bc 和 cb) 中插入 a，得到 abc, bac, bca 和 acb, cab, cba\n</code></pre>\n<ul>\n<li>这个思路很像是，先一直走到底 (即长度为 0 的时候)，弹出的过程中，我们再来生成需要的结果</li>\n<li>这段代码加注释不太方便，详细解释还是写到代码之后吧</li>\n<li>如果你还是不知道如何写代码，不要怕麻烦，试着写出来 <code>'abcd'</code> 的详细过程，写完你就能理解了</li>\n</ul>\n<h2>代码</h2>\n<pre><code class=\"language-js\">function permAlone(string) {\n    return _perm(string.split('')).filter(function(str) {\n        return !/(\\w)\\1/.test(str);\n    }).length;\n\n    function _perm(arr) {\n        return arr.length === 0 ? [[]] : _perm(arr.slice(1)).reduce(function(accum, curr) {\n            // 插值的实现\n            for (var i = 0; i &#x3C; arr.length; i++) {\n                accum.push([curr.slice(0, i), arr[0], curr.slice(i)].join(''));\n            }\n            return accum;\n        }, []);\n    }\n}\n</code></pre>\n<h2>解释</h2>\n<ul>\n<li>先说一句，上面的代码，尽管思路优化了，但速度理论上会比之前的慢，因为咱们用了数组</li>\n<li>外面那层应该没啥疑问，既然决定了用数组去处理，那就干脆直接传入数组，一个 <code>split</code> 的事儿而已</li>\n<li>封装的 <code>_perm</code>，其实还是要进行递归调用的。当外面的 <code>string</code> 是空字符串时，返回值是 <code>[[]]</code>，而不可以是 <code>[]</code>。原因很简单，如果是 <code>[]</code>，那么 <code>reduce</code> 就不会执行了，因为没有元素。你可以试试以下的代码片段，就理解了：</li>\n</ul>\n<pre><code class=\"language-js\">// 不会输出 '执行了'，返回值是 []\n[].reduce((accum, curr) => {\n    console.log('执行了');\n    return accum;\n}, []);\n\n// 会输出 '执行了'，返回值也是 []\n[[]].reduce((accum, curr) => {\n    console.log('执行了');\n    return accum;\n}, []);\n</code></pre>\n<ul>\n<li>只要 <code>arr</code> 长度不为 <code>0</code>，那我们就递归调用 <code>_perm(arr.slice(1))</code>，直到遇到传入的 <code>arr</code> 长度为 <code>0</code>，才开始执行 <code>reduce</code> 弹出的过程。详情请看上面的思路分析</li>\n<li>里面的 <code>for</code> 循环很重要，\"插值\" 这个核心步骤就是在这里实现的。如果看不懂这个过程，请去了解一下 <code>slice</code> 方法是怎么回事，然后举几个例子带进去试一试就明白了</li>\n</ul>\n<h1>算法优化 - Heap's algorithm</h1>\n<h2>思路提示</h2>\n<ul>\n<li>注意，这里的 Heap 不是指数据结构的 \"堆\"，而是发明者的名字。如果你从来没听说过这个算法，那只靠自己想可能有些困难</li>\n<li>\n<p>给出字符串 <code>'abc'</code>，我们可以按照先确定结尾字符的思路来这样推一下：</p>\n<ul>\n<li>\n<p><code>'c'</code> 作为结尾：</p>\n<ul>\n<li>我们得到第一个排列 <code>'abc'</code></li>\n<li>通过交换 <code>'a'</code> 和 <code>'b'</code>，我们可以得到另一种排列 <code>'bac'</code></li>\n</ul>\n</li>\n<li>\n<p>交换开头结尾，这时候 <code>'b'</code> 作为结尾：</p>\n<ul>\n<li>得到 <code>'cab'</code></li>\n<li>通过交换 <code>'c'</code> 和 <code>'a'</code>，得到 <code>'acb'</code></li>\n</ul>\n</li>\n<li>\n<p>交换开头结尾，这时候 <code>'a'</code> 作为结尾：</p>\n<ul>\n<li>得到 <code>'bca'</code></li>\n<li>通过交换 <code>'b'</code> 和 <code>'c'</code>，得到 <code>'cba'</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>思路大致上是这样，通过交换去实现。交换的好处在于，我们不需要额外的空间去存储。值得注意的是，在 JavaScript 中，字符串可以通过 index 访问某一个位置的字符，但不可以修改它的值。因此，想要换位，我们还是要通过数组来实现的</li>\n<li>事实上，真正实现起来还与上面的例子有区别。在 <code>Heap's Algorithm</code> 的 <a href=\"https://en.wikipedia.org/wiki/Heap%27s_algorithm\">维基百科页面</a> 有详细的解释，也有四个元素的详细步骤示例。其实，并不是 \"交换开头结尾\" 这么简单的</li>\n<li>实现数组中元素交换的方式也非常多。有朋友可能首先想到的是用 <code>splice</code>，但这样做效率会很低，我会比较推荐用变量缓存一个值的做法，很容易写。比如，我们需要交换 index 为 <code>2</code> 和 <code>4</code> 的元素：</li>\n</ul>\n<pre><code class=\"language-js\">var arr = [1, 2, 3, 4, 5, 6];\n\nvar temp = arr[2];\narr[2] = arr[4];\narr[4] = temp;\n\nconsole.log(arr);  // [1, 2, 5, 4, 3, 6]\n</code></pre>\n<ul>\n<li>当然，还有一种比较好玩儿的黑科技：</li>\n</ul>\n<pre><code class=\"language-js\">var arr = [1, 2, 3, 4, 5, 6];\narr[2] = [arr[4], arr[4] = arr[2]][0]\n\nconsole.log(arr);  // [1, 2, 5, 4, 3, 6]\n</code></pre>\n<ul>\n<li>如果你听说过 ES6 的解构赋值，也可以这么写。注意这个在不支持 ES6 的浏览器里是不行的：</li>\n</ul>\n<pre><code class=\"language-js\">var arr = [1, 2, 3, 4, 5, 6];\n[arr[2], arr[4]] = [arr[4], arr[2]]\n\nconsole.log(arr);  // [1, 2, 5, 4, 3, 6]\n</code></pre>\n<ul>\n<li>维基百科页面也提供了伪代码，而且提供了递归和非递归的两个版本。两个版本都用到了两个参数，但我们只需要一个 <code>n</code> 就够了，不需要第二个 <code>A</code>，因为我们的数组可以通过 <code>var arr = str.split('');</code> 将它定义到函数 <code>generate</code> 外面。这样，伪代码如下：</li>\n</ul>\n<pre><code class=\"language-js\">函数 generate\n参数 num\n\n如果 num 等于 1:\n    arr.join('')，并添加到结果数组\n否则:\n    循环，0 至 num:\n        递归调用 generate(num - 1)\n        如果 num 为偶数:\n            交换 strArr[i] 与 strArr[num - 1]\n        如果 num 为奇数:\n            交换 strArr[0] 与 strArr[num - 1]\n</code></pre>\n<h2>代码</h2>\n<pre><code class=\"language-js\">function permAlone(str) {\n    var arr = str.split('');\n    var result = [];\n    // 声明需要放在这里，因为赋值是在弹出的时候执行的\n    var tempIndex;\n\n    function generate(num) {\n        if (num === 1) {\n            result.push(arr.join(''));\n        } else {\n            for (var i = 0; i &#x3C; num; i++) {\n                generate(num - 1);\n                tempIndex = num % 2 ? 0 : i;\n                arr[tempIndex] = [arr[num - 1], arr[num - 1] = arr[tempIndex]][0];\n            }\n        }\n    }\n    \n    generate(arr.length);\n    \n    return result.filter(function(str) {\n        return !/(\\w)\\1/.test(str);\n    }).length;\n}\n</code></pre>","fields":{"slug":"/advanced-no-repeats-please/"},"frontmatter":{"title":"FreeCodeCamp 高级算法题 - 字符串排列","tags":["FreeCodeCamp","高级","算法"],"categories":"FCC"}}},{"node":{"html":"<p>Francis write his second blog\n意不意外，惊不惊喜</p>\n<div>哈哈哈哈还，我是第二个div哦</div>","fields":{"slug":"/second-blog/"},"frontmatter":{"title":"second blog","tags":["FreeCodeCamp","高级","算法"],"categories":"FCC"}}},{"node":{"html":"<p>Francis write his third blog\n意不意外，惊不惊喜</p>\n<div>哈哈哈哈还，我是第三个div哦</div>","fields":{"slug":"/third-blog/"},"frontmatter":{"title":"third blog","tags":["FreeCodeCamp","高级","算法"],"categories":"FCC"}}},{"node":{"html":"<h1>类型</h1>\n<h2>内置类型</h2>\n<ul>\n<li>内置类型有哪些？如何校验？</li>\n<li>特殊类型有哪些？注意事项是？</li>\n</ul>\n<h2>问题解释</h2>\n<ul>\n<li>内置类型为空值<code>(null)</code>，未定义<code>(undefined)</code>，布尔值<code>(boolean)</code>，数字<code>(number)</code>，字符串<code>(string)</code>，对象<code>(object)</code>，符号<code>(symbol,ES6新增)</code></li>\n<li>\n<p>特殊类型为空值(特殊对象)，数组(特殊对象)，函数(特殊对象)</p>\n<!--more-->\n</li>\n<li>\n<p>类型校验</p>\n<pre><code class=\"language-js\">typeof undefined === 'undefined' //true\ntypeof true === 'boolean' //true\ntypeof 42 === 'number' //true\ntypeof '42' === 'string' //true\ntypeof {a:2} === 'object' //true\ntypeof Symbol() === 'symbol' //true\n// 特殊情况\ntypeof null === 'object' //true\ntypeof [1,2,3] === 'object' //true\ntypeof function(){} === 'function' // true\n</code></pre>\n<h3>校验方式</h3>\n</li>\n<li>校验null (!a &#x26;&#x26; typeof a ==='object') //true</li>\n<li>校验数组 arr.constructor === Array 或 arr instanceof Array</li>\n</ul>\n<h3>数组</h3>\n<ul>\n<li>\n<p>数组可以容纳任何类型的值，无需设定大小</p>\n</li>\n<li>\n<p>delete运算符可以将单元从数组中删除，但，删除后，数组length属性不会发生变化</p>\n</li>\n<li>\n<p>数组通过数组进行索引，但因为它是对象的本质，所以也可以包含字符串键值与属性<code>(但并不计算在数组长度内)</code></p>\n<pre><code class=\"language-js\">var a = []\na[0] = 1\na['foo'] = 2\na.length; // 1\na['foo']; // 2\na.foo;    // 2\n</code></pre>\n</li>\n<li>\n<p>注意点：若字符串键值能强制转换为数字的话，会被当作数字索引来处理</p>\n<pre><code class=\"language-js\">  var a = []\n  a['13'] = 42\n  a.length; // 14\n</code></pre>\n</li>\n<li>\n<p>Array.from()可将类数组对象转为数组对象，例（arguments,dom列表）</p>\n<h2>字符串与字符串数组</h2>\n</li>\n<li>\n<p>都具有<code>length</code>属性与<code>indexOf</code>方法和<code>concat</code>方法</p>\n<pre><code class=\"language-js\">var a = 'foo'\nvar b = ['f','o','o']\n\na.length; // 3\nb.length; //3\n\na.indexOf('o') // 1\nb.indexOf('o') // 1\nvar c = a.concat('bar') //foobar\nvar d = b.concat(['b', 'a', 'r']) // ['f', 'o', 'o', 'b', 'a', 'r']\n</code></pre>\n</li>\n<li>\n<p>字符串没有数组函数，但可以借用数组的非变更方法来处理</p>\n<pre><code class=\"language-js\">var c = Array.prototype.join.call(a, '-')\nvar d = Array.prototype.map.call(a, function(v) {\n  return v.toUpperCase() + '.'\n}).join(\"\")\nc; //\"f-o-o\"\nd: //\"f.o.o\"\n</code></pre>\n</li>\n<li>\n<p>不可借用数组的可变成员函数reverse,因为字符串是不可变的<code>Array.prototype.reserve.call(a)</code>无效</p>\n</li>\n<li>\n<p>处理方法：</p>\n<pre><code class=\"language-js\">var c = a.split(\"\").reverse().join(\"\")\n</code></pre>\n</li>\n</ul>\n<h2>数字</h2>\n<ul>\n<li>检测是否是整数 <code>Number.isInteger()</code></li>\n<li>检测是狗是安全整数 <code>Number.isSafeInteger()</code></li>\n<li>检测是否是NaN <code>Number.isNaN()</code></li>\n<li>检测两个值是否绝对相等 <code>Object.is(a, b)</code></li>\n</ul>\n<h2>奇特的小技巧</h2>\n<ul>\n<li>\n<p>~运算符可将结果强制类型转换为真值/假值</p>\n<pre><code class=\"language-js\">var a = \"Hello world\"\nif(~a.indexOf('lo')) { // true\n  // 找到匹配\n}\n// 相应的 !~a.indexOf('lo')为未找到匹配\n</code></pre>\n</li>\n</ul>","fields":{"slug":"/type/"},"frontmatter":{"title":"你不知道的javascript-类型","tags":["javascript","入门"],"categories":"JavasSript"}}},{"node":{"html":"<h1>TCP协议的3次握手与4次分手</h1>\n<h2>TCP协议的连接与断开</h2>\n<ul>\n<li>什么是TCP协议的三次握手？为什么会有三次握手？</li>\n<li>什么是TCO协议的四次分手？为什么会有四次分手？</li>\n</ul>\n<h2>问题解释</h2>\n<ul>\n<li>TCP的三次握手其实是在客户端与服务端建立一个TCP连接，在TCP/IP协议中，采用三次握手可建立可靠的连接服务</li>\n<li>\n<p>TCP的四次分手用来断开客户端与服务端的连接</p>\n<!--more-->\n</li>\n</ul>\n<h2>详解</h2>\n<h3>TCP报文重要字段解释</h3>\n<ul>\n<li>序号：<code>seq</code>序号，标识从TCP源向目的端发送字节流，并由发送端对其标记</li>\n<li>确认序号：<code>ack</code>序号，只有<code>ACK</code>标志位为1时确认序号字段才有效，<code>ack=seq+1</code>（注意：<code>ack</code>序号与<code>ACK</code>标志位不是同一个东西）</li>\n<li>注意：确认放<code>ack</code>=发起方<code>req+1</code>时两者配对成功</li>\n<li>\n<p>标志位：共六个，即<code>URG</code>,<code>ACK</code>,<code>PSH</code>,<code>RST</code>,<code>SYN</code>,<code>FIN</code></p>\n<ul>\n<li><code>ACK</code>:确认序号有效</li>\n<li><code>PSH</code>:接收方尽快将报文提交应用层</li>\n<li><code>RST</code>:连接重置</li>\n<li><code>URG</code>:紧急指针有效</li>\n<li><code>SYN</code>:发起一个新连接</li>\n<li><code>FIN</code>:释放一个链接</li>\n</ul>\n</li>\n</ul>\n<h3>三次握手</h3>\n<ul>\n<li>\n<p>三次握手是为了在客户端与服务端建立可靠安全的连接服务，所以需要三次握手确认</p>\n<ul>\n<li>第一次：客户端将标志位<code>SYN</code>设置为<code>1</code>，产生一个随机值<code>seq=J</code>并将其发送给server,等待server确认，自己进入<code>SYN_SENT</code>状态（我要跟你连接了，你看看你听得到吗）</li>\n<li>第二次：server收到数据包由<code>SYN=1</code>知道客户端建立请求，server将标志位<code>SYN</code>与<code>ACK</code>都设置为1，随机产生一个值<code>seq=K</code>，并将该数据发回客户端确认连接请求，server进入<code>SYN_RCVD</code>状态（我听到了，你看看你听得到我吗）</li>\n<li>第三次：客户端收到确认后检查<code>ack</code>是否为<code>J+1</code>,<code>ACK</code>是否为<code>1</code>，如果正确则将标志位<code>ACK</code>设置为<code>1</code>，<code>ack=K+1</code>,并将数据包发给server，server检查<code>ack</code>是否为<code>K+1</code>,<code>ACK</code>是否为<code>1</code>，如果正确则连接建立成功，客户端与服务端进入<code>ESTABLISHED</code>状态，完成三次握手，此后客户端与服务端即可开始传输数据了（我也能听到了，咱们来交流吧）</li>\n</ul>\n</li>\n</ul>\n<h3>四次分手</h3>\n<ul>\n<li>\n<p>当我们用三次握手建立连接后数据传输完成要断开TCP链接啊，所以就有了四次分手</p>\n<ul>\n<li>由于TCP连接是双全工的，每个方向都需要单独关闭，当一方发送数据完成后需要发送一个<code>FIN</code>来终止这一方向连接，收到FIN只是表示对方不会有数据流动了，但是接收方依然可以发送数据，直到接收方也发送了<code>FIN</code></li>\n<li>第一次：客户端发送一个FIN，用来关闭客户端到服务端的数据传输，客户端进入<code>FIN_WAIT_1</code>状态（我没有要说的了，我想关闭连接了）</li>\n<li>第二次：服务端收到<code>FIN</code>后，发送一个<code>ACK</code>给客户端，确认序号为收到序号+1，服务端进入<code>CLOSE_WAIT</code>状态（我知道你不想说了，我不确定我还有没有要说的）</li>\n<li>第三次：服务端向客户端发送一个<code>FIN</code>，用来关闭服务端到客户端的数据传输，服务端进入<code>LAST_ACK</code>状态（我也没有要说的了，咱关闭连接吧）</li>\n<li>第四次：客户端收到<code>FIN</code>后，客户端进入<code>TIME_WAIT</code>状态，接着发送一个<code>ACK</code>给服务端，确认序号为收到序号+1，服务端进入<code>CLOSED</code>状态，完成四次分手（好的，我知道了，咱关闭吧，你听不到我的声音就说明关闭了）</li>\n</ul>\n</li>\n<li>\n<p>为什么建立连接是三次而分手要四次呐？</p>\n<ul>\n<li>因为服务端在<code>LISTEN</code>状态下，收到建立请求的<code>SYN</code>报文后，把<code>ACK</code>与<code>SYN</code>都放在一个报文里发给了客户端。关闭连接时当收到对方的<code>FIn</code>报文仅仅表示对方不再发数据了，但还能接数据，自己也未必把所有数据发送给对方了，所以己方可以立即关闭也可以发送数据后再发送<code>FIn</code>报文给对方同意现在关闭，因此<code>ACK</code>与<code>FIN</code>都会分开发送</li>\n</ul>\n</li>\n</ul>","fields":{"slug":"/first-blog/"},"frontmatter":{"title":"HTTP与TCP/IP了解","tags":["HTTP","TCP/IP"],"categories":"HTTP"}}}]}},"pageContext":{}}