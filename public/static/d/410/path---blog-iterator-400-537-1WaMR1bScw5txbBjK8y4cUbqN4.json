{"data":{"markdownRemark":{"html":"<h1>一脸懵逼的迭代器</h1>\n<h2>迭代器</h2>\n<ul>\n<li>迭代器：<code>迭代器</code>是一个结构化的模式，用于从一个源一次一个的方式获取数据</li>\n<li><code>JavaScript</code>开发中从来不缺乏它的出现，总有各种各样的方法来实现它</li>\n<li><code>ES6</code>中为<code>迭代器</code>提供了一个<code>隐式的标准化接口</code>，并在一些内建数据结构中都实现了它</li>\n</ul>\n<!--more-->\n<h1>内置数据结构迭代器</h1>\n<h2>数组</h2>\n<ul>\n<li>\n<p><code>数组</code>中的迭代器</p>\n<pre><code class=\"language-js\">let arr = [1,2,3]\nlet it = arr[Symbol.iterator]()\nit.next() // { value: 1, done: false }\nit.next() // { value: 2, done: false }\nit.next() // { value: 3, done: false }\nit.next() // { value: undefined, done: true }\n</code></pre>\n</li>\n<li>每次在数祖上调用<code>Symbol.iterator</code>方法时都会产生一个新的迭代器</li>\n<li>当数组迭代完成并不会立即将<code>done</code>设置为<code>true</code>,而是在迭代完所有之后再迭代一次才会将其改变</li>\n</ul>\n<h2>字符串</h2>\n<ul>\n<li>\n<p><code>字符串</code>中的迭代器</p>\n<pre><code class=\"language-js\">let str = 'hello'\nlet it = arr[Symbol.iterator]()\nconsole.log(it.next()) // { value: 'h', done: false }\nconsole.log(it.next()) // { value: 'e', done: false }\nconsole.log(it.next()) // { value: 'l', done: false }\nconsole.log(it.next()) // { value: 'l', done: false }\nconsole.log(it.next()) // { value: 'o', done: false }\nconsole.log(it.next()) // { value: undefined, done: true }\n</code></pre>\n</li>\n<li>严格来说<code>字符串</code>本身并不是<code>iterator</code>,但是这里被强制转换为<code>String对象</code>封装形式，从而变成一个<code>iterator</code></li>\n</ul>\n<h2>map</h2>\n<ul>\n<li>\n<p><code>map</code>中的迭代器</p>\n<pre><code class=\"language-js\">let map = new Map()\nmap.set({name: '张三'}, {age: 24})\nmap.set('foo', 42)\nlet it = map[Symbol.iterator]()\nconsole.log(it.next()) // { value: [ { name: '张三' }, { age: 24 } ], done: false }\nconsole.log(it.next()) // { value: [ 'foo', 42 ], done: false }\nconsole.log(it.next()) // { value: undefined, done: true }\nlet arr = [1,2,3]\nlet str = 'hello'\nlet map = new Map()\nmap.set({name: '张三'}, {age: 24})\nmap.set('foo', 42)\nfor(let v of map) {\nconsole.log(v)\n}\n</code></pre>\n<h2>for...of循环迭代器</h2>\n</li>\n<li>\n<p><code>for...of</code>可用于消耗迭代器，也就是<code>循环调用迭代器</code>，形式如下</p>\n<pre><code class=\"language-js\">let map = new Map()\nmap.set({name: '张三'}, {age: 24})\nmap.set('foo', 42)\nfor(let v of map) {\nconsole.log(v)\n}\n// [ { name: '张三' }, { age: 24 } ], [ 'foo', 42 ]\n</code></pre>\n</li>\n<li><code>for...of</code>会将迭代器中的内容返回</li>\n</ul>\n<h1>自定义迭代器</h1>\n<ul>\n<li>利用<code>Symbol.itertor</code>我们可以构造可以与<code>ES6</code>交互的属于自己的<code>迭代器</code></li>\n<li>\n<p>下面是构造一个<code>无限斐波纳契序列</code></p>\n<pre><code class=\"language-js\">var Fib = {\n[Symbol.iterator](){\n  let n1 = 1, n2 = 1\n  return {\n    [Symbol.iterator](){return this},\n    next(){\n      let current = n2\n      n2 = n1\n      n1 = current + n1\n      return {value: current, done: false}\n    },\n    return (v){\n      console.log(\n      \"Fibonacci sequence abandoned.\"\n      );\n      return { value: v, done: true }; \n    }\n  }\n}\n}\nfor(let v of Fib) {\nconsole.log(v)\nif(v > 500) break\n}\n// 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610\n</code></pre>\n</li>\n<li>这里当我们调用<code>Fib</code>的<code>Symbol.iterator</code>方法会返回一个带有<code>next</code>跟<code>return</code>方法的迭代器</li>\n<li>通过闭包里面的<code>n1</code>与<code>n2</code>来维护数据</li>\n</ul>\n<h1>迭代器其他用法</h1>\n<h2>模拟事件队列机制</h2>\n<ul>\n<li>\n<p>下面实现一个<code>运行一系列事件</code>的迭代器</p>\n<pre><code class=\"language-js\">let tasks = {\n[Symbol.iterator](){\n  let steps = this.options.slice()\n  return {\n    [Symbol.iteratro](){return this},\n    next(...args){\n      if(steps.length > 0) {\n        let res = steps.shift()(...args)\n        return {value: res, done: false}\n      } else {\n        return { done: true }\n      }\n    }\n  }\n},\noptions: []\n}\ntasks.options.push(\nfunction(x){\n  return x * 2\n},\nfunction(x, y){\n  return x + y * 2\n},\nfunction(x, y, z) {\n  return x * y + z\n}\n)\nlet it = tasks[Symbol.iterator]()\nconsole.log(it.next(10)) //{ value: 20, done: false } \nconsole.log(it.next(10, 20)) //{ value: 50, done: false }\nconsole.log(it.next(10, 20, 30)) //{ value: 230, done: false }\nconsole.log(it.next()) //{ done: true }\n</code></pre>\n</li>\n<li>其中可以看到，我们将要运行的事件都传入我们的<code>数组集合options</code>中，然后便可以迭代运行了</li>\n</ul>\n<h2>模拟数字生成数组</h2>\n<ul>\n<li>\n<p>我们可以将数字构造为一个迭代器，使其拥有迭代器的一些操作，用来<code>生成数组</code>或<code>一定次数的循环</code></p>\n<pre><code class=\"language-js\">if(!Number.prototype[Symbol.iterator]){\nObject.defineProperty(\n  Number.prototype,\n  Symbol.iterator,\n  {\n    writable: true,\n    configurable: true,\n    enumerable: false,\n    value: function iterator(){\n      var i, inc, done = false, top = +this\n      inc = 1 * (top &#x3C; 0 ? -1 : 1)\n      return {\n        [Symbol.iterator](){return this},\n        next(){\n          if(!done) {\n            if(i == null) {\n              i = 0\n            } else if (top >= 0) {\n              i = Math.min(top, i + inc)\n            } else {\n              i = Math.max(top, i + inc)\n            }\n            if(i == top) {done = true}\n            return {value: i, done: false}\n          } else {\n            return {done: true}\n          }\n        }\n      }\n    }\n  }\n)\n}\nfor(let v of 3) {\nconsole.log(v)\n}\n// 0 1 2 3\n\n[...3] // [0,1,2,3]\n</code></pre>\n</li>\n<li>\n<p>第一个<code>for...of</code>循环可以使我们循环指定次数来完成我们的操作</p>\n</li>\n<li>\n<p>因为我们<code>ES6</code>的<code>解构符</code>本来就可以<code>消耗</code>或者说是<code>解读</code>我们的迭代器，所以会帮助我们直接生成指定长度的纯数字数组</p>\n</li>\n</ul>","frontmatter":{"title":"ES2015迭代器","date":"2019-03-12T00:00:00.000Z","tags":["JavaScript","ES2015","进修"],"categories":null},"fields":{"slug":"/iterator/"}}},"pageContext":{"slug":"/iterator/"}}