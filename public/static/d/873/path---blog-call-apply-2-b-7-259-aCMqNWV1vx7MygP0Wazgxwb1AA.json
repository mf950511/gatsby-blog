{"data":{"markdownRemark":{"html":"<h1>call,apply,bind详解</h1>\n<h2>call,apply,bind的使用</h2>\n<ul>\n<li>call,apply,bind的作用是什么？用法是什么？</li>\n<li>call,apply,bind之间有什么联系？区别是什么？</li>\n</ul>\n<h2>问题详解</h2>\n<ul>\n<li>功能上，call，apply，bind都可以用来改变函数内部this的指向</li>\n<li>用法上，三者都是函数调用对应的call,apply,bind方法，传入不同的参数实现函数内部this指向改变</li>\n</ul>\n<!--more-->\n<h2>apply与call</h2>\n<ul>\n<li><code>call</code>与<code>apply</code>在功能上是完全一致的，都是为了改变函数运行的上下文，即this的指向</li>\n<li>用法上，<code>apply</code>接受两个参数，第一个是重新定义的this对象，第二个则是想要传递给函数的参数列表的集合，是一个数组</li>\n<li><code>call</code>接受多个参数，第一个参数为重新定义的this对象，第二个及以后的各个参数即为传递给函数的参数列表</li>\n<li>综上，当函数的参数数量确定的情况下，可以使用<code>call</code>，当函数参数数量不确定的情况下应该使用<code>apply</code>,可以将参数push进数组，然后将数组作为第二个参数，或者可以在函数内部通过<code>arguments</code>来获取所有参数列表</li>\n</ul>\n<h3>apply与call妙用</h3>\n<ul>\n<li>当我们一个对象没有某个方法，但是别的对象有的情况下我们就可以使用call或者apply来“借用”别的对象的方法，例：</li>\n</ul>\n<pre><code class=\"language-js\">  \nvar apple = {\n  color: 'red',\n  say: function(){\n    console.log(this.color)\n  }\n}\nvar banana = {\n  color: 'yellow'\n}\napple.say.call(banana) // yellow\n</code></pre>\n<ul>\n<li>\n<p>这里banana本来是没有say这个方法的，但是apple有这个方法，所以我们暂时借用他的方法来说出自己的颜色</p>\n</li>\n<li>\n<p>call与apply的常用妙法</p>\n<ul>\n<li>\n<p>数组之间追加</p>\n<pre><code class=\"language-js\">var arr1 = [12,'foo',{a:1}]\nvar arr2 = ['a', 23, {b:2}]\nArray.prototype.push.apply(arr1, arr2)\nconsole.log(arr1) // [ 12, 'foo', { a: 1 }, 'a', 23, { b: 2 } ]\n</code></pre>\n<p>这里利用了<code>apply</code>会将数组分解为各个参数的效果配合数组的push方法，将第二个数组分别添加到第一个数组实现数组的追加</p>\n</li>\n<li>\n<p>获取数组的最大值</p>\n<pre><code class=\"language-js\">var numbers = [13, 14,5,34,-38,56]\nvar maxNumbers = Math.max.apply(Math, numbers)\nconsole.log(maxNumbers)\n</code></pre>\n<p>这里数组本身没有max方法，但是Math对象有，所以我们就通过apply将其借用</p>\n</li>\n<li>\n<p>伪类数组调用数组方法实现自定义log方法，代理consolelog方法，并在每个打印之前添加一个（app）前缀</p>\n<pre><code class=\"language-js\">function log(){\nvar args = Array.prototype.slice.apply(arguments)\nargs.unshift('(app)')\nconsole.log.apply(console, args) \n}\nlog(1) // (app) 1\nlog(1,2,3) // (app) 1 2 3\n</code></pre>\n<p>这里的话可能有点难懂，其实实现这个功能我们先是获取到我们需要打印的数据，因为<code>console.log()</code>可以接受多个参数，所以我们采用<code>arguments</code>来获取所有参数，因为要在打印之前添加前缀,其实就是添加一个打印内容，所以我们要在传递给<code>console.log</code>的参数列表里面新增一个，但因为参数列表是一个类数组对象，并没有数组方法，所以我们通过借用数组的slice方法将类数组对象转为数组对象，然后再传递给<code>console.log</code></p>\n</li>\n</ul>\n</li>\n</ul>\n<h3>bind方法</h3>\n<ul>\n<li>bind方法其实会创建一个新的函数，称为绑定函数，当调用这个函数的时候，绑定函数会以创建它时传入的第一个参数作为this，第二个及以后的参数按顺序作为原函数的参数来调用原函数</li>\n<li>\n<p>bind常用用法</p>\n<ul>\n<li>\n<p>改变系统函数this指向</p>\n<pre><code class=\"language-js\">var foo = {\nbar: '哈哈',\neventBind: function(){\n  setTimeout(function(){\n    console.log(this)\n    console.log(this.bar)\n  }, 20)\n}\n}\nfoo.eventBind() // window对象\n</code></pre>\n<p>在setTimeout里面，定时器函数内部的this是指向window对象的</p>\n</li>\n</ul>\n</li>\n</ul>","frontmatter":{"title":"javascript回顾","date":"2019-2-27","tags":["JavaScript","回顾","入门"],"categories":"JavasSript"},"fields":{"slug":"/call-apply/"}}},"pageContext":{"slug":"/call-apply/"}}