{"data":{"markdownRemark":{"html":"<h1>生成器详解</h1>\n<h2>生成器</h2>\n<ul>\n<li>生成器是什么？为什么会需要生成器？</li>\n</ul>\n<h2>生成器的由来</h2>\n<ul>\n<li>传统异步流程对程序员并不友好，设定回调函数的方式不符合大脑对任务步骤的规划</li>\n<li>生成器就是实现看似同步的异步流程控制</li>\n</ul>\n<!--more-->\n<h1>生成器的奇特之处</h1>\n<h2>打破完整运行</h2>\n<ul>\n<li>传统意义上，<code>javascript</code>函数一旦开始运行，那么在结束之前将没有别的代码可以打断并插入运行</li>\n<li>\n<p>ES2015引入了新的函数类型，并不符合从始到终不可打断的原则，这类新的函数就是生成器</p>\n<pre><code class=\"language-js\">var x = 1;\nfunction foo() {\nx++\nbar();\nconsole.log( \"x:\", x )\n}\nfunction bar() {\nx++\n}\nfoo(); // x: 3 \n</code></pre>\n</li>\n<li>这里因为bar存在于foo内部，所以可以实现x的改变，那如过在外面调用bar有没有可能改变x的输出呐？</li>\n<li>如果在多线程语言中，这个自然可以通过抢占线程来实现，但javascript是一个单线程的语言。但是，要是我们通过让<code>foo</code>暂停然后先执行<code>bar</code>会怎么样呐？</li>\n<li>\n<p>下面就是我们用ES2015来实现的效果</p>\n<pre><code class=\"language-js\">var x = 1;\nfunction *foo() {\nx++;\nyield; // 暂停！\nconsole.log( \"x:\", x );\n}\nfunction bar() {\nx++;\n} \n// 构造一个迭代器it来控制这个生成器\nvar it = foo();\n// 这里启动foo()！\nit.next();\nx; // 2\nbar();\nx; // 3\nit.next(); // x: 3\n</code></pre>\n</li>\n<li><code>it=foo()</code> 运算其实只是生成了一个迭代器，并没有执行生成器（迭代器在下面会介绍）</li>\n<li>第一个<code>it.next()</code>执行了生成器，也就运行了<code>*foo</code>代码里的<code>x++</code>这一句，停在了<code>yield</code></li>\n<li><code>*foo</code>停在了<code>yield</code>这里，第一个<code>it.next</code>调用结束，暂停了<code>foo</code>,此时<code>x</code>值变为<code>2</code></li>\n<li>暂停<code>foo</code>后我们执行了<code>bar</code>函数使<code>x</code>变为<code>3</code></li>\n<li>最后一个<code>it.next</code>将生成器恢复了，使其完成代码块的执行，打印了<code>3</code></li>\n<li>这里我们也能发现，生成器函数与普通函数相比函数名之前会多一个<code>*</code>,并且函数执行过程碰到<code>yield</code>会被暂停</li>\n</ul>\n<h2>输入与输出</h2>\n<ul>\n<li>\n<p>生成器作为一个函数，除了有新的执行模式，还具备一般函数的基本特性，可接受参数与返回值</p>\n<pre><code class=\"language-js\">function *foo(x,y) {\nreturn x * y;\n}\nvar it = foo( 6, 7 ); \nvar res = it.next();\nres.value; // 42 \n</code></pre>\n</li>\n<li>\n<p>生成器的传参，返回值与传统函数一致</p>\n</li>\n<li>\n<p>注意：这里我们能看到foo(6,7)并没有像普通函数一样执行，是因为这一步只是执行了迭代器的生成并赋值给了it,然后我们才可以对其进行暂停与恢复</p>\n</li>\n<li>\n<p>it.next是让生成器从当前位置继续运行，直到碰到下一个yield或者生成器代码执行结束</p>\n</li>\n<li>\n<p>it.next调用的结果是一个对象，有value属性，值为生成器返回的值(如果有的话)</p>\n</li>\n</ul>\n<h2>迭代器消息传递</h2>\n<ul>\n<li>\n<p>迭代器除了控制生成器之外，还提供了消息的输入与输出，通过yield与next(..)实现</p>\n<pre><code class=\"language-js\">function *foo(x) {\nvar y = x * (yield);\nreturn y;\n}\nvar it = foo( 6 );\n// 启动foo(..)\nit.next();\nvar res = it.next( 7 );\nres.value; // 42 \n</code></pre>\n</li>\n<li>这里是外部消息的输入，foo函数接受原始参数6，之后执行到了yield这一步暂停，并要求调用代码即it.next为yield提供一个结果值</li>\n<li>第二个it.next作为yield的恢复调用理所当然的需要提供一个值，也就是我们的7</li>\n<li>所以函数内部y = x * (yield) 其实就是y = 6 * 7即42</li>\n<li>这里我们要注意，迭代器的next总要比生成器的yield多一个，因为它需要第一个next来启动生成器，其后才是每次遇到yield暂停，next恢复</li>\n</ul>\n<pre><code class=\"language-js\">function *foo(x) {\n  var y = x * (yield \"Hello\"); // &#x3C;-- yield一个值！\n  return y;\n}\nvar it = foo( 6 );\nvar res = it.next(); // 第一个next()，并不传入任何东西\nres.value // \"Hello\"\nres = it.next( 7 ); // 向等待的yield传入7\nres.value; // 42 \n</code></pre>\n<ul>\n<li>这里与上面的改动在于yield之后跟了一个数据'Hello'，它其实是yield传给外面的数据，用来响应next的调用</li>\n<li>上面也就是我们生成器的消息互通，通过yield与next构成消息的双向传递</li>\n</ul>","frontmatter":{"title":"ES2015生成器","date":"2019-02-28","tags":["JavaScript","ES2015","进修"],"categories":null},"fields":{"slug":"/yield/"}}},"pageContext":{"slug":"/yield/"}}