{"data":{"markdownRemark":{"html":"<h1>一脸懵逼的迭代器</h1>\n<h2>迭代器</h2>\n<ul>\n<li>迭代器：迭代器是一个结构化的模式，用于从一个源一次一个的方式获取数据</li>\n<li>JavaScript开发中从来不缺乏它的出现，总有各种各样的方法来实现它</li>\n<li>ES6中为迭代器提供了一个隐式的标准化接口，并在一些内建数据结构中都实现了它</li>\n</ul>\n<!--more-->\n<h1>细观迭代器</h1>\n<h2>内置数据结构迭代器</h2>\n<h3>数组</h3>\n<ul>\n<li>\n<p>数组中的迭代器</p>\n<pre><code class=\"language-js\">let arr = [1,2,3]\nlet it = arr[Symbol.iterator]()\nit.next() // { value: 1, done: false }\nit.next() // { value: 2, done: false }\nit.next() // { value: 3, done: false }\nit.next() // { value: undefined, done: true }\n</code></pre>\n</li>\n<li>每次在数祖上调用Symbol.iterator方法时都会产生一个新的迭代器</li>\n<li>当数组迭代完成并不会立即将done设置为true,而是在迭代完所有之后再迭代一次才会将其改变</li>\n</ul>\n<h3>字符串</h3>\n<ul>\n<li>\n<p>字符串中的迭代器</p>\n<pre><code class=\"language-js\">let str = 'hello'\nlet it = arr[Symbol.iterator]()\nconsole.log(it.next()) // { value: 'h', done: false }\nconsole.log(it.next()) // { value: 'e', done: false }\nconsole.log(it.next()) // { value: 'l', done: false }\nconsole.log(it.next()) // { value: 'l', done: false }\nconsole.log(it.next()) // { value: 'o', done: false }\nconsole.log(it.next()) // { value: undefined, done: true }\n</code></pre>\n</li>\n<li>严格来说字符串本事并不是iterator,但是这里被强制转换为String对象封装形式，从而变成一个iterator</li>\n</ul>\n<h3>map</h3>\n<ul>\n<li>\n<p>map中的迭代器</p>\n<pre><code class=\"language-js\">let map = new Map()\nmap.set({name: '张三'}, {age: 24})\nmap.set('foo', 42)\nlet it = map[Symbol.iterator]()\nconsole.log(it.next()) // { value: [ { name: '张三' }, { age: 24 } ], done: false }\nconsole.log(it.next()) // { value: [ 'foo', 42 ], done: false }\nconsole.log(it.next()) // { value: undefined, done: true }\nlet arr = [1,2,3]\nlet str = 'hello'\nlet map = new Map()\nmap.set({name: '张三'}, {age: 24})\nmap.set('foo', 42)\nfor(let v of map) {\nconsole.log(v)\n}\n</code></pre>\n<h2>for...of循环迭代器</h2>\n</li>\n<li>\n<p>for...of可用于消耗迭代器，也就是循环调用迭代器，形式如下</p>\n<pre><code class=\"language-js\">let map = new Map()\nmap.set({name: '张三'}, {age: 24})\nmap.set('foo', 42)\nfor(let v of map) {\nconsole.log(v)\n}\n// [ { name: '张三' }, { age: 24 } ], [ 'foo', 42 ]\n</code></pre>\n</li>\n<li>for...of会将迭代器中的内容返回</li>\n</ul>\n<h1>自定义迭代器</h1>\n<ul>\n<li>利用Symbol.itertor我们可以构造可以与ES6交互的属于自己的迭代器</li>\n<li>\n<p>下面是构造一个无限斐波纳契序列</p>\n<pre><code class=\"language-js\">var Fib = {\n[Symbol.iterator](){\n  let n1 = 1, n2 = 1\n  return {\n    [Symbol.iterator](){return this},\n    next(){\n      let current = n2\n      n2 = n1\n      n1 = current + n1\n      return {value: current, done: false}\n    },\n    return (v){\n      console.log(\n      \"Fibonacci sequence abandoned.\"\n      );\n      return { value: v, done: true }; \n    }\n  }\n}\n}\nfor(let v of Fib) {\nconsole.log(v)\nif(v > 500) break\n}\n// 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610\n</code></pre>\n</li>\n<li>这里当我们调用Fib的Symbol.iterator方法会返回一个带有next跟return方法的迭代器</li>\n<li>通过闭包里面的n1与n2来维护数据</li>\n</ul>\n<h1>迭代器其他用法</h1>\n<h2>模拟事件队列机制</h2>\n<ul>\n<li>\n<p>下面实现一个运行一系列事件的迭代器</p>\n<pre><code class=\"language-js\">let tasks = {\n[Symbol.iterator](){\n  let steps = this.options.slice()\n  return {\n    [Symbol.iteratro](){return this},\n    next(...args){\n      if(steps.length > 0) {\n        let res = steps.shift()(...args)\n        return {value: res, done: false}\n      } else {\n        return { done: true }\n      }\n    }\n  }\n},\noptions: []\n}\ntasks.options.push(\nfunction(x){\n  return x * 2\n},\nfunction(x, y){\n  return x + y * 2\n},\nfunction(x, y, z) {\n  return x * y + z\n}\n)\nlet it = tasks[Symbol.iterator]()\nconsole.log(it.next(10)) //{ value: 20, done: false } \nconsole.log(it.next(10, 20)) //{ value: 50, done: false }\nconsole.log(it.next(10, 20, 30)) //{ value: 230, done: false }\nconsole.log(it.next()) //{ done: true }\n</code></pre>\n</li>\n<li>\n<p>其中可以看到，我们将要运行的事件都传入我们的数组集合options中，然后便可以迭代运行了</p>\n<h2>模拟数字生成数组</h2>\n</li>\n<li>\n<p>我们可以将数字构造为一个迭代器，使其拥有迭代器的一些操作，用来生成数组或一定次数的循环</p>\n<pre><code class=\"language-js\">if(!Number.prototype[Symbol.iterator]){\nObject.defineProperty(\n  Number.prototype,\n  Symbol.iterator,\n  {\n    writable: true,\n    configurable: true,\n    enumerable: false,\n    value: function iterator(){\n      var i, inc, done = false, top = +this\n      inc = 1 * (top &#x3C; 0 ? -1 : 1)\n      return {\n        [Symbol.iterator](){return this},\n        next(){\n          if(!done) {\n            if(i == null) {\n              i = 0\n            } else if (top >= 0) {\n              i = Math.min(top, i + inc)\n            } else {\n              i = Math.max(top, i + inc)\n            }\n            if(i == top) {done = true}\n            return {value: i, done: false}\n          } else {\n            return {done: true}\n          }\n        }\n      }\n    }\n  }\n)\n}\nfor(let v of 3) {\nconsole.log(v)\n}\n// 0 1 2 3\n\n[...3] // [0,1,2,3]\n</code></pre>\n</li>\n<li>\n<p>第一个for...of循环可以使我们循环指定次数来完成我们的操作</p>\n</li>\n<li>\n<p>因为我们ES6的结构符本来就可以消耗或者说是解读我们的迭代器，所以会帮助我们直接生成指定长度的纯数字数组</p>\n</li>\n</ul>","frontmatter":{"title":"ES2015迭代器","date":"2019-03-12T00:00:00.000Z","tags":["JavaScript","ES2015","进修"],"categories":null},"fields":{"slug":"/iterator/"}}},"pageContext":{"slug":"/iterator/"}}